diff --git a/node_modules/@hathor/wallet-lib/lib/api/txApi.d.ts b/node_modules/@hathor/wallet-lib/lib/api/txApi.d.ts
index 5b69cdb..9bf3c21 100644
--- a/node_modules/@hathor/wallet-lib/lib/api/txApi.d.ts
+++ b/node_modules/@hathor/wallet-lib/lib/api/txApi.d.ts
@@ -104,6 +104,1813 @@ declare const txApi: {
      * @inner
      */
     getGraphviz(url: any, resolve: any): Promise<void>;
+    schemas: {
+        transactionApi: import("zod").ZodDiscriminatedUnion<"success", [import("zod").ZodObject<{
+            success: import("zod").ZodLiteral<true>;
+            tx: import("zod").ZodObject<{
+                hash: import("zod").ZodString;
+                nonce: import("zod").ZodString;
+                timestamp: import("zod").ZodNumber;
+                version: import("zod").ZodNumber;
+                weight: import("zod").ZodNumber;
+                signal_bits: import("zod").ZodNumber;
+                parents: import("zod").ZodArray<import("zod").ZodString, "many">;
+                nc_id: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodString>>;
+                nc_method: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodString>>;
+                nc_pubkey: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodString>>;
+                nc_address: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodString>>;
+                nc_context: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodObject<{
+                    actions: import("zod").ZodArray<import("zod").ZodDiscriminatedUnion<"type", [import("zod").ZodObject<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"deposit">;
+                    }>, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"deposit">;
+                    }>, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"deposit">;
+                    }>, import("zod").ZodTypeAny, "passthrough">>, import("zod").ZodObject<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"withdrawal">;
+                    }>, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"withdrawal">;
+                    }>, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"withdrawal">;
+                    }>, import("zod").ZodTypeAny, "passthrough">>, import("zod").ZodObject<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"grant_authority">;
+                    }>, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"grant_authority">;
+                    }>, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"grant_authority">;
+                    }>, import("zod").ZodTypeAny, "passthrough">>, import("zod").ZodObject<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"acquire_authority">;
+                    }>, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"acquire_authority">;
+                    }>, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"acquire_authority">;
+                    }>, import("zod").ZodTypeAny, "passthrough">>]>, "many">;
+                    address: import("zod").ZodString;
+                    timestamp: import("zod").ZodNumber;
+                }, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<{
+                    actions: import("zod").ZodArray<import("zod").ZodDiscriminatedUnion<"type", [import("zod").ZodObject<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"deposit">;
+                    }>, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"deposit">;
+                    }>, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"deposit">;
+                    }>, import("zod").ZodTypeAny, "passthrough">>, import("zod").ZodObject<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"withdrawal">;
+                    }>, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"withdrawal">;
+                    }>, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"withdrawal">;
+                    }>, import("zod").ZodTypeAny, "passthrough">>, import("zod").ZodObject<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"grant_authority">;
+                    }>, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"grant_authority">;
+                    }>, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"grant_authority">;
+                    }>, import("zod").ZodTypeAny, "passthrough">>, import("zod").ZodObject<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"acquire_authority">;
+                    }>, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"acquire_authority">;
+                    }>, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"acquire_authority">;
+                    }>, import("zod").ZodTypeAny, "passthrough">>]>, "many">;
+                    address: import("zod").ZodString;
+                    timestamp: import("zod").ZodNumber;
+                }, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<{
+                    actions: import("zod").ZodArray<import("zod").ZodDiscriminatedUnion<"type", [import("zod").ZodObject<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"deposit">;
+                    }>, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"deposit">;
+                    }>, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"deposit">;
+                    }>, import("zod").ZodTypeAny, "passthrough">>, import("zod").ZodObject<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"withdrawal">;
+                    }>, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"withdrawal">;
+                    }>, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"withdrawal">;
+                    }>, import("zod").ZodTypeAny, "passthrough">>, import("zod").ZodObject<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"grant_authority">;
+                    }>, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"grant_authority">;
+                    }>, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"grant_authority">;
+                    }>, import("zod").ZodTypeAny, "passthrough">>, import("zod").ZodObject<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"acquire_authority">;
+                    }>, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"acquire_authority">;
+                    }>, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"acquire_authority">;
+                    }>, import("zod").ZodTypeAny, "passthrough">>]>, "many">;
+                    address: import("zod").ZodString;
+                    timestamp: import("zod").ZodNumber;
+                }, import("zod").ZodTypeAny, "passthrough">>>>;
+                nc_args: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodString>>;
+                nc_blueprint_id: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodString>>;
+                inputs: import("zod").ZodArray<import("zod").ZodObject<{
+                    value: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    token_data: import("zod").ZodNumber;
+                    script: import("zod").ZodString;
+                    decoded: import("zod").ZodDiscriminatedUnion<"type", [import("zod").ZodObject<{
+                        type: import("zod").ZodLiteral<"P2PKH">;
+                        address: import("zod").ZodString;
+                        timelock: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodNumber>>;
+                        value: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                        token_data: import("zod").ZodNumber;
+                    }, "strip", import("zod").ZodTypeAny, {
+                        type: "P2PKH";
+                        address: string;
+                        value: bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    }, {
+                        type: "P2PKH";
+                        address: string;
+                        value: string | number | bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    }>, import("zod").ZodObject<{
+                        type: import("zod").ZodLiteral<"MultiSig">;
+                        address: import("zod").ZodString;
+                        timelock: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodNumber>>;
+                        value: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                        token_data: import("zod").ZodNumber;
+                    }, "strip", import("zod").ZodTypeAny, {
+                        type: "MultiSig";
+                        address: string;
+                        value: bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    }, {
+                        type: "MultiSig";
+                        address: string;
+                        value: string | number | bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    }>, import("zod").ZodObject<{
+                        type: import("zod").ZodUndefined;
+                    }, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<{
+                        type: import("zod").ZodUndefined;
+                    }, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<{
+                        type: import("zod").ZodUndefined;
+                    }, import("zod").ZodTypeAny, "passthrough">>]>;
+                    tx_id: import("zod").ZodString;
+                    index: import("zod").ZodNumber;
+                    token: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodString>>;
+                }, "strip", import("zod").ZodTypeAny, {
+                    index: number;
+                    value: bigint;
+                    script: string;
+                    token_data: number;
+                    decoded: {
+                        type: "P2PKH";
+                        address: string;
+                        value: bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    } | {
+                        type: "MultiSig";
+                        address: string;
+                        value: bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    } | import("zod").objectOutputType<{
+                        type: import("zod").ZodUndefined;
+                    }, import("zod").ZodTypeAny, "passthrough">;
+                    tx_id: string;
+                    token?: string | null | undefined;
+                }, {
+                    index: number;
+                    value: string | number | bigint;
+                    script: string;
+                    token_data: number;
+                    decoded: {
+                        type: "P2PKH";
+                        address: string;
+                        value: string | number | bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    } | {
+                        type: "MultiSig";
+                        address: string;
+                        value: string | number | bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    } | import("zod").objectInputType<{
+                        type: import("zod").ZodUndefined;
+                    }, import("zod").ZodTypeAny, "passthrough">;
+                    tx_id: string;
+                    token?: string | null | undefined;
+                }>, "many">;
+                outputs: import("zod").ZodArray<import("zod").ZodObject<{
+                    value: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    token_data: import("zod").ZodNumber;
+                    script: import("zod").ZodString;
+                    decoded: import("zod").ZodDiscriminatedUnion<"type", [import("zod").ZodObject<{
+                        type: import("zod").ZodLiteral<"P2PKH">;
+                        address: import("zod").ZodString;
+                        timelock: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodNumber>>;
+                        value: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                        token_data: import("zod").ZodNumber;
+                    }, "strip", import("zod").ZodTypeAny, {
+                        type: "P2PKH";
+                        address: string;
+                        value: bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    }, {
+                        type: "P2PKH";
+                        address: string;
+                        value: string | number | bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    }>, import("zod").ZodObject<{
+                        type: import("zod").ZodLiteral<"MultiSig">;
+                        address: import("zod").ZodString;
+                        timelock: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodNumber>>;
+                        value: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                        token_data: import("zod").ZodNumber;
+                    }, "strip", import("zod").ZodTypeAny, {
+                        type: "MultiSig";
+                        address: string;
+                        value: bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    }, {
+                        type: "MultiSig";
+                        address: string;
+                        value: string | number | bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    }>, import("zod").ZodObject<{
+                        type: import("zod").ZodUndefined;
+                    }, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<{
+                        type: import("zod").ZodUndefined;
+                    }, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<{
+                        type: import("zod").ZodUndefined;
+                    }, import("zod").ZodTypeAny, "passthrough">>]>;
+                    token: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodString>>;
+                    spent_by: import("zod").ZodDefault<import("zod").ZodNullable<import("zod").ZodString>>;
+                }, "strip", import("zod").ZodTypeAny, {
+                    value: bigint;
+                    script: string;
+                    token_data: number;
+                    decoded: {
+                        type: "P2PKH";
+                        address: string;
+                        value: bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    } | {
+                        type: "MultiSig";
+                        address: string;
+                        value: bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    } | import("zod").objectOutputType<{
+                        type: import("zod").ZodUndefined;
+                    }, import("zod").ZodTypeAny, "passthrough">;
+                    spent_by: string | null;
+                    token?: string | null | undefined;
+                }, {
+                    value: string | number | bigint;
+                    script: string;
+                    token_data: number;
+                    decoded: {
+                        type: "P2PKH";
+                        address: string;
+                        value: string | number | bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    } | {
+                        type: "MultiSig";
+                        address: string;
+                        value: string | number | bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    } | import("zod").objectInputType<{
+                        type: import("zod").ZodUndefined;
+                    }, import("zod").ZodTypeAny, "passthrough">;
+                    token?: string | null | undefined;
+                    spent_by?: string | null | undefined;
+                }>, "many">;
+                tokens: import("zod").ZodArray<import("zod").ZodObject<{
+                    uid: import("zod").ZodString;
+                    name: import("zod").ZodNullable<import("zod").ZodString>;
+                    symbol: import("zod").ZodNullable<import("zod").ZodString>;
+                }, "strip", import("zod").ZodTypeAny, {
+                    symbol: string | null;
+                    name: string | null;
+                    uid: string;
+                }, {
+                    symbol: string | null;
+                    name: string | null;
+                    uid: string;
+                }>, "many">;
+                token_name: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodString>>;
+                token_symbol: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodString>>;
+                raw: import("zod").ZodString;
+            }, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<{
+                hash: import("zod").ZodString;
+                nonce: import("zod").ZodString;
+                timestamp: import("zod").ZodNumber;
+                version: import("zod").ZodNumber;
+                weight: import("zod").ZodNumber;
+                signal_bits: import("zod").ZodNumber;
+                parents: import("zod").ZodArray<import("zod").ZodString, "many">;
+                nc_id: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodString>>;
+                nc_method: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodString>>;
+                nc_pubkey: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodString>>;
+                nc_address: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodString>>;
+                nc_context: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodObject<{
+                    actions: import("zod").ZodArray<import("zod").ZodDiscriminatedUnion<"type", [import("zod").ZodObject<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"deposit">;
+                    }>, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"deposit">;
+                    }>, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"deposit">;
+                    }>, import("zod").ZodTypeAny, "passthrough">>, import("zod").ZodObject<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"withdrawal">;
+                    }>, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"withdrawal">;
+                    }>, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"withdrawal">;
+                    }>, import("zod").ZodTypeAny, "passthrough">>, import("zod").ZodObject<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"grant_authority">;
+                    }>, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"grant_authority">;
+                    }>, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"grant_authority">;
+                    }>, import("zod").ZodTypeAny, "passthrough">>, import("zod").ZodObject<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"acquire_authority">;
+                    }>, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"acquire_authority">;
+                    }>, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"acquire_authority">;
+                    }>, import("zod").ZodTypeAny, "passthrough">>]>, "many">;
+                    address: import("zod").ZodString;
+                    timestamp: import("zod").ZodNumber;
+                }, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<{
+                    actions: import("zod").ZodArray<import("zod").ZodDiscriminatedUnion<"type", [import("zod").ZodObject<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"deposit">;
+                    }>, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"deposit">;
+                    }>, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"deposit">;
+                    }>, import("zod").ZodTypeAny, "passthrough">>, import("zod").ZodObject<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"withdrawal">;
+                    }>, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"withdrawal">;
+                    }>, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"withdrawal">;
+                    }>, import("zod").ZodTypeAny, "passthrough">>, import("zod").ZodObject<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"grant_authority">;
+                    }>, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"grant_authority">;
+                    }>, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"grant_authority">;
+                    }>, import("zod").ZodTypeAny, "passthrough">>, import("zod").ZodObject<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"acquire_authority">;
+                    }>, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"acquire_authority">;
+                    }>, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"acquire_authority">;
+                    }>, import("zod").ZodTypeAny, "passthrough">>]>, "many">;
+                    address: import("zod").ZodString;
+                    timestamp: import("zod").ZodNumber;
+                }, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<{
+                    actions: import("zod").ZodArray<import("zod").ZodDiscriminatedUnion<"type", [import("zod").ZodObject<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"deposit">;
+                    }>, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"deposit">;
+                    }>, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"deposit">;
+                    }>, import("zod").ZodTypeAny, "passthrough">>, import("zod").ZodObject<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"withdrawal">;
+                    }>, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"withdrawal">;
+                    }>, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"withdrawal">;
+                    }>, import("zod").ZodTypeAny, "passthrough">>, import("zod").ZodObject<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"grant_authority">;
+                    }>, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"grant_authority">;
+                    }>, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"grant_authority">;
+                    }>, import("zod").ZodTypeAny, "passthrough">>, import("zod").ZodObject<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"acquire_authority">;
+                    }>, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"acquire_authority">;
+                    }>, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"acquire_authority">;
+                    }>, import("zod").ZodTypeAny, "passthrough">>]>, "many">;
+                    address: import("zod").ZodString;
+                    timestamp: import("zod").ZodNumber;
+                }, import("zod").ZodTypeAny, "passthrough">>>>;
+                nc_args: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodString>>;
+                nc_blueprint_id: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodString>>;
+                inputs: import("zod").ZodArray<import("zod").ZodObject<{
+                    value: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    token_data: import("zod").ZodNumber;
+                    script: import("zod").ZodString;
+                    decoded: import("zod").ZodDiscriminatedUnion<"type", [import("zod").ZodObject<{
+                        type: import("zod").ZodLiteral<"P2PKH">;
+                        address: import("zod").ZodString;
+                        timelock: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodNumber>>;
+                        value: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                        token_data: import("zod").ZodNumber;
+                    }, "strip", import("zod").ZodTypeAny, {
+                        type: "P2PKH";
+                        address: string;
+                        value: bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    }, {
+                        type: "P2PKH";
+                        address: string;
+                        value: string | number | bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    }>, import("zod").ZodObject<{
+                        type: import("zod").ZodLiteral<"MultiSig">;
+                        address: import("zod").ZodString;
+                        timelock: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodNumber>>;
+                        value: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                        token_data: import("zod").ZodNumber;
+                    }, "strip", import("zod").ZodTypeAny, {
+                        type: "MultiSig";
+                        address: string;
+                        value: bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    }, {
+                        type: "MultiSig";
+                        address: string;
+                        value: string | number | bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    }>, import("zod").ZodObject<{
+                        type: import("zod").ZodUndefined;
+                    }, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<{
+                        type: import("zod").ZodUndefined;
+                    }, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<{
+                        type: import("zod").ZodUndefined;
+                    }, import("zod").ZodTypeAny, "passthrough">>]>;
+                    tx_id: import("zod").ZodString;
+                    index: import("zod").ZodNumber;
+                    token: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodString>>;
+                }, "strip", import("zod").ZodTypeAny, {
+                    index: number;
+                    value: bigint;
+                    script: string;
+                    token_data: number;
+                    decoded: {
+                        type: "P2PKH";
+                        address: string;
+                        value: bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    } | {
+                        type: "MultiSig";
+                        address: string;
+                        value: bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    } | import("zod").objectOutputType<{
+                        type: import("zod").ZodUndefined;
+                    }, import("zod").ZodTypeAny, "passthrough">;
+                    tx_id: string;
+                    token?: string | null | undefined;
+                }, {
+                    index: number;
+                    value: string | number | bigint;
+                    script: string;
+                    token_data: number;
+                    decoded: {
+                        type: "P2PKH";
+                        address: string;
+                        value: string | number | bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    } | {
+                        type: "MultiSig";
+                        address: string;
+                        value: string | number | bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    } | import("zod").objectInputType<{
+                        type: import("zod").ZodUndefined;
+                    }, import("zod").ZodTypeAny, "passthrough">;
+                    tx_id: string;
+                    token?: string | null | undefined;
+                }>, "many">;
+                outputs: import("zod").ZodArray<import("zod").ZodObject<{
+                    value: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    token_data: import("zod").ZodNumber;
+                    script: import("zod").ZodString;
+                    decoded: import("zod").ZodDiscriminatedUnion<"type", [import("zod").ZodObject<{
+                        type: import("zod").ZodLiteral<"P2PKH">;
+                        address: import("zod").ZodString;
+                        timelock: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodNumber>>;
+                        value: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                        token_data: import("zod").ZodNumber;
+                    }, "strip", import("zod").ZodTypeAny, {
+                        type: "P2PKH";
+                        address: string;
+                        value: bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    }, {
+                        type: "P2PKH";
+                        address: string;
+                        value: string | number | bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    }>, import("zod").ZodObject<{
+                        type: import("zod").ZodLiteral<"MultiSig">;
+                        address: import("zod").ZodString;
+                        timelock: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodNumber>>;
+                        value: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                        token_data: import("zod").ZodNumber;
+                    }, "strip", import("zod").ZodTypeAny, {
+                        type: "MultiSig";
+                        address: string;
+                        value: bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    }, {
+                        type: "MultiSig";
+                        address: string;
+                        value: string | number | bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    }>, import("zod").ZodObject<{
+                        type: import("zod").ZodUndefined;
+                    }, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<{
+                        type: import("zod").ZodUndefined;
+                    }, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<{
+                        type: import("zod").ZodUndefined;
+                    }, import("zod").ZodTypeAny, "passthrough">>]>;
+                    token: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodString>>;
+                    spent_by: import("zod").ZodDefault<import("zod").ZodNullable<import("zod").ZodString>>;
+                }, "strip", import("zod").ZodTypeAny, {
+                    value: bigint;
+                    script: string;
+                    token_data: number;
+                    decoded: {
+                        type: "P2PKH";
+                        address: string;
+                        value: bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    } | {
+                        type: "MultiSig";
+                        address: string;
+                        value: bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    } | import("zod").objectOutputType<{
+                        type: import("zod").ZodUndefined;
+                    }, import("zod").ZodTypeAny, "passthrough">;
+                    spent_by: string | null;
+                    token?: string | null | undefined;
+                }, {
+                    value: string | number | bigint;
+                    script: string;
+                    token_data: number;
+                    decoded: {
+                        type: "P2PKH";
+                        address: string;
+                        value: string | number | bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    } | {
+                        type: "MultiSig";
+                        address: string;
+                        value: string | number | bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    } | import("zod").objectInputType<{
+                        type: import("zod").ZodUndefined;
+                    }, import("zod").ZodTypeAny, "passthrough">;
+                    token?: string | null | undefined;
+                    spent_by?: string | null | undefined;
+                }>, "many">;
+                tokens: import("zod").ZodArray<import("zod").ZodObject<{
+                    uid: import("zod").ZodString;
+                    name: import("zod").ZodNullable<import("zod").ZodString>;
+                    symbol: import("zod").ZodNullable<import("zod").ZodString>;
+                }, "strip", import("zod").ZodTypeAny, {
+                    symbol: string | null;
+                    name: string | null;
+                    uid: string;
+                }, {
+                    symbol: string | null;
+                    name: string | null;
+                    uid: string;
+                }>, "many">;
+                token_name: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodString>>;
+                token_symbol: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodString>>;
+                raw: import("zod").ZodString;
+            }, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<{
+                hash: import("zod").ZodString;
+                nonce: import("zod").ZodString;
+                timestamp: import("zod").ZodNumber;
+                version: import("zod").ZodNumber;
+                weight: import("zod").ZodNumber;
+                signal_bits: import("zod").ZodNumber;
+                parents: import("zod").ZodArray<import("zod").ZodString, "many">;
+                nc_id: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodString>>;
+                nc_method: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodString>>;
+                nc_pubkey: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodString>>;
+                nc_address: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodString>>;
+                nc_context: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodObject<{
+                    actions: import("zod").ZodArray<import("zod").ZodDiscriminatedUnion<"type", [import("zod").ZodObject<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"deposit">;
+                    }>, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"deposit">;
+                    }>, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"deposit">;
+                    }>, import("zod").ZodTypeAny, "passthrough">>, import("zod").ZodObject<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"withdrawal">;
+                    }>, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"withdrawal">;
+                    }>, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"withdrawal">;
+                    }>, import("zod").ZodTypeAny, "passthrough">>, import("zod").ZodObject<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"grant_authority">;
+                    }>, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"grant_authority">;
+                    }>, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"grant_authority">;
+                    }>, import("zod").ZodTypeAny, "passthrough">>, import("zod").ZodObject<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"acquire_authority">;
+                    }>, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"acquire_authority">;
+                    }>, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"acquire_authority">;
+                    }>, import("zod").ZodTypeAny, "passthrough">>]>, "many">;
+                    address: import("zod").ZodString;
+                    timestamp: import("zod").ZodNumber;
+                }, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<{
+                    actions: import("zod").ZodArray<import("zod").ZodDiscriminatedUnion<"type", [import("zod").ZodObject<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"deposit">;
+                    }>, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"deposit">;
+                    }>, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"deposit">;
+                    }>, import("zod").ZodTypeAny, "passthrough">>, import("zod").ZodObject<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"withdrawal">;
+                    }>, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"withdrawal">;
+                    }>, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"withdrawal">;
+                    }>, import("zod").ZodTypeAny, "passthrough">>, import("zod").ZodObject<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"grant_authority">;
+                    }>, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"grant_authority">;
+                    }>, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"grant_authority">;
+                    }>, import("zod").ZodTypeAny, "passthrough">>, import("zod").ZodObject<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"acquire_authority">;
+                    }>, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"acquire_authority">;
+                    }>, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"acquire_authority">;
+                    }>, import("zod").ZodTypeAny, "passthrough">>]>, "many">;
+                    address: import("zod").ZodString;
+                    timestamp: import("zod").ZodNumber;
+                }, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<{
+                    actions: import("zod").ZodArray<import("zod").ZodDiscriminatedUnion<"type", [import("zod").ZodObject<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"deposit">;
+                    }>, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"deposit">;
+                    }>, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"deposit">;
+                    }>, import("zod").ZodTypeAny, "passthrough">>, import("zod").ZodObject<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"withdrawal">;
+                    }>, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"withdrawal">;
+                    }>, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"withdrawal">;
+                    }>, import("zod").ZodTypeAny, "passthrough">>, import("zod").ZodObject<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"grant_authority">;
+                    }>, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"grant_authority">;
+                    }>, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"grant_authority">;
+                    }>, import("zod").ZodTypeAny, "passthrough">>, import("zod").ZodObject<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"acquire_authority">;
+                    }>, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"acquire_authority">;
+                    }>, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"acquire_authority">;
+                    }>, import("zod").ZodTypeAny, "passthrough">>]>, "many">;
+                    address: import("zod").ZodString;
+                    timestamp: import("zod").ZodNumber;
+                }, import("zod").ZodTypeAny, "passthrough">>>>;
+                nc_args: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodString>>;
+                nc_blueprint_id: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodString>>;
+                inputs: import("zod").ZodArray<import("zod").ZodObject<{
+                    value: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    token_data: import("zod").ZodNumber;
+                    script: import("zod").ZodString;
+                    decoded: import("zod").ZodDiscriminatedUnion<"type", [import("zod").ZodObject<{
+                        type: import("zod").ZodLiteral<"P2PKH">;
+                        address: import("zod").ZodString;
+                        timelock: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodNumber>>;
+                        value: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                        token_data: import("zod").ZodNumber;
+                    }, "strip", import("zod").ZodTypeAny, {
+                        type: "P2PKH";
+                        address: string;
+                        value: bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    }, {
+                        type: "P2PKH";
+                        address: string;
+                        value: string | number | bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    }>, import("zod").ZodObject<{
+                        type: import("zod").ZodLiteral<"MultiSig">;
+                        address: import("zod").ZodString;
+                        timelock: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodNumber>>;
+                        value: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                        token_data: import("zod").ZodNumber;
+                    }, "strip", import("zod").ZodTypeAny, {
+                        type: "MultiSig";
+                        address: string;
+                        value: bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    }, {
+                        type: "MultiSig";
+                        address: string;
+                        value: string | number | bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    }>, import("zod").ZodObject<{
+                        type: import("zod").ZodUndefined;
+                    }, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<{
+                        type: import("zod").ZodUndefined;
+                    }, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<{
+                        type: import("zod").ZodUndefined;
+                    }, import("zod").ZodTypeAny, "passthrough">>]>;
+                    tx_id: import("zod").ZodString;
+                    index: import("zod").ZodNumber;
+                    token: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodString>>;
+                }, "strip", import("zod").ZodTypeAny, {
+                    index: number;
+                    value: bigint;
+                    script: string;
+                    token_data: number;
+                    decoded: {
+                        type: "P2PKH";
+                        address: string;
+                        value: bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    } | {
+                        type: "MultiSig";
+                        address: string;
+                        value: bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    } | import("zod").objectOutputType<{
+                        type: import("zod").ZodUndefined;
+                    }, import("zod").ZodTypeAny, "passthrough">;
+                    tx_id: string;
+                    token?: string | null | undefined;
+                }, {
+                    index: number;
+                    value: string | number | bigint;
+                    script: string;
+                    token_data: number;
+                    decoded: {
+                        type: "P2PKH";
+                        address: string;
+                        value: string | number | bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    } | {
+                        type: "MultiSig";
+                        address: string;
+                        value: string | number | bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    } | import("zod").objectInputType<{
+                        type: import("zod").ZodUndefined;
+                    }, import("zod").ZodTypeAny, "passthrough">;
+                    tx_id: string;
+                    token?: string | null | undefined;
+                }>, "many">;
+                outputs: import("zod").ZodArray<import("zod").ZodObject<{
+                    value: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    token_data: import("zod").ZodNumber;
+                    script: import("zod").ZodString;
+                    decoded: import("zod").ZodDiscriminatedUnion<"type", [import("zod").ZodObject<{
+                        type: import("zod").ZodLiteral<"P2PKH">;
+                        address: import("zod").ZodString;
+                        timelock: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodNumber>>;
+                        value: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                        token_data: import("zod").ZodNumber;
+                    }, "strip", import("zod").ZodTypeAny, {
+                        type: "P2PKH";
+                        address: string;
+                        value: bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    }, {
+                        type: "P2PKH";
+                        address: string;
+                        value: string | number | bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    }>, import("zod").ZodObject<{
+                        type: import("zod").ZodLiteral<"MultiSig">;
+                        address: import("zod").ZodString;
+                        timelock: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodNumber>>;
+                        value: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                        token_data: import("zod").ZodNumber;
+                    }, "strip", import("zod").ZodTypeAny, {
+                        type: "MultiSig";
+                        address: string;
+                        value: bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    }, {
+                        type: "MultiSig";
+                        address: string;
+                        value: string | number | bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    }>, import("zod").ZodObject<{
+                        type: import("zod").ZodUndefined;
+                    }, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<{
+                        type: import("zod").ZodUndefined;
+                    }, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<{
+                        type: import("zod").ZodUndefined;
+                    }, import("zod").ZodTypeAny, "passthrough">>]>;
+                    token: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodString>>;
+                    spent_by: import("zod").ZodDefault<import("zod").ZodNullable<import("zod").ZodString>>;
+                }, "strip", import("zod").ZodTypeAny, {
+                    value: bigint;
+                    script: string;
+                    token_data: number;
+                    decoded: {
+                        type: "P2PKH";
+                        address: string;
+                        value: bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    } | {
+                        type: "MultiSig";
+                        address: string;
+                        value: bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    } | import("zod").objectOutputType<{
+                        type: import("zod").ZodUndefined;
+                    }, import("zod").ZodTypeAny, "passthrough">;
+                    spent_by: string | null;
+                    token?: string | null | undefined;
+                }, {
+                    value: string | number | bigint;
+                    script: string;
+                    token_data: number;
+                    decoded: {
+                        type: "P2PKH";
+                        address: string;
+                        value: string | number | bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    } | {
+                        type: "MultiSig";
+                        address: string;
+                        value: string | number | bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    } | import("zod").objectInputType<{
+                        type: import("zod").ZodUndefined;
+                    }, import("zod").ZodTypeAny, "passthrough">;
+                    token?: string | null | undefined;
+                    spent_by?: string | null | undefined;
+                }>, "many">;
+                tokens: import("zod").ZodArray<import("zod").ZodObject<{
+                    uid: import("zod").ZodString;
+                    name: import("zod").ZodNullable<import("zod").ZodString>;
+                    symbol: import("zod").ZodNullable<import("zod").ZodString>;
+                }, "strip", import("zod").ZodTypeAny, {
+                    symbol: string | null;
+                    name: string | null;
+                    uid: string;
+                }, {
+                    symbol: string | null;
+                    name: string | null;
+                    uid: string;
+                }>, "many">;
+                token_name: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodString>>;
+                token_symbol: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodString>>;
+                raw: import("zod").ZodString;
+            }, import("zod").ZodTypeAny, "passthrough">>;
+            meta: import("zod").ZodObject<{
+                hash: import("zod").ZodString;
+                spent_outputs: import("zod").ZodArray<import("zod").ZodTuple<[import("zod").ZodNumber, import("zod").ZodArray<import("zod").ZodString, "many">], null>, "many">;
+                received_by: import("zod").ZodArray<import("zod").ZodString, "many">;
+                children: import("zod").ZodArray<import("zod").ZodString, "many">;
+                conflict_with: import("zod").ZodArray<import("zod").ZodString, "many">;
+                voided_by: import("zod").ZodArray<import("zod").ZodString, "many">;
+                twins: import("zod").ZodArray<import("zod").ZodString, "many">;
+                accumulated_weight: import("zod").ZodNumber;
+                score: import("zod").ZodNumber;
+                height: import("zod").ZodNumber;
+                min_height: import("zod").ZodNumber;
+                feature_activation_bit_counts: import("zod").ZodNullable<import("zod").ZodArray<import("zod").ZodNumber, "many">>;
+                first_block: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodString>>;
+                validation: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodString>>;
+                first_block_height: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodNumber>>;
+            }, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<{
+                hash: import("zod").ZodString;
+                spent_outputs: import("zod").ZodArray<import("zod").ZodTuple<[import("zod").ZodNumber, import("zod").ZodArray<import("zod").ZodString, "many">], null>, "many">;
+                received_by: import("zod").ZodArray<import("zod").ZodString, "many">;
+                children: import("zod").ZodArray<import("zod").ZodString, "many">;
+                conflict_with: import("zod").ZodArray<import("zod").ZodString, "many">;
+                voided_by: import("zod").ZodArray<import("zod").ZodString, "many">;
+                twins: import("zod").ZodArray<import("zod").ZodString, "many">;
+                accumulated_weight: import("zod").ZodNumber;
+                score: import("zod").ZodNumber;
+                height: import("zod").ZodNumber;
+                min_height: import("zod").ZodNumber;
+                feature_activation_bit_counts: import("zod").ZodNullable<import("zod").ZodArray<import("zod").ZodNumber, "many">>;
+                first_block: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodString>>;
+                validation: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodString>>;
+                first_block_height: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodNumber>>;
+            }, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<{
+                hash: import("zod").ZodString;
+                spent_outputs: import("zod").ZodArray<import("zod").ZodTuple<[import("zod").ZodNumber, import("zod").ZodArray<import("zod").ZodString, "many">], null>, "many">;
+                received_by: import("zod").ZodArray<import("zod").ZodString, "many">;
+                children: import("zod").ZodArray<import("zod").ZodString, "many">;
+                conflict_with: import("zod").ZodArray<import("zod").ZodString, "many">;
+                voided_by: import("zod").ZodArray<import("zod").ZodString, "many">;
+                twins: import("zod").ZodArray<import("zod").ZodString, "many">;
+                accumulated_weight: import("zod").ZodNumber;
+                score: import("zod").ZodNumber;
+                height: import("zod").ZodNumber;
+                min_height: import("zod").ZodNumber;
+                feature_activation_bit_counts: import("zod").ZodNullable<import("zod").ZodArray<import("zod").ZodNumber, "many">>;
+                first_block: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodString>>;
+                validation: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodString>>;
+                first_block_height: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodNumber>>;
+            }, import("zod").ZodTypeAny, "passthrough">>;
+            spent_outputs: import("zod").ZodRecord<import("zod").ZodNumber, import("zod").ZodString>;
+        }, "strip", import("zod").ZodTypeAny, {
+            meta: {
+                height: number;
+                children: string[];
+                hash: string;
+                spent_outputs: [number, string[]][];
+                received_by: string[];
+                conflict_with: string[];
+                voided_by: string[];
+                twins: string[];
+                accumulated_weight: number;
+                score: number;
+                min_height: number;
+                feature_activation_bit_counts: number[] | null;
+                validation?: string | null | undefined;
+                first_block?: string | null | undefined;
+                first_block_height?: number | null | undefined;
+            } & {
+                [k: string]: unknown;
+            };
+            success: true;
+            tx: {
+                raw: string;
+                nonce: string;
+                hash: string;
+                tokens: {
+                    symbol: string | null;
+                    name: string | null;
+                    uid: string;
+                }[];
+                timestamp: number;
+                version: number;
+                weight: number;
+                inputs: {
+                    index: number;
+                    value: bigint;
+                    script: string;
+                    token_data: number;
+                    decoded: {
+                        type: "P2PKH";
+                        address: string;
+                        value: bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    } | {
+                        type: "MultiSig";
+                        address: string;
+                        value: bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    } | import("zod").objectOutputType<{
+                        type: import("zod").ZodUndefined;
+                    }, import("zod").ZodTypeAny, "passthrough">;
+                    tx_id: string;
+                    token?: string | null | undefined;
+                }[];
+                outputs: {
+                    value: bigint;
+                    script: string;
+                    token_data: number;
+                    decoded: {
+                        type: "P2PKH";
+                        address: string;
+                        value: bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    } | {
+                        type: "MultiSig";
+                        address: string;
+                        value: bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    } | import("zod").objectOutputType<{
+                        type: import("zod").ZodUndefined;
+                    }, import("zod").ZodTypeAny, "passthrough">;
+                    spent_by: string | null;
+                    token?: string | null | undefined;
+                }[];
+                parents: string[];
+                signal_bits: number;
+                token_name?: string | null | undefined;
+                token_symbol?: string | null | undefined;
+                nc_id?: string | null | undefined;
+                nc_blueprint_id?: string | null | undefined;
+                nc_method?: string | null | undefined;
+                nc_args?: string | null | undefined;
+                nc_pubkey?: string | null | undefined;
+                nc_address?: string | null | undefined;
+                nc_context?: import("zod").objectOutputType<{
+                    actions: import("zod").ZodArray<import("zod").ZodDiscriminatedUnion<"type", [import("zod").ZodObject<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"deposit">;
+                    }>, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"deposit">;
+                    }>, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"deposit">;
+                    }>, import("zod").ZodTypeAny, "passthrough">>, import("zod").ZodObject<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"withdrawal">;
+                    }>, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"withdrawal">;
+                    }>, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"withdrawal">;
+                    }>, import("zod").ZodTypeAny, "passthrough">>, import("zod").ZodObject<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"grant_authority">;
+                    }>, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"grant_authority">;
+                    }>, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"grant_authority">;
+                    }>, import("zod").ZodTypeAny, "passthrough">>, import("zod").ZodObject<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"acquire_authority">;
+                    }>, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"acquire_authority">;
+                    }>, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"acquire_authority">;
+                    }>, import("zod").ZodTypeAny, "passthrough">>]>, "many">;
+                    address: import("zod").ZodString;
+                    timestamp: import("zod").ZodNumber;
+                }, import("zod").ZodTypeAny, "passthrough"> | null | undefined;
+            } & {
+                [k: string]: unknown;
+            };
+            spent_outputs: Record<number, string>;
+        }, {
+            meta: {
+                height: number;
+                children: string[];
+                hash: string;
+                spent_outputs: [number, string[]][];
+                received_by: string[];
+                conflict_with: string[];
+                voided_by: string[];
+                twins: string[];
+                accumulated_weight: number;
+                score: number;
+                min_height: number;
+                feature_activation_bit_counts: number[] | null;
+                validation?: string | null | undefined;
+                first_block?: string | null | undefined;
+                first_block_height?: number | null | undefined;
+            } & {
+                [k: string]: unknown;
+            };
+            success: true;
+            tx: {
+                raw: string;
+                nonce: string;
+                hash: string;
+                tokens: {
+                    symbol: string | null;
+                    name: string | null;
+                    uid: string;
+                }[];
+                timestamp: number;
+                version: number;
+                weight: number;
+                inputs: {
+                    index: number;
+                    value: string | number | bigint;
+                    script: string;
+                    token_data: number;
+                    decoded: {
+                        type: "P2PKH";
+                        address: string;
+                        value: string | number | bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    } | {
+                        type: "MultiSig";
+                        address: string;
+                        value: string | number | bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    } | import("zod").objectInputType<{
+                        type: import("zod").ZodUndefined;
+                    }, import("zod").ZodTypeAny, "passthrough">;
+                    tx_id: string;
+                    token?: string | null | undefined;
+                }[];
+                outputs: {
+                    value: string | number | bigint;
+                    script: string;
+                    token_data: number;
+                    decoded: {
+                        type: "P2PKH";
+                        address: string;
+                        value: string | number | bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    } | {
+                        type: "MultiSig";
+                        address: string;
+                        value: string | number | bigint;
+                        token_data: number;
+                        timelock?: number | null | undefined;
+                    } | import("zod").objectInputType<{
+                        type: import("zod").ZodUndefined;
+                    }, import("zod").ZodTypeAny, "passthrough">;
+                    token?: string | null | undefined;
+                    spent_by?: string | null | undefined;
+                }[];
+                parents: string[];
+                signal_bits: number;
+                token_name?: string | null | undefined;
+                token_symbol?: string | null | undefined;
+                nc_id?: string | null | undefined;
+                nc_blueprint_id?: string | null | undefined;
+                nc_method?: string | null | undefined;
+                nc_args?: string | null | undefined;
+                nc_pubkey?: string | null | undefined;
+                nc_address?: string | null | undefined;
+                nc_context?: import("zod").objectInputType<{
+                    actions: import("zod").ZodArray<import("zod").ZodDiscriminatedUnion<"type", [import("zod").ZodObject<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"deposit">;
+                    }>, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"deposit">;
+                    }>, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"deposit">;
+                    }>, import("zod").ZodTypeAny, "passthrough">>, import("zod").ZodObject<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"withdrawal">;
+                    }>, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"withdrawal">;
+                    }>, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        amount: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+                    }>, {
+                        type: import("zod").ZodLiteral<"withdrawal">;
+                    }>, import("zod").ZodTypeAny, "passthrough">>, import("zod").ZodObject<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"grant_authority">;
+                    }>, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"grant_authority">;
+                    }>, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"grant_authority">;
+                    }>, import("zod").ZodTypeAny, "passthrough">>, import("zod").ZodObject<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"acquire_authority">;
+                    }>, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"acquire_authority">;
+                    }>, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<import("zod").objectUtil.extendShape<import("zod").objectUtil.extendShape<{
+                        token_uid: import("zod").ZodString;
+                    }, {
+                        mint: import("zod").ZodBoolean;
+                        melt: import("zod").ZodBoolean;
+                    }>, {
+                        type: import("zod").ZodLiteral<"acquire_authority">;
+                    }>, import("zod").ZodTypeAny, "passthrough">>]>, "many">;
+                    address: import("zod").ZodString;
+                    timestamp: import("zod").ZodNumber;
+                }, import("zod").ZodTypeAny, "passthrough"> | null | undefined;
+            } & {
+                [k: string]: unknown;
+            };
+            spent_outputs: Record<number, string>;
+        }>, import("zod").ZodObject<{
+            success: import("zod").ZodLiteral<false>;
+            message: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodString>>;
+        }, "strip", import("zod").ZodTypeAny, {
+            success: false;
+            message?: string | null | undefined;
+        }, {
+            success: false;
+            message?: string | null | undefined;
+        }>]>;
+    };
 };
 export default txApi;
 //# sourceMappingURL=txApi.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/lib/api/txApi.d.ts.map b/node_modules/@hathor/wallet-lib/lib/api/txApi.d.ts.map
index 5048bf1..8fd7698 100644
--- a/node_modules/@hathor/wallet-lib/lib/api/txApi.d.ts.map
+++ b/node_modules/@hathor/wallet-lib/lib/api/txApi.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"txApi.d.ts","sourceRoot":"","sources":["../../src/api/txApi.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;AAIH,OAAO,EAAE,qBAAqB,EAAwB,MAAM,iBAAiB,CAAC;AAE9E;;;;GAIG;AAEH,QAAA,MAAM,KAAK;IACT;;;;;;;;;OASG;;IAiBH;;;;;;;;;;;;;OAaG;;IAYH;;;;;;;;;OASG;uBACgB,MAAM,WAAW,CAAC,QAAQ,EAAE,qBAAqB,KAAK,IAAI,GAAG,QAAQ,IAAI,CAAC;IAK7F;;;;;;;;;OASG;;IAeH;;;;;;;;;OASG;;IAeH;;;;;;;;;OASG;;IAeH;;;;;;;;;;OAUG;;IAeH;;;;;;;;;OASG;;CAaJ,CAAC;AAEF,eAAe,KAAK,CAAC"}
\ No newline at end of file
+{"version":3,"file":"txApi.d.ts","sourceRoot":"","sources":["../../src/api/txApi.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;AAIH,OAAO,EAAE,qBAAqB,EAAwB,MAAM,iBAAiB,CAAC;AAE9E;;;;GAIG;AAEH,QAAA,MAAM,KAAK;IACT;;;;;;;;;OASG;;IAiBH;;;;;;;;;;;;;OAaG;;IAYH;;;;;;;;;OASG;uBACgB,MAAM,WAAW,CAAC,QAAQ,EAAE,qBAAqB,KAAK,IAAI,GAAG,QAAQ,IAAI,CAAC;IAK7F;;;;;;;;;OASG;;IAeH;;;;;;;;;OASG;;IAeH;;;;;;;;;OASG;;IAeH;;;;;;;;;;OAUG;;IAeH;;;;;;;;;OASG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAkBJ,CAAC;AAEF,eAAe,KAAK,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/lib/api/txApi.js b/node_modules/@hathor/wallet-lib/lib/api/txApi.js
index c9db45b..54c40a3 100644
--- a/node_modules/@hathor/wallet-lib/lib/api/txApi.js
+++ b/node_modules/@hathor/wallet-lib/lib/api/txApi.js
@@ -189,6 +189,10 @@ const txApi = {
     }, res => {
       return Promise.reject(res);
     });
+  },
+  // Expose the txApi zod schemas
+  schemas: {
+    transactionApi: _txApi.transactionApiSchema
   }
 };
 var _default = exports.default = txApi;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/lib/api/wallet.d.ts b/node_modules/@hathor/wallet-lib/lib/api/wallet.d.ts
index 862e896..47d2451 100644
--- a/node_modules/@hathor/wallet-lib/lib/api/wallet.d.ts
+++ b/node_modules/@hathor/wallet-lib/lib/api/wallet.d.ts
@@ -139,6 +139,124 @@ declare const walletApi: {
      * @inner
      */
     getSearchAddress(address: any, count: any, hash: any, page: any, token: any, resolve: any): Promise<void>;
+    schemas: {
+        addressHistory: import("zod").ZodDiscriminatedUnion<"success", [import("zod").ZodObject<{
+            success: import("zod").ZodLiteral<true>;
+            history: import("zod").ZodArray<import("../utils/bigint").ZodSchema<import("../types").IHistoryTx>, "many">;
+            has_more: import("zod").ZodBoolean;
+            first_hash: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodString>>;
+            first_address: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodString>>;
+        }, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<{
+            success: import("zod").ZodLiteral<true>;
+            history: import("zod").ZodArray<import("../utils/bigint").ZodSchema<import("../types").IHistoryTx>, "many">;
+            has_more: import("zod").ZodBoolean;
+            first_hash: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodString>>;
+            first_address: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodString>>;
+        }, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<{
+            success: import("zod").ZodLiteral<true>;
+            history: import("zod").ZodArray<import("../utils/bigint").ZodSchema<import("../types").IHistoryTx>, "many">;
+            has_more: import("zod").ZodBoolean;
+            first_hash: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodString>>;
+            first_address: import("zod").ZodOptional<import("zod").ZodNullable<import("zod").ZodString>>;
+        }, import("zod").ZodTypeAny, "passthrough">>, import("zod").ZodObject<{
+            success: import("zod").ZodLiteral<false>;
+            message: import("zod").ZodString;
+        }, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<{
+            success: import("zod").ZodLiteral<false>;
+            message: import("zod").ZodString;
+        }, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<{
+            success: import("zod").ZodLiteral<false>;
+            message: import("zod").ZodString;
+        }, import("zod").ZodTypeAny, "passthrough">>]>;
+        generalTokenInfo: import("zod").ZodDiscriminatedUnion<"success", [import("zod").ZodObject<{
+            success: import("zod").ZodLiteral<true>;
+            name: import("zod").ZodString;
+            symbol: import("zod").ZodString;
+            mint: import("zod").ZodArray<import("zod").ZodObject<{
+                tx_id: import("zod").ZodString;
+                index: import("zod").ZodNumber;
+            }, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<{
+                tx_id: import("zod").ZodString;
+                index: import("zod").ZodNumber;
+            }, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<{
+                tx_id: import("zod").ZodString;
+                index: import("zod").ZodNumber;
+            }, import("zod").ZodTypeAny, "passthrough">>, "many">;
+            melt: import("zod").ZodArray<import("zod").ZodObject<{
+                tx_id: import("zod").ZodString;
+                index: import("zod").ZodNumber;
+            }, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<{
+                tx_id: import("zod").ZodString;
+                index: import("zod").ZodNumber;
+            }, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<{
+                tx_id: import("zod").ZodString;
+                index: import("zod").ZodNumber;
+            }, import("zod").ZodTypeAny, "passthrough">>, "many">;
+            total: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+            transactions_count: import("zod").ZodNumber;
+        }, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<{
+            success: import("zod").ZodLiteral<true>;
+            name: import("zod").ZodString;
+            symbol: import("zod").ZodString;
+            mint: import("zod").ZodArray<import("zod").ZodObject<{
+                tx_id: import("zod").ZodString;
+                index: import("zod").ZodNumber;
+            }, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<{
+                tx_id: import("zod").ZodString;
+                index: import("zod").ZodNumber;
+            }, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<{
+                tx_id: import("zod").ZodString;
+                index: import("zod").ZodNumber;
+            }, import("zod").ZodTypeAny, "passthrough">>, "many">;
+            melt: import("zod").ZodArray<import("zod").ZodObject<{
+                tx_id: import("zod").ZodString;
+                index: import("zod").ZodNumber;
+            }, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<{
+                tx_id: import("zod").ZodString;
+                index: import("zod").ZodNumber;
+            }, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<{
+                tx_id: import("zod").ZodString;
+                index: import("zod").ZodNumber;
+            }, import("zod").ZodTypeAny, "passthrough">>, "many">;
+            total: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+            transactions_count: import("zod").ZodNumber;
+        }, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<{
+            success: import("zod").ZodLiteral<true>;
+            name: import("zod").ZodString;
+            symbol: import("zod").ZodString;
+            mint: import("zod").ZodArray<import("zod").ZodObject<{
+                tx_id: import("zod").ZodString;
+                index: import("zod").ZodNumber;
+            }, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<{
+                tx_id: import("zod").ZodString;
+                index: import("zod").ZodNumber;
+            }, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<{
+                tx_id: import("zod").ZodString;
+                index: import("zod").ZodNumber;
+            }, import("zod").ZodTypeAny, "passthrough">>, "many">;
+            melt: import("zod").ZodArray<import("zod").ZodObject<{
+                tx_id: import("zod").ZodString;
+                index: import("zod").ZodNumber;
+            }, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<{
+                tx_id: import("zod").ZodString;
+                index: import("zod").ZodNumber;
+            }, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<{
+                tx_id: import("zod").ZodString;
+                index: import("zod").ZodNumber;
+            }, import("zod").ZodTypeAny, "passthrough">>, "many">;
+            total: import("zod").ZodPipeline<import("zod").ZodUnion<[import("zod").ZodUnion<[import("zod").ZodBigInt, import("zod").ZodNumber]>, import("zod").ZodString]>, import("zod").ZodBigInt>;
+            transactions_count: import("zod").ZodNumber;
+        }, import("zod").ZodTypeAny, "passthrough">>, import("zod").ZodObject<{
+            success: import("zod").ZodLiteral<false>;
+            message: import("zod").ZodString;
+        }, "passthrough", import("zod").ZodTypeAny, import("zod").objectOutputType<{
+            success: import("zod").ZodLiteral<false>;
+            message: import("zod").ZodString;
+        }, import("zod").ZodTypeAny, "passthrough">, import("zod").objectInputType<{
+            success: import("zod").ZodLiteral<false>;
+            message: import("zod").ZodString;
+        }, import("zod").ZodTypeAny, "passthrough">>]>;
+    };
 };
 export default walletApi;
 //# sourceMappingURL=wallet.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/lib/api/wallet.d.ts.map b/node_modules/@hathor/wallet-lib/lib/api/wallet.d.ts.map
index 08fbac8..3891c94 100644
--- a/node_modules/@hathor/wallet-lib/lib/api/wallet.d.ts.map
+++ b/node_modules/@hathor/wallet-lib/lib/api/wallet.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"wallet.d.ts","sourceRoot":"","sources":["../../src/api/wallet.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;AAEH,OAAO,EAAE,aAAa,EAAE,MAAM,OAAO,CAAC;AAItC,OAAO,EACL,oBAAoB,EAEpB,sBAAsB,EAEvB,MAAM,kBAAkB,CAAC;AAE1B;;;;GAIG;AAEH,QAAA,MAAM,SAAS;IACb;;;;;;;;;;OAUG;gEAC0C,QAAQ,IAAI,GAAG,cAAc,oBAAoB,CAAC,CAAC;IAqBhG;;;;;;;;;;;;;;;;;;;;OAoBG;0DACyC,QAAQ,cAAc,oBAAoB,CAAC,CAAC;IAYxF;;;;;;;;;;OAUG;8DAC6C,QAAQ,cAAc,oBAAoB,CAAC,CAAC;IAW5F;;;;;;;;;OASG;;IAeH;;;;;;;;;OASG;iDACgC,QAAQ,IAAI,GAAG,cAAc,sBAAsB,CAAC,CAAC;IAiBxF;;;;;;;;;;;;;OAaG;;IAuBH;;;;;;;;OAQG;;IAcH;;;;;;;;OAQG;;IAcH;;;;;;;;OAQG;;IAeH;;;;;;;;;;;;OAYG;;CAyBJ,CAAC;AAEF,eAAe,SAAS,CAAC"}
\ No newline at end of file
+{"version":3,"file":"wallet.d.ts","sourceRoot":"","sources":["../../src/api/wallet.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;AAEH,OAAO,EAAE,aAAa,EAAE,MAAM,OAAO,CAAC;AAItC,OAAO,EACL,oBAAoB,EAEpB,sBAAsB,EAEvB,MAAM,kBAAkB,CAAC;AAE1B;;;;GAIG;AAEH,QAAA,MAAM,SAAS;IACb;;;;;;;;;;OAUG;gEAC0C,QAAQ,IAAI,GAAG,cAAc,oBAAoB,CAAC,CAAC;IAqBhG;;;;;;;;;;;;;;;;;;;;OAoBG;0DACyC,QAAQ,cAAc,oBAAoB,CAAC,CAAC;IAYxF;;;;;;;;;;OAUG;8DAC6C,QAAQ,cAAc,oBAAoB,CAAC,CAAC;IAW5F;;;;;;;;;OASG;;IAeH;;;;;;;;;OASG;iDACgC,QAAQ,IAAI,GAAG,cAAc,sBAAsB,CAAC,CAAC;IAiBxF;;;;;;;;;;;;;OAaG;;IAuBH;;;;;;;;OAQG;;IAcH;;;;;;;;OAQG;;IAcH;;;;;;;;OAQG;;IAeH;;;;;;;;;;;;OAYG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA+BJ,CAAC;AAEF,eAAe,SAAS,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/lib/api/wallet.js b/node_modules/@hathor/wallet-lib/lib/api/wallet.js
index 8b382a6..894e02c 100644
--- a/node_modules/@hathor/wallet-lib/lib/api/wallet.js
+++ b/node_modules/@hathor/wallet-lib/lib/api/wallet.js
@@ -272,6 +272,11 @@ const walletApi = {
     }, res => {
       return Promise.reject(res);
     });
+  },
+  // Expose api validation schemas
+  schemas: {
+    addressHistory: _wallet.addressHistorySchema,
+    generalTokenInfo: _wallet.generalTokenInfoSchema
   }
 };
 var _default = exports.default = walletApi;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/lib/utils/bigint.js b/node_modules/@hathor/wallet-lib/lib/utils/bigint.js
index 8c56ad2..ce80a79 100644
--- a/node_modules/@hathor/wallet-lib/lib/utils/bigint.js
+++ b/node_modules/@hathor/wallet-lib/lib/utils/bigint.js
@@ -9,6 +9,13 @@ exports.parseSchema = parseSchema;
 exports.transformJsonBigIntResponse = transformJsonBigIntResponse;
 var _zod = require("zod");
 var _types = require("../types");
+
+// The wallet-lib implements a custom reviver in its bigint utils (which it uses
+// behind the scenes. The problem is that this custom reviver expects JSON.parse
+// to receive `context`, which is a new feature implemented in nodejs > 22 and
+// react-native doesn 't have it neither in Hermes or in JavascriptCore
+const corejsParser = require('core-js-pure/actual/json/parse');
+
 /**
  * Copyright (c) Hathor Labs and its affiliates.
  *
@@ -27,7 +34,7 @@ const JSONBigInt = exports.JSONBigInt = {
   /* eslint-disable @typescript-eslint/no-explicit-any */
   parse(text) {
     // @ts-expect-error TypeScript hasn't been updated with the `context` argument from Node v22.
-    return JSON.parse(text, this.bigIntReviver);
+    return corejsParser(text, this.bigIntReviver);
   },
   stringify(value, space) {
     return JSON.stringify(value, this.bigIntReplacer, space);
@@ -47,7 +54,11 @@ const JSONBigInt = exports.JSONBigInt = {
       // Otherwise, we can keep it as a Number.
       return value;
     } catch (e) {
-      if (e instanceof SyntaxError && (e.message === `Cannot convert ${context.source} to a BigInt` || e.message === `invalid BigInt syntax`)) {
+      if (e instanceof SyntaxError
+        && (e.message === `Cannot convert ${context.source} to a BigInt`
+          || (e.message === `can't convert string to bigint`)
+          || (e.message === `Failed to parse String to BigInt`))) {
+
         // When this error happens, it means the number cannot be converted to a BigInt,
         // so it's a double, for example '123.456' or '1e2'.
         return value;
diff --git a/node_modules/@hathor/wallet-lib/lib/utils/wallet.d.ts b/node_modules/@hathor/wallet-lib/lib/utils/wallet.d.ts
index 4d5bcaa..6a889ec 100644
--- a/node_modules/@hathor/wallet-lib/lib/utils/wallet.d.ts
+++ b/node_modules/@hathor/wallet-lib/lib/utils/wallet.d.ts
@@ -58,6 +58,22 @@ declare const wallet: {
      * @inner
      */
     xpubFromData(pubkey: Buffer, chainCode: Buffer, fingerprint: Buffer, networkName?: string): string;
+    /**
+     * Get xpriv from data
+     *
+     * @param {Buffer} privateKey Compressed private key
+     * @param {Buffer} chainCode HDPublic key chaincode
+     * @param {Number} fingerprint parent fingerprint
+     * @param {Number} depth Depth derivation of the private key
+     * @param {Number} childIndex Child index of the private key
+     * @param {string} networkName Network to use
+     *
+     * @return {String} xpriv
+     *
+     * @memberof Wallet
+     * @inner
+     */
+    xprivFromData(privateKey: Buffer, chainCode: Buffer, fingerprint: number, depth: number, childIndex: number, networkName: string): string;
     /**
      * Get compressed public key from uncompressed
      *
diff --git a/node_modules/@hathor/wallet-lib/lib/utils/wallet.d.ts.map b/node_modules/@hathor/wallet-lib/lib/utils/wallet.d.ts.map
index f68549b..76e5709 100644
--- a/node_modules/@hathor/wallet-lib/lib/utils/wallet.d.ts.map
+++ b/node_modules/@hathor/wallet-lib/lib/utils/wallet.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"wallet.d.ts","sourceRoot":"","sources":["../../src/utils/wallet.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;;AAiBH,OAAO,EAEL,aAAa,EACb,iBAAiB,EAGlB,MAAM,UAAU,CAAC;AAGlB,QAAA,MAAM,MAAM;IACV;;;;;;;;OAQG;8BACuB,MAAM,GAAG,MAAM;IAIzC;;;;;;;;;;;;OAYG;sBACe,MAAM,GAAG;QAAE,KAAK,EAAE,OAAO,CAAC;QAAC,KAAK,EAAE,MAAM,CAAA;KAAE;IAiD5D;;;;;;;;OAQG;kCAC0B,MAAM,GAAuB,MAAM;IAKhE;;;;;;;;;;;;OAYG;yBAEO,MAAM,aACH,MAAM,eACJ,MAAM,gBACN,MAAM,GAClB,MAAM;IAcT;;;;;;;;;;OAUG;+BACwB,MAAM,GAAG,MAAM;IAU1C;;;;;;;;;;;;;;OAcG;kCAC2B,MAAM,UAAU,MAAM;IAkBpD;;;;;;;;OAQG;kCAC2B,MAAM,GAAG,MAAM;IAK7C;;;;;;;;;OASG;6BAEK,MAAM,YACH;QAAE,UAAU,CAAC,EAAE,MAAM,CAAC;QAAC,WAAW,CAAC,EAAE,MAAM,CAAC;QAAC,sBAAsB,CAAC,EAAE,MAAM,CAAA;KAAE,GACtF,MAAM;IAgBT;;;;;;;;;;;OAWG;8BAEK,MAAM,YACH;QAAE,UAAU,CAAC,EAAE,MAAM,CAAC;QAAC,WAAW,CAAC,EAAE,MAAM,CAAA;KAAE;IAUxD;;;;;;;;;;OAUG;6DACsD,MAAM;IAI/D;;;;;;;;OAQG;4BACqB,MAAM,GAAG,OAAO;IAIxC;;;;;;;;;;OAUG;6BACsB,MAAM,mBAAmB,MAAM,GAAG,MAAM;IAgBjE;;;;;;;;;;;;OAYG;kCAC2B,MAAM,EAAE,iBAAiB,MAAM,SAAS,MAAM,GAAG,MAAM;IAoBrF;;;;;;;;;OASG;iCAC0B,MAAM,EAAE,gBAAgB,MAAM,GAAG,MAAM;IAcpE;;;;;;;;OAQG;mDAC4C,MAAM;IAKrD;;;;;;;;;OASG;mCAEK,MAAM,YACH;QAAE,UAAU,CAAC,EAAE,MAAM,CAAC;QAAC,WAAW,CAAC,EAAE,MAAM,CAAA;KAAE,GACrD,MAAM;IAMT;;;;;;;;;;;;;;;;;OAiBG;wCAEQ,MAAM,2BACiB;QAAE,QAAQ,CAAC,EAAE,aAAa,CAAC;QAAC,QAAQ,CAAC,EAAE,OAAO,CAAA;KAAE,GAC/E,iBAAiB;IAyDpB;;;;;;;;;;;;;;;;OAgBG;0CAES,MAAM,iDAOb;QACD,QAAQ,CAAC,EAAE,aAAa,CAAC;QACzB,GAAG,EAAE,MAAM,CAAC;QACZ,IAAI,CAAC,EAAE,MAAM,CAAC;QACd,QAAQ,CAAC,EAAE,MAAM,CAAC;QAClB,SAAS,CAAC,EAAE,MAAM,CAAC;KACpB,GACA,iBAAiB;sCA2EX,MAAM,yDAOV;QACD,QAAQ,CAAC,EAAE,aAAa,CAAC;QACzB,GAAG,EAAE,MAAM,CAAC;QACZ,QAAQ,EAAE,MAAM,CAAC;QACjB,UAAU,CAAC,EAAE,MAAM,CAAC;QACpB,WAAW,EAAE,MAAM,CAAC;KACrB,GACA,iBAAiB;IAkDpB;;;;;;;;OAQG;oCAEW,iBAAiB,UACrB,MAAM,UACN,MAAM,GACb,iBAAiB;IA2BpB;;;;;;;;OAQG;yCAEW,iBAAiB,eAChB,MAAM,eACN,MAAM,GAClB,iBAAiB;CAYrB,CAAC;AAEF,eAAe,MAAM,CAAC"}
\ No newline at end of file
+{"version":3,"file":"wallet.d.ts","sourceRoot":"","sources":["../../src/utils/wallet.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;;AAiBH,OAAO,EAEL,aAAa,EACb,iBAAiB,EAGlB,MAAM,UAAU,CAAC;AAGlB,QAAA,MAAM,MAAM;IACV;;;;;;;;OAQG;8BACuB,MAAM,GAAG,MAAM;IAIzC;;;;;;;;;;;;OAYG;sBACe,MAAM,GAAG;QAAE,KAAK,EAAE,OAAO,CAAC;QAAC,KAAK,EAAE,MAAM,CAAA;KAAE;IAiD5D;;;;;;;;OAQG;kCAC0B,MAAM,GAAuB,MAAM;IAKhE;;;;;;;;;;;;OAYG;yBAEO,MAAM,aACH,MAAM,eACJ,MAAM,gBACN,MAAM,GAClB,MAAM;IAcT;;;;;;;;;;;;;;OAcG;8BAEW,MAAM,aACP,MAAM,eACJ,MAAM,SACZ,MAAM,cACD,MAAM,eACL,MAAM,GAClB,MAAM;IAcT;;;;;;;;;;OAUG;+BACwB,MAAM,GAAG,MAAM;IAU1C;;;;;;;;;;;;;;OAcG;kCAC2B,MAAM,UAAU,MAAM;IAkBpD;;;;;;;;OAQG;kCAC2B,MAAM,GAAG,MAAM;IAK7C;;;;;;;;;OASG;6BAEK,MAAM,YACH;QAAE,UAAU,CAAC,EAAE,MAAM,CAAC;QAAC,WAAW,CAAC,EAAE,MAAM,CAAC;QAAC,sBAAsB,CAAC,EAAE,MAAM,CAAA;KAAE,GACtF,MAAM;IAgBT;;;;;;;;;;;OAWG;8BAEK,MAAM,YACH;QAAE,UAAU,CAAC,EAAE,MAAM,CAAC;QAAC,WAAW,CAAC,EAAE,MAAM,CAAA;KAAE;IAUxD;;;;;;;;;;OAUG;6DACsD,MAAM;IAI/D;;;;;;;;OAQG;4BACqB,MAAM,GAAG,OAAO;IAIxC;;;;;;;;;;OAUG;6BACsB,MAAM,mBAAmB,MAAM,GAAG,MAAM;IAgBjE;;;;;;;;;;;;OAYG;kCAC2B,MAAM,EAAE,iBAAiB,MAAM,SAAS,MAAM,GAAG,MAAM;IAoBrF;;;;;;;;;OASG;iCAC0B,MAAM,EAAE,gBAAgB,MAAM,GAAG,MAAM;IAcpE;;;;;;;;OAQG;mDAC4C,MAAM;IAKrD;;;;;;;;;OASG;mCAEK,MAAM,YACH;QAAE,UAAU,CAAC,EAAE,MAAM,CAAC;QAAC,WAAW,CAAC,EAAE,MAAM,CAAA;KAAE,GACrD,MAAM;IAMT;;;;;;;;;;;;;;;;;OAiBG;wCAEQ,MAAM,2BACiB;QAAE,QAAQ,CAAC,EAAE,aAAa,CAAC;QAAC,QAAQ,CAAC,EAAE,OAAO,CAAA;KAAE,GAC/E,iBAAiB;IAyDpB;;;;;;;;;;;;;;;;OAgBG;0CAES,MAAM,iDAOb;QACD,QAAQ,CAAC,EAAE,aAAa,CAAC;QACzB,GAAG,EAAE,MAAM,CAAC;QACZ,IAAI,CAAC,EAAE,MAAM,CAAC;QACd,QAAQ,CAAC,EAAE,MAAM,CAAC;QAClB,SAAS,CAAC,EAAE,MAAM,CAAC;KACpB,GACA,iBAAiB;sCA2EX,MAAM,yDAOV;QACD,QAAQ,CAAC,EAAE,aAAa,CAAC;QACzB,GAAG,EAAE,MAAM,CAAC;QACZ,QAAQ,EAAE,MAAM,CAAC;QACjB,UAAU,CAAC,EAAE,MAAM,CAAC;QACpB,WAAW,EAAE,MAAM,CAAC;KACrB,GACA,iBAAiB;IAkDpB;;;;;;;;OAQG;oCAEW,iBAAiB,UACrB,MAAM,UACN,MAAM,GACb,iBAAiB;IA2BpB;;;;;;;;OAQG;yCAEW,iBAAiB,eAChB,MAAM,eACN,MAAM,GAClB,iBAAiB;CAYrB,CAAC;AAEF,eAAe,MAAM,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/lib/utils/wallet.js b/node_modules/@hathor/wallet-lib/lib/utils/wallet.js
index e4a36e2..6f085a6 100644
--- a/node_modules/@hathor/wallet-lib/lib/utils/wallet.js
+++ b/node_modules/@hathor/wallet-lib/lib/utils/wallet.js
@@ -129,6 +129,33 @@ const wallet = {
     });
     return hdpubkey.xpubkey;
   },
+  /**
+   * Get xpriv from data
+   *
+   * @param {Buffer} privateKey Compressed private key
+   * @param {Buffer} chainCode HDPublic key chaincode
+   * @param {Number} fingerprint parent fingerprint
+   * @param {Number} depth Depth derivation of the private key
+   * @param {Number} childIndex Child index of the private key
+   * @param {string} networkName Network to use
+   *
+   * @return {String} xpriv
+   *
+   * @memberof Wallet
+   * @inner
+   */
+  xprivFromData(privateKey, chainCode, fingerprint, depth, childIndex, networkName) {
+    const network = new _network.default(networkName);
+    const hdprivkey = new _bitcoreLib.HDPrivateKey({
+      network: network.bitcoreNetwork,
+      depth,
+      parentFingerPrint: fingerprint,
+      childIndex,
+      chainCode,
+      privateKey
+    });
+    return hdprivkey.xprivkey;
+  },
   /**
    * Get compressed public key from uncompressed
    *
diff --git a/node_modules/@hathor/wallet-lib/lib/wallet/wallet.d.ts b/node_modules/@hathor/wallet-lib/lib/wallet/wallet.d.ts
index ad52833..d67786c 100644
--- a/node_modules/@hathor/wallet-lib/lib/wallet/wallet.d.ts
+++ b/node_modules/@hathor/wallet-lib/lib/wallet/wallet.d.ts
@@ -12,7 +12,7 @@ import Transaction from '../models/transaction';
 import CreateTokenTransaction from '../models/create_token_transaction';
 import Network from '../models/network';
 import { AddressInfoObject, GetBalanceObject, GetAddressesObject, GetHistoryObject, Utxo, OutputRequestObj, DataScriptOutputRequestObj, InputRequestObj, TransactionFullObject, IHathorWallet, WsTransaction, CreateWalletAuthData, ConnectionState, TokenDetailsObject, AuthorityTxOutput, WalletServiceServerUrls, FullNodeVersionData, WalletAddressMap, TxByIdTokensResponseData, DelegateAuthorityOptions, DestroyAuthorityOptions, FullNodeTxResponse, FullNodeTxConfirmationDataResponse } from './types';
-import { IStorage, OutputValueType, IHistoryTx } from '../types';
+import { IStorage, IWalletAccessData, OutputValueType, IHistoryTx } from '../types';
 declare class HathorWalletServiceWallet extends EventEmitter implements IHathorWallet {
     passphrase: string;
     walletId: string | null;
@@ -139,7 +139,7 @@ declare class HathorWalletServiceWallet extends EventEmitter implements IHathorW
      * @memberof HathorWalletServiceWallet
      * @inner
      */
-    generateCreateWalletAuthData(pinCode: string): Promise<CreateWalletAuthData>;
+    generateCreateWalletAuthData(accessData: IWalletAccessData, pinCode: string): Promise<CreateWalletAuthData>;
     /**
      * onUpdateTx: Event called when a transaction is updated
      *
@@ -368,6 +368,13 @@ declare class HathorWalletServiceWallet extends EventEmitter implements IHathorW
      * @inner
      */
     getAddressPrivKey(pinCode: string, addressIndex: number): Promise<bitcore.HDPrivateKey>;
+    /**
+     * Gets the network name
+     *
+     * @memberof HathorWalletServiceWallet
+     * @inner
+     */
+    getNetwork(): string;
     /**
      * Gets the network model object
      *
diff --git a/node_modules/@hathor/wallet-lib/lib/wallet/wallet.d.ts.map b/node_modules/@hathor/wallet-lib/lib/wallet/wallet.d.ts.map
index c854ff7..db8d809 100644
--- a/node_modules/@hathor/wallet-lib/lib/wallet/wallet.d.ts.map
+++ b/node_modules/@hathor/wallet-lib/lib/wallet/wallet.d.ts.map
@@ -1 +1 @@
-{"version":3,"file":"wallet.d.ts","sourceRoot":"","sources":["../../src/wallet/wallet.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"wallet.d.ts","sourceRoot":"","sources":["../../src/wallet/wallet.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/lib/wallet/wallet.js b/node_modules/@hathor/wallet-lib/lib/wallet/wallet.js
index c6e32ac..d65bf0e 100644
--- a/node_modules/@hathor/wallet-lib/lib/wallet/wallet.js
+++ b/node_modules/@hathor/wallet-lib/lib/wallet/wallet.js
@@ -39,7 +39,16 @@ function _awaitAsyncGenerator(e) { return new _OverloadYield(e, 0); }
 function _wrapAsyncGenerator(e) { return function () { return new AsyncGenerator(e.apply(this, arguments)); }; }
 function AsyncGenerator(e) { var r, t; function resume(r, t) { try { var n = e[r](t), o = n.value, u = o instanceof _OverloadYield; Promise.resolve(u ? o.v : o).then(function (t) { if (u) { var i = "return" === r ? "return" : "next"; if (!o.k || t.done) return resume(i, t); t = e[i](t).value; } settle(n.done ? "return" : "normal", t); }, function (e) { resume("throw", e); }); } catch (e) { settle("throw", e); } } function settle(e, n) { switch (e) { case "return": r.resolve({ value: n, done: !0 }); break; case "throw": r.reject(n); break; default: r.resolve({ value: n, done: !1 }); } (r = r.next) ? resume(r.key, r.arg) : t = null; } this._invoke = function (e, n) { return new Promise(function (o, u) { var i = { key: e, arg: n, resolve: o, reject: u, next: null }; t ? t = t.next = i : (r = t = i, resume(e, n)); }); }, "function" != typeof e.return && (this.return = void 0); }
 AsyncGenerator.prototype["function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator"] = function () { return this; }, AsyncGenerator.prototype.next = function (e) { return this._invoke("next", e); }, AsyncGenerator.prototype.throw = function (e) { return this._invoke("throw", e); }, AsyncGenerator.prototype.return = function (e) { return this._invoke("return", e); };
-function _OverloadYield(e, d) { this.v = e, this.k = d; } /**
+function _OverloadYield(e, d) { this.v = e, this.k = d; }
+
+const timerlabels = {};
+function startTimer(l) { timerlabels[l] = Date.now(); }
+function endTimer(l) {
+  const endTimer = Date.now();
+  console.log(`[${l}] ${endTimer - timerlabels[l]}ms`);
+}
+
+/**
  * Copyright (c) Hathor Labs and its affiliates.
  *
  * This source code is licensed under the MIT license found in the
@@ -274,19 +283,18 @@ class HathorWalletServiceWallet extends _events.EventEmitter {
       throw new Error('Pin code is required when starting the wallet.');
     }
     this.setState(walletState.LOADING);
-    let hasAccessData;
+    startTimer('check accessData');
+    let accessData = null;
     try {
-      const accessData = await this.storage.getAccessData();
-      hasAccessData = !!accessData;
+      accessData = await this.storage.getAccessData();
     } catch (err) {
-      if (err instanceof _errors.UninitializedWalletError) {
-        hasAccessData = false;
-      } else {
+      if (!(err instanceof _errors.UninitializedWalletError)) {
         throw err;
       }
     }
-    if (!hasAccessData) {
-      let accessData;
+    endTimer('check accessData');
+    if (!accessData) {
+    startTimer('generate accessData');
       if (this.seed) {
         if (!password) {
           throw new Error('Password is required when starting the wallet from the seed.');
@@ -311,7 +319,9 @@ class HathorWalletServiceWallet extends _events.EventEmitter {
         throw new Error('WalletService facade initialized without seed or xprivkey');
       }
       await this.storage.saveAccessData(accessData);
+      endTimer('generate accessData');
     }
+    startTimer('generateCreateWalletAuthData');
     const {
       xpub,
       authXpub,
@@ -320,7 +330,8 @@ class HathorWalletServiceWallet extends _events.EventEmitter {
       timestampNow,
       firstAddress,
       authDerivedPrivKey
-    } = await this.generateCreateWalletAuthData(pinCode);
+    } = await this.generateCreateWalletAuthData(accessData, pinCode);
+    endTimer('generateCreateWalletAuthData');
     this.xpub = xpub;
     this.authPrivKey = authDerivedPrivKey;
     const handleCreate = async data => {
@@ -338,9 +349,15 @@ class HathorWalletServiceWallet extends _events.EventEmitter {
       }
       await this.onWalletReady();
     };
+    startTimer('createWallet');
     const data = await _walletApi.default.createWallet(this, xpub, xpubkeySignature, authXpub, authXpubkeySignature, timestampNow, firstAddress);
+    endTimer('createWallet');
+    startTimer('handleCreate');
     await handleCreate(data.status);
+    endTimer('handleCreate');
+    startTimer('clearSensitiveData');
     this.clearSensitiveData();
+    endTimer('clearSensitiveData');
   }

   /**
@@ -359,42 +376,53 @@ class HathorWalletServiceWallet extends _events.EventEmitter {
    * @memberof HathorWalletServiceWallet
    * @inner
    */
-  async generateCreateWalletAuthData(pinCode) {
+  async generateCreateWalletAuthData(accessData, pinCode) {
     let xpub;
     let authXpub;
+    let privKey;
     let privKeyAccountPath;
     let authDerivedPrivKey;
     const now = Date.now();
     const timestampNow = Math.floor(now / 1000); // in seconds

-    if (this.seed) {
-      // getXPrivKeyFromSeed returns a HDPrivateKey on the root path
-      const privKey = _wallet.default.getXPrivKeyFromSeed(this.seed, {
-        passphrase: this.passphrase,
-        networkName: this.network.name
-      });
-      // getXPubKeyFromSeed returns a xpubkey on the account level path
-      xpub = _wallet.default.getXPubKeyFromSeed(this.seed, {
-        passphrase: this.passphrase,
-        networkName: this.network.name
-      });
-      authXpub = HathorWalletServiceWallet.getAuthXPubKeyFromSeed(this.seed, {
-        passphrase: this.passphrase,
-        networkName: this.network.name
-      });
-      privKeyAccountPath = _wallet.default.deriveXpriv(privKey, "0'");
-      authDerivedPrivKey = HathorWalletServiceWallet.deriveAuthPrivateKey(privKey);
-    } else if (this.xpriv) {
-      // this.xpriv is already on the account derivation path
-      privKeyAccountPath = _bitcoreLib.default.HDPrivateKey(this.xpriv);
-      xpub = privKeyAccountPath.xpubkey;
-
-      // If the wallet is being loaded from the xpriv, we assume we already have the authXPriv on storage, so just fetch it
-      authDerivedPrivKey = _bitcoreLib.default.HDPrivateKey.fromString(await this.storage.getAuthPrivKey(pinCode));
+    if (!!accessData.acctPathKey) {
+      const acctKey = (0, _crypto.decryptData)(accessData.acctPathKey, pinCode);
+      privKeyAccountPath = _bitcoreLib.default.HDPrivateKey(acctKey);
+    } else {
+      // Derive from seed present in memory
+      if (this.seed) {
+        // getXPrivKeyFromSeed returns a HDPrivateKey on the root path
+        privKey = _wallet.default.getXPrivKeyFromSeed(this.seed, {
+          passphrase: this.passphrase,
+          networkName: this.network.name
+        });
+        privKeyAccountPath = privKey.deriveNonCompliantChild("m/44'/280'/0'");
+      } else if (this.xpriv) {
+        privKeyAccountPath = _bitcoreLib.default.HDPrivateKey(this.xpriv);
+      } else {
+        throw new Error('Cannot derive account path key');
+      }
+    }
+    xpub = privKeyAccountPath.xpubkey;
+    if (!!accessData.authKey) {
+      const authKey = (0, _crypto.decryptData)(accessData.authKey, pinCode);
+      authDerivedPrivKey = _bitcoreLib.default.HDPrivateKey(authKey);
       authXpub = authDerivedPrivKey.xpubkey;
     } else {
-      throw new Error('generateCreateWalletAuthData called without seed or xpriv in memory.');
+      // Derive from seed present in memory
+      if (this.seed) {
+        if (!privKey) {
+          privKey = _wallet.default.getXPrivKeyFromSeed(this.seed, {
+            passphrase: this.passphrase,
+            networkName: this.network.name
+          });
+        }
+        authDerivedPrivKey = privKey.deriveNonCompliantChild("m/280'/280'");
+      } else {
+        throw new Error('Cannot derive auth path key');
+      }
     }
+    authXpub = authDerivedPrivKey.xpubkey;
     const walletId = HathorWalletServiceWallet.getWalletIdFromXPub(xpub);

     // prove we own the xpubkey
@@ -535,8 +563,11 @@ class HathorWalletServiceWallet extends _events.EventEmitter {
    */
   async pollForWalletStatus() {
     return new Promise((resolve, reject) => {
+      startTimer('polling for createWallet status');
       const pollIntervalTimer = setInterval(async () => {
         const data = await _walletApi.default.getWalletStatus(this);
+        endTimer('polling for createWallet status');
+        startTimer('polling for createWallet status');
         if (data.status.status === 'ready') {
           clearInterval(pollIntervalTimer);
           resolve();
@@ -572,7 +603,9 @@ class HathorWalletServiceWallet extends _events.EventEmitter {
    */
   async onWalletReady() {
     // We should wait for new addresses before setting wallet to ready
+    startTimer('getNewAddresses');
     await this.getNewAddresses(true);
+    endTimer('getNewAddresses');
     if (this.isWsEnabled()) {
       this.setupConnection();
     }
@@ -982,6 +1015,16 @@ class HathorWalletServiceWallet extends _events.EventEmitter {
     return addressHDPrivKey;
   }

+  /**
+   * Gets the network name
+   *
+   * @memberof HathorWalletServiceWallet
+   * @inner
+   */
+  getNetwork() {
+    return this.getNetworkObject().name;
+  }
+
   /**
    * Gets the network model object
    *
diff --git a/node_modules/@hathor/wallet-lib/oldLib/api/axiosInstance.d.ts b/node_modules/@hathor/wallet-lib/oldLib/api/axiosInstance.d.ts
new file mode 100644
index 0000000..17d24c0
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/api/axiosInstance.d.ts
@@ -0,0 +1,22 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/**
+ * Create axios instance settings base URL and content type
+ * Besides that, it captures error to show modal error and save in Redux
+ *
+ * @module Axios
+ */
+/**
+ * Create an axios instance to be used when sending requests
+ *
+ * @param {callback} resolve Callback to be stored and used in case of a retry after a fail
+ * @param {number} timeout Timeout in milliseconds for the request
+ */
+export declare const defaultCreateRequestInstance: (resolve?: null, timeout?: number) => import("axios").AxiosInstance;
+export declare const registerNewCreateRequestInstance: (fn: any) => void;
+export declare const createRequestInstance: (resolve?: null, timeout?: number) => import("axios").AxiosInstance;
+//# sourceMappingURL=axiosInstance.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/api/axiosInstance.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/api/axiosInstance.d.ts.map
new file mode 100644
index 0000000..65e1e90
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/api/axiosInstance.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"axiosInstance.d.ts","sourceRoot":"","sources":["../../src/api/axiosInstance.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;AAKH;;;;;GAKG;AAEH;;;;;GAKG;AACH,eAAO,MAAM,4BAA4B,aAAc,IAAI,YAAY,MAAM,kCAE5E,CAAC;AAIF,eAAO,MAAM,gCAAgC,mBAE5C,CAAC;AAEF,eAAO,MAAM,qBAAqB,aAAc,IAAI,YAAY,MAAM,kCAErE,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/api/axiosInstance.js b/node_modules/@hathor/wallet-lib/oldLib/api/axiosInstance.js
new file mode 100644
index 0000000..a558cd3
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/api/axiosInstance.js
@@ -0,0 +1,42 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.registerNewCreateRequestInstance = exports.defaultCreateRequestInstance = exports.createRequestInstance = void 0;
+var _config = _interopRequireDefault(require("../config"));
+var _axiosWrapper = _interopRequireDefault(require("./axiosWrapper"));
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+/**
+ * Create axios instance settings base URL and content type
+ * Besides that, it captures error to show modal error and save in Redux
+ *
+ * @module Axios
+ */
+
+/**
+ * Create an axios instance to be used when sending requests
+ *
+ * @param {callback} resolve Callback to be stored and used in case of a retry after a fail
+ * @param {number} timeout Timeout in milliseconds for the request
+ */
+const defaultCreateRequestInstance = (resolve, timeout) => {
+  return (0, _axiosWrapper.default)(_config.default.getServerUrl(), resolve, timeout);
+};
+exports.defaultCreateRequestInstance = defaultCreateRequestInstance;
+let _createRequestInstance = defaultCreateRequestInstance;
+const registerNewCreateRequestInstance = fn => {
+  _createRequestInstance = fn;
+};
+exports.registerNewCreateRequestInstance = registerNewCreateRequestInstance;
+const createRequestInstance = (resolve, timeout) => {
+  return _createRequestInstance(resolve, timeout);
+};
+exports.createRequestInstance = createRequestInstance;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/api/axiosWrapper.d.ts b/node_modules/@hathor/wallet-lib/oldLib/api/axiosWrapper.d.ts
new file mode 100644
index 0000000..ae3e207
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/api/axiosWrapper.d.ts
@@ -0,0 +1,22 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/**
+ * Method that creates an axios instance
+ *
+ * @module Axios
+ */
+/**
+ * Create an axios instance to be used when sending requests
+ *
+ * @param url Base URL for the api requests
+ * @param _resolve (UNUSED) Callback to be stored and used in case of a retry after a fail
+ * @param timeout Timeout in milliseconds for the request
+ * @param additionalHeaders Headers to be sent with the request
+ */
+export declare const axiosWrapperCreateRequestInstance: (url: string, _resolve?: undefined | null, timeout?: number | null, additionalHeaders?: {}) => import("axios").AxiosInstance;
+export default axiosWrapperCreateRequestInstance;
+//# sourceMappingURL=axiosWrapper.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/api/axiosWrapper.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/api/axiosWrapper.d.ts.map
new file mode 100644
index 0000000..5abeaed
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/api/axiosWrapper.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"axiosWrapper.d.ts","sourceRoot":"","sources":["../../src/api/axiosWrapper.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;AAMH;;;;GAIG;AAEH;;;;;;;GAOG;AACH,eAAO,MAAM,iCAAiC,QACvC,MAAM,aACA,SAAS,GAAG,IAAI,YACjB,MAAM,GAAG,IAAI,0DA+BxB,CAAC;AAEF,eAAe,iCAAiC,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/api/axiosWrapper.js b/node_modules/@hathor/wallet-lib/oldLib/api/axiosWrapper.js
new file mode 100644
index 0000000..4b13e8d
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/api/axiosWrapper.js
@@ -0,0 +1,59 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = exports.axiosWrapperCreateRequestInstance = void 0;
+var _axios = _interopRequireDefault(require("axios"));
+var _constants = require("../constants");
+var _config = _interopRequireDefault(require("../config"));
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+/**
+ * Method that creates an axios instance
+ *
+ * @module Axios
+ */
+
+/**
+ * Create an axios instance to be used when sending requests
+ *
+ * @param url Base URL for the api requests
+ * @param _resolve (UNUSED) Callback to be stored and used in case of a retry after a fail
+ * @param timeout Timeout in milliseconds for the request
+ * @param additionalHeaders Headers to be sent with the request
+ */
+const axiosWrapperCreateRequestInstance = (url, _resolve, timeout, additionalHeaders = {}) => {
+  let timeoutRef;
+  const additionalHeadersObj = {
+    ...additionalHeaders
+  };
+  if (timeout === undefined) {
+    timeoutRef = _constants.TIMEOUT;
+  }
+
+  // Any application using the lib may set in the config object a user agent to be set in all requests
+  const userAgent = _config.default.getUserAgent();
+  if (userAgent) {
+    additionalHeadersObj['User-Agent'] = userAgent;
+  }
+  const defaultOptions = {
+    baseURL: url,
+    headers: {
+      'Content-Type': 'application/json',
+      ...additionalHeadersObj
+    }
+  };
+  if (timeoutRef) {
+    defaultOptions.timeout = timeoutRef;
+  }
+  return _axios.default.create(defaultOptions);
+};
+exports.axiosWrapperCreateRequestInstance = axiosWrapperCreateRequestInstance;
+var _default = exports.default = axiosWrapperCreateRequestInstance;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/api/explorerServiceAxios.d.ts b/node_modules/@hathor/wallet-lib/oldLib/api/explorerServiceAxios.d.ts
new file mode 100644
index 0000000..c4be2a8
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/api/explorerServiceAxios.d.ts
@@ -0,0 +1,20 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/**
+ * Method that creates an axios instance
+ *
+ * @module Axios
+ */
+/**
+ * Create an axios instance to be used when sending requests to the explorer service
+ *
+ * @param {string} network The network to access the explorer service
+ * @param {number} timeout Timeout in milliseconds for the request
+ */
+export declare const axiosInstance: (network: string, timeout?: number) => Promise<import("axios").AxiosInstance>;
+export default axiosInstance;
+//# sourceMappingURL=explorerServiceAxios.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/api/explorerServiceAxios.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/api/explorerServiceAxios.d.ts.map
new file mode 100644
index 0000000..6d8b241
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/api/explorerServiceAxios.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"explorerServiceAxios.d.ts","sourceRoot":"","sources":["../../src/api/explorerServiceAxios.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;AAMH;;;;GAIG;AAEH;;;;;GAKG;AACH,eAAO,MAAM,aAAa,YAAmB,MAAM,YAAW,MAAM,2CAGnE,CAAC;AAEF,eAAe,aAAa,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/api/explorerServiceAxios.js b/node_modules/@hathor/wallet-lib/oldLib/api/explorerServiceAxios.js
new file mode 100644
index 0000000..6c2a0db
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/api/explorerServiceAxios.js
@@ -0,0 +1,35 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = exports.axiosInstance = void 0;
+var _axiosWrapper = _interopRequireDefault(require("./axiosWrapper"));
+var _constants = require("../constants");
+var _config = _interopRequireDefault(require("../config"));
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+/**
+ * Method that creates an axios instance
+ *
+ * @module Axios
+ */
+
+/**
+ * Create an axios instance to be used when sending requests to the explorer service
+ *
+ * @param {string} network The network to access the explorer service
+ * @param {number} timeout Timeout in milliseconds for the request
+ */
+const axiosInstance = async (network, timeout = _constants.TIMEOUT) => {
+  const baseURL = _config.default.getExplorerServiceBaseUrl(network);
+  return (0, _axiosWrapper.default)(baseURL, undefined, timeout);
+};
+exports.axiosInstance = axiosInstance;
+var _default = exports.default = axiosInstance;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/api/featuresApi.d.ts b/node_modules/@hathor/wallet-lib/oldLib/api/featuresApi.d.ts
new file mode 100644
index 0000000..119a243
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/api/featuresApi.d.ts
@@ -0,0 +1,293 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+import { z } from 'zod';
+export declare const featureActivationSchema: z.ZodObject<{
+    name: z.ZodString;
+    state: z.ZodString;
+    acceptance: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+    threshold: z.ZodNumber;
+    start_height: z.ZodNumber;
+    minimum_activation_height: z.ZodNumber;
+    timeout_height: z.ZodNumber;
+    lock_in_on_timeout: z.ZodBoolean;
+    version: z.ZodString;
+}, "passthrough", z.ZodTypeAny, z.objectOutputType<{
+    name: z.ZodString;
+    state: z.ZodString;
+    acceptance: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+    threshold: z.ZodNumber;
+    start_height: z.ZodNumber;
+    minimum_activation_height: z.ZodNumber;
+    timeout_height: z.ZodNumber;
+    lock_in_on_timeout: z.ZodBoolean;
+    version: z.ZodString;
+}, z.ZodTypeAny, "passthrough">, z.objectInputType<{
+    name: z.ZodString;
+    state: z.ZodString;
+    acceptance: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+    threshold: z.ZodNumber;
+    start_height: z.ZodNumber;
+    minimum_activation_height: z.ZodNumber;
+    timeout_height: z.ZodNumber;
+    lock_in_on_timeout: z.ZodBoolean;
+    version: z.ZodString;
+}, z.ZodTypeAny, "passthrough">>;
+export declare const getFeaturesSchema: z.ZodObject<{
+    block_hash: z.ZodString;
+    block_height: z.ZodNumber;
+    features: z.ZodArray<z.ZodObject<{
+        name: z.ZodString;
+        state: z.ZodString;
+        acceptance: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+        threshold: z.ZodNumber;
+        start_height: z.ZodNumber;
+        minimum_activation_height: z.ZodNumber;
+        timeout_height: z.ZodNumber;
+        lock_in_on_timeout: z.ZodBoolean;
+        version: z.ZodString;
+    }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
+        name: z.ZodString;
+        state: z.ZodString;
+        acceptance: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+        threshold: z.ZodNumber;
+        start_height: z.ZodNumber;
+        minimum_activation_height: z.ZodNumber;
+        timeout_height: z.ZodNumber;
+        lock_in_on_timeout: z.ZodBoolean;
+        version: z.ZodString;
+    }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
+        name: z.ZodString;
+        state: z.ZodString;
+        acceptance: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+        threshold: z.ZodNumber;
+        start_height: z.ZodNumber;
+        minimum_activation_height: z.ZodNumber;
+        timeout_height: z.ZodNumber;
+        lock_in_on_timeout: z.ZodBoolean;
+        version: z.ZodString;
+    }, z.ZodTypeAny, "passthrough">>, "many">;
+}, "passthrough", z.ZodTypeAny, z.objectOutputType<{
+    block_hash: z.ZodString;
+    block_height: z.ZodNumber;
+    features: z.ZodArray<z.ZodObject<{
+        name: z.ZodString;
+        state: z.ZodString;
+        acceptance: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+        threshold: z.ZodNumber;
+        start_height: z.ZodNumber;
+        minimum_activation_height: z.ZodNumber;
+        timeout_height: z.ZodNumber;
+        lock_in_on_timeout: z.ZodBoolean;
+        version: z.ZodString;
+    }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
+        name: z.ZodString;
+        state: z.ZodString;
+        acceptance: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+        threshold: z.ZodNumber;
+        start_height: z.ZodNumber;
+        minimum_activation_height: z.ZodNumber;
+        timeout_height: z.ZodNumber;
+        lock_in_on_timeout: z.ZodBoolean;
+        version: z.ZodString;
+    }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
+        name: z.ZodString;
+        state: z.ZodString;
+        acceptance: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+        threshold: z.ZodNumber;
+        start_height: z.ZodNumber;
+        minimum_activation_height: z.ZodNumber;
+        timeout_height: z.ZodNumber;
+        lock_in_on_timeout: z.ZodBoolean;
+        version: z.ZodString;
+    }, z.ZodTypeAny, "passthrough">>, "many">;
+}, z.ZodTypeAny, "passthrough">, z.objectInputType<{
+    block_hash: z.ZodString;
+    block_height: z.ZodNumber;
+    features: z.ZodArray<z.ZodObject<{
+        name: z.ZodString;
+        state: z.ZodString;
+        acceptance: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+        threshold: z.ZodNumber;
+        start_height: z.ZodNumber;
+        minimum_activation_height: z.ZodNumber;
+        timeout_height: z.ZodNumber;
+        lock_in_on_timeout: z.ZodBoolean;
+        version: z.ZodString;
+    }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
+        name: z.ZodString;
+        state: z.ZodString;
+        acceptance: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+        threshold: z.ZodNumber;
+        start_height: z.ZodNumber;
+        minimum_activation_height: z.ZodNumber;
+        timeout_height: z.ZodNumber;
+        lock_in_on_timeout: z.ZodBoolean;
+        version: z.ZodString;
+    }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
+        name: z.ZodString;
+        state: z.ZodString;
+        acceptance: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+        threshold: z.ZodNumber;
+        start_height: z.ZodNumber;
+        minimum_activation_height: z.ZodNumber;
+        timeout_height: z.ZodNumber;
+        lock_in_on_timeout: z.ZodBoolean;
+        version: z.ZodString;
+    }, z.ZodTypeAny, "passthrough">>, "many">;
+}, z.ZodTypeAny, "passthrough">>;
+export declare const errorSchema: z.ZodObject<{
+    success: z.ZodLiteral<false>;
+    error: z.ZodString;
+}, "strip", z.ZodTypeAny, {
+    error: string;
+    success: false;
+}, {
+    error: string;
+    success: false;
+}>;
+export declare const getBlockFeatureSignalBitSchema: z.ZodObject<{
+    bit: z.ZodNumber;
+    signal: z.ZodNumber;
+    feature: z.ZodString;
+    feature_state: z.ZodString;
+}, "passthrough", z.ZodTypeAny, z.objectOutputType<{
+    bit: z.ZodNumber;
+    signal: z.ZodNumber;
+    feature: z.ZodString;
+    feature_state: z.ZodString;
+}, z.ZodTypeAny, "passthrough">, z.objectInputType<{
+    bit: z.ZodNumber;
+    signal: z.ZodNumber;
+    feature: z.ZodString;
+    feature_state: z.ZodString;
+}, z.ZodTypeAny, "passthrough">>;
+export declare const getBlockFeaturesSuccessSchema: z.ZodObject<{
+    signal_bits: z.ZodArray<z.ZodObject<{
+        bit: z.ZodNumber;
+        signal: z.ZodNumber;
+        feature: z.ZodString;
+        feature_state: z.ZodString;
+    }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
+        bit: z.ZodNumber;
+        signal: z.ZodNumber;
+        feature: z.ZodString;
+        feature_state: z.ZodString;
+    }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
+        bit: z.ZodNumber;
+        signal: z.ZodNumber;
+        feature: z.ZodString;
+        feature_state: z.ZodString;
+    }, z.ZodTypeAny, "passthrough">>, "many">;
+}, "passthrough", z.ZodTypeAny, z.objectOutputType<{
+    signal_bits: z.ZodArray<z.ZodObject<{
+        bit: z.ZodNumber;
+        signal: z.ZodNumber;
+        feature: z.ZodString;
+        feature_state: z.ZodString;
+    }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
+        bit: z.ZodNumber;
+        signal: z.ZodNumber;
+        feature: z.ZodString;
+        feature_state: z.ZodString;
+    }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
+        bit: z.ZodNumber;
+        signal: z.ZodNumber;
+        feature: z.ZodString;
+        feature_state: z.ZodString;
+    }, z.ZodTypeAny, "passthrough">>, "many">;
+}, z.ZodTypeAny, "passthrough">, z.objectInputType<{
+    signal_bits: z.ZodArray<z.ZodObject<{
+        bit: z.ZodNumber;
+        signal: z.ZodNumber;
+        feature: z.ZodString;
+        feature_state: z.ZodString;
+    }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
+        bit: z.ZodNumber;
+        signal: z.ZodNumber;
+        feature: z.ZodString;
+        feature_state: z.ZodString;
+    }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
+        bit: z.ZodNumber;
+        signal: z.ZodNumber;
+        feature: z.ZodString;
+        feature_state: z.ZodString;
+    }, z.ZodTypeAny, "passthrough">>, "many">;
+}, z.ZodTypeAny, "passthrough">>;
+export declare const getBlockFeaturesSchema: z.ZodUnion<[z.ZodObject<{
+    signal_bits: z.ZodArray<z.ZodObject<{
+        bit: z.ZodNumber;
+        signal: z.ZodNumber;
+        feature: z.ZodString;
+        feature_state: z.ZodString;
+    }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
+        bit: z.ZodNumber;
+        signal: z.ZodNumber;
+        feature: z.ZodString;
+        feature_state: z.ZodString;
+    }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
+        bit: z.ZodNumber;
+        signal: z.ZodNumber;
+        feature: z.ZodString;
+        feature_state: z.ZodString;
+    }, z.ZodTypeAny, "passthrough">>, "many">;
+}, "passthrough", z.ZodTypeAny, z.objectOutputType<{
+    signal_bits: z.ZodArray<z.ZodObject<{
+        bit: z.ZodNumber;
+        signal: z.ZodNumber;
+        feature: z.ZodString;
+        feature_state: z.ZodString;
+    }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
+        bit: z.ZodNumber;
+        signal: z.ZodNumber;
+        feature: z.ZodString;
+        feature_state: z.ZodString;
+    }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
+        bit: z.ZodNumber;
+        signal: z.ZodNumber;
+        feature: z.ZodString;
+        feature_state: z.ZodString;
+    }, z.ZodTypeAny, "passthrough">>, "many">;
+}, z.ZodTypeAny, "passthrough">, z.objectInputType<{
+    signal_bits: z.ZodArray<z.ZodObject<{
+        bit: z.ZodNumber;
+        signal: z.ZodNumber;
+        feature: z.ZodString;
+        feature_state: z.ZodString;
+    }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
+        bit: z.ZodNumber;
+        signal: z.ZodNumber;
+        feature: z.ZodString;
+        feature_state: z.ZodString;
+    }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
+        bit: z.ZodNumber;
+        signal: z.ZodNumber;
+        feature: z.ZodString;
+        feature_state: z.ZodString;
+    }, z.ZodTypeAny, "passthrough">>, "many">;
+}, z.ZodTypeAny, "passthrough">>, z.ZodObject<{
+    success: z.ZodLiteral<false>;
+    error: z.ZodString;
+}, "strip", z.ZodTypeAny, {
+    error: string;
+    success: false;
+}, {
+    error: string;
+    success: false;
+}>]>;
+declare const featuresApi: {
+    /**
+     * Get feature activation information
+     */
+    getFeatures(): Promise<z.output<typeof getFeaturesSchema>>;
+    /**
+     * Get block features information
+     * @param blockHash Block id encoded as hex
+     */
+    getBlockFeatures(blockHash: string): Promise<z.output<typeof getBlockFeaturesSchema>>;
+};
+export default featuresApi;
+//# sourceMappingURL=featuresApi.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/api/featuresApi.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/api/featuresApi.d.ts.map
new file mode 100644
index 0000000..663a8d7
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/api/featuresApi.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"featuresApi.d.ts","sourceRoot":"","sources":["../../src/api/featuresApi.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;AAEH,OAAO,EAAE,CAAC,EAAE,MAAM,KAAK,CAAC;AAIxB,eAAO,MAAM,uBAAuB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gCAYpB,CAAC;AAEjB,eAAO,MAAM,iBAAiB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gCAMd,CAAC;AAEjB,eAAO,MAAM,WAAW;;;;;;;;;EAGtB,CAAC;AAEH,eAAO,MAAM,8BAA8B;;;;;;;;;;;;;;;gCAO3B,CAAC;AAEjB,eAAO,MAAM,6BAA6B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gCAI1B,CAAC;AAEjB,eAAO,MAAM,sBAAsB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAAwD,CAAC;AAE5F,QAAA,MAAM,WAAW;IACf;;OAEG;mBACkB,QAAQ,EAAE,MAAM,CAAC,wBAAwB,CAAC,CAAC;IAkBhE;;;OAGG;gCAC+B,MAAM,GAAG,QAAQ,EAAE,MAAM,CAAC,6BAA6B,CAAC,CAAC;CAkB5F,CAAC;AAEF,eAAe,WAAW,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/api/featuresApi.js b/node_modules/@hathor/wallet-lib/oldLib/api/featuresApi.js
new file mode 100644
index 0000000..353bd6e
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/api/featuresApi.js
@@ -0,0 +1,83 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.getFeaturesSchema = exports.getBlockFeaturesSuccessSchema = exports.getBlockFeaturesSchema = exports.getBlockFeatureSignalBitSchema = exports.featureActivationSchema = exports.errorSchema = exports.default = void 0;
+var _zod = require("zod");
+var _axiosInstance = require("./axiosInstance");
+var _bigint = require("../utils/bigint");
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+const featureActivationSchema = exports.featureActivationSchema = _zod.z.object({
+  name: _zod.z.string(),
+  state: _zod.z.string(),
+  acceptance: _zod.z.number().nullish(),
+  threshold: _zod.z.number(),
+  start_height: _zod.z.number(),
+  minimum_activation_height: _zod.z.number(),
+  timeout_height: _zod.z.number(),
+  lock_in_on_timeout: _zod.z.boolean(),
+  version: _zod.z.string()
+}).passthrough();
+const getFeaturesSchema = exports.getFeaturesSchema = _zod.z.object({
+  block_hash: _zod.z.string(),
+  block_height: _zod.z.number().min(0),
+  features: _zod.z.array(featureActivationSchema)
+}).passthrough();
+const errorSchema = exports.errorSchema = _zod.z.object({
+  success: _zod.z.literal(false),
+  error: _zod.z.string()
+});
+const getBlockFeatureSignalBitSchema = exports.getBlockFeatureSignalBitSchema = _zod.z.object({
+  bit: _zod.z.number(),
+  signal: _zod.z.number(),
+  feature: _zod.z.string(),
+  feature_state: _zod.z.string()
+}).passthrough();
+const getBlockFeaturesSuccessSchema = exports.getBlockFeaturesSuccessSchema = _zod.z.object({
+  signal_bits: _zod.z.array(getBlockFeatureSignalBitSchema)
+}).passthrough();
+const getBlockFeaturesSchema = exports.getBlockFeaturesSchema = _zod.z.union([getBlockFeaturesSuccessSchema, errorSchema]);
+const featuresApi = {
+  /**
+   * Get feature activation information
+   */
+  async getFeatures() {
+    return new Promise((resolve, reject) => {
+      // @ts-expect-error XXX: createRequestInstance resolve argument is not typed correctly
+      (0, _axiosInstance.createRequestInstance)(resolve).get(`feature`, {
+        transformResponse: res => (0, _bigint.transformJsonBigIntResponse)(res, getFeaturesSchema)
+      }).then(res => {
+        resolve(res.data);
+      }, res => {
+        reject(res);
+      });
+    });
+  },
+  /**
+   * Get block features information
+   * @param blockHash Block id encoded as hex
+   */
+  async getBlockFeatures(blockHash) {
+    return new Promise((resolve, reject) => {
+      // @ts-expect-error XXX: createRequestInstance resolve argument is not typed correctly
+      (0, _axiosInstance.createRequestInstance)(resolve).get(`feature`, {
+        params: {
+          block: blockHash
+        },
+        transformResponse: res => (0, _bigint.transformJsonBigIntResponse)(res, getBlockFeaturesSchema)
+      }).then(res => {
+        resolve(res.data);
+      }, res => {
+        reject(res);
+      });
+    });
+  }
+};
+var _default = exports.default = featuresApi;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/api/health.js b/node_modules/@hathor/wallet-lib/oldLib/api/health.js
new file mode 100644
index 0000000..08b88c6
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/api/health.js
@@ -0,0 +1,39 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+var _axiosInstance = require("./axiosInstance");
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+/**
+ * Api calls for healthcheck
+ *
+ * @namespace ApiHealth
+ */
+
+const healthApi = {
+  /**
+   * Get health information of full node running in connected server
+   *
+   * @return {Promise}
+   * @memberof ApiHealth
+   * @inner
+   */
+  async getHealth() {
+    return new Promise((resolve, reject) => {
+      (0, _axiosInstance.createRequestInstance)(resolve).get(`health`).then(res => {
+        resolve(res.data);
+      }, err => {
+        reject(err);
+      });
+    });
+  }
+};
+var _default = exports.default = healthApi;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/api/metadataApi.d.ts b/node_modules/@hathor/wallet-lib/oldLib/api/metadataApi.d.ts
new file mode 100644
index 0000000..26693c3
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/api/metadataApi.d.ts
@@ -0,0 +1,36 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+type MetadataApiResponse = {
+    id: string;
+    nft?: boolean;
+    banned?: boolean;
+    verified?: boolean;
+    reason?: string;
+    nft_media?: {
+        file: string;
+        type: string;
+        loop: boolean;
+        autoplay: boolean;
+        mime_type?: string;
+    };
+};
+declare const metadataApi: {
+    /**
+     * Returns the Dag Metadata for a given transaction id
+     * @param id Tx Identifier
+     * @param network Network name
+     * @param options
+     * @param [options.retries] Number of retries that the method will attempt before rejecting
+     * @param [options.retryInterval] Interval, in miliseconds, between each attempt
+     */
+    getDagMetadata(id: string, network: string, options?: {
+        retries?: number;
+        retryInterval?: number;
+    }): Promise<MetadataApiResponse | null>;
+};
+export default metadataApi;
+//# sourceMappingURL=metadataApi.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/api/metadataApi.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/api/metadataApi.d.ts.map
new file mode 100644
index 0000000..62aec87
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/api/metadataApi.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"metadataApi.d.ts","sourceRoot":"","sources":["../../src/api/metadataApi.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;AAQH,KAAK,mBAAmB,GAAG;IACzB,EAAE,EAAE,MAAM,CAAC;IACX,GAAG,CAAC,EAAE,OAAO,CAAC;IACd,MAAM,CAAC,EAAE,OAAO,CAAC;IACjB,QAAQ,CAAC,EAAE,OAAO,CAAC;IACnB,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,SAAS,CAAC,EAAE;QAAE,IAAI,EAAE,MAAM,CAAC;QAAC,IAAI,EAAE,MAAM,CAAC;QAAC,IAAI,EAAE,OAAO,CAAC;QAAC,QAAQ,EAAE,OAAO,CAAC;QAAC,SAAS,CAAC,EAAE,MAAM,CAAA;KAAE,CAAC;CAClG,CAAC;AAEF,QAAA,MAAM,WAAW;IACf;;;;;;;OAOG;uBAEG,MAAM,WACD,MAAM,YACN;QAAE,OAAO,CAAC,EAAE,MAAM,CAAC;QAAC,aAAa,CAAC,EAAE,MAAM,CAAA;KAAE;CAmDxD,CAAC;AAEF,eAAe,WAAW,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/api/metadataApi.js b/node_modules/@hathor/wallet-lib/oldLib/api/metadataApi.js
new file mode 100644
index 0000000..898f576
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/api/metadataApi.js
@@ -0,0 +1,82 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+var _explorerServiceAxios = _interopRequireDefault(require("./explorerServiceAxios"));
+var _helpers = _interopRequireDefault(require("../utils/helpers"));
+var _constants = require("../constants");
+var _errors = require("../errors");
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+const metadataApi = {
+  /**
+   * Returns the Dag Metadata for a given transaction id
+   * @param id Tx Identifier
+   * @param network Network name
+   * @param options
+   * @param [options.retries] Number of retries that the method will attempt before rejecting
+   * @param [options.retryInterval] Interval, in miliseconds, between each attempt
+   */
+  async getDagMetadata(id, network, options = {}) {
+    const newOptions = {
+      retries: _constants.METADATA_RETRY_LIMIT,
+      retryInterval: _constants.DOWNLOAD_METADATA_RETRY_INTERVAL,
+      ...options
+    };
+    const {
+      retryInterval
+    } = newOptions;
+    let {
+      retries
+    } = newOptions;
+    let metaData = null;
+    while (retries >= 0) {
+      const client = await (0, _explorerServiceAxios.default)(network);
+      try {
+        const response = await client.get('metadata/dag', {
+          params: {
+            id
+          }
+        });
+        if (response.data) {
+          metaData = response.data;
+          break;
+        }
+        // Error downloading metadata
+        // throw Error and the catch will handle it
+        throw new _errors.GetDagMetadataApiError('Invalid metadata API response.');
+      } catch (e) {
+        if (e.response?.status === 404) {
+          // 404 is not flagged as an error by our current Axios configuration
+          // No need to do anything, the metadata for this token was not found
+          // There is no error here, we just return null
+          metaData = null;
+          break;
+        }
+        if (!(e instanceof Error)) {
+          // This is for the typescript compiler, since it doesn't know that e is an Error
+          throw new _errors.GetDagMetadataApiError('Unknown error.');
+        }
+        // Error downloading metadata
+        if (retries === 0) {
+          // If we have no more retries left, then we propagate the error
+          throw new _errors.GetDagMetadataApiError(e.message);
+        } else {
+          // If we still have retry attempts, then we wait a few seconds and retry
+          await _helpers.default.sleep(retryInterval);
+          retries--;
+        }
+      }
+    }
+    return metaData;
+  }
+};
+var _default = exports.default = metadataApi;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/api/nano.d.ts b/node_modules/@hathor/wallet-lib/oldLib/api/nano.d.ts
new file mode 100644
index 0000000..3f98b72
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/api/nano.d.ts
@@ -0,0 +1,52 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+import { NanoContractBlueprintInformationAPIResponse, NanoContractHistoryAPIResponse, NanoContractStateAPIResponse } from '../nano_contracts/types';
+/**
+ * Api calls for nano contracts
+ *
+ * @namespace ApiNanoContracts
+ */
+declare const ncApi: {
+    /**
+     * Call get nano contracts state API
+     *
+     * @param id Nano Contract ID
+     * @param fields Array of fields to get state
+     * @param balances Array of balances to get state
+     * @param calls Array of private method calls to execute in the nano contract and get the result
+     * @param block_hash Hash of the block to get the state of the nano
+     * @param block_height Height of the block to get the state of the nano
+     *
+     * @memberof ApiNanoContracts
+     * @inner
+     */
+    getNanoContractState(id: string, fields: string[], balances: string[], calls: string[], block_hash?: string | null, block_height?: number | null): Promise<NanoContractStateAPIResponse>;
+    /**
+     * Call get nano contracts history API
+     *
+     * @param id Nano Contract ID
+     * @param count Quantity of elements to return
+     * @param after Used for pagination in the results
+     * @param before Used for pagination in the results
+     *
+     * @memberof ApiNanoContracts
+     * @inner
+     */
+    getNanoContractHistory(id: string, count?: number | null, after?: string | null, before?: string | null): Promise<NanoContractHistoryAPIResponse>;
+    /**
+     * Call get blueprint information
+     *
+     * @param id Blueprint ID
+     *
+     * @return {Promise}
+     * @memberof ApiNanoContracts
+     * @inner
+     */
+    getBlueprintInformation(id: string): Promise<NanoContractBlueprintInformationAPIResponse>;
+};
+export default ncApi;
+//# sourceMappingURL=nano.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/api/nano.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/api/nano.d.ts.map
new file mode 100644
index 0000000..e59411e
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/api/nano.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"nano.d.ts","sourceRoot":"","sources":["../../src/api/nano.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;AAKH,OAAO,EACL,2CAA2C,EAC3C,8BAA8B,EAC9B,4BAA4B,EAE7B,MAAM,yBAAyB,CAAC;AAEjC;;;;GAIG;AAEH,QAAA,MAAM,KAAK;IACT;;;;;;;;;;;;OAYG;6BAEG,MAAM,UACF,MAAM,EAAE,YACN,MAAM,EAAE,SACX,MAAM,EAAE,eACH,MAAM,GAAG,IAAI,iBACX,MAAM,GAAG,IAAI,GAC1B,QAAQ,4BAA4B,CAAC;IAgCxC;;;;;;;;;;OAUG;+BAEG,MAAM,UACH,MAAM,GAAG,IAAI,UACb,MAAM,GAAG,IAAI,WACZ,MAAM,GAAG,IAAI,GACpB,QAAQ,8BAA8B,CAAC;IAuB1C;;;;;;;;OAQG;gCAC+B,MAAM,GAAG,QAAQ,2CAA2C,CAAC;CAsBhG,CAAC;AAEF,eAAe,KAAK,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/api/nano.js b/node_modules/@hathor/wallet-lib/oldLib/api/nano.js
new file mode 100644
index 0000000..04be165
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/api/nano.js
@@ -0,0 +1,143 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+var _axios = _interopRequireDefault(require("axios"));
+var _axiosInstance = require("./axiosInstance");
+var _errors = require("../errors");
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+/**
+ * Api calls for nano contracts
+ *
+ * @namespace ApiNanoContracts
+ */
+
+const ncApi = {
+  /**
+   * Call get nano contracts state API
+   *
+   * @param id Nano Contract ID
+   * @param fields Array of fields to get state
+   * @param balances Array of balances to get state
+   * @param calls Array of private method calls to execute in the nano contract and get the result
+   * @param block_hash Hash of the block to get the state of the nano
+   * @param block_height Height of the block to get the state of the nano
+   *
+   * @memberof ApiNanoContracts
+   * @inner
+   */
+  async getNanoContractState(id, fields, balances, calls, block_hash = null, block_height = null) {
+    const data = {
+      id,
+      fields,
+      balances,
+      calls
+    };
+    if (block_hash) {
+      data.block_hash = block_hash;
+    }
+    if (block_height) {
+      data.block_height = block_height;
+    }
+    const axiosInstance = await (0, _axiosInstance.createRequestInstance)();
+    try {
+      const response = await axiosInstance.get(`nano_contract/state`, {
+        params: data
+      });
+      const responseData = response.data;
+      if (response.status === 200 && responseData.success) {
+        return responseData;
+      }
+      throw new _errors.NanoRequestError('Error getting nano contract state.', null, response);
+    } catch (error) {
+      if (_axios.default.isAxiosError(error)) {
+        const e = error;
+        if (e.response && e.response.status === 404) {
+          throw new _errors.NanoRequest404Error('Nano contract not found.', e, e.response);
+        }
+      }
+      throw new _errors.NanoRequestError('Error getting nano contract state.', error);
+    }
+  },
+  /**
+   * Call get nano contracts history API
+   *
+   * @param id Nano Contract ID
+   * @param count Quantity of elements to return
+   * @param after Used for pagination in the results
+   * @param before Used for pagination in the results
+   *
+   * @memberof ApiNanoContracts
+   * @inner
+   */
+  async getNanoContractHistory(id, count = null, after = null, before = null) {
+    const data = {
+      id,
+      count,
+      after,
+      before
+    };
+    const axiosInstance = await (0, _axiosInstance.createRequestInstance)();
+    try {
+      const response = await axiosInstance.get(`nano_contract/history`, {
+        params: data
+      });
+      const responseData = response.data;
+      if (response.status === 200 && responseData.success) {
+        return responseData;
+      }
+      throw new _errors.NanoRequestError('Error getting nano contract history.', null, response);
+    } catch (error) {
+      if (_axios.default.isAxiosError(error)) {
+        const e = error;
+        if (e.response && e.response.status === 404) {
+          throw new _errors.NanoRequest404Error('Nano contract not found.', e, e.response);
+        }
+      }
+      throw new _errors.NanoRequestError('Error getting nano contract history.', error);
+    }
+  },
+  /**
+   * Call get blueprint information
+   *
+   * @param id Blueprint ID
+   *
+   * @return {Promise}
+   * @memberof ApiNanoContracts
+   * @inner
+   */
+  async getBlueprintInformation(id) {
+    const data = {
+      blueprint_id: id
+    };
+    const axiosInstance = await (0, _axiosInstance.createRequestInstance)();
+    try {
+      const response = await axiosInstance.get(`nano_contract/blueprint/info`, {
+        params: data
+      });
+      const responseData = response.data;
+      if (response.status === 200) {
+        return responseData;
+      }
+      throw new _errors.NanoRequestError('Error getting blueprint information.', null, response);
+    } catch (error) {
+      if (_axios.default.isAxiosError(error)) {
+        const e = error;
+        if (e.response && e.response.status === 404) {
+          throw new _errors.NanoRequest404Error('Blueprint not found.', e, e.response);
+        }
+      }
+      throw new _errors.NanoRequestError('Error getting blueprint information.', error);
+    }
+  }
+};
+var _default = exports.default = ncApi;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/api/schemas/txApi.d.ts b/node_modules/@hathor/wallet-lib/oldLib/api/schemas/txApi.d.ts
new file mode 100644
index 0000000..279f335
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/api/schemas/txApi.d.ts
@@ -0,0 +1,2871 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+import { z } from 'zod';
+export declare const decodedSchema: z.ZodDiscriminatedUnion<"type", [z.ZodObject<{
+    type: z.ZodLiteral<"P2PKH">;
+    address: z.ZodString;
+    timelock: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+    value: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+    token_data: z.ZodNumber;
+}, "strip", z.ZodTypeAny, {
+    type: "P2PKH";
+    address: string;
+    value: bigint;
+    token_data: number;
+    timelock?: number | null | undefined;
+}, {
+    type: "P2PKH";
+    address: string;
+    value: string | number | bigint;
+    token_data: number;
+    timelock?: number | null | undefined;
+}>, z.ZodObject<{
+    type: z.ZodLiteral<"MultiSig">;
+    address: z.ZodString;
+    timelock: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+    value: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+    token_data: z.ZodNumber;
+}, "strip", z.ZodTypeAny, {
+    type: "MultiSig";
+    address: string;
+    value: bigint;
+    token_data: number;
+    timelock?: number | null | undefined;
+}, {
+    type: "MultiSig";
+    address: string;
+    value: string | number | bigint;
+    token_data: number;
+    timelock?: number | null | undefined;
+}>, z.ZodObject<{
+    type: z.ZodUndefined;
+}, "passthrough", z.ZodTypeAny, z.objectOutputType<{
+    type: z.ZodUndefined;
+}, z.ZodTypeAny, "passthrough">, z.objectInputType<{
+    type: z.ZodUndefined;
+}, z.ZodTypeAny, "passthrough">>]>;
+export declare const fullnodeTxApiInputSchema: z.ZodObject<{
+    value: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+    token_data: z.ZodNumber;
+    script: z.ZodString;
+    decoded: z.ZodDiscriminatedUnion<"type", [z.ZodObject<{
+        type: z.ZodLiteral<"P2PKH">;
+        address: z.ZodString;
+        timelock: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+        value: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+        token_data: z.ZodNumber;
+    }, "strip", z.ZodTypeAny, {
+        type: "P2PKH";
+        address: string;
+        value: bigint;
+        token_data: number;
+        timelock?: number | null | undefined;
+    }, {
+        type: "P2PKH";
+        address: string;
+        value: string | number | bigint;
+        token_data: number;
+        timelock?: number | null | undefined;
+    }>, z.ZodObject<{
+        type: z.ZodLiteral<"MultiSig">;
+        address: z.ZodString;
+        timelock: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+        value: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+        token_data: z.ZodNumber;
+    }, "strip", z.ZodTypeAny, {
+        type: "MultiSig";
+        address: string;
+        value: bigint;
+        token_data: number;
+        timelock?: number | null | undefined;
+    }, {
+        type: "MultiSig";
+        address: string;
+        value: string | number | bigint;
+        token_data: number;
+        timelock?: number | null | undefined;
+    }>, z.ZodObject<{
+        type: z.ZodUndefined;
+    }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
+        type: z.ZodUndefined;
+    }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
+        type: z.ZodUndefined;
+    }, z.ZodTypeAny, "passthrough">>]>;
+    tx_id: z.ZodString;
+    index: z.ZodNumber;
+    token: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+}, "strip", z.ZodTypeAny, {
+    index: number;
+    value: bigint;
+    script: string;
+    token_data: number;
+    decoded: {
+        type: "P2PKH";
+        address: string;
+        value: bigint;
+        token_data: number;
+        timelock?: number | null | undefined;
+    } | {
+        type: "MultiSig";
+        address: string;
+        value: bigint;
+        token_data: number;
+        timelock?: number | null | undefined;
+    } | z.objectOutputType<{
+        type: z.ZodUndefined;
+    }, z.ZodTypeAny, "passthrough">;
+    tx_id: string;
+    token?: string | null | undefined;
+}, {
+    index: number;
+    value: string | number | bigint;
+    script: string;
+    token_data: number;
+    decoded: {
+        type: "P2PKH";
+        address: string;
+        value: string | number | bigint;
+        token_data: number;
+        timelock?: number | null | undefined;
+    } | {
+        type: "MultiSig";
+        address: string;
+        value: string | number | bigint;
+        token_data: number;
+        timelock?: number | null | undefined;
+    } | z.objectInputType<{
+        type: z.ZodUndefined;
+    }, z.ZodTypeAny, "passthrough">;
+    tx_id: string;
+    token?: string | null | undefined;
+}>;
+export declare const fullnodeTxApiOutputSchema: z.ZodObject<{
+    value: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+    token_data: z.ZodNumber;
+    script: z.ZodString;
+    decoded: z.ZodDiscriminatedUnion<"type", [z.ZodObject<{
+        type: z.ZodLiteral<"P2PKH">;
+        address: z.ZodString;
+        timelock: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+        value: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+        token_data: z.ZodNumber;
+    }, "strip", z.ZodTypeAny, {
+        type: "P2PKH";
+        address: string;
+        value: bigint;
+        token_data: number;
+        timelock?: number | null | undefined;
+    }, {
+        type: "P2PKH";
+        address: string;
+        value: string | number | bigint;
+        token_data: number;
+        timelock?: number | null | undefined;
+    }>, z.ZodObject<{
+        type: z.ZodLiteral<"MultiSig">;
+        address: z.ZodString;
+        timelock: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+        value: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+        token_data: z.ZodNumber;
+    }, "strip", z.ZodTypeAny, {
+        type: "MultiSig";
+        address: string;
+        value: bigint;
+        token_data: number;
+        timelock?: number | null | undefined;
+    }, {
+        type: "MultiSig";
+        address: string;
+        value: string | number | bigint;
+        token_data: number;
+        timelock?: number | null | undefined;
+    }>, z.ZodObject<{
+        type: z.ZodUndefined;
+    }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
+        type: z.ZodUndefined;
+    }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
+        type: z.ZodUndefined;
+    }, z.ZodTypeAny, "passthrough">>]>;
+    token: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+    spent_by: z.ZodDefault<z.ZodNullable<z.ZodString>>;
+}, "strip", z.ZodTypeAny, {
+    value: bigint;
+    script: string;
+    token_data: number;
+    decoded: {
+        type: "P2PKH";
+        address: string;
+        value: bigint;
+        token_data: number;
+        timelock?: number | null | undefined;
+    } | {
+        type: "MultiSig";
+        address: string;
+        value: bigint;
+        token_data: number;
+        timelock?: number | null | undefined;
+    } | z.objectOutputType<{
+        type: z.ZodUndefined;
+    }, z.ZodTypeAny, "passthrough">;
+    spent_by: string | null;
+    token?: string | null | undefined;
+}, {
+    value: string | number | bigint;
+    script: string;
+    token_data: number;
+    decoded: {
+        type: "P2PKH";
+        address: string;
+        value: string | number | bigint;
+        token_data: number;
+        timelock?: number | null | undefined;
+    } | {
+        type: "MultiSig";
+        address: string;
+        value: string | number | bigint;
+        token_data: number;
+        timelock?: number | null | undefined;
+    } | z.objectInputType<{
+        type: z.ZodUndefined;
+    }, z.ZodTypeAny, "passthrough">;
+    token?: string | null | undefined;
+    spent_by?: string | null | undefined;
+}>;
+export declare const fullnodeTxApiTokenSchema: z.ZodObject<{
+    uid: z.ZodString;
+    name: z.ZodNullable<z.ZodString>;
+    symbol: z.ZodNullable<z.ZodString>;
+}, "strip", z.ZodTypeAny, {
+    symbol: string | null;
+    name: string | null;
+    uid: string;
+}, {
+    symbol: string | null;
+    name: string | null;
+    uid: string;
+}>;
+export declare const fullnodeTxApiTxSchema: z.ZodObject<{
+    hash: z.ZodString;
+    nonce: z.ZodString;
+    timestamp: z.ZodNumber;
+    version: z.ZodNumber;
+    weight: z.ZodNumber;
+    signal_bits: z.ZodNumber;
+    parents: z.ZodArray<z.ZodString, "many">;
+    nc_id: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+    nc_method: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+    nc_pubkey: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+    nc_address: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+    nc_context: z.ZodOptional<z.ZodNullable<z.ZodObject<{
+        actions: z.ZodArray<z.ZodDiscriminatedUnion<"type", [z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+        }>, {
+            type: z.ZodLiteral<"deposit">;
+        }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+        }>, {
+            type: z.ZodLiteral<"deposit">;
+        }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+        }>, {
+            type: z.ZodLiteral<"deposit">;
+        }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+        }>, {
+            type: z.ZodLiteral<"withdrawal">;
+        }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+        }>, {
+            type: z.ZodLiteral<"withdrawal">;
+        }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+        }>, {
+            type: z.ZodLiteral<"withdrawal">;
+        }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            mint: z.ZodBoolean;
+            melt: z.ZodBoolean;
+        }>, {
+            type: z.ZodLiteral<"grant_authority">;
+        }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            mint: z.ZodBoolean;
+            melt: z.ZodBoolean;
+        }>, {
+            type: z.ZodLiteral<"grant_authority">;
+        }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            mint: z.ZodBoolean;
+            melt: z.ZodBoolean;
+        }>, {
+            type: z.ZodLiteral<"grant_authority">;
+        }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            mint: z.ZodBoolean;
+            melt: z.ZodBoolean;
+        }>, {
+            type: z.ZodLiteral<"acquire_authority">;
+        }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            mint: z.ZodBoolean;
+            melt: z.ZodBoolean;
+        }>, {
+            type: z.ZodLiteral<"acquire_authority">;
+        }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            mint: z.ZodBoolean;
+            melt: z.ZodBoolean;
+        }>, {
+            type: z.ZodLiteral<"acquire_authority">;
+        }>, z.ZodTypeAny, "passthrough">>]>, "many">;
+        address: z.ZodString;
+        timestamp: z.ZodNumber;
+    }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
+        actions: z.ZodArray<z.ZodDiscriminatedUnion<"type", [z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+        }>, {
+            type: z.ZodLiteral<"deposit">;
+        }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+        }>, {
+            type: z.ZodLiteral<"deposit">;
+        }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+        }>, {
+            type: z.ZodLiteral<"deposit">;
+        }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+        }>, {
+            type: z.ZodLiteral<"withdrawal">;
+        }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+        }>, {
+            type: z.ZodLiteral<"withdrawal">;
+        }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+        }>, {
+            type: z.ZodLiteral<"withdrawal">;
+        }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            mint: z.ZodBoolean;
+            melt: z.ZodBoolean;
+        }>, {
+            type: z.ZodLiteral<"grant_authority">;
+        }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            mint: z.ZodBoolean;
+            melt: z.ZodBoolean;
+        }>, {
+            type: z.ZodLiteral<"grant_authority">;
+        }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            mint: z.ZodBoolean;
+            melt: z.ZodBoolean;
+        }>, {
+            type: z.ZodLiteral<"grant_authority">;
+        }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            mint: z.ZodBoolean;
+            melt: z.ZodBoolean;
+        }>, {
+            type: z.ZodLiteral<"acquire_authority">;
+        }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            mint: z.ZodBoolean;
+            melt: z.ZodBoolean;
+        }>, {
+            type: z.ZodLiteral<"acquire_authority">;
+        }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            mint: z.ZodBoolean;
+            melt: z.ZodBoolean;
+        }>, {
+            type: z.ZodLiteral<"acquire_authority">;
+        }>, z.ZodTypeAny, "passthrough">>]>, "many">;
+        address: z.ZodString;
+        timestamp: z.ZodNumber;
+    }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
+        actions: z.ZodArray<z.ZodDiscriminatedUnion<"type", [z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+        }>, {
+            type: z.ZodLiteral<"deposit">;
+        }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+        }>, {
+            type: z.ZodLiteral<"deposit">;
+        }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+        }>, {
+            type: z.ZodLiteral<"deposit">;
+        }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+        }>, {
+            type: z.ZodLiteral<"withdrawal">;
+        }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+        }>, {
+            type: z.ZodLiteral<"withdrawal">;
+        }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+        }>, {
+            type: z.ZodLiteral<"withdrawal">;
+        }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            mint: z.ZodBoolean;
+            melt: z.ZodBoolean;
+        }>, {
+            type: z.ZodLiteral<"grant_authority">;
+        }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            mint: z.ZodBoolean;
+            melt: z.ZodBoolean;
+        }>, {
+            type: z.ZodLiteral<"grant_authority">;
+        }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            mint: z.ZodBoolean;
+            melt: z.ZodBoolean;
+        }>, {
+            type: z.ZodLiteral<"grant_authority">;
+        }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            mint: z.ZodBoolean;
+            melt: z.ZodBoolean;
+        }>, {
+            type: z.ZodLiteral<"acquire_authority">;
+        }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            mint: z.ZodBoolean;
+            melt: z.ZodBoolean;
+        }>, {
+            type: z.ZodLiteral<"acquire_authority">;
+        }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            mint: z.ZodBoolean;
+            melt: z.ZodBoolean;
+        }>, {
+            type: z.ZodLiteral<"acquire_authority">;
+        }>, z.ZodTypeAny, "passthrough">>]>, "many">;
+        address: z.ZodString;
+        timestamp: z.ZodNumber;
+    }, z.ZodTypeAny, "passthrough">>>>;
+    nc_args: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+    nc_blueprint_id: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+    inputs: z.ZodArray<z.ZodObject<{
+        value: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+        token_data: z.ZodNumber;
+        script: z.ZodString;
+        decoded: z.ZodDiscriminatedUnion<"type", [z.ZodObject<{
+            type: z.ZodLiteral<"P2PKH">;
+            address: z.ZodString;
+            timelock: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+            value: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            token_data: z.ZodNumber;
+        }, "strip", z.ZodTypeAny, {
+            type: "P2PKH";
+            address: string;
+            value: bigint;
+            token_data: number;
+            timelock?: number | null | undefined;
+        }, {
+            type: "P2PKH";
+            address: string;
+            value: string | number | bigint;
+            token_data: number;
+            timelock?: number | null | undefined;
+        }>, z.ZodObject<{
+            type: z.ZodLiteral<"MultiSig">;
+            address: z.ZodString;
+            timelock: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+            value: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            token_data: z.ZodNumber;
+        }, "strip", z.ZodTypeAny, {
+            type: "MultiSig";
+            address: string;
+            value: bigint;
+            token_data: number;
+            timelock?: number | null | undefined;
+        }, {
+            type: "MultiSig";
+            address: string;
+            value: string | number | bigint;
+            token_data: number;
+            timelock?: number | null | undefined;
+        }>, z.ZodObject<{
+            type: z.ZodUndefined;
+        }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
+            type: z.ZodUndefined;
+        }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
+            type: z.ZodUndefined;
+        }, z.ZodTypeAny, "passthrough">>]>;
+        tx_id: z.ZodString;
+        index: z.ZodNumber;
+        token: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+    }, "strip", z.ZodTypeAny, {
+        index: number;
+        value: bigint;
+        script: string;
+        token_data: number;
+        decoded: {
+            type: "P2PKH";
+            address: string;
+            value: bigint;
+            token_data: number;
+            timelock?: number | null | undefined;
+        } | {
+            type: "MultiSig";
+            address: string;
+            value: bigint;
+            token_data: number;
+            timelock?: number | null | undefined;
+        } | z.objectOutputType<{
+            type: z.ZodUndefined;
+        }, z.ZodTypeAny, "passthrough">;
+        tx_id: string;
+        token?: string | null | undefined;
+    }, {
+        index: number;
+        value: string | number | bigint;
+        script: string;
+        token_data: number;
+        decoded: {
+            type: "P2PKH";
+            address: string;
+            value: string | number | bigint;
+            token_data: number;
+            timelock?: number | null | undefined;
+        } | {
+            type: "MultiSig";
+            address: string;
+            value: string | number | bigint;
+            token_data: number;
+            timelock?: number | null | undefined;
+        } | z.objectInputType<{
+            type: z.ZodUndefined;
+        }, z.ZodTypeAny, "passthrough">;
+        tx_id: string;
+        token?: string | null | undefined;
+    }>, "many">;
+    outputs: z.ZodArray<z.ZodObject<{
+        value: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+        token_data: z.ZodNumber;
+        script: z.ZodString;
+        decoded: z.ZodDiscriminatedUnion<"type", [z.ZodObject<{
+            type: z.ZodLiteral<"P2PKH">;
+            address: z.ZodString;
+            timelock: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+            value: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            token_data: z.ZodNumber;
+        }, "strip", z.ZodTypeAny, {
+            type: "P2PKH";
+            address: string;
+            value: bigint;
+            token_data: number;
+            timelock?: number | null | undefined;
+        }, {
+            type: "P2PKH";
+            address: string;
+            value: string | number | bigint;
+            token_data: number;
+            timelock?: number | null | undefined;
+        }>, z.ZodObject<{
+            type: z.ZodLiteral<"MultiSig">;
+            address: z.ZodString;
+            timelock: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+            value: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            token_data: z.ZodNumber;
+        }, "strip", z.ZodTypeAny, {
+            type: "MultiSig";
+            address: string;
+            value: bigint;
+            token_data: number;
+            timelock?: number | null | undefined;
+        }, {
+            type: "MultiSig";
+            address: string;
+            value: string | number | bigint;
+            token_data: number;
+            timelock?: number | null | undefined;
+        }>, z.ZodObject<{
+            type: z.ZodUndefined;
+        }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
+            type: z.ZodUndefined;
+        }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
+            type: z.ZodUndefined;
+        }, z.ZodTypeAny, "passthrough">>]>;
+        token: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+        spent_by: z.ZodDefault<z.ZodNullable<z.ZodString>>;
+    }, "strip", z.ZodTypeAny, {
+        value: bigint;
+        script: string;
+        token_data: number;
+        decoded: {
+            type: "P2PKH";
+            address: string;
+            value: bigint;
+            token_data: number;
+            timelock?: number | null | undefined;
+        } | {
+            type: "MultiSig";
+            address: string;
+            value: bigint;
+            token_data: number;
+            timelock?: number | null | undefined;
+        } | z.objectOutputType<{
+            type: z.ZodUndefined;
+        }, z.ZodTypeAny, "passthrough">;
+        spent_by: string | null;
+        token?: string | null | undefined;
+    }, {
+        value: string | number | bigint;
+        script: string;
+        token_data: number;
+        decoded: {
+            type: "P2PKH";
+            address: string;
+            value: string | number | bigint;
+            token_data: number;
+            timelock?: number | null | undefined;
+        } | {
+            type: "MultiSig";
+            address: string;
+            value: string | number | bigint;
+            token_data: number;
+            timelock?: number | null | undefined;
+        } | z.objectInputType<{
+            type: z.ZodUndefined;
+        }, z.ZodTypeAny, "passthrough">;
+        token?: string | null | undefined;
+        spent_by?: string | null | undefined;
+    }>, "many">;
+    tokens: z.ZodArray<z.ZodObject<{
+        uid: z.ZodString;
+        name: z.ZodNullable<z.ZodString>;
+        symbol: z.ZodNullable<z.ZodString>;
+    }, "strip", z.ZodTypeAny, {
+        symbol: string | null;
+        name: string | null;
+        uid: string;
+    }, {
+        symbol: string | null;
+        name: string | null;
+        uid: string;
+    }>, "many">;
+    token_name: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+    token_symbol: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+    raw: z.ZodString;
+}, "strip", z.ZodTypeAny, {
+    raw: string;
+    nonce: string;
+    hash: string;
+    tokens: {
+        symbol: string | null;
+        name: string | null;
+        uid: string;
+    }[];
+    timestamp: number;
+    version: number;
+    weight: number;
+    inputs: {
+        index: number;
+        value: bigint;
+        script: string;
+        token_data: number;
+        decoded: {
+            type: "P2PKH";
+            address: string;
+            value: bigint;
+            token_data: number;
+            timelock?: number | null | undefined;
+        } | {
+            type: "MultiSig";
+            address: string;
+            value: bigint;
+            token_data: number;
+            timelock?: number | null | undefined;
+        } | z.objectOutputType<{
+            type: z.ZodUndefined;
+        }, z.ZodTypeAny, "passthrough">;
+        tx_id: string;
+        token?: string | null | undefined;
+    }[];
+    outputs: {
+        value: bigint;
+        script: string;
+        token_data: number;
+        decoded: {
+            type: "P2PKH";
+            address: string;
+            value: bigint;
+            token_data: number;
+            timelock?: number | null | undefined;
+        } | {
+            type: "MultiSig";
+            address: string;
+            value: bigint;
+            token_data: number;
+            timelock?: number | null | undefined;
+        } | z.objectOutputType<{
+            type: z.ZodUndefined;
+        }, z.ZodTypeAny, "passthrough">;
+        spent_by: string | null;
+        token?: string | null | undefined;
+    }[];
+    parents: string[];
+    signal_bits: number;
+    token_name?: string | null | undefined;
+    token_symbol?: string | null | undefined;
+    nc_id?: string | null | undefined;
+    nc_blueprint_id?: string | null | undefined;
+    nc_method?: string | null | undefined;
+    nc_args?: string | null | undefined;
+    nc_pubkey?: string | null | undefined;
+    nc_address?: string | null | undefined;
+    nc_context?: z.objectOutputType<{
+        actions: z.ZodArray<z.ZodDiscriminatedUnion<"type", [z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+        }>, {
+            type: z.ZodLiteral<"deposit">;
+        }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+        }>, {
+            type: z.ZodLiteral<"deposit">;
+        }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+        }>, {
+            type: z.ZodLiteral<"deposit">;
+        }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+        }>, {
+            type: z.ZodLiteral<"withdrawal">;
+        }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+        }>, {
+            type: z.ZodLiteral<"withdrawal">;
+        }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+        }>, {
+            type: z.ZodLiteral<"withdrawal">;
+        }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            mint: z.ZodBoolean;
+            melt: z.ZodBoolean;
+        }>, {
+            type: z.ZodLiteral<"grant_authority">;
+        }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            mint: z.ZodBoolean;
+            melt: z.ZodBoolean;
+        }>, {
+            type: z.ZodLiteral<"grant_authority">;
+        }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            mint: z.ZodBoolean;
+            melt: z.ZodBoolean;
+        }>, {
+            type: z.ZodLiteral<"grant_authority">;
+        }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            mint: z.ZodBoolean;
+            melt: z.ZodBoolean;
+        }>, {
+            type: z.ZodLiteral<"acquire_authority">;
+        }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            mint: z.ZodBoolean;
+            melt: z.ZodBoolean;
+        }>, {
+            type: z.ZodLiteral<"acquire_authority">;
+        }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            mint: z.ZodBoolean;
+            melt: z.ZodBoolean;
+        }>, {
+            type: z.ZodLiteral<"acquire_authority">;
+        }>, z.ZodTypeAny, "passthrough">>]>, "many">;
+        address: z.ZodString;
+        timestamp: z.ZodNumber;
+    }, z.ZodTypeAny, "passthrough"> | null | undefined;
+}, {
+    raw: string;
+    nonce: string;
+    hash: string;
+    tokens: {
+        symbol: string | null;
+        name: string | null;
+        uid: string;
+    }[];
+    timestamp: number;
+    version: number;
+    weight: number;
+    inputs: {
+        index: number;
+        value: string | number | bigint;
+        script: string;
+        token_data: number;
+        decoded: {
+            type: "P2PKH";
+            address: string;
+            value: string | number | bigint;
+            token_data: number;
+            timelock?: number | null | undefined;
+        } | {
+            type: "MultiSig";
+            address: string;
+            value: string | number | bigint;
+            token_data: number;
+            timelock?: number | null | undefined;
+        } | z.objectInputType<{
+            type: z.ZodUndefined;
+        }, z.ZodTypeAny, "passthrough">;
+        tx_id: string;
+        token?: string | null | undefined;
+    }[];
+    outputs: {
+        value: string | number | bigint;
+        script: string;
+        token_data: number;
+        decoded: {
+            type: "P2PKH";
+            address: string;
+            value: string | number | bigint;
+            token_data: number;
+            timelock?: number | null | undefined;
+        } | {
+            type: "MultiSig";
+            address: string;
+            value: string | number | bigint;
+            token_data: number;
+            timelock?: number | null | undefined;
+        } | z.objectInputType<{
+            type: z.ZodUndefined;
+        }, z.ZodTypeAny, "passthrough">;
+        token?: string | null | undefined;
+        spent_by?: string | null | undefined;
+    }[];
+    parents: string[];
+    signal_bits: number;
+    token_name?: string | null | undefined;
+    token_symbol?: string | null | undefined;
+    nc_id?: string | null | undefined;
+    nc_blueprint_id?: string | null | undefined;
+    nc_method?: string | null | undefined;
+    nc_args?: string | null | undefined;
+    nc_pubkey?: string | null | undefined;
+    nc_address?: string | null | undefined;
+    nc_context?: z.objectInputType<{
+        actions: z.ZodArray<z.ZodDiscriminatedUnion<"type", [z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+        }>, {
+            type: z.ZodLiteral<"deposit">;
+        }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+        }>, {
+            type: z.ZodLiteral<"deposit">;
+        }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+        }>, {
+            type: z.ZodLiteral<"deposit">;
+        }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+        }>, {
+            type: z.ZodLiteral<"withdrawal">;
+        }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+        }>, {
+            type: z.ZodLiteral<"withdrawal">;
+        }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+        }>, {
+            type: z.ZodLiteral<"withdrawal">;
+        }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            mint: z.ZodBoolean;
+            melt: z.ZodBoolean;
+        }>, {
+            type: z.ZodLiteral<"grant_authority">;
+        }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            mint: z.ZodBoolean;
+            melt: z.ZodBoolean;
+        }>, {
+            type: z.ZodLiteral<"grant_authority">;
+        }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            mint: z.ZodBoolean;
+            melt: z.ZodBoolean;
+        }>, {
+            type: z.ZodLiteral<"grant_authority">;
+        }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            mint: z.ZodBoolean;
+            melt: z.ZodBoolean;
+        }>, {
+            type: z.ZodLiteral<"acquire_authority">;
+        }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            mint: z.ZodBoolean;
+            melt: z.ZodBoolean;
+        }>, {
+            type: z.ZodLiteral<"acquire_authority">;
+        }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+            token_uid: z.ZodString;
+        }, {
+            mint: z.ZodBoolean;
+            melt: z.ZodBoolean;
+        }>, {
+            type: z.ZodLiteral<"acquire_authority">;
+        }>, z.ZodTypeAny, "passthrough">>]>, "many">;
+        address: z.ZodString;
+        timestamp: z.ZodNumber;
+    }, z.ZodTypeAny, "passthrough"> | null | undefined;
+}>;
+export declare const fullnodeTxApiMetaSchema: z.ZodObject<{
+    hash: z.ZodString;
+    spent_outputs: z.ZodArray<z.ZodTuple<[z.ZodNumber, z.ZodArray<z.ZodString, "many">], null>, "many">;
+    received_by: z.ZodArray<z.ZodString, "many">;
+    children: z.ZodArray<z.ZodString, "many">;
+    conflict_with: z.ZodArray<z.ZodString, "many">;
+    voided_by: z.ZodArray<z.ZodString, "many">;
+    twins: z.ZodArray<z.ZodString, "many">;
+    accumulated_weight: z.ZodNumber;
+    score: z.ZodNumber;
+    height: z.ZodNumber;
+    min_height: z.ZodNumber;
+    feature_activation_bit_counts: z.ZodNullable<z.ZodArray<z.ZodNumber, "many">>;
+    first_block: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+    validation: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+    first_block_height: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+}, "strip", z.ZodTypeAny, {
+    height: number;
+    children: string[];
+    hash: string;
+    spent_outputs: [number, string[]][];
+    received_by: string[];
+    conflict_with: string[];
+    voided_by: string[];
+    twins: string[];
+    accumulated_weight: number;
+    score: number;
+    min_height: number;
+    feature_activation_bit_counts: number[] | null;
+    validation?: string | null | undefined;
+    first_block?: string | null | undefined;
+    first_block_height?: number | null | undefined;
+}, {
+    height: number;
+    children: string[];
+    hash: string;
+    spent_outputs: [number, string[]][];
+    received_by: string[];
+    conflict_with: string[];
+    voided_by: string[];
+    twins: string[];
+    accumulated_weight: number;
+    score: number;
+    min_height: number;
+    feature_activation_bit_counts: number[] | null;
+    validation?: string | null | undefined;
+    first_block?: string | null | undefined;
+    first_block_height?: number | null | undefined;
+}>;
+export declare const transactionApiSchema: z.ZodDiscriminatedUnion<"success", [z.ZodObject<{
+    success: z.ZodLiteral<true>;
+    tx: z.ZodObject<{
+        hash: z.ZodString;
+        nonce: z.ZodString;
+        timestamp: z.ZodNumber;
+        version: z.ZodNumber;
+        weight: z.ZodNumber;
+        signal_bits: z.ZodNumber;
+        parents: z.ZodArray<z.ZodString, "many">;
+        nc_id: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+        nc_method: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+        nc_pubkey: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+        nc_address: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+        nc_context: z.ZodOptional<z.ZodNullable<z.ZodObject<{
+            actions: z.ZodArray<z.ZodDiscriminatedUnion<"type", [z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"deposit">;
+            }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"deposit">;
+            }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"deposit">;
+            }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"withdrawal">;
+            }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"withdrawal">;
+            }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"withdrawal">;
+            }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"grant_authority">;
+            }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"grant_authority">;
+            }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"grant_authority">;
+            }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"acquire_authority">;
+            }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"acquire_authority">;
+            }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"acquire_authority">;
+            }>, z.ZodTypeAny, "passthrough">>]>, "many">;
+            address: z.ZodString;
+            timestamp: z.ZodNumber;
+        }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
+            actions: z.ZodArray<z.ZodDiscriminatedUnion<"type", [z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"deposit">;
+            }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"deposit">;
+            }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"deposit">;
+            }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"withdrawal">;
+            }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"withdrawal">;
+            }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"withdrawal">;
+            }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"grant_authority">;
+            }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"grant_authority">;
+            }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"grant_authority">;
+            }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"acquire_authority">;
+            }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"acquire_authority">;
+            }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"acquire_authority">;
+            }>, z.ZodTypeAny, "passthrough">>]>, "many">;
+            address: z.ZodString;
+            timestamp: z.ZodNumber;
+        }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
+            actions: z.ZodArray<z.ZodDiscriminatedUnion<"type", [z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"deposit">;
+            }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"deposit">;
+            }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"deposit">;
+            }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"withdrawal">;
+            }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"withdrawal">;
+            }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"withdrawal">;
+            }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"grant_authority">;
+            }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"grant_authority">;
+            }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"grant_authority">;
+            }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"acquire_authority">;
+            }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"acquire_authority">;
+            }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"acquire_authority">;
+            }>, z.ZodTypeAny, "passthrough">>]>, "many">;
+            address: z.ZodString;
+            timestamp: z.ZodNumber;
+        }, z.ZodTypeAny, "passthrough">>>>;
+        nc_args: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+        nc_blueprint_id: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+        inputs: z.ZodArray<z.ZodObject<{
+            value: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            token_data: z.ZodNumber;
+            script: z.ZodString;
+            decoded: z.ZodDiscriminatedUnion<"type", [z.ZodObject<{
+                type: z.ZodLiteral<"P2PKH">;
+                address: z.ZodString;
+                timelock: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+                value: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+                token_data: z.ZodNumber;
+            }, "strip", z.ZodTypeAny, {
+                type: "P2PKH";
+                address: string;
+                value: bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            }, {
+                type: "P2PKH";
+                address: string;
+                value: string | number | bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            }>, z.ZodObject<{
+                type: z.ZodLiteral<"MultiSig">;
+                address: z.ZodString;
+                timelock: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+                value: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+                token_data: z.ZodNumber;
+            }, "strip", z.ZodTypeAny, {
+                type: "MultiSig";
+                address: string;
+                value: bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            }, {
+                type: "MultiSig";
+                address: string;
+                value: string | number | bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            }>, z.ZodObject<{
+                type: z.ZodUndefined;
+            }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
+                type: z.ZodUndefined;
+            }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
+                type: z.ZodUndefined;
+            }, z.ZodTypeAny, "passthrough">>]>;
+            tx_id: z.ZodString;
+            index: z.ZodNumber;
+            token: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+        }, "strip", z.ZodTypeAny, {
+            index: number;
+            value: bigint;
+            script: string;
+            token_data: number;
+            decoded: {
+                type: "P2PKH";
+                address: string;
+                value: bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            } | {
+                type: "MultiSig";
+                address: string;
+                value: bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            } | z.objectOutputType<{
+                type: z.ZodUndefined;
+            }, z.ZodTypeAny, "passthrough">;
+            tx_id: string;
+            token?: string | null | undefined;
+        }, {
+            index: number;
+            value: string | number | bigint;
+            script: string;
+            token_data: number;
+            decoded: {
+                type: "P2PKH";
+                address: string;
+                value: string | number | bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            } | {
+                type: "MultiSig";
+                address: string;
+                value: string | number | bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            } | z.objectInputType<{
+                type: z.ZodUndefined;
+            }, z.ZodTypeAny, "passthrough">;
+            tx_id: string;
+            token?: string | null | undefined;
+        }>, "many">;
+        outputs: z.ZodArray<z.ZodObject<{
+            value: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            token_data: z.ZodNumber;
+            script: z.ZodString;
+            decoded: z.ZodDiscriminatedUnion<"type", [z.ZodObject<{
+                type: z.ZodLiteral<"P2PKH">;
+                address: z.ZodString;
+                timelock: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+                value: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+                token_data: z.ZodNumber;
+            }, "strip", z.ZodTypeAny, {
+                type: "P2PKH";
+                address: string;
+                value: bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            }, {
+                type: "P2PKH";
+                address: string;
+                value: string | number | bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            }>, z.ZodObject<{
+                type: z.ZodLiteral<"MultiSig">;
+                address: z.ZodString;
+                timelock: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+                value: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+                token_data: z.ZodNumber;
+            }, "strip", z.ZodTypeAny, {
+                type: "MultiSig";
+                address: string;
+                value: bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            }, {
+                type: "MultiSig";
+                address: string;
+                value: string | number | bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            }>, z.ZodObject<{
+                type: z.ZodUndefined;
+            }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
+                type: z.ZodUndefined;
+            }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
+                type: z.ZodUndefined;
+            }, z.ZodTypeAny, "passthrough">>]>;
+            token: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+            spent_by: z.ZodDefault<z.ZodNullable<z.ZodString>>;
+        }, "strip", z.ZodTypeAny, {
+            value: bigint;
+            script: string;
+            token_data: number;
+            decoded: {
+                type: "P2PKH";
+                address: string;
+                value: bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            } | {
+                type: "MultiSig";
+                address: string;
+                value: bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            } | z.objectOutputType<{
+                type: z.ZodUndefined;
+            }, z.ZodTypeAny, "passthrough">;
+            spent_by: string | null;
+            token?: string | null | undefined;
+        }, {
+            value: string | number | bigint;
+            script: string;
+            token_data: number;
+            decoded: {
+                type: "P2PKH";
+                address: string;
+                value: string | number | bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            } | {
+                type: "MultiSig";
+                address: string;
+                value: string | number | bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            } | z.objectInputType<{
+                type: z.ZodUndefined;
+            }, z.ZodTypeAny, "passthrough">;
+            token?: string | null | undefined;
+            spent_by?: string | null | undefined;
+        }>, "many">;
+        tokens: z.ZodArray<z.ZodObject<{
+            uid: z.ZodString;
+            name: z.ZodNullable<z.ZodString>;
+            symbol: z.ZodNullable<z.ZodString>;
+        }, "strip", z.ZodTypeAny, {
+            symbol: string | null;
+            name: string | null;
+            uid: string;
+        }, {
+            symbol: string | null;
+            name: string | null;
+            uid: string;
+        }>, "many">;
+        token_name: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+        token_symbol: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+        raw: z.ZodString;
+    }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
+        hash: z.ZodString;
+        nonce: z.ZodString;
+        timestamp: z.ZodNumber;
+        version: z.ZodNumber;
+        weight: z.ZodNumber;
+        signal_bits: z.ZodNumber;
+        parents: z.ZodArray<z.ZodString, "many">;
+        nc_id: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+        nc_method: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+        nc_pubkey: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+        nc_address: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+        nc_context: z.ZodOptional<z.ZodNullable<z.ZodObject<{
+            actions: z.ZodArray<z.ZodDiscriminatedUnion<"type", [z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"deposit">;
+            }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"deposit">;
+            }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"deposit">;
+            }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"withdrawal">;
+            }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"withdrawal">;
+            }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"withdrawal">;
+            }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"grant_authority">;
+            }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"grant_authority">;
+            }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"grant_authority">;
+            }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"acquire_authority">;
+            }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"acquire_authority">;
+            }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"acquire_authority">;
+            }>, z.ZodTypeAny, "passthrough">>]>, "many">;
+            address: z.ZodString;
+            timestamp: z.ZodNumber;
+        }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
+            actions: z.ZodArray<z.ZodDiscriminatedUnion<"type", [z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"deposit">;
+            }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"deposit">;
+            }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"deposit">;
+            }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"withdrawal">;
+            }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"withdrawal">;
+            }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"withdrawal">;
+            }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"grant_authority">;
+            }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"grant_authority">;
+            }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"grant_authority">;
+            }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"acquire_authority">;
+            }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"acquire_authority">;
+            }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"acquire_authority">;
+            }>, z.ZodTypeAny, "passthrough">>]>, "many">;
+            address: z.ZodString;
+            timestamp: z.ZodNumber;
+        }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
+            actions: z.ZodArray<z.ZodDiscriminatedUnion<"type", [z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"deposit">;
+            }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"deposit">;
+            }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"deposit">;
+            }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"withdrawal">;
+            }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"withdrawal">;
+            }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"withdrawal">;
+            }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"grant_authority">;
+            }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"grant_authority">;
+            }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"grant_authority">;
+            }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"acquire_authority">;
+            }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"acquire_authority">;
+            }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"acquire_authority">;
+            }>, z.ZodTypeAny, "passthrough">>]>, "many">;
+            address: z.ZodString;
+            timestamp: z.ZodNumber;
+        }, z.ZodTypeAny, "passthrough">>>>;
+        nc_args: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+        nc_blueprint_id: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+        inputs: z.ZodArray<z.ZodObject<{
+            value: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            token_data: z.ZodNumber;
+            script: z.ZodString;
+            decoded: z.ZodDiscriminatedUnion<"type", [z.ZodObject<{
+                type: z.ZodLiteral<"P2PKH">;
+                address: z.ZodString;
+                timelock: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+                value: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+                token_data: z.ZodNumber;
+            }, "strip", z.ZodTypeAny, {
+                type: "P2PKH";
+                address: string;
+                value: bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            }, {
+                type: "P2PKH";
+                address: string;
+                value: string | number | bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            }>, z.ZodObject<{
+                type: z.ZodLiteral<"MultiSig">;
+                address: z.ZodString;
+                timelock: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+                value: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+                token_data: z.ZodNumber;
+            }, "strip", z.ZodTypeAny, {
+                type: "MultiSig";
+                address: string;
+                value: bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            }, {
+                type: "MultiSig";
+                address: string;
+                value: string | number | bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            }>, z.ZodObject<{
+                type: z.ZodUndefined;
+            }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
+                type: z.ZodUndefined;
+            }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
+                type: z.ZodUndefined;
+            }, z.ZodTypeAny, "passthrough">>]>;
+            tx_id: z.ZodString;
+            index: z.ZodNumber;
+            token: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+        }, "strip", z.ZodTypeAny, {
+            index: number;
+            value: bigint;
+            script: string;
+            token_data: number;
+            decoded: {
+                type: "P2PKH";
+                address: string;
+                value: bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            } | {
+                type: "MultiSig";
+                address: string;
+                value: bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            } | z.objectOutputType<{
+                type: z.ZodUndefined;
+            }, z.ZodTypeAny, "passthrough">;
+            tx_id: string;
+            token?: string | null | undefined;
+        }, {
+            index: number;
+            value: string | number | bigint;
+            script: string;
+            token_data: number;
+            decoded: {
+                type: "P2PKH";
+                address: string;
+                value: string | number | bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            } | {
+                type: "MultiSig";
+                address: string;
+                value: string | number | bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            } | z.objectInputType<{
+                type: z.ZodUndefined;
+            }, z.ZodTypeAny, "passthrough">;
+            tx_id: string;
+            token?: string | null | undefined;
+        }>, "many">;
+        outputs: z.ZodArray<z.ZodObject<{
+            value: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            token_data: z.ZodNumber;
+            script: z.ZodString;
+            decoded: z.ZodDiscriminatedUnion<"type", [z.ZodObject<{
+                type: z.ZodLiteral<"P2PKH">;
+                address: z.ZodString;
+                timelock: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+                value: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+                token_data: z.ZodNumber;
+            }, "strip", z.ZodTypeAny, {
+                type: "P2PKH";
+                address: string;
+                value: bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            }, {
+                type: "P2PKH";
+                address: string;
+                value: string | number | bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            }>, z.ZodObject<{
+                type: z.ZodLiteral<"MultiSig">;
+                address: z.ZodString;
+                timelock: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+                value: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+                token_data: z.ZodNumber;
+            }, "strip", z.ZodTypeAny, {
+                type: "MultiSig";
+                address: string;
+                value: bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            }, {
+                type: "MultiSig";
+                address: string;
+                value: string | number | bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            }>, z.ZodObject<{
+                type: z.ZodUndefined;
+            }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
+                type: z.ZodUndefined;
+            }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
+                type: z.ZodUndefined;
+            }, z.ZodTypeAny, "passthrough">>]>;
+            token: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+            spent_by: z.ZodDefault<z.ZodNullable<z.ZodString>>;
+        }, "strip", z.ZodTypeAny, {
+            value: bigint;
+            script: string;
+            token_data: number;
+            decoded: {
+                type: "P2PKH";
+                address: string;
+                value: bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            } | {
+                type: "MultiSig";
+                address: string;
+                value: bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            } | z.objectOutputType<{
+                type: z.ZodUndefined;
+            }, z.ZodTypeAny, "passthrough">;
+            spent_by: string | null;
+            token?: string | null | undefined;
+        }, {
+            value: string | number | bigint;
+            script: string;
+            token_data: number;
+            decoded: {
+                type: "P2PKH";
+                address: string;
+                value: string | number | bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            } | {
+                type: "MultiSig";
+                address: string;
+                value: string | number | bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            } | z.objectInputType<{
+                type: z.ZodUndefined;
+            }, z.ZodTypeAny, "passthrough">;
+            token?: string | null | undefined;
+            spent_by?: string | null | undefined;
+        }>, "many">;
+        tokens: z.ZodArray<z.ZodObject<{
+            uid: z.ZodString;
+            name: z.ZodNullable<z.ZodString>;
+            symbol: z.ZodNullable<z.ZodString>;
+        }, "strip", z.ZodTypeAny, {
+            symbol: string | null;
+            name: string | null;
+            uid: string;
+        }, {
+            symbol: string | null;
+            name: string | null;
+            uid: string;
+        }>, "many">;
+        token_name: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+        token_symbol: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+        raw: z.ZodString;
+    }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
+        hash: z.ZodString;
+        nonce: z.ZodString;
+        timestamp: z.ZodNumber;
+        version: z.ZodNumber;
+        weight: z.ZodNumber;
+        signal_bits: z.ZodNumber;
+        parents: z.ZodArray<z.ZodString, "many">;
+        nc_id: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+        nc_method: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+        nc_pubkey: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+        nc_address: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+        nc_context: z.ZodOptional<z.ZodNullable<z.ZodObject<{
+            actions: z.ZodArray<z.ZodDiscriminatedUnion<"type", [z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"deposit">;
+            }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"deposit">;
+            }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"deposit">;
+            }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"withdrawal">;
+            }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"withdrawal">;
+            }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"withdrawal">;
+            }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"grant_authority">;
+            }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"grant_authority">;
+            }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"grant_authority">;
+            }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"acquire_authority">;
+            }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"acquire_authority">;
+            }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"acquire_authority">;
+            }>, z.ZodTypeAny, "passthrough">>]>, "many">;
+            address: z.ZodString;
+            timestamp: z.ZodNumber;
+        }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
+            actions: z.ZodArray<z.ZodDiscriminatedUnion<"type", [z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"deposit">;
+            }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"deposit">;
+            }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"deposit">;
+            }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"withdrawal">;
+            }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"withdrawal">;
+            }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"withdrawal">;
+            }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"grant_authority">;
+            }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"grant_authority">;
+            }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"grant_authority">;
+            }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"acquire_authority">;
+            }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"acquire_authority">;
+            }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"acquire_authority">;
+            }>, z.ZodTypeAny, "passthrough">>]>, "many">;
+            address: z.ZodString;
+            timestamp: z.ZodNumber;
+        }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
+            actions: z.ZodArray<z.ZodDiscriminatedUnion<"type", [z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"deposit">;
+            }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"deposit">;
+            }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"deposit">;
+            }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"withdrawal">;
+            }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"withdrawal">;
+            }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"withdrawal">;
+            }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"grant_authority">;
+            }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"grant_authority">;
+            }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"grant_authority">;
+            }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"acquire_authority">;
+            }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"acquire_authority">;
+            }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"acquire_authority">;
+            }>, z.ZodTypeAny, "passthrough">>]>, "many">;
+            address: z.ZodString;
+            timestamp: z.ZodNumber;
+        }, z.ZodTypeAny, "passthrough">>>>;
+        nc_args: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+        nc_blueprint_id: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+        inputs: z.ZodArray<z.ZodObject<{
+            value: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            token_data: z.ZodNumber;
+            script: z.ZodString;
+            decoded: z.ZodDiscriminatedUnion<"type", [z.ZodObject<{
+                type: z.ZodLiteral<"P2PKH">;
+                address: z.ZodString;
+                timelock: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+                value: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+                token_data: z.ZodNumber;
+            }, "strip", z.ZodTypeAny, {
+                type: "P2PKH";
+                address: string;
+                value: bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            }, {
+                type: "P2PKH";
+                address: string;
+                value: string | number | bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            }>, z.ZodObject<{
+                type: z.ZodLiteral<"MultiSig">;
+                address: z.ZodString;
+                timelock: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+                value: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+                token_data: z.ZodNumber;
+            }, "strip", z.ZodTypeAny, {
+                type: "MultiSig";
+                address: string;
+                value: bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            }, {
+                type: "MultiSig";
+                address: string;
+                value: string | number | bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            }>, z.ZodObject<{
+                type: z.ZodUndefined;
+            }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
+                type: z.ZodUndefined;
+            }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
+                type: z.ZodUndefined;
+            }, z.ZodTypeAny, "passthrough">>]>;
+            tx_id: z.ZodString;
+            index: z.ZodNumber;
+            token: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+        }, "strip", z.ZodTypeAny, {
+            index: number;
+            value: bigint;
+            script: string;
+            token_data: number;
+            decoded: {
+                type: "P2PKH";
+                address: string;
+                value: bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            } | {
+                type: "MultiSig";
+                address: string;
+                value: bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            } | z.objectOutputType<{
+                type: z.ZodUndefined;
+            }, z.ZodTypeAny, "passthrough">;
+            tx_id: string;
+            token?: string | null | undefined;
+        }, {
+            index: number;
+            value: string | number | bigint;
+            script: string;
+            token_data: number;
+            decoded: {
+                type: "P2PKH";
+                address: string;
+                value: string | number | bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            } | {
+                type: "MultiSig";
+                address: string;
+                value: string | number | bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            } | z.objectInputType<{
+                type: z.ZodUndefined;
+            }, z.ZodTypeAny, "passthrough">;
+            tx_id: string;
+            token?: string | null | undefined;
+        }>, "many">;
+        outputs: z.ZodArray<z.ZodObject<{
+            value: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            token_data: z.ZodNumber;
+            script: z.ZodString;
+            decoded: z.ZodDiscriminatedUnion<"type", [z.ZodObject<{
+                type: z.ZodLiteral<"P2PKH">;
+                address: z.ZodString;
+                timelock: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+                value: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+                token_data: z.ZodNumber;
+            }, "strip", z.ZodTypeAny, {
+                type: "P2PKH";
+                address: string;
+                value: bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            }, {
+                type: "P2PKH";
+                address: string;
+                value: string | number | bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            }>, z.ZodObject<{
+                type: z.ZodLiteral<"MultiSig">;
+                address: z.ZodString;
+                timelock: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+                value: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+                token_data: z.ZodNumber;
+            }, "strip", z.ZodTypeAny, {
+                type: "MultiSig";
+                address: string;
+                value: bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            }, {
+                type: "MultiSig";
+                address: string;
+                value: string | number | bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            }>, z.ZodObject<{
+                type: z.ZodUndefined;
+            }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
+                type: z.ZodUndefined;
+            }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
+                type: z.ZodUndefined;
+            }, z.ZodTypeAny, "passthrough">>]>;
+            token: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+            spent_by: z.ZodDefault<z.ZodNullable<z.ZodString>>;
+        }, "strip", z.ZodTypeAny, {
+            value: bigint;
+            script: string;
+            token_data: number;
+            decoded: {
+                type: "P2PKH";
+                address: string;
+                value: bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            } | {
+                type: "MultiSig";
+                address: string;
+                value: bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            } | z.objectOutputType<{
+                type: z.ZodUndefined;
+            }, z.ZodTypeAny, "passthrough">;
+            spent_by: string | null;
+            token?: string | null | undefined;
+        }, {
+            value: string | number | bigint;
+            script: string;
+            token_data: number;
+            decoded: {
+                type: "P2PKH";
+                address: string;
+                value: string | number | bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            } | {
+                type: "MultiSig";
+                address: string;
+                value: string | number | bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            } | z.objectInputType<{
+                type: z.ZodUndefined;
+            }, z.ZodTypeAny, "passthrough">;
+            token?: string | null | undefined;
+            spent_by?: string | null | undefined;
+        }>, "many">;
+        tokens: z.ZodArray<z.ZodObject<{
+            uid: z.ZodString;
+            name: z.ZodNullable<z.ZodString>;
+            symbol: z.ZodNullable<z.ZodString>;
+        }, "strip", z.ZodTypeAny, {
+            symbol: string | null;
+            name: string | null;
+            uid: string;
+        }, {
+            symbol: string | null;
+            name: string | null;
+            uid: string;
+        }>, "many">;
+        token_name: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+        token_symbol: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+        raw: z.ZodString;
+    }, z.ZodTypeAny, "passthrough">>;
+    meta: z.ZodObject<{
+        hash: z.ZodString;
+        spent_outputs: z.ZodArray<z.ZodTuple<[z.ZodNumber, z.ZodArray<z.ZodString, "many">], null>, "many">;
+        received_by: z.ZodArray<z.ZodString, "many">;
+        children: z.ZodArray<z.ZodString, "many">;
+        conflict_with: z.ZodArray<z.ZodString, "many">;
+        voided_by: z.ZodArray<z.ZodString, "many">;
+        twins: z.ZodArray<z.ZodString, "many">;
+        accumulated_weight: z.ZodNumber;
+        score: z.ZodNumber;
+        height: z.ZodNumber;
+        min_height: z.ZodNumber;
+        feature_activation_bit_counts: z.ZodNullable<z.ZodArray<z.ZodNumber, "many">>;
+        first_block: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+        validation: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+        first_block_height: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+    }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
+        hash: z.ZodString;
+        spent_outputs: z.ZodArray<z.ZodTuple<[z.ZodNumber, z.ZodArray<z.ZodString, "many">], null>, "many">;
+        received_by: z.ZodArray<z.ZodString, "many">;
+        children: z.ZodArray<z.ZodString, "many">;
+        conflict_with: z.ZodArray<z.ZodString, "many">;
+        voided_by: z.ZodArray<z.ZodString, "many">;
+        twins: z.ZodArray<z.ZodString, "many">;
+        accumulated_weight: z.ZodNumber;
+        score: z.ZodNumber;
+        height: z.ZodNumber;
+        min_height: z.ZodNumber;
+        feature_activation_bit_counts: z.ZodNullable<z.ZodArray<z.ZodNumber, "many">>;
+        first_block: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+        validation: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+        first_block_height: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+    }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
+        hash: z.ZodString;
+        spent_outputs: z.ZodArray<z.ZodTuple<[z.ZodNumber, z.ZodArray<z.ZodString, "many">], null>, "many">;
+        received_by: z.ZodArray<z.ZodString, "many">;
+        children: z.ZodArray<z.ZodString, "many">;
+        conflict_with: z.ZodArray<z.ZodString, "many">;
+        voided_by: z.ZodArray<z.ZodString, "many">;
+        twins: z.ZodArray<z.ZodString, "many">;
+        accumulated_weight: z.ZodNumber;
+        score: z.ZodNumber;
+        height: z.ZodNumber;
+        min_height: z.ZodNumber;
+        feature_activation_bit_counts: z.ZodNullable<z.ZodArray<z.ZodNumber, "many">>;
+        first_block: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+        validation: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+        first_block_height: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+    }, z.ZodTypeAny, "passthrough">>;
+    spent_outputs: z.ZodRecord<z.ZodNumber, z.ZodString>;
+}, "strip", z.ZodTypeAny, {
+    meta: {
+        height: number;
+        children: string[];
+        hash: string;
+        spent_outputs: [number, string[]][];
+        received_by: string[];
+        conflict_with: string[];
+        voided_by: string[];
+        twins: string[];
+        accumulated_weight: number;
+        score: number;
+        min_height: number;
+        feature_activation_bit_counts: number[] | null;
+        validation?: string | null | undefined;
+        first_block?: string | null | undefined;
+        first_block_height?: number | null | undefined;
+    } & {
+        [k: string]: unknown;
+    };
+    success: true;
+    tx: {
+        raw: string;
+        nonce: string;
+        hash: string;
+        tokens: {
+            symbol: string | null;
+            name: string | null;
+            uid: string;
+        }[];
+        timestamp: number;
+        version: number;
+        weight: number;
+        inputs: {
+            index: number;
+            value: bigint;
+            script: string;
+            token_data: number;
+            decoded: {
+                type: "P2PKH";
+                address: string;
+                value: bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            } | {
+                type: "MultiSig";
+                address: string;
+                value: bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            } | z.objectOutputType<{
+                type: z.ZodUndefined;
+            }, z.ZodTypeAny, "passthrough">;
+            tx_id: string;
+            token?: string | null | undefined;
+        }[];
+        outputs: {
+            value: bigint;
+            script: string;
+            token_data: number;
+            decoded: {
+                type: "P2PKH";
+                address: string;
+                value: bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            } | {
+                type: "MultiSig";
+                address: string;
+                value: bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            } | z.objectOutputType<{
+                type: z.ZodUndefined;
+            }, z.ZodTypeAny, "passthrough">;
+            spent_by: string | null;
+            token?: string | null | undefined;
+        }[];
+        parents: string[];
+        signal_bits: number;
+        token_name?: string | null | undefined;
+        token_symbol?: string | null | undefined;
+        nc_id?: string | null | undefined;
+        nc_blueprint_id?: string | null | undefined;
+        nc_method?: string | null | undefined;
+        nc_args?: string | null | undefined;
+        nc_pubkey?: string | null | undefined;
+        nc_address?: string | null | undefined;
+        nc_context?: z.objectOutputType<{
+            actions: z.ZodArray<z.ZodDiscriminatedUnion<"type", [z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"deposit">;
+            }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"deposit">;
+            }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"deposit">;
+            }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"withdrawal">;
+            }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"withdrawal">;
+            }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"withdrawal">;
+            }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"grant_authority">;
+            }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"grant_authority">;
+            }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"grant_authority">;
+            }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"acquire_authority">;
+            }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"acquire_authority">;
+            }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"acquire_authority">;
+            }>, z.ZodTypeAny, "passthrough">>]>, "many">;
+            address: z.ZodString;
+            timestamp: z.ZodNumber;
+        }, z.ZodTypeAny, "passthrough"> | null | undefined;
+    } & {
+        [k: string]: unknown;
+    };
+    spent_outputs: Record<number, string>;
+}, {
+    meta: {
+        height: number;
+        children: string[];
+        hash: string;
+        spent_outputs: [number, string[]][];
+        received_by: string[];
+        conflict_with: string[];
+        voided_by: string[];
+        twins: string[];
+        accumulated_weight: number;
+        score: number;
+        min_height: number;
+        feature_activation_bit_counts: number[] | null;
+        validation?: string | null | undefined;
+        first_block?: string | null | undefined;
+        first_block_height?: number | null | undefined;
+    } & {
+        [k: string]: unknown;
+    };
+    success: true;
+    tx: {
+        raw: string;
+        nonce: string;
+        hash: string;
+        tokens: {
+            symbol: string | null;
+            name: string | null;
+            uid: string;
+        }[];
+        timestamp: number;
+        version: number;
+        weight: number;
+        inputs: {
+            index: number;
+            value: string | number | bigint;
+            script: string;
+            token_data: number;
+            decoded: {
+                type: "P2PKH";
+                address: string;
+                value: string | number | bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            } | {
+                type: "MultiSig";
+                address: string;
+                value: string | number | bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            } | z.objectInputType<{
+                type: z.ZodUndefined;
+            }, z.ZodTypeAny, "passthrough">;
+            tx_id: string;
+            token?: string | null | undefined;
+        }[];
+        outputs: {
+            value: string | number | bigint;
+            script: string;
+            token_data: number;
+            decoded: {
+                type: "P2PKH";
+                address: string;
+                value: string | number | bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            } | {
+                type: "MultiSig";
+                address: string;
+                value: string | number | bigint;
+                token_data: number;
+                timelock?: number | null | undefined;
+            } | z.objectInputType<{
+                type: z.ZodUndefined;
+            }, z.ZodTypeAny, "passthrough">;
+            token?: string | null | undefined;
+            spent_by?: string | null | undefined;
+        }[];
+        parents: string[];
+        signal_bits: number;
+        token_name?: string | null | undefined;
+        token_symbol?: string | null | undefined;
+        nc_id?: string | null | undefined;
+        nc_blueprint_id?: string | null | undefined;
+        nc_method?: string | null | undefined;
+        nc_args?: string | null | undefined;
+        nc_pubkey?: string | null | undefined;
+        nc_address?: string | null | undefined;
+        nc_context?: z.objectInputType<{
+            actions: z.ZodArray<z.ZodDiscriminatedUnion<"type", [z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"deposit">;
+            }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"deposit">;
+            }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"deposit">;
+            }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"withdrawal">;
+            }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"withdrawal">;
+            }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }>, {
+                type: z.ZodLiteral<"withdrawal">;
+            }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"grant_authority">;
+            }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"grant_authority">;
+            }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"grant_authority">;
+            }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"acquire_authority">;
+            }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"acquire_authority">;
+            }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+                token_uid: z.ZodString;
+            }, {
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }>, {
+                type: z.ZodLiteral<"acquire_authority">;
+            }>, z.ZodTypeAny, "passthrough">>]>, "many">;
+            address: z.ZodString;
+            timestamp: z.ZodNumber;
+        }, z.ZodTypeAny, "passthrough"> | null | undefined;
+    } & {
+        [k: string]: unknown;
+    };
+    spent_outputs: Record<number, string>;
+}>, z.ZodObject<{
+    success: z.ZodLiteral<false>;
+    message: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+}, "strip", z.ZodTypeAny, {
+    success: false;
+    message?: string | null | undefined;
+}, {
+    success: false;
+    message?: string | null | undefined;
+}>]>;
+export type FullNodeTxApiResponse = z.infer<typeof transactionApiSchema>;
+//# sourceMappingURL=txApi.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/api/schemas/txApi.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/api/schemas/txApi.d.ts.map
new file mode 100644
index 0000000..304c4d7
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/api/schemas/txApi.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"txApi.d.ts","sourceRoot":"","sources":["../../../src/api/schemas/txApi.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;AAEH,OAAO,EAAE,CAAC,EAAE,MAAM,KAAK,CAAC;AA2BxB,eAAO,MAAM,aAAa;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kCAIxB,CAAC;AAEH,eAAO,MAAM,wBAAwB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAQnC,CAAC;AAEH,eAAO,MAAM,yBAAyB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAOpC,CAAC;AAEH,eAAO,MAAM,wBAAwB;;;;;;;;;;;;EAInC,CAAC;AAEH,eAAO,MAAM,qBAAqB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAqBhC,CAAC;AAEH,eAAO,MAAM,uBAAuB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAgBlC,CAAC;AAEH,eAAO,MAAM,oBAAoB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAQ/B,CAAC;AAEH,MAAM,MAAM,qBAAqB,GAAG,CAAC,CAAC,KAAK,CAAC,OAAO,oBAAoB,CAAC,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/api/schemas/txApi.js b/node_modules/@hathor/wallet-lib/oldLib/api/schemas/txApi.js
new file mode 100644
index 0000000..ba2c5be
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/api/schemas/txApi.js
@@ -0,0 +1,106 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.transactionApiSchema = exports.fullnodeTxApiTxSchema = exports.fullnodeTxApiTokenSchema = exports.fullnodeTxApiOutputSchema = exports.fullnodeTxApiMetaSchema = exports.fullnodeTxApiInputSchema = exports.decodedSchema = void 0;
+var _zod = require("zod");
+var _bigint = require("../../utils/bigint");
+var _schemas = require("../../schemas");
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+const p2pkhDecodedScriptSchema = _zod.z.object({
+  type: _zod.z.literal('P2PKH'),
+  address: _zod.z.string(),
+  timelock: _zod.z.number().nullish(),
+  value: _bigint.bigIntCoercibleSchema,
+  token_data: _zod.z.number()
+});
+const p2shDecodedScriptSchema = _zod.z.object({
+  type: _zod.z.literal('MultiSig'),
+  address: _zod.z.string(),
+  timelock: _zod.z.number().nullish(),
+  value: _bigint.bigIntCoercibleSchema,
+  token_data: _zod.z.number()
+});
+const unknownDecodedScriptSchema = _zod.z.object({
+  type: _zod.z.undefined()
+}).passthrough();
+
+// TODO: This should be unified with IHistoryOutputDecodedSchema
+const decodedSchema = exports.decodedSchema = _zod.z.discriminatedUnion('type', [p2pkhDecodedScriptSchema, p2shDecodedScriptSchema, unknownDecodedScriptSchema]);
+const fullnodeTxApiInputSchema = exports.fullnodeTxApiInputSchema = _zod.z.object({
+  value: _bigint.bigIntCoercibleSchema,
+  token_data: _zod.z.number(),
+  script: _zod.z.string(),
+  decoded: decodedSchema,
+  tx_id: _zod.z.string(),
+  index: _zod.z.number(),
+  token: _zod.z.string().nullish()
+});
+const fullnodeTxApiOutputSchema = exports.fullnodeTxApiOutputSchema = _zod.z.object({
+  value: _bigint.bigIntCoercibleSchema,
+  token_data: _zod.z.number(),
+  script: _zod.z.string(),
+  decoded: decodedSchema,
+  token: _zod.z.string().nullish(),
+  spent_by: _zod.z.string().nullable().default(null)
+});
+const fullnodeTxApiTokenSchema = exports.fullnodeTxApiTokenSchema = _zod.z.object({
+  uid: _zod.z.string(),
+  name: _zod.z.string().nullable(),
+  symbol: _zod.z.string().nullable()
+});
+const fullnodeTxApiTxSchema = exports.fullnodeTxApiTxSchema = _zod.z.object({
+  hash: _zod.z.string(),
+  nonce: _zod.z.string(),
+  timestamp: _zod.z.number(),
+  version: _zod.z.number(),
+  weight: _zod.z.number(),
+  signal_bits: _zod.z.number(),
+  parents: _zod.z.string().array(),
+  nc_id: _zod.z.string().nullish(),
+  nc_method: _zod.z.string().nullish(),
+  nc_pubkey: _zod.z.string().nullish(),
+  nc_address: _zod.z.string().nullish(),
+  nc_context: _schemas.IHistoryNanoContractContextSchema.nullish(),
+  nc_args: _zod.z.string().nullish(),
+  nc_blueprint_id: _zod.z.string().nullish(),
+  inputs: fullnodeTxApiInputSchema.array(),
+  outputs: fullnodeTxApiOutputSchema.array(),
+  tokens: fullnodeTxApiTokenSchema.array(),
+  token_name: _zod.z.string().nullish(),
+  token_symbol: _zod.z.string().nullish(),
+  raw: _zod.z.string()
+});
+const fullnodeTxApiMetaSchema = exports.fullnodeTxApiMetaSchema = _zod.z.object({
+  hash: _zod.z.string(),
+  spent_outputs: _zod.z.tuple([_zod.z.number(), _zod.z.string().array()]).array(),
+  received_by: _zod.z.string().array(),
+  children: _zod.z.string().array(),
+  conflict_with: _zod.z.string().array(),
+  voided_by: _zod.z.string().array(),
+  twins: _zod.z.string().array(),
+  accumulated_weight: _zod.z.number(),
+  score: _zod.z.number(),
+  height: _zod.z.number(),
+  min_height: _zod.z.number(),
+  feature_activation_bit_counts: _zod.z.number().array().nullable(),
+  first_block: _zod.z.string().nullish(),
+  validation: _zod.z.string().nullish(),
+  first_block_height: _zod.z.number().nullish()
+});
+const transactionApiSchema = exports.transactionApiSchema = _zod.z.discriminatedUnion('success', [_zod.z.object({
+  success: _zod.z.literal(true),
+  tx: fullnodeTxApiTxSchema.passthrough(),
+  meta: fullnodeTxApiMetaSchema.passthrough(),
+  spent_outputs: _zod.z.record(_zod.z.coerce.number(), _zod.z.string())
+}), _zod.z.object({
+  success: _zod.z.literal(false),
+  message: _zod.z.string().nullish()
+})]);
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/api/schemas/wallet.d.ts b/node_modules/@hathor/wallet-lib/oldLib/api/schemas/wallet.d.ts
new file mode 100644
index 0000000..610d31e
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/api/schemas/wallet.d.ts
@@ -0,0 +1,136 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+import { z } from 'zod';
+export declare const addressHistorySchema: z.ZodDiscriminatedUnion<"success", [z.ZodObject<{
+    success: z.ZodLiteral<true>;
+    history: z.ZodArray<import("../../utils/bigint").ZodSchema<import("../../types").IHistoryTx>, "many">;
+    has_more: z.ZodBoolean;
+    first_hash: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+    first_address: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+}, "passthrough", z.ZodTypeAny, z.objectOutputType<{
+    success: z.ZodLiteral<true>;
+    history: z.ZodArray<import("../../utils/bigint").ZodSchema<import("../../types").IHistoryTx>, "many">;
+    has_more: z.ZodBoolean;
+    first_hash: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+    first_address: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+}, z.ZodTypeAny, "passthrough">, z.objectInputType<{
+    success: z.ZodLiteral<true>;
+    history: z.ZodArray<import("../../utils/bigint").ZodSchema<import("../../types").IHistoryTx>, "many">;
+    has_more: z.ZodBoolean;
+    first_hash: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+    first_address: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+}, z.ZodTypeAny, "passthrough">>, z.ZodObject<{
+    success: z.ZodLiteral<false>;
+    message: z.ZodString;
+}, "passthrough", z.ZodTypeAny, z.objectOutputType<{
+    success: z.ZodLiteral<false>;
+    message: z.ZodString;
+}, z.ZodTypeAny, "passthrough">, z.objectInputType<{
+    success: z.ZodLiteral<false>;
+    message: z.ZodString;
+}, z.ZodTypeAny, "passthrough">>]>;
+export type AddressHistorySchema = z.infer<typeof addressHistorySchema>;
+export declare const mintMeltUtxoSchema: z.ZodObject<{
+    tx_id: z.ZodString;
+    index: z.ZodNumber;
+}, "passthrough", z.ZodTypeAny, z.objectOutputType<{
+    tx_id: z.ZodString;
+    index: z.ZodNumber;
+}, z.ZodTypeAny, "passthrough">, z.objectInputType<{
+    tx_id: z.ZodString;
+    index: z.ZodNumber;
+}, z.ZodTypeAny, "passthrough">>;
+export declare const generalTokenInfoSchema: z.ZodDiscriminatedUnion<"success", [z.ZodObject<{
+    success: z.ZodLiteral<true>;
+    name: z.ZodString;
+    symbol: z.ZodString;
+    mint: z.ZodArray<z.ZodObject<{
+        tx_id: z.ZodString;
+        index: z.ZodNumber;
+    }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
+        tx_id: z.ZodString;
+        index: z.ZodNumber;
+    }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
+        tx_id: z.ZodString;
+        index: z.ZodNumber;
+    }, z.ZodTypeAny, "passthrough">>, "many">;
+    melt: z.ZodArray<z.ZodObject<{
+        tx_id: z.ZodString;
+        index: z.ZodNumber;
+    }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
+        tx_id: z.ZodString;
+        index: z.ZodNumber;
+    }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
+        tx_id: z.ZodString;
+        index: z.ZodNumber;
+    }, z.ZodTypeAny, "passthrough">>, "many">;
+    total: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+    transactions_count: z.ZodNumber;
+}, "passthrough", z.ZodTypeAny, z.objectOutputType<{
+    success: z.ZodLiteral<true>;
+    name: z.ZodString;
+    symbol: z.ZodString;
+    mint: z.ZodArray<z.ZodObject<{
+        tx_id: z.ZodString;
+        index: z.ZodNumber;
+    }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
+        tx_id: z.ZodString;
+        index: z.ZodNumber;
+    }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
+        tx_id: z.ZodString;
+        index: z.ZodNumber;
+    }, z.ZodTypeAny, "passthrough">>, "many">;
+    melt: z.ZodArray<z.ZodObject<{
+        tx_id: z.ZodString;
+        index: z.ZodNumber;
+    }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
+        tx_id: z.ZodString;
+        index: z.ZodNumber;
+    }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
+        tx_id: z.ZodString;
+        index: z.ZodNumber;
+    }, z.ZodTypeAny, "passthrough">>, "many">;
+    total: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+    transactions_count: z.ZodNumber;
+}, z.ZodTypeAny, "passthrough">, z.objectInputType<{
+    success: z.ZodLiteral<true>;
+    name: z.ZodString;
+    symbol: z.ZodString;
+    mint: z.ZodArray<z.ZodObject<{
+        tx_id: z.ZodString;
+        index: z.ZodNumber;
+    }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
+        tx_id: z.ZodString;
+        index: z.ZodNumber;
+    }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
+        tx_id: z.ZodString;
+        index: z.ZodNumber;
+    }, z.ZodTypeAny, "passthrough">>, "many">;
+    melt: z.ZodArray<z.ZodObject<{
+        tx_id: z.ZodString;
+        index: z.ZodNumber;
+    }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
+        tx_id: z.ZodString;
+        index: z.ZodNumber;
+    }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
+        tx_id: z.ZodString;
+        index: z.ZodNumber;
+    }, z.ZodTypeAny, "passthrough">>, "many">;
+    total: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+    transactions_count: z.ZodNumber;
+}, z.ZodTypeAny, "passthrough">>, z.ZodObject<{
+    success: z.ZodLiteral<false>;
+    message: z.ZodString;
+}, "passthrough", z.ZodTypeAny, z.objectOutputType<{
+    success: z.ZodLiteral<false>;
+    message: z.ZodString;
+}, z.ZodTypeAny, "passthrough">, z.objectInputType<{
+    success: z.ZodLiteral<false>;
+    message: z.ZodString;
+}, z.ZodTypeAny, "passthrough">>]>;
+export type GeneralTokenInfoSchema = z.infer<typeof generalTokenInfoSchema>;
+//# sourceMappingURL=wallet.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/api/schemas/wallet.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/api/schemas/wallet.d.ts.map
new file mode 100644
index 0000000..d27a525
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/api/schemas/wallet.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"wallet.d.ts","sourceRoot":"","sources":["../../../src/api/schemas/wallet.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;AAEH,OAAO,EAAE,CAAC,EAAE,MAAM,KAAK,CAAC;AAIxB,eAAO,MAAM,oBAAoB;;;;;;;;;;;;;;;;;;;;;;;;;;;kCAW/B,CAAC;AAEH,MAAM,MAAM,oBAAoB,GAAG,CAAC,CAAC,KAAK,CAAC,OAAO,oBAAoB,CAAC,CAAC;AAExE,eAAO,MAAM,kBAAkB;;;;;;;;;gCAKf,CAAC;AAEjB,eAAO,MAAM,sBAAsB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kCAajC,CAAC;AAEH,MAAM,MAAM,sBAAsB,GAAG,CAAC,CAAC,KAAK,CAAC,OAAO,sBAAsB,CAAC,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/api/schemas/wallet.js b/node_modules/@hathor/wallet-lib/oldLib/api/schemas/wallet.js
new file mode 100644
index 0000000..50bd168
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/api/schemas/wallet.js
@@ -0,0 +1,42 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.mintMeltUtxoSchema = exports.generalTokenInfoSchema = exports.addressHistorySchema = void 0;
+var _zod = require("zod");
+var _schemas = require("../../schemas");
+var _bigint = require("../../utils/bigint");
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+const addressHistorySchema = exports.addressHistorySchema = _zod.z.discriminatedUnion('success', [_zod.z.object({
+  success: _zod.z.literal(true),
+  history: _schemas.IHistoryTxSchema.array(),
+  has_more: _zod.z.boolean(),
+  first_hash: _zod.z.string().nullish(),
+  first_address: _zod.z.string().nullish()
+}).passthrough(), _zod.z.object({
+  success: _zod.z.literal(false),
+  message: _zod.z.string()
+}).passthrough()]);
+const mintMeltUtxoSchema = exports.mintMeltUtxoSchema = _zod.z.object({
+  tx_id: _zod.z.string(),
+  index: _zod.z.number()
+}).passthrough();
+const generalTokenInfoSchema = exports.generalTokenInfoSchema = _zod.z.discriminatedUnion('success', [_zod.z.object({
+  success: _zod.z.literal(true),
+  name: _zod.z.string(),
+  symbol: _zod.z.string(),
+  mint: mintMeltUtxoSchema.array(),
+  melt: mintMeltUtxoSchema.array(),
+  total: _bigint.bigIntCoercibleSchema,
+  transactions_count: _zod.z.number()
+}).passthrough(), _zod.z.object({
+  success: _zod.z.literal(false),
+  message: _zod.z.string()
+}).passthrough()]);
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/api/txApi.d.ts b/node_modules/@hathor/wallet-lib/oldLib/api/txApi.d.ts
new file mode 100644
index 0000000..5b69cdb
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/api/txApi.d.ts
@@ -0,0 +1,109 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+import { FullNodeTxApiResponse } from './schemas/txApi';
+/**
+ * Api calls for transaction
+ *
+ * @namespace ApiTransaction
+ */
+declare const txApi: {
+    /**
+     * Call get transaction API with data passed as parameter
+     *
+     * @param {Object} data Data to be sent in the request
+     * @param {function} resolve Method to be called after response arrives
+     *
+     * @return {Promise}
+     * @memberof ApiTransaction
+     * @inner
+     */
+    getTransactionBase(data: any, resolve: any, schema?: any): Promise<void>;
+    /**
+     * Call api to get many transactions
+     *
+     * @param {string} type 'block' or 'tx' (if we are getting txs or blocks)
+     * @param {number} count How many objects we want
+     * @param {number} timestamp (optional) timestamp reference for the pagination (works together with 'page' parameter)
+     * @param {string} hash (optional)  hash reference for the pagination (works together with 'page' parameter)
+     * @param {string} page (optional) 'previous' or 'next': if 'previous', we get the objects before the hash reference. If 'next', we get the objects after the hash reference
+     * @params {function} resolve Method to be called after response arrives
+     *
+     * @return {Promise}
+     * @memberof ApiTransaction
+     * @inner
+     */
+    getTransactions(type: any, count: any, timestamp: any, hash: any, page: any, resolve: any): Promise<void>;
+    /**
+     * Call api to get one transaction
+     *
+     * @param {string} id Transaction ID to search
+     * @params {function} resolve Method to be called after response arrives
+     *
+     * @return {Promise}
+     * @memberof ApiTransaction
+     * @inner
+     */
+    getTransaction(id: string, resolve: (response: FullNodeTxApiResponse) => void): Promise<void>;
+    /**
+     * Call api to get confirmation data of a tx
+     *
+     * @param {string} id Transaction hash in hex
+     * @param {function} resolve Method to be called after response arrives
+     *
+     * @return {Promise}
+     * @memberof ApiTransaction
+     * @inner
+     */
+    getConfirmationData(id: any, resolve: any): Promise<void>;
+    /**
+     * Call api to decode a transaction
+     *
+     * @param {string} hex_tx Full transaction in hexadecimal
+     * @param {function} resolve Method to be called after response arrives
+     *
+     * @return {Promise}
+     * @memberof ApiTransaction
+     * @inner
+     */
+    decodeTx(hex_tx: any, resolve: any): Promise<void>;
+    /**
+     * Call api to push a transaction
+     *
+     * @param {string} hex_tx Full transaction in hexadecimal
+     * @param {function} resolve Method to be called after response arrives
+     *
+     * @return {Promise}
+     * @memberof ApiTransaction
+     * @inner
+     */
+    pushTx(hex_tx: any, force: any, resolve: any): Promise<void>;
+    /**
+     * Call api to get dashboard data
+     *
+     * @param {number} block Quantity of blocks to return
+     * @param {number} tx Quantity of transactions to return
+     * @param {function} resolve Method to be called after response arrives
+     *
+     * @return {Promise}
+     * @memberof ApiTransaction
+     * @inner
+     */
+    getDashboardTx(block: any, tx: any, resolve: any): Promise<void>;
+    /**
+     * Call api to get graphviz
+     *
+     * @param {string} url URL to get graph data
+     * @param {function} resolve Method to be called after response arrives
+     *
+     * @return {Promise}
+     * @memberof ApiTransaction
+     * @inner
+     */
+    getGraphviz(url: any, resolve: any): Promise<void>;
+};
+export default txApi;
+//# sourceMappingURL=txApi.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/api/txApi.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/api/txApi.d.ts.map
new file mode 100644
index 0000000..5048bf1
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/api/txApi.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"txApi.d.ts","sourceRoot":"","sources":["../../src/api/txApi.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;AAIH,OAAO,EAAE,qBAAqB,EAAwB,MAAM,iBAAiB,CAAC;AAE9E;;;;GAIG;AAEH,QAAA,MAAM,KAAK;IACT;;;;;;;;;OASG;;IAiBH;;;;;;;;;;;;;OAaG;;IAYH;;;;;;;;;OASG;uBACgB,MAAM,WAAW,CAAC,QAAQ,EAAE,qBAAqB,KAAK,IAAI,GAAG,QAAQ,IAAI,CAAC;IAK7F;;;;;;;;;OASG;;IAeH;;;;;;;;;OASG;;IAeH;;;;;;;;;OASG;;IAeH;;;;;;;;;;OAUG;;IAeH;;;;;;;;;OASG;;CAaJ,CAAC;AAEF,eAAe,KAAK,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/api/txApi.js b/node_modules/@hathor/wallet-lib/oldLib/api/txApi.js
new file mode 100644
index 0000000..c9db45b
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/api/txApi.js
@@ -0,0 +1,194 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+var _axiosInstance = require("./axiosInstance");
+var _bigint = require("../utils/bigint");
+var _txApi = require("./schemas/txApi");
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+/**
+ * Api calls for transaction
+ *
+ * @namespace ApiTransaction
+ */
+
+const txApi = {
+  /**
+   * Call get transaction API with data passed as parameter
+   *
+   * @param {Object} data Data to be sent in the request
+   * @param {function} resolve Method to be called after response arrives
+   *
+   * @return {Promise}
+   * @memberof ApiTransaction
+   * @inner
+   */
+  getTransactionBase(data, resolve, schema) {
+    return (0, _axiosInstance.createRequestInstance)(resolve).get(`transaction`, {
+      params: data,
+      transformResponse: res => schema ? (0, _bigint.transformJsonBigIntResponse)(res, schema) : res
+    }).then(res => {
+      resolve(res.data);
+    }, res => {
+      return Promise.reject(res);
+    });
+  },
+  /**
+   * Call api to get many transactions
+   *
+   * @param {string} type 'block' or 'tx' (if we are getting txs or blocks)
+   * @param {number} count How many objects we want
+   * @param {number} timestamp (optional) timestamp reference for the pagination (works together with 'page' parameter)
+   * @param {string} hash (optional)  hash reference for the pagination (works together with 'page' parameter)
+   * @param {string} page (optional) 'previous' or 'next': if 'previous', we get the objects before the hash reference. If 'next', we get the objects after the hash reference
+   * @params {function} resolve Method to be called after response arrives
+   *
+   * @return {Promise}
+   * @memberof ApiTransaction
+   * @inner
+   */
+  getTransactions(type, count, timestamp, hash, page, resolve) {
+    // eslint-disable-next-line @typescript-eslint/no-explicit-any
+    const data = {
+      type,
+      count
+    };
+    if (hash) {
+      data.hash = hash;
+      data.timestamp = timestamp;
+      data.page = page;
+    }
+    return this.getTransactionBase(data, resolve);
+  },
+  /**
+   * Call api to get one transaction
+   *
+   * @param {string} id Transaction ID to search
+   * @params {function} resolve Method to be called after response arrives
+   *
+   * @return {Promise}
+   * @memberof ApiTransaction
+   * @inner
+   */
+  getTransaction(id, resolve) {
+    const data = {
+      id
+    };
+    return this.getTransactionBase(data, resolve, _txApi.transactionApiSchema);
+  },
+  /**
+   * Call api to get confirmation data of a tx
+   *
+   * @param {string} id Transaction hash in hex
+   * @param {function} resolve Method to be called after response arrives
+   *
+   * @return {Promise}
+   * @memberof ApiTransaction
+   * @inner
+   */
+  getConfirmationData(id, resolve) {
+    const data = {
+      id
+    };
+    return (0, _axiosInstance.createRequestInstance)(resolve).get(`transaction_acc_weight`, {
+      params: data
+    }).then(res => {
+      resolve(res.data);
+    }, res => {
+      Promise.reject(res);
+    });
+  },
+  /**
+   * Call api to decode a transaction
+   *
+   * @param {string} hex_tx Full transaction in hexadecimal
+   * @param {function} resolve Method to be called after response arrives
+   *
+   * @return {Promise}
+   * @memberof ApiTransaction
+   * @inner
+   */
+  decodeTx(hex_tx, resolve) {
+    const data = {
+      hex_tx
+    };
+    return (0, _axiosInstance.createRequestInstance)(resolve).get(`decode_tx`, {
+      params: data
+    }).then(res => {
+      resolve(res.data);
+    }, res => {
+      return Promise.reject(res);
+    });
+  },
+  /**
+   * Call api to push a transaction
+   *
+   * @param {string} hex_tx Full transaction in hexadecimal
+   * @param {function} resolve Method to be called after response arrives
+   *
+   * @return {Promise}
+   * @memberof ApiTransaction
+   * @inner
+   */
+  pushTx(hex_tx, force, resolve) {
+    const data = {
+      hex_tx,
+      force
+    };
+    return (0, _axiosInstance.createRequestInstance)(resolve).post(`push_tx`, data).then(res => {
+      resolve(res.data);
+    }, res => {
+      return Promise.reject(res);
+    });
+  },
+  /**
+   * Call api to get dashboard data
+   *
+   * @param {number} block Quantity of blocks to return
+   * @param {number} tx Quantity of transactions to return
+   * @param {function} resolve Method to be called after response arrives
+   *
+   * @return {Promise}
+   * @memberof ApiTransaction
+   * @inner
+   */
+  getDashboardTx(block, tx, resolve) {
+    const data = {
+      block,
+      tx
+    };
+    return (0, _axiosInstance.createRequestInstance)(resolve).get(`dashboard_tx`, {
+      params: data
+    }).then(res => {
+      resolve(res.data);
+    }, res => {
+      return Promise.reject(res);
+    });
+  },
+  /**
+   * Call api to get graphviz
+   *
+   * @param {string} url URL to get graph data
+   * @param {function} resolve Method to be called after response arrives
+   *
+   * @return {Promise}
+   * @memberof ApiTransaction
+   * @inner
+   */
+  getGraphviz(url, resolve) {
+    return (0, _axiosInstance.createRequestInstance)(resolve).get(url).then(res => {
+      resolve(res.data);
+    }, res => {
+      return Promise.reject(res);
+    });
+  }
+};
+var _default = exports.default = txApi;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/api/txMining.js b/node_modules/@hathor/wallet-lib/oldLib/api/txMining.js
new file mode 100644
index 0000000..a3f2539
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/api/txMining.js
@@ -0,0 +1,107 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+var _txMiningAxios = _interopRequireDefault(require("./txMiningAxios"));
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+/**
+ * Api calls for tx mining
+ *
+ * @namespace ApiTxMining
+ */
+
+const txMiningApi = {
+  /**
+   * Submit tx to be mined
+   *
+   * @param {String} tx Data in hexadecimal
+   * @param {boolean} propagate If should propagate tx after the job is completed
+   * @param {boolean} add_parents If should return the parents
+   * @param {Number} timeout Optional parameter to define the timeout of the submit job in seconds
+   *
+   * @return {Promise}
+   * @memberof ApiTxMining
+   * @inner
+   */
+  submitJob(tx, propagate, add_parents, timeout, resolve) {
+    const postData = {
+      tx,
+      propagate,
+      add_parents
+    };
+    if (timeout) {
+      postData.timeout = timeout;
+    }
+    return (0, _txMiningAxios.default)(resolve).post('submit-job', postData).then(res => {
+      resolve(res.data);
+    }, error => {
+      return Promise.reject(error);
+    });
+  },
+  /**
+   * Get job status
+   *
+   * @param {String} job Job id
+   *
+   * @return {Promise}
+   * @memberof ApiTxMining
+   * @inner
+   */
+  getJobStatus(job, resolve) {
+    const data = {
+      'job-id': job
+    };
+    return (0, _txMiningAxios.default)(resolve).get('job-status', {
+      params: data
+    }).then(res => {
+      resolve(res.data);
+    }, error => {
+      return Promise.reject(error);
+    });
+  },
+  /**
+   * Cancel a job
+   *
+   * @param {String} job Job id
+   *
+   * @return {Promise}
+   * @memberof ApiTxMining
+   * @inner
+   */
+  cancelJob(job, resolve) {
+    const data = {
+      'job-id': job
+    };
+    return (0, _txMiningAxios.default)(resolve).post('cancel-job', data).then(res => {
+      resolve(res.data);
+    }, error => {
+      return Promise.reject(error);
+    });
+  },
+  /**
+   * Get health information for the tx-mining-service
+   *
+   * @return {Promise}
+   * @memberof ApiTxMining
+   * @inner
+   */
+  async getHealth() {
+    return new Promise((resolve, reject) => {
+      (0, _txMiningAxios.default)(resolve).get(`health`).then(res => {
+        resolve(res.data);
+      }, err => {
+        reject(err);
+      });
+    });
+  }
+};
+var _default = exports.default = txMiningApi;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/api/txMiningAxios.d.ts b/node_modules/@hathor/wallet-lib/oldLib/api/txMiningAxios.d.ts
new file mode 100644
index 0000000..ba345f8
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/api/txMiningAxios.d.ts
@@ -0,0 +1,21 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/**
+ * Create axios instance settings base URL and content type
+ * Besides that, it captures error to show modal error and save in Redux
+ *
+ * @module Axios
+ */
+/**
+ * Create an axios instance to be used when sending requests
+ *
+ * @param resolve (UNUSED) Callback to be stored and used in case of a retry after a fail
+ * @param timeout Timeout in milliseconds for the request
+ */
+declare const txMiningRequestClient: (resolve: undefined | null, timeout?: number | null) => import("axios").AxiosInstance;
+export default txMiningRequestClient;
+//# sourceMappingURL=txMiningAxios.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/api/txMiningAxios.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/api/txMiningAxios.d.ts.map
new file mode 100644
index 0000000..5be6b52
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/api/txMiningAxios.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"txMiningAxios.d.ts","sourceRoot":"","sources":["../../src/api/txMiningAxios.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;AAKH;;;;;GAKG;AAEH;;;;;GAKG;AACH,QAAA,MAAM,qBAAqB,YAAa,SAAS,GAAG,IAAI,YAAY,MAAM,GAAG,IAAI,kCAWhF,CAAC;AAEF,eAAe,qBAAqB,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/api/txMiningAxios.js b/node_modules/@hathor/wallet-lib/oldLib/api/txMiningAxios.js
new file mode 100644
index 0000000..f6bd514
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/api/txMiningAxios.js
@@ -0,0 +1,39 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+var _axiosWrapper = _interopRequireDefault(require("./axiosWrapper"));
+var _config = _interopRequireDefault(require("../config"));
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+/**
+ * Create axios instance settings base URL and content type
+ * Besides that, it captures error to show modal error and save in Redux
+ *
+ * @module Axios
+ */
+
+/**
+ * Create an axios instance to be used when sending requests
+ *
+ * @param resolve (UNUSED) Callback to be stored and used in case of a retry after a fail
+ * @param timeout Timeout in milliseconds for the request
+ */
+const txMiningRequestClient = (resolve, timeout) => {
+  const txMiningURL = _config.default.getTxMiningUrl();
+  const txMiningApiKey = _config.default.getTxMiningApiKey();
+  const headers = {};
+  if (txMiningApiKey) {
+    headers.apikey = txMiningApiKey;
+  }
+  return (0, _axiosWrapper.default)(txMiningURL, resolve, timeout, headers);
+};
+var _default = exports.default = txMiningRequestClient;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/api/version.js b/node_modules/@hathor/wallet-lib/oldLib/api/version.js
new file mode 100644
index 0000000..a919e2a
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/api/version.js
@@ -0,0 +1,55 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+var _axiosInstance = require("./axiosInstance");
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+/**
+ * Api calls for version
+ *
+ * @namespace ApiVersion
+ */
+
+const versionApi = {
+  /**
+   * Get version of full node running in connected server
+   *
+   * @param {function} resolve Method to be called after response arrives
+   *
+   * @return {Promise}
+   * @memberof ApiVersion
+   * @inner
+   */
+  getVersion(resolve) {
+    return (0, _axiosInstance.createRequestInstance)(resolve).get(`version`).then(res => {
+      resolve(res.data);
+    }, res => {
+      return Promise.reject(res);
+    });
+  },
+  /**
+   * Get version of full node running in connected server
+   *
+   * @return {Promise}
+   * @memberof ApiVersion
+   * @inner
+   */
+  async asyncGetVersion() {
+    return new Promise((resolve, reject) => {
+      (0, _axiosInstance.createRequestInstance)(resolve).get(`version`).then(res => {
+        resolve(res.data);
+      }, err => {
+        reject(err);
+      });
+    });
+  }
+};
+var _default = exports.default = versionApi;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/api/wallet.d.ts b/node_modules/@hathor/wallet-lib/oldLib/api/wallet.d.ts
new file mode 100644
index 0000000..862e896
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/api/wallet.d.ts
@@ -0,0 +1,144 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+import { AxiosResponse } from 'axios';
+import { AddressHistorySchema, GeneralTokenInfoSchema } from './schemas/wallet';
+/**
+ * Api calls for wallet
+ *
+ * @namespace ApiWallet
+ */
+declare const walletApi: {
+    /**
+     * Get address history from passed addresses
+     *
+     * @param {Array} addresses Array of addresses to search for the history
+     * @param {String} hash String of the hash to start the search in the first address (optional)
+     * @param {function} resolve Method to be called after response arrives
+     *
+     * @return {Promise}
+     * @memberof ApiWallet
+     * @inner
+     */
+    getAddressHistory(addresses: any, hash: any, resolve: any): Promise<void | AxiosResponse<AddressHistorySchema>>;
+    /**
+     * Call API to get address history
+     *
+     * XXX Our current method to allow retry a request demands that we create an axios
+     * instance with a resolve callback, which will be used in case of failure and the
+     * user decides to retry. Because of that, it's impossible to use the old method (getAddressHistory)
+     * to get data with async/await, only with promises. Because of the pagination,
+     * we are in a loop getting data while not finished, so the code with async/await is
+     * much cleaner.
+     *
+     * So, right now to use async/await we must use this method and it's not possible to
+     * retry a request executed here. We must redesign the retry structure, so we can
+     * support calling API methods with async/await.
+     *
+     * @param {Array} addresses Array of addresses to search for the history
+     * @param {String} hash String of the hash to start the search in the first address (optional)
+     *
+     * @return {Promise}
+     * @memberof ApiWallet
+     * @inner
+     */
+    getAddressHistoryForAwait(addresses: any, hash: any): Promise<AxiosResponse<AddressHistorySchema>>;
+    /**
+     * Same as the GET API but as a POST, in order to support requests with many addresses
+     * in the GET we are getting 414, which is URI too large
+     *
+     * @param {Array} addresses Array of addresses to search for the history
+     * @param {String} hash String of the hash to start the search in the first address (optional)
+     *
+     * @return {Promise}
+     * @memberof ApiWallet
+     * @inner
+     */
+    getAddressHistoryForAwaitPOST(addresses: any, hash: any): Promise<AxiosResponse<AddressHistorySchema>>;
+    /**
+     * Execute method to send tokens
+     *
+     * @param {string} txHex Complete transaction serialized in hexadecimal
+     * @param {function} resolve Method to be called after response arrives
+     *
+     * @return {Promise}
+     * @memberof ApiWallet
+     * @inner
+     */
+    sendTokens(txHex: any, resolve: any): Promise<void>;
+    /**
+     * Call get general token info API
+     *
+     * @param {string} uid Token uid to get the general info
+     * @param {function} resolve Method to be called after response arrives
+     *
+     * @return {Promise}
+     * @memberof ApiWallet
+     * @inner
+     */
+    getGeneralTokenInfo(uid: any, resolve: any): Promise<void | AxiosResponse<GeneralTokenInfoSchema>>;
+    /**
+     * Call get token transaction history API
+     *
+     * @param {string} uid Token uid to get the info
+     * @param {number} count Quantity of elements to be returned
+     * @param {string} hash Hash of transaction as reference in pagination
+     * @param {number} timestamp Timestamp of transaction as reference in pagination
+     * @param {string} page The button clicked in the pagination ('previous' or 'next')
+     * @param {function} resolve Method to be called after response arrives
+     *
+     * @return {Promise}
+     * @memberof ApiWallet
+     * @inner
+     */
+    getTokenHistory(uid: any, count: any, hash: any, timestamp: any, page: any, resolve: any): Promise<void>;
+    /**
+     * Call get mining info data
+     *
+     * @param {function} resolve Method to be called after response arrives
+     *
+     * @return {Promise}
+     * @memberof ApiWallet
+     * @inner
+     */
+    getMiningInfo(resolve: any): Promise<void>;
+    /**
+     * Call get tokens list API
+     *
+     * @param {function} resolve Method to be called after response arrives
+     *
+     * @return {Promise}
+     * @memberof ApiWallet
+     * @inner
+     */
+    getTokensList(resolve: any): Promise<void>;
+    /**
+     * Get address balance summary
+     *
+     * @param {String} addresse Address to get the balance summary
+     *
+     * @return {Promise}
+     * @memberof ApiWallet
+     * @inner
+     */
+    getAddressBalance(address: any, resolve: any): Promise<void>;
+    /**
+     * Search address
+     *
+     * @param {String} address Address to search history
+     * @param {Number} count Quantity of elements to return
+     * @param {String} hash Optional pagination parameter to reference the search
+     * @param {String} page Optional pagination parameter to indicate which page button was clicked
+     * @param {function} resolve Method to be called after response arrives
+     *
+     * @return {Promise}
+     * @memberof ApiWallet
+     * @inner
+     */
+    getSearchAddress(address: any, count: any, hash: any, page: any, token: any, resolve: any): Promise<void>;
+};
+export default walletApi;
+//# sourceMappingURL=wallet.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/api/wallet.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/api/wallet.d.ts.map
new file mode 100644
index 0000000..08fbac8
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/api/wallet.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"wallet.d.ts","sourceRoot":"","sources":["../../src/api/wallet.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;AAEH,OAAO,EAAE,aAAa,EAAE,MAAM,OAAO,CAAC;AAItC,OAAO,EACL,oBAAoB,EAEpB,sBAAsB,EAEvB,MAAM,kBAAkB,CAAC;AAE1B;;;;GAIG;AAEH,QAAA,MAAM,SAAS;IACb;;;;;;;;;;OAUG;gEAC0C,QAAQ,IAAI,GAAG,cAAc,oBAAoB,CAAC,CAAC;IAqBhG;;;;;;;;;;;;;;;;;;;;OAoBG;0DACyC,QAAQ,cAAc,oBAAoB,CAAC,CAAC;IAYxF;;;;;;;;;;OAUG;8DAC6C,QAAQ,cAAc,oBAAoB,CAAC,CAAC;IAW5F;;;;;;;;;OASG;;IAeH;;;;;;;;;OASG;iDACgC,QAAQ,IAAI,GAAG,cAAc,sBAAsB,CAAC,CAAC;IAiBxF;;;;;;;;;;;;;OAaG;;IAuBH;;;;;;;;OAQG;;IAcH;;;;;;;;OAQG;;IAcH;;;;;;;;OAQG;;IAeH;;;;;;;;;;;;OAYG;;CAyBJ,CAAC;AAEF,eAAe,SAAS,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/api/wallet.js b/node_modules/@hathor/wallet-lib/oldLib/api/wallet.js
new file mode 100644
index 0000000..8b382a6
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/api/wallet.js
@@ -0,0 +1,277 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+var _axiosInstance = require("./axiosInstance");
+var _constants = require("../constants");
+var _bigint = require("../utils/bigint");
+var _wallet = require("./schemas/wallet");
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+/**
+ * Api calls for wallet
+ *
+ * @namespace ApiWallet
+ */
+
+const walletApi = {
+  /**
+   * Get address history from passed addresses
+   *
+   * @param {Array} addresses Array of addresses to search for the history
+   * @param {String} hash String of the hash to start the search in the first address (optional)
+   * @param {function} resolve Method to be called after response arrives
+   *
+   * @return {Promise}
+   * @memberof ApiWallet
+   * @inner
+   */
+  getAddressHistory(addresses, hash, resolve) {
+    // eslint-disable-next-line @typescript-eslint/no-explicit-any
+    const data = {
+      addresses,
+      paginate: true
+    };
+    if (hash) {
+      data.hash = hash;
+    }
+    return (0, _axiosInstance.createRequestInstance)(resolve).get('thin_wallet/address_history', {
+      params: data,
+      transformResponse: res => (0, _bigint.transformJsonBigIntResponse)(res, _wallet.addressHistorySchema)
+    }).then(res => {
+      resolve(res.data);
+    }, res => {
+      return Promise.reject(res);
+    });
+  },
+  /**
+   * Call API to get address history
+   *
+   * XXX Our current method to allow retry a request demands that we create an axios
+   * instance with a resolve callback, which will be used in case of failure and the
+   * user decides to retry. Because of that, it's impossible to use the old method (getAddressHistory)
+   * to get data with async/await, only with promises. Because of the pagination,
+   * we are in a loop getting data while not finished, so the code with async/await is
+   * much cleaner.
+   *
+   * So, right now to use async/await we must use this method and it's not possible to
+   * retry a request executed here. We must redesign the retry structure, so we can
+   * support calling API methods with async/await.
+   *
+   * @param {Array} addresses Array of addresses to search for the history
+   * @param {String} hash String of the hash to start the search in the first address (optional)
+   *
+   * @return {Promise}
+   * @memberof ApiWallet
+   * @inner
+   */
+  getAddressHistoryForAwait(addresses, hash) {
+    // eslint-disable-next-line @typescript-eslint/no-explicit-any
+    const data = {
+      addresses,
+      paginate: true
+    };
+    if (hash) {
+      data.hash = hash;
+    }
+    return (0, _axiosInstance.createRequestInstance)().get('thin_wallet/address_history', {
+      params: data,
+      transformResponse: res => (0, _bigint.transformJsonBigIntResponse)(res, _wallet.addressHistorySchema)
+    });
+  },
+  /**
+   * Same as the GET API but as a POST, in order to support requests with many addresses
+   * in the GET we are getting 414, which is URI too large
+   *
+   * @param {Array} addresses Array of addresses to search for the history
+   * @param {String} hash String of the hash to start the search in the first address (optional)
+   *
+   * @return {Promise}
+   * @memberof ApiWallet
+   * @inner
+   */
+  getAddressHistoryForAwaitPOST(addresses, hash) {
+    // eslint-disable-next-line @typescript-eslint/no-explicit-any
+    const data = {
+      addresses,
+      paginate: true
+    };
+    if (hash) {
+      data.hash = hash;
+    }
+    return (0, _axiosInstance.createRequestInstance)().post('thin_wallet/address_history', data, {
+      transformResponse: res => (0, _bigint.transformJsonBigIntResponse)(res, _wallet.addressHistorySchema)
+    });
+  },
+  /**
+   * Execute method to send tokens
+   *
+   * @param {string} txHex Complete transaction serialized in hexadecimal
+   * @param {function} resolve Method to be called after response arrives
+   *
+   * @return {Promise}
+   * @memberof ApiWallet
+   * @inner
+   */
+  sendTokens(txHex, resolve) {
+    const postData = {
+      tx_hex: txHex
+    };
+    return (0, _axiosInstance.createRequestInstance)(resolve, _constants.SEND_TOKENS_TIMEOUT).post('thin_wallet/send_tokens', postData).then(res => {
+      resolve(res.data);
+    }, res => {
+      return Promise.reject(res);
+    });
+  },
+  /**
+   * Call get general token info API
+   *
+   * @param {string} uid Token uid to get the general info
+   * @param {function} resolve Method to be called after response arrives
+   *
+   * @return {Promise}
+   * @memberof ApiWallet
+   * @inner
+   */
+  getGeneralTokenInfo(uid, resolve) {
+    const data = {
+      id: uid
+    };
+    return (0, _axiosInstance.createRequestInstance)(resolve).get('thin_wallet/token', {
+      params: data,
+      transformResponse: res => (0, _bigint.transformJsonBigIntResponse)(res, _wallet.generalTokenInfoSchema)
+    }).then(res => {
+      resolve(res.data);
+    }, res => {
+      return Promise.reject(res);
+    });
+  },
+  /**
+   * Call get token transaction history API
+   *
+   * @param {string} uid Token uid to get the info
+   * @param {number} count Quantity of elements to be returned
+   * @param {string} hash Hash of transaction as reference in pagination
+   * @param {number} timestamp Timestamp of transaction as reference in pagination
+   * @param {string} page The button clicked in the pagination ('previous' or 'next')
+   * @param {function} resolve Method to be called after response arrives
+   *
+   * @return {Promise}
+   * @memberof ApiWallet
+   * @inner
+   */
+  getTokenHistory(uid, count, hash, timestamp, page, resolve) {
+    // eslint-disable-next-line @typescript-eslint/no-explicit-any
+    const data = {
+      id: uid,
+      count
+    };
+    if (hash) {
+      data.hash = hash;
+      data.timestamp = timestamp;
+      data.page = page;
+    }
+    return (0, _axiosInstance.createRequestInstance)(resolve).get('thin_wallet/token_history', {
+      params: data
+    }).then(res => {
+      resolve(res.data);
+    }, res => {
+      return Promise.reject(res);
+    });
+  },
+  /**
+   * Call get mining info data
+   *
+   * @param {function} resolve Method to be called after response arrives
+   *
+   * @return {Promise}
+   * @memberof ApiWallet
+   * @inner
+   */
+  getMiningInfo(resolve) {
+    return (0, _axiosInstance.createRequestInstance)(resolve).get('getmininginfo').then(res => {
+      resolve(res.data);
+    }, res => {
+      return Promise.reject(res);
+    });
+  },
+  /**
+   * Call get tokens list API
+   *
+   * @param {function} resolve Method to be called after response arrives
+   *
+   * @return {Promise}
+   * @memberof ApiWallet
+   * @inner
+   */
+  getTokensList(resolve) {
+    return (0, _axiosInstance.createRequestInstance)(resolve).get('thin_wallet/token').then(res => {
+      resolve(res.data);
+    }, res => {
+      return Promise.reject(res);
+    });
+  },
+  /**
+   * Get address balance summary
+   *
+   * @param {String} addresse Address to get the balance summary
+   *
+   * @return {Promise}
+   * @memberof ApiWallet
+   * @inner
+   */
+  getAddressBalance(address, resolve) {
+    const data = {
+      address
+    };
+    return (0, _axiosInstance.createRequestInstance)(resolve).get('thin_wallet/address_balance', {
+      params: data
+    }).then(res => {
+      resolve(res.data);
+    }, res => {
+      return Promise.reject(res);
+    });
+  },
+  /**
+   * Search address
+   *
+   * @param {String} address Address to search history
+   * @param {Number} count Quantity of elements to return
+   * @param {String} hash Optional pagination parameter to reference the search
+   * @param {String} page Optional pagination parameter to indicate which page button was clicked
+   * @param {function} resolve Method to be called after response arrives
+   *
+   * @return {Promise}
+   * @memberof ApiWallet
+   * @inner
+   */
+  getSearchAddress(address, count, hash, page, token, resolve) {
+    // eslint-disable-next-line @typescript-eslint/no-explicit-any
+    const data = {
+      address,
+      count
+    };
+    if (hash) {
+      data.hash = hash;
+      data.page = page;
+    }
+    if (token) {
+      data.token = token;
+    }
+    return (0, _axiosInstance.createRequestInstance)(resolve).get('thin_wallet/address_search', {
+      params: data
+    }).then(res => {
+      resolve(res.data);
+    }, res => {
+      return Promise.reject(res);
+    });
+  }
+};
+var _default = exports.default = walletApi;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/config.d.ts b/node_modules/@hathor/wallet-lib/oldLib/config.d.ts
new file mode 100644
index 0000000..940f332
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/config.d.ts
@@ -0,0 +1,146 @@
+import Network from './models/network';
+export declare const DEFAULT_SERVER = "https://node1.mainnet.hathor.network/v1a/";
+export declare const SWAP_SERVICE_MAINNET_BASE_URL = "https://atomic-swap-service.hathor.network/";
+export declare const SWAP_SERVICE_TESTNET_BASE_URL = "https://atomic-swap-service.testnet.hathor.network/";
+export declare class Config {
+    TX_MINING_URL?: string;
+    TX_MINING_API_KEY?: string;
+    SWAP_SERVICE_BASE_URL?: string;
+    WALLET_SERVICE_BASE_URL?: string;
+    WALLET_SERVICE_BASE_WS_URL?: string;
+    EXPLORER_SERVICE_BASE_URL?: string;
+    SERVER_URL?: string;
+    NETWORK?: string;
+    USER_AGENT?: string;
+    /**
+     * Sets the tx mining service url that will be returned by the config object.
+     *
+     * @param url - The url to be set
+     */
+    setTxMiningUrl(url: string): void;
+    /**
+     * Returns the correct base url constant for tx mining.
+     * If the url was explicitly set using the config object, it is always returned.
+     * Otherwise, we return it based on the network set with networkInstance.
+     *
+     * @return The tx mining service url
+     */
+    getTxMiningUrl(): string;
+    /**
+     * Sets the tx mining service api key that will be returned by the config object.
+     *
+     * @param apiKey - The api key to be set
+     */
+    setTxMiningApiKey(apiKey: string): void;
+    /**
+     * Gets the configured api key for tx-mining-service
+     *
+     * @returns The api key
+     */
+    getTxMiningApiKey(): string | undefined;
+    /**
+     * Sets the wallet service url that will be returned by the config object.
+     *
+     * @param url - The url to be set
+     */
+    setWalletServiceBaseUrl(url: string): void;
+    /**
+     * Returns the base url for wallet service set previously using setWalletServiceBaseUrl
+     *
+     * Throws an error if it is not yet set.
+     *
+     * @return The wallet service url
+     */
+    getWalletServiceBaseUrl(): string;
+    /**
+     * Returns the correct base url constant for the Atomic Swap Service.
+     * If the url was explicitly set using the config object, it is always returned.
+     * Otherwise, we return it based on the provided network parameter.
+     *
+     * If the url was not set in the config, and no network is provided, we throw an Error.
+     *
+     * @param network - The name of the network to be used to select the url.
+     * @throws {Error} When `network` is not 'mainnet' or 'testnet'
+     * @throws {Error} When `network` is not provided neither by `setSwapServiceBaseUrl` nor parameter
+     * @return The Atomic Swap Service url
+     */
+    getSwapServiceBaseUrl(network?: 'mainnet' | 'testnet'): string;
+    /**
+     * Sets the swap service url that will be returned by the config object.
+     *
+     * @param url - The url to be set
+     */
+    setSwapServiceBaseUrl(url: string): void;
+    /**
+     * Returns the correct websocket base url constant for wallet service.
+     *
+     * If it is not set, throw an error.
+     *
+     * @return The wallet service websocket url
+     */
+    getWalletServiceBaseWsUrl(): string;
+    /**
+     * Sets the wallet service websocket url that will be returned by the config object.
+     *
+     * @param url - The url to be set
+     */
+    setWalletServiceBaseWsUrl(url: string): void;
+    /**
+     * Sets the explorer service url that will be returned by the config object.
+     *
+     * @param url - The url to be set
+     */
+    setExplorerServiceBaseUrl(url: string): void;
+    /**
+     * Returns the correct base url constant for explorer service.
+     * If the url was explicitly set using the config object, it is always returned.
+     * Otherwise, we return it based on the provided network object.
+     *
+     * If the url was not set in the config, and no network is provided, we throw an Error.
+     *
+     * @param network - The name of the network to be used to select the url.
+     * @return The explorer service url
+     */
+    getExplorerServiceBaseUrl(network: string): string;
+    /**
+     * Sets the fullnode server url that will be returned by the config object.
+     *
+     * @param url - The url to be set
+     */
+    setServerUrl(url: string): void;
+    /**
+     * Get the server URL that the wallet is connected.
+     *
+     * There is more than one method of setting this.
+     * The priority will be given to the url set using the config object.
+     * If not set, we look next into the storage object keys.
+     * If still not set, the default url is returned
+     *
+     * @return Server URL according to the priority described above
+     */
+    getServerUrl(): string;
+    /**
+     * Sets the current network the wallet is connected to
+     */
+    setNetwork(network: string): void;
+    /**
+     * Gets the current network
+     *
+     * There is more than one method of setting this.
+     * The priority will be given to the network set using the config object.
+     * If not set, we look next into the storage object keys.
+     * If still not set, the default url is returned
+     */
+    getNetwork(): Network;
+    /**
+     * Sets the user agent to be set in all requests
+     */
+    setUserAgent(userAgent: string): void;
+    /**
+     * Gets the user agent
+     */
+    getUserAgent(): string | undefined;
+}
+declare const instance: Config;
+export default instance;
+//# sourceMappingURL=config.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/config.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/config.d.ts.map
new file mode 100644
index 0000000..a9fd669
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/config.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"config.d.ts","sourceRoot":"","sources":["../src/config.ts"],"names":[],"mappings":"AACA,OAAO,OAAO,MAAM,kBAAkB,CAAC;AAIvC,eAAO,MAAM,cAAc,8CAA8C,CAAC;AAY1E,eAAO,MAAM,6BAA6B,gDAAgD,CAAC;AAC3F,eAAO,MAAM,6BAA6B,wDAAwD,CAAC;AAEnG,qBAAa,MAAM;IACjB,aAAa,CAAC,EAAE,MAAM,CAAC;IAEvB,iBAAiB,CAAC,EAAE,MAAM,CAAC;IAE3B,qBAAqB,CAAC,EAAE,MAAM,CAAC;IAE/B,uBAAuB,CAAC,EAAE,MAAM,CAAC;IAEjC,0BAA0B,CAAC,EAAE,MAAM,CAAC;IAEpC,yBAAyB,CAAC,EAAE,MAAM,CAAC;IAEnC,UAAU,CAAC,EAAE,MAAM,CAAC;IAEpB,OAAO,CAAC,EAAE,MAAM,CAAC;IAEjB,UAAU,CAAC,EAAE,MAAM,CAAC;IAEpB;;;;OAIG;IACH,cAAc,CAAC,GAAG,EAAE,MAAM;IAI1B;;;;;;OAMG;IACH,cAAc,IAAI,MAAM;IAiBxB;;;;OAIG;IACH,iBAAiB,CAAC,MAAM,EAAE,MAAM;IAIhC;;;;OAIG;IACH,iBAAiB,IAAI,MAAM,GAAG,SAAS;IAIvC;;;;OAIG;IACH,uBAAuB,CAAC,GAAG,EAAE,MAAM,GAAG,IAAI;IAI1C;;;;;;OAMG;IACH,uBAAuB,IAAI,MAAM;IAQjC;;;;;;;;;;;OAWG;IACH,qBAAqB,CAAC,OAAO,CAAC,EAAE,SAAS,GAAG,SAAS,GAAG,MAAM;IAuB9D;;;;OAIG;IACH,qBAAqB,CAAC,GAAG,EAAE,MAAM,GAAG,IAAI;IAIxC;;;;;;OAMG;IACH,yBAAyB,IAAI,MAAM;IAQnC;;;;OAIG;IACH,yBAAyB,CAAC,GAAG,EAAE,MAAM,GAAG,IAAI;IAI5C;;;;OAIG;IACH,yBAAyB,CAAC,GAAG,EAAE,MAAM,GAAG,IAAI;IAI5C;;;;;;;;;OASG;IACH,yBAAyB,CAAC,OAAO,EAAE,MAAM,GAAG,MAAM;IAuBlD;;;;OAIG;IACH,YAAY,CAAC,GAAG,EAAE,MAAM,GAAG,IAAI;IAI/B;;;;;;;;;OASG;IACH,YAAY,IAAI,MAAM;IAQtB;;OAEG;IACH,UAAU,CAAC,OAAO,EAAE,MAAM,GAAG,IAAI;IAYjC;;;;;;;OAOG;IACH,UAAU,IAAI,OAAO;IAQrB;;OAEG;IACH,YAAY,CAAC,SAAS,EAAE,MAAM,GAAG,IAAI;IAIrC;;OAEG;IACH,YAAY,IAAI,MAAM,GAAG,SAAS;CAGnC;AAED,QAAA,MAAM,QAAQ,QAAe,CAAC;AAE9B,eAAe,QAAQ,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/config.js b/node_modules/@hathor/wallet-lib/oldLib/config.js
new file mode 100644
index 0000000..a83228a
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/config.js
@@ -0,0 +1,283 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = exports.SWAP_SERVICE_TESTNET_BASE_URL = exports.SWAP_SERVICE_MAINNET_BASE_URL = exports.DEFAULT_SERVER = exports.Config = void 0;
+var _network = _interopRequireDefault(require("./network"));
+var _network2 = _interopRequireDefault(require("./models/network"));
+var _errors = require("./errors");
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
+function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
+function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
+// Default server and network user will connect when none have been chosen
+const DEFAULT_SERVER = exports.DEFAULT_SERVER = 'https://node1.mainnet.hathor.network/v1a/';
+const DEFAULT_NETWORK = new _network2.default('mainnet');
+
+// Base URL for the tx mining api
+const TX_MINING_MAINNET_URL = 'https://txmining.mainnet.hathor.network/';
+const TX_MINING_TESTNET_URL = 'https://txmining.testnet.hathor.network/';
+
+// Explorer service URL
+const EXPLORER_SERVICE_MAINNET_BASE_URL = 'https://explorer-service.hathor.network/';
+const EXPLORER_SERVICE_TESTNET_BASE_URL = 'https://explorer-service.testnet.hathor.network/';
+
+// Atomic Swap Service URL
+const SWAP_SERVICE_MAINNET_BASE_URL = exports.SWAP_SERVICE_MAINNET_BASE_URL = 'https://atomic-swap-service.hathor.network/';
+const SWAP_SERVICE_TESTNET_BASE_URL = exports.SWAP_SERVICE_TESTNET_BASE_URL = 'https://atomic-swap-service.testnet.hathor.network/';
+class Config {
+  constructor() {
+    _defineProperty(this, "TX_MINING_URL", void 0);
+    _defineProperty(this, "TX_MINING_API_KEY", void 0);
+    _defineProperty(this, "SWAP_SERVICE_BASE_URL", void 0);
+    _defineProperty(this, "WALLET_SERVICE_BASE_URL", void 0);
+    _defineProperty(this, "WALLET_SERVICE_BASE_WS_URL", void 0);
+    _defineProperty(this, "EXPLORER_SERVICE_BASE_URL", void 0);
+    _defineProperty(this, "SERVER_URL", void 0);
+    _defineProperty(this, "NETWORK", void 0);
+    _defineProperty(this, "USER_AGENT", void 0);
+  }
+  /**
+   * Sets the tx mining service url that will be returned by the config object.
+   *
+   * @param url - The url to be set
+   */
+  setTxMiningUrl(url) {
+    this.TX_MINING_URL = url;
+  }
+
+  /**
+   * Returns the correct base url constant for tx mining.
+   * If the url was explicitly set using the config object, it is always returned.
+   * Otherwise, we return it based on the network set with networkInstance.
+   *
+   * @return The tx mining service url
+   */
+  getTxMiningUrl() {
+    if (this.TX_MINING_URL) {
+      return this.TX_MINING_URL;
+    }
+
+    // Keeps the old behavior for cases that don't explicitly set a TX_MINING_URL
+    if (_network.default.name === 'mainnet') {
+      return TX_MINING_MAINNET_URL;
+    }
+    if (_network.default.name === 'testnet') {
+      return TX_MINING_TESTNET_URL;
+    }
+    throw new Error(`Network ${_network.default.name} doesn't have a correspondent tx mining service url. You should set it explicitly.`);
+  }
+
+  /**
+   * Sets the tx mining service api key that will be returned by the config object.
+   *
+   * @param apiKey - The api key to be set
+   */
+  setTxMiningApiKey(apiKey) {
+    this.TX_MINING_API_KEY = apiKey;
+  }
+
+  /**
+   * Gets the configured api key for tx-mining-service
+   *
+   * @returns The api key
+   */
+  getTxMiningApiKey() {
+    return this.TX_MINING_API_KEY;
+  }
+
+  /**
+   * Sets the wallet service url that will be returned by the config object.
+   *
+   * @param url - The url to be set
+   */
+  setWalletServiceBaseUrl(url) {
+    this.WALLET_SERVICE_BASE_URL = url;
+  }
+
+  /**
+   * Returns the base url for wallet service set previously using setWalletServiceBaseUrl
+   *
+   * Throws an error if it is not yet set.
+   *
+   * @return The wallet service url
+   */
+  getWalletServiceBaseUrl() {
+    if (!this.WALLET_SERVICE_BASE_URL) {
+      throw new _errors.GetWalletServiceUrlError('Wallet service base URL not set.');
+    }
+    return this.WALLET_SERVICE_BASE_URL;
+  }
+
+  /**
+   * Returns the correct base url constant for the Atomic Swap Service.
+   * If the url was explicitly set using the config object, it is always returned.
+   * Otherwise, we return it based on the provided network parameter.
+   *
+   * If the url was not set in the config, and no network is provided, we throw an Error.
+   *
+   * @param network - The name of the network to be used to select the url.
+   * @throws {Error} When `network` is not 'mainnet' or 'testnet'
+   * @throws {Error} When `network` is not provided neither by `setSwapServiceBaseUrl` nor parameter
+   * @return The Atomic Swap Service url
+   */
+  getSwapServiceBaseUrl(network) {
+    if (this.SWAP_SERVICE_BASE_URL) {
+      return this.SWAP_SERVICE_BASE_URL;
+    }
+    if (!network) {
+      throw new Error('You should either provide a network or call setSwapServiceBaseUrl before calling this.');
+    }
+
+    // Keeps the old behavior for cases that don't explicitly set a SWAP_SERVICE_BASE_URL
+    if (network === 'mainnet') {
+      return SWAP_SERVICE_MAINNET_BASE_URL;
+    }
+    if (network === 'testnet') {
+      return SWAP_SERVICE_TESTNET_BASE_URL;
+    }
+    throw new Error(`Network ${network} doesn't have a correspondent Atomic Swap Service url. You should set it explicitly by calling setSwapServiceBaseUrl.`);
+  }
+
+  /**
+   * Sets the swap service url that will be returned by the config object.
+   *
+   * @param url - The url to be set
+   */
+  setSwapServiceBaseUrl(url) {
+    this.SWAP_SERVICE_BASE_URL = url;
+  }
+
+  /**
+   * Returns the correct websocket base url constant for wallet service.
+   *
+   * If it is not set, throw an error.
+   *
+   * @return The wallet service websocket url
+   */
+  getWalletServiceBaseWsUrl() {
+    if (!this.WALLET_SERVICE_BASE_WS_URL) {
+      throw new _errors.GetWalletServiceWsUrlError('Wallet service base WebSocket URL not set.');
+    }
+    return this.WALLET_SERVICE_BASE_WS_URL;
+  }
+
+  /**
+   * Sets the wallet service websocket url that will be returned by the config object.
+   *
+   * @param url - The url to be set
+   */
+  setWalletServiceBaseWsUrl(url) {
+    this.WALLET_SERVICE_BASE_WS_URL = url;
+  }
+
+  /**
+   * Sets the explorer service url that will be returned by the config object.
+   *
+   * @param url - The url to be set
+   */
+  setExplorerServiceBaseUrl(url) {
+    this.EXPLORER_SERVICE_BASE_URL = url;
+  }
+
+  /**
+   * Returns the correct base url constant for explorer service.
+   * If the url was explicitly set using the config object, it is always returned.
+   * Otherwise, we return it based on the provided network object.
+   *
+   * If the url was not set in the config, and no network is provided, we throw an Error.
+   *
+   * @param network - The name of the network to be used to select the url.
+   * @return The explorer service url
+   */
+  getExplorerServiceBaseUrl(network) {
+    if (this.EXPLORER_SERVICE_BASE_URL) {
+      return this.EXPLORER_SERVICE_BASE_URL;
+    }
+    if (!network) {
+      throw new Error('You should either provide a network or call setExplorerServiceBaseUrl before calling this.');
+    }
+
+    // Keeps the old behavior for cases that don't explicitly set a EXPLORER_SERVICE_BASE_URL
+    if (network === 'mainnet') {
+      return EXPLORER_SERVICE_MAINNET_BASE_URL;
+    }
+    if (network === 'testnet') {
+      return EXPLORER_SERVICE_TESTNET_BASE_URL;
+    }
+    throw new Error(`Network ${network} doesn't have a correspondent explorer service url. You should set it explicitly.`);
+  }
+
+  /**
+   * Sets the fullnode server url that will be returned by the config object.
+   *
+   * @param url - The url to be set
+   */
+  setServerUrl(url) {
+    this.SERVER_URL = url;
+  }
+
+  /**
+   * Get the server URL that the wallet is connected.
+   *
+   * There is more than one method of setting this.
+   * The priority will be given to the url set using the config object.
+   * If not set, we look next into the storage object keys.
+   * If still not set, the default url is returned
+   *
+   * @return Server URL according to the priority described above
+   */
+  getServerUrl() {
+    if (this.SERVER_URL) {
+      return this.SERVER_URL;
+    }
+    return DEFAULT_SERVER;
+  }
+
+  /**
+   * Sets the current network the wallet is connected to
+   */
+  setNetwork(network) {
+    /* Until we replace the network singleton with the new config singleton, we need to
+     * maintain reverse compatibility as there are multiple use cases using the lib with
+     * the network singleton
+     *
+     * TODO: Remove this when the network singleton is completely deprecated
+     */
+    _network.default.setNetwork(network, true);
+    this.NETWORK = network;
+  }
+
+  /**
+   * Gets the current network
+   *
+   * There is more than one method of setting this.
+   * The priority will be given to the network set using the config object.
+   * If not set, we look next into the storage object keys.
+   * If still not set, the default url is returned
+   */
+  getNetwork() {
+    if (this.NETWORK) {
+      return new _network2.default(this.NETWORK);
+    }
+    return DEFAULT_NETWORK;
+  }
+
+  /**
+   * Sets the user agent to be set in all requests
+   */
+  setUserAgent(userAgent) {
+    this.USER_AGENT = userAgent;
+  }
+
+  /**
+   * Gets the user agent
+   */
+  getUserAgent() {
+    return this.USER_AGENT;
+  }
+}
+exports.Config = Config;
+const instance = new Config();
+var _default = exports.default = instance;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/connection.d.ts b/node_modules/@hathor/wallet-lib/oldLib/connection.d.ts
new file mode 100644
index 0000000..3abd7a0
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/connection.d.ts
@@ -0,0 +1,93 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/// <reference types="node" />
+import { EventEmitter } from 'events';
+import GenericWebSocket from './websocket';
+import WalletServiceWebSocket from './wallet/websocket';
+import { ConnectionState } from './wallet/types';
+import { ILogger } from './types';
+export declare const DEFAULT_PARAMS: {
+    network: string;
+    servers: never[];
+    connectionTimeout: number;
+    logger: ILogger;
+};
+export type ConnectionParams = {
+    network?: string;
+    servers?: string[];
+    connectionTimeout?: number;
+    logger: ILogger;
+};
+/**
+ * This is a Connection that may be shared by one or more wallets.
+ *
+ * It has the following states:
+ * - CLOSED: When it is disconnected from the server.
+ * - CONNECTING: When it is connecting to the server.
+ * - CONNECTED: When it is connected.
+ *
+ * You can subscribe for the following events:
+ * - state: Fired when the state of the Wallet changes.
+ * - wallet-update: Fired when a new wallet message arrive from the websocket.
+ * */
+declare abstract class Connection extends EventEmitter {
+    protected network: string;
+    websocket: GenericWebSocket | WalletServiceWebSocket | null;
+    protected currentServer: string;
+    protected state: ConnectionState;
+    protected logger: ILogger;
+    constructor(options: ConnectionParams);
+    /**
+     * Called when the connection to the websocket changes.
+     * It is also called if the network is down.
+     * */
+    onConnectionChange(value: boolean): void;
+    /**
+     * Called when a new wallet message arrives from websocket.
+     *
+     * @param {Object} wsData Websocket message data
+     * */
+    handleWalletMessage(wsData: any): void;
+    handleStreamMessage(wsData: any): void;
+    /**
+     * Update class state
+     *
+     * @param {Number} state New state
+     */
+    setState(state: any): void;
+    /**
+     * Connect to the server and start emitting events.
+     * */
+    abstract start(): void;
+    /**
+     * Close the connections and stop emitting events.
+     * */
+    stop(): void;
+    /**
+     * Call websocket endConnection
+     * Needed for compatibility with old src/wallet code
+     * */
+    endConnection(): void;
+    /**
+     * Call websocket setup
+     * Needed for compatibility with old src/wallet code
+     * */
+    setup(): void;
+    /**
+     * Gets current server
+     */
+    getCurrentServer(): string;
+    /**
+     * Gets current network
+     */
+    getCurrentNetwork(): string;
+    startControlHandlers(options?: unknown): void;
+    removeMetricsHandlers(): void;
+    sendMessageWS(msg: string): void;
+}
+export default Connection;
+//# sourceMappingURL=connection.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/connection.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/connection.d.ts.map
new file mode 100644
index 0000000..ee3561d
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/connection.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"connection.d.ts","sourceRoot":"","sources":["../src/connection.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;;AAEH,OAAO,EAAE,YAAY,EAAE,MAAM,QAAQ,CAAC;AAGtC,OAAO,gBAAgB,MAAM,aAAa,CAAC;AAC3C,OAAO,sBAAsB,MAAM,oBAAoB,CAAC;AACxD,OAAO,EAAE,eAAe,EAAE,MAAM,gBAAgB,CAAC;AACjD,OAAO,EAAE,OAAO,EAAoB,MAAM,SAAS,CAAC;AAEpD,eAAO,MAAM,cAAc;;;;;CAK1B,CAAC;AAEF,MAAM,MAAM,gBAAgB,GAAG;IAC7B,OAAO,CAAC,EAAE,MAAM,CAAC;IACjB,OAAO,CAAC,EAAE,MAAM,EAAE,CAAC;IACnB,iBAAiB,CAAC,EAAE,MAAM,CAAC;IAC3B,MAAM,EAAE,OAAO,CAAC;CACjB,CAAC;AAEF;;;;;;;;;;;KAWK;AACL,uBAAe,UAAW,SAAQ,YAAY;IAE5C,SAAS,CAAC,OAAO,EAAE,MAAM,CAAC;IAEnB,SAAS,EAAE,gBAAgB,GAAG,sBAAsB,GAAG,IAAI,CAAC;IAEnE,SAAS,CAAC,aAAa,EAAE,MAAM,CAAC;IAEhC,SAAS,CAAC,KAAK,EAAE,eAAe,CAAC;IAEjC,SAAS,CAAC,MAAM,EAAE,OAAO,CAAC;gBAKd,OAAO,EAAE,gBAAgB;IAuBrC;;;SAGK;IACL,kBAAkB,CAAC,KAAK,EAAE,OAAO;IAQjC;;;;SAIK;IACL,mBAAmB,CAAC,MAAM,KAAA;IAI1B,mBAAmB,CAAC,MAAM,KAAA;IAI1B;;;;OAIG;IACH,QAAQ,CAAC,KAAK,KAAA;IAKd;;SAEK;IACL,QAAQ,CAAC,KAAK,IAAI,IAAI;IAEtB;;SAEK;IACL,IAAI;IAWJ;;;SAGK;IACL,aAAa;IAMb;;;SAGK;IACL,KAAK;IASL;;OAEG;IACH,gBAAgB,IAAI,MAAM;IAI1B;;OAEG;IACH,iBAAiB,IAAI,MAAM;IAK3B,oBAAoB,CAAC,OAAO,CAAC,EAAE,OAAO;IAEtC,qBAAqB;IAOrB,aAAa,CAAC,GAAG,EAAE,MAAM;CAK1B;AAED,eAAe,UAAU,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/connection.js b/node_modules/@hathor/wallet-lib/oldLib/connection.js
new file mode 100644
index 0000000..5eccb3c
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/connection.js
@@ -0,0 +1,171 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = exports.DEFAULT_PARAMS = void 0;
+var _events = require("events");
+var _network = _interopRequireDefault(require("./network"));
+var _config = _interopRequireDefault(require("./config"));
+var _types = require("./wallet/types");
+var _types2 = require("./types");
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
+function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
+function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+const DEFAULT_PARAMS = exports.DEFAULT_PARAMS = {
+  network: 'mainnet',
+  servers: [],
+  connectionTimeout: 5000,
+  logger: (0, _types2.getDefaultLogger)()
+};
+/**
+ * This is a Connection that may be shared by one or more wallets.
+ *
+ * It has the following states:
+ * - CLOSED: When it is disconnected from the server.
+ * - CONNECTING: When it is connecting to the server.
+ * - CONNECTED: When it is connected.
+ *
+ * You can subscribe for the following events:
+ * - state: Fired when the state of the Wallet changes.
+ * - wallet-update: Fired when a new wallet message arrive from the websocket.
+ * */
+class Connection extends _events.EventEmitter {
+  /*
+   * servers {Array} List of servers for the wallet to connect to, e.g. http://localhost:8080/v1a/
+   */
+  constructor(options) {
+    super();
+    // network: 'testnet' or 'mainnet'
+    _defineProperty(this, "network", void 0);
+    _defineProperty(this, "websocket", void 0);
+    _defineProperty(this, "currentServer", void 0);
+    _defineProperty(this, "state", void 0);
+    _defineProperty(this, "logger", void 0);
+    const {
+      network,
+      servers
+    } = {
+      ...DEFAULT_PARAMS,
+      ...options
+    };
+    if (!network) {
+      throw Error('You must explicitly provide the network.');
+    }
+    _network.default.setNetwork(network);
+    this.onConnectionChange = this.onConnectionChange.bind(this);
+    this.websocket = null;
+    this.network = network;
+    this.state = _types.ConnectionState.CLOSED;
+    this.currentServer = servers[0] || _config.default.getServerUrl();
+    this.logger = options.logger || (0, _types2.getDefaultLogger)();
+  }
+
+  /**
+   * Called when the connection to the websocket changes.
+   * It is also called if the network is down.
+   * */
+  onConnectionChange(value) {
+    if (value) {
+      this.setState(_types.ConnectionState.CONNECTED);
+    } else {
+      this.setState(_types.ConnectionState.CONNECTING);
+    }
+  }
+
+  /**
+   * Called when a new wallet message arrives from websocket.
+   *
+   * @param {Object} wsData Websocket message data
+   * */
+  handleWalletMessage(wsData) {
+    this.emit('wallet-update', wsData);
+  }
+  handleStreamMessage(wsData) {
+    this.emit('stream', wsData);
+  }
+
+  /**
+   * Update class state
+   *
+   * @param {Number} state New state
+   */
+  setState(state) {
+    this.state = state;
+    this.emit('state', state);
+  }
+
+  /**
+   * Connect to the server and start emitting events.
+   * */
+
+  /**
+   * Close the connections and stop emitting events.
+   * */
+  stop() {
+    // TODO Double check that we are properly cleaning things up.
+    // See: https://github.com/HathorNetwork/hathor-wallet-headless/pull/1#discussion_r369859701
+    this.removeAllListeners();
+    if (this.websocket) {
+      this.websocket.close();
+    }
+    this.setState(_types.ConnectionState.CLOSED);
+  }
+
+  /**
+   * Call websocket endConnection
+   * Needed for compatibility with old src/wallet code
+   * */
+  endConnection() {
+    if (this.websocket) {
+      this.websocket.endConnection();
+    }
+  }
+
+  /**
+   * Call websocket setup
+   * Needed for compatibility with old src/wallet code
+   * */
+  setup() {
+    // This should never happen as this.websocket is initialized on the constructor
+    if (!this.websocket) {
+      throw new Error('Websocket is not initialized.');
+    }
+    this.websocket.setup();
+  }
+
+  /**
+   * Gets current server
+   */
+  getCurrentServer() {
+    return this.currentServer;
+  }
+
+  /**
+   * Gets current network
+   */
+  getCurrentNetwork() {
+    return this.network;
+  }
+
+  // eslint-disable-next-line class-methods-use-this -- This method is a no-op
+  startControlHandlers(options) {}
+  removeMetricsHandlers() {
+    if (this.websocket) {
+      this.websocket.removeAllListeners('dashboard');
+      this.websocket.removeAllListeners('subscribe_address');
+    }
+  }
+  sendMessageWS(msg) {
+    if (this.websocket) {
+      this.websocket.sendMessage(msg);
+    }
+  }
+}
+var _default = exports.default = Connection;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/constants.d.ts b/node_modules/@hathor/wallet-lib/oldLib/constants.d.ts
new file mode 100644
index 0000000..95b746f
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/constants.d.ts
@@ -0,0 +1,244 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+import { AddressScanPolicy, OutputValueType } from './types';
+/**
+ * Constants defined for the Hathor Wallet
+ * @module Constants
+ */
+/**
+ * Quantity of decimal places of tokens amount
+ */
+export declare const DECIMAL_PLACES: number;
+/**
+ * How many addresses we can have without being used
+ */
+export declare const GAP_LIMIT: number;
+/**
+ * The maximum number of addresses to add in the address_history GET request
+ */
+export declare const MAX_ADDRESSES_GET: number;
+/**
+ * Minimum expected API version
+ */
+export declare const MIN_API_VERSION: string;
+/**
+ * If we should forbid to generate a quantity of unused addresses more than the GAP_LIMIT
+ */
+export declare const LIMIT_ADDRESS_GENERATION: boolean;
+/**
+ * Hathor address BIP44 code
+ * (listed here: https://github.com/satoshilabs/slips/blob/master/slip-0044.md)
+ */
+export declare const HATHOR_BIP44_CODE = 280;
+/**
+ * Auth derivation path used for auth on the Wallet Service facade
+ */
+export declare const WALLET_SERVICE_AUTH_DERIVATION_PATH = "m/280'/280'";
+/**
+ * Default signalBits value
+ */
+export declare const DEFAULT_SIGNAL_BITS = 0;
+/**
+ * Block version field
+ */
+export declare const BLOCK_VERSION = 0;
+/**
+ * Transaction version field
+ */
+export declare const DEFAULT_TX_VERSION = 1;
+/**
+ * Create token transaction version field
+ */
+export declare const CREATE_TOKEN_TX_VERSION = 2;
+/**
+ * Merged mined block version field
+ */
+export declare const MERGED_MINED_BLOCK_VERSION = 3;
+/**
+ * On chain blueprints transaction version field
+ */
+export declare const ON_CHAIN_BLUEPRINTS_VERSION = 6;
+/**
+ * Proof-of-Authority block version field
+ */
+export declare const POA_BLOCK_VERSION = 5;
+/**
+ * String with the name of the initialize method of all blueprints
+ */
+export declare const NANO_CONTRACTS_INITIALIZE_METHOD = "initialize";
+/**
+ * On chain blueprints information version
+ * If we decide to change the serialization of the object information
+ * data, then we can change this version, so we can
+ * correctly deserialize all the on chain blueprint transactions
+ */
+export declare const ON_CHAIN_BLUEPRINTS_INFO_VERSION = 1;
+/**
+ * Create token information version
+ * so far we expect name and symbol
+ */
+export declare const TOKEN_INFO_VERSION = 1;
+/**
+ * Max value (inclusive) before having to use 8 bytes: 2147483648 ~= 2.14748e+09
+ */
+export declare const MAX_OUTPUT_VALUE_32: OutputValueType;
+/**
+ * Max accepted value for an output
+ */
+export declare const MAX_OUTPUT_VALUE: OutputValueType;
+/**
+ * Entropy for the new HD wallet words
+ */
+export declare const HD_WALLET_ENTROPY: number;
+/**
+ * Mask to get token index from token data
+ */
+export declare const TOKEN_INDEX_MASK: number;
+/**
+ * Mask to check if it's authority output (first bit indicates it)
+ * For further information: https://gitlab.com/HathorNetwork/rfcs/blob/master/text/0004-tokens.md
+ */
+export declare const TOKEN_AUTHORITY_MASK: number;
+/**
+ * Mask to check if it's mint UTXO (last bit indicates it)
+ * For further information: https://gitlab.com/HathorNetwork/rfcs/blob/master/text/0004-tokens.md
+ */
+export declare const TOKEN_MINT_MASK: OutputValueType;
+/**
+ * Mask to check if it's melt UTXO (second to last bit indicates it)
+ * For further information: https://gitlab.com/HathorNetwork/rfcs/blob/master/text/0004-tokens.md
+ */
+export declare const TOKEN_MELT_MASK: OutputValueType;
+/**
+ * Token data for an authority output of the first token in a transaction.
+ * As most transactions with authority outputs have only one token, it may be directly used, as a shortcut.
+ */
+export declare const AUTHORITY_TOKEN_DATA: number;
+/**
+ * Native token uid
+ */
+export declare const NATIVE_TOKEN_UID: string;
+/**
+ * Default HTR token config
+ */
+export declare const DEFAULT_NATIVE_TOKEN_CONFIG: {
+    name: string;
+    symbol: string;
+};
+/**
+ * Hathor token default index
+ */
+export declare const HATHOR_TOKEN_INDEX: number;
+/**
+ * Default timeout for each request in milliseconds
+ */
+export declare const TIMEOUT: number;
+/**
+ * Default timeout for send tokens request in milliseconds
+ */
+export declare const SEND_TOKENS_TIMEOUT: number;
+/**
+ * Number of iterations to execute when hashing the password
+ *
+ * Even though NIST recommeds at least 10,000 iterations (https://pages.nist.gov/800-63-3/sp800-63b.html#sec5),
+ * some tests show that it takes ~3s in iPhone 7 and ~1,5s in Galaxy S8.
+ * That's why we have decided to keep the default as 1,000 for now.
+ */
+export declare const HASH_ITERATIONS: number;
+/**
+ * Size of the key to hash the password (in bits).
+ *
+ * CryptoJS expects the size in words so this will be converted in code.
+ * The conversion is done by dividing by 32, so HASH_KEY_SIZE needs to be a multiple of 32.
+ *
+ * Actual keySize will be 256/32 = 8 words.
+ */
+export declare const HASH_KEY_SIZE: number;
+/**
+ * Return code of the send_tokens response when there is a stratum timeout
+ */
+export declare const STRATUM_TIMEOUT_RETURN_CODE = "stratum_timeout";
+/**
+ * Minimum job status poll to update job data when mining a tx
+ */
+export declare const MIN_POLLING_INTERVAL: number;
+/**
+ * Constants to calculate weight
+ */
+export declare const TX_WEIGHT_CONSTANTS: {
+    txMinWeight: number;
+    txWeightCoefficient: number;
+    txMinWeightK: number;
+};
+/**
+ * Maximum number of inputs
+ */
+export declare const MAX_INPUTS: number;
+/**
+ * Maximum number of outputs
+ */
+export declare const MAX_OUTPUTS: number;
+/**
+ * Percentage of Hathor to deposit when creating a token
+ */
+export declare const TOKEN_DEPOSIT_PERCENTAGE: number;
+/**
+ * Timeout in milliseconds to call the method to set all selected outputs of a tx as 'selected': false
+ */
+export declare const SELECT_OUTPUTS_TIMEOUT: number;
+/**
+ * Size in bytes of a transaction hash (32 bytes)
+ */
+export declare const TX_HASH_SIZE_BYTES: number;
+/**
+ * Maximum number of retries allowed when an error different
+ * from client timeout happens when loading wallet history
+ */
+export declare const LOAD_WALLET_MAX_RETRY: number;
+/**
+ * Time in milliseconds between each load wallet retry
+ */
+export declare const LOAD_WALLET_RETRY_SLEEP: number;
+/**
+ * Limit of retries when downloading token metadata
+ */
+export declare const METADATA_RETRY_LIMIT: number;
+/**
+ * Interval between metadata download retries in milliseconds
+ */
+export declare const DOWNLOAD_METADATA_RETRY_INTERVAL: number;
+/**
+ * Maximum characters of created token name
+ */
+export declare const MAX_TOKEN_NAME_SIZE: number;
+/**
+ * Maximum characters of created token symbol
+ */
+export declare const MAX_TOKEN_SYMBOL_SIZE: number;
+/**
+ * Account path for P2SH MultiSig
+ * account is the last hardened level
+ */
+export declare const P2SH_ACCT_PATH = "m/45'/280'/0'";
+/**
+ * Account path for P2PKH
+ * account is the last hardened level
+ */
+export declare const P2PKH_ACCT_PATH = "m/44'/280'/0'";
+/**
+ * String to be prefixed before signed messages using bitcore-message
+ */
+export declare const HATHOR_MAGIC_BYTES = "Hathor Signed Message:\n";
+/**
+ * Default address scanning policy
+ */
+export declare const DEFAULT_ADDRESS_SCANNING_POLICY: AddressScanPolicy;
+/**
+ * Max argument length in bytes (64Kib)
+ */
+export declare const NC_ARGS_MAX_BYTES_LENGTH: bigint;
+//# sourceMappingURL=constants.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/constants.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/constants.d.ts.map
new file mode 100644
index 0000000..0e1f897
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/constants.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"constants.d.ts","sourceRoot":"","sources":["../src/constants.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;AAEH,OAAO,EAAE,iBAAiB,EAAE,eAAe,EAAmB,MAAM,SAAS,CAAC;AAE9E;;;GAGG;AAEH;;GAEG;AACH,eAAO,MAAM,cAAc,EAAE,MAAU,CAAC;AAExC;;GAEG;AACH,eAAO,MAAM,SAAS,EAAE,MAAW,CAAC;AAEpC;;GAEG;AACH,eAAO,MAAM,iBAAiB,EAAE,MAAW,CAAC;AAE5C;;GAEG;AACH,eAAO,MAAM,eAAe,EAAE,MAAiB,CAAC;AAEhD;;GAEG;AACH,eAAO,MAAM,wBAAwB,EAAE,OAAc,CAAC;AAEtD;;;GAGG;AACH,eAAO,MAAM,iBAAiB,MAAM,CAAC;AAErC;;GAEG;AACH,eAAO,MAAM,mCAAmC,gBAAkD,CAAC;AAEnG;;GAEG;AACH,eAAO,MAAM,mBAAmB,IAAI,CAAC;AAErC;;GAEG;AACH,eAAO,MAAM,aAAa,IAAI,CAAC;AAE/B;;GAEG;AACH,eAAO,MAAM,kBAAkB,IAAI,CAAC;AAEpC;;GAEG;AACH,eAAO,MAAM,uBAAuB,IAAI,CAAC;AAEzC;;GAEG;AACH,eAAO,MAAM,0BAA0B,IAAI,CAAC;AAE5C;;GAEG;AACH,eAAO,MAAM,2BAA2B,IAAI,CAAC;AAE7C;;GAEG;AACH,eAAO,MAAM,iBAAiB,IAAI,CAAC;AAEnC;;GAEG;AACH,eAAO,MAAM,gCAAgC,eAAe,CAAC;AAE7D;;;;;GAKG;AACH,eAAO,MAAM,gCAAgC,IAAI,CAAC;AAElD;;;GAGG;AACH,eAAO,MAAM,kBAAkB,IAAI,CAAC;AAEpC;;GAEG;AACH,eAAO,MAAM,mBAAmB,EAAE,eAAgC,CAAC;AAEnE;;GAEG;AACH,eAAO,MAAM,gBAAgB,EAAE,eAA2B,CAAC;AAE3D;;GAEG;AACH,eAAO,MAAM,iBAAiB,EAAE,MAAY,CAAC;AAE7C;;GAEG;AACH,eAAO,MAAM,gBAAgB,EAAE,MAAmB,CAAC;AAEnD;;;GAGG;AACH,eAAO,MAAM,oBAAoB,EAAE,MAAmB,CAAC;AAEvD;;;GAGG;AACH,eAAO,MAAM,eAAe,EAAE,eAA6B,CAAC;AAE5D;;;GAGG;AACH,eAAO,MAAM,eAAe,EAAE,eAA6B,CAAC;AAE5D;;;GAGG;AACH,eAAO,MAAM,oBAAoB,QAA2B,CAAC;AAE7D;;GAEG;AACH,eAAO,MAAM,gBAAgB,EAAE,MAAa,CAAC;AAE7C;;GAEG;AACH,eAAO,MAAM,2BAA2B;;;CAGvC,CAAC;AAEF;;GAEG;AACH,eAAO,MAAM,kBAAkB,EAAE,MAAU,CAAC;AAE5C;;GAEG;AACH,eAAO,MAAM,OAAO,EAAE,MAAc,CAAC;AAErC;;GAEG;AACH,eAAO,MAAM,mBAAmB,EAAE,MAAe,CAAC;AAElD;;;;;;GAMG;AACH,eAAO,MAAM,eAAe,EAAE,MAAa,CAAC;AAE5C;;;;;;;GAOG;AACH,eAAO,MAAM,aAAa,EAAE,MAAY,CAAC;AAEzC;;GAEG;AACH,eAAO,MAAM,2BAA2B,oBAAoB,CAAC;AAE7D;;GAEG;AACH,eAAO,MAAM,oBAAoB,EAAE,MAAY,CAAC;AAEhD;;GAEG;AACH,eAAO,MAAM,mBAAmB;;;;CAI/B,CAAC;AAEF;;GAEG;AACH,eAAO,MAAM,UAAU,EAAE,MAAY,CAAC;AAEtC;;GAEG;AACH,eAAO,MAAM,WAAW,EAAE,MAAY,CAAC;AAEvC;;GAEG;AACH,eAAO,MAAM,wBAAwB,EAAE,MAAa,CAAC;AAErD;;GAEG;AACH,eAAO,MAAM,sBAAsB,EAAE,MAAkB,CAAC;AAExD;;GAEG;AACH,eAAO,MAAM,kBAAkB,EAAE,MAAW,CAAC;AAE7C;;;GAGG;AACH,eAAO,MAAM,qBAAqB,EAAE,MAAU,CAAC;AAE/C;;GAEG;AACH,eAAO,MAAM,uBAAuB,EAAE,MAAa,CAAC;AAEpD;;GAEG;AACH,eAAO,MAAM,oBAAoB,EAAE,MAAU,CAAC;AAE9C;;GAEG;AACH,eAAO,MAAM,gCAAgC,EAAE,MAAa,CAAC;AAE7D;;GAEG;AACH,eAAO,MAAM,mBAAmB,EAAE,MAAW,CAAC;AAE9C;;GAEG;AACH,eAAO,MAAM,qBAAqB,EAAE,MAAU,CAAC;AAE/C;;;GAGG;AACH,eAAO,MAAM,cAAc,kBAAmC,CAAC;AAE/D;;;GAGG;AACH,eAAO,MAAM,eAAe,kBAAmC,CAAC;AAEhE;;GAEG;AACH,eAAO,MAAM,kBAAkB,6BAA6B,CAAC;AAE7D;;GAEG;AACH,eAAO,MAAM,+BAA+B,EAAE,iBAA6C,CAAC;AAE5F;;GAEG;AACH,eAAO,MAAM,wBAAwB,QAAY,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/constants.js b/node_modules/@hathor/wallet-lib/oldLib/constants.js
new file mode 100644
index 0000000..8a4219d
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/constants.js
@@ -0,0 +1,301 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.WALLET_SERVICE_AUTH_DERIVATION_PATH = exports.TX_WEIGHT_CONSTANTS = exports.TX_HASH_SIZE_BYTES = exports.TOKEN_MINT_MASK = exports.TOKEN_MELT_MASK = exports.TOKEN_INFO_VERSION = exports.TOKEN_INDEX_MASK = exports.TOKEN_DEPOSIT_PERCENTAGE = exports.TOKEN_AUTHORITY_MASK = exports.TIMEOUT = exports.STRATUM_TIMEOUT_RETURN_CODE = exports.SEND_TOKENS_TIMEOUT = exports.SELECT_OUTPUTS_TIMEOUT = exports.POA_BLOCK_VERSION = exports.P2SH_ACCT_PATH = exports.P2PKH_ACCT_PATH = exports.ON_CHAIN_BLUEPRINTS_VERSION = exports.ON_CHAIN_BLUEPRINTS_INFO_VERSION = exports.NC_ARGS_MAX_BYTES_LENGTH = exports.NATIVE_TOKEN_UID = exports.NANO_CONTRACTS_INITIALIZE_METHOD = exports.MIN_POLLING_INTERVAL = exports.MIN_API_VERSION = exports.METADATA_RETRY_LIMIT = exports.MERGED_MINED_BLOCK_VERSION = exports.MAX_TOKEN_SYMBOL_SIZE = exports.MAX_TOKEN_NAME_SIZE = exports.MAX_OUTPUT_VALUE_32 = exports.MAX_OUTPUT_VALUE = exports.MAX_OUTPUTS = exports.MAX_INPUTS = exports.MAX_ADDRESSES_GET = exports.LOAD_WALLET_RETRY_SLEEP = exports.LOAD_WALLET_MAX_RETRY = exports.LIMIT_ADDRESS_GENERATION = exports.HD_WALLET_ENTROPY = exports.HATHOR_TOKEN_INDEX = exports.HATHOR_MAGIC_BYTES = exports.HATHOR_BIP44_CODE = exports.HASH_KEY_SIZE = exports.HASH_ITERATIONS = exports.GAP_LIMIT = exports.DOWNLOAD_METADATA_RETRY_INTERVAL = exports.DEFAULT_TX_VERSION = exports.DEFAULT_SIGNAL_BITS = exports.DEFAULT_NATIVE_TOKEN_CONFIG = exports.DEFAULT_ADDRESS_SCANNING_POLICY = exports.DECIMAL_PLACES = exports.CREATE_TOKEN_TX_VERSION = exports.BLOCK_VERSION = exports.AUTHORITY_TOKEN_DATA = void 0;
+var _types = require("./types");
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+/**
+ * Constants defined for the Hathor Wallet
+ * @module Constants
+ */
+
+/**
+ * Quantity of decimal places of tokens amount
+ */
+const DECIMAL_PLACES = exports.DECIMAL_PLACES = 2;
+
+/**
+ * How many addresses we can have without being used
+ */
+const GAP_LIMIT = exports.GAP_LIMIT = 20;
+
+/**
+ * The maximum number of addresses to add in the address_history GET request
+ */
+const MAX_ADDRESSES_GET = exports.MAX_ADDRESSES_GET = 20;
+
+/**
+ * Minimum expected API version
+ */
+const MIN_API_VERSION = exports.MIN_API_VERSION = '0.37.2';
+
+/**
+ * If we should forbid to generate a quantity of unused addresses more than the GAP_LIMIT
+ */
+const LIMIT_ADDRESS_GENERATION = exports.LIMIT_ADDRESS_GENERATION = true;
+
+/**
+ * Hathor address BIP44 code
+ * (listed here: https://github.com/satoshilabs/slips/blob/master/slip-0044.md)
+ */
+const HATHOR_BIP44_CODE = exports.HATHOR_BIP44_CODE = 280;
+
+/**
+ * Auth derivation path used for auth on the Wallet Service facade
+ */
+const WALLET_SERVICE_AUTH_DERIVATION_PATH = exports.WALLET_SERVICE_AUTH_DERIVATION_PATH = `m/${HATHOR_BIP44_CODE}'/${HATHOR_BIP44_CODE}'`;
+
+/**
+ * Default signalBits value
+ */
+const DEFAULT_SIGNAL_BITS = exports.DEFAULT_SIGNAL_BITS = 0;
+
+/**
+ * Block version field
+ */
+const BLOCK_VERSION = exports.BLOCK_VERSION = 0;
+
+/**
+ * Transaction version field
+ */
+const DEFAULT_TX_VERSION = exports.DEFAULT_TX_VERSION = 1;
+
+/**
+ * Create token transaction version field
+ */
+const CREATE_TOKEN_TX_VERSION = exports.CREATE_TOKEN_TX_VERSION = 2;
+
+/**
+ * Merged mined block version field
+ */
+const MERGED_MINED_BLOCK_VERSION = exports.MERGED_MINED_BLOCK_VERSION = 3;
+
+/**
+ * On chain blueprints transaction version field
+ */
+const ON_CHAIN_BLUEPRINTS_VERSION = exports.ON_CHAIN_BLUEPRINTS_VERSION = 6;
+
+/**
+ * Proof-of-Authority block version field
+ */
+const POA_BLOCK_VERSION = exports.POA_BLOCK_VERSION = 5;
+
+/**
+ * String with the name of the initialize method of all blueprints
+ */
+const NANO_CONTRACTS_INITIALIZE_METHOD = exports.NANO_CONTRACTS_INITIALIZE_METHOD = 'initialize';
+
+/**
+ * On chain blueprints information version
+ * If we decide to change the serialization of the object information
+ * data, then we can change this version, so we can
+ * correctly deserialize all the on chain blueprint transactions
+ */
+const ON_CHAIN_BLUEPRINTS_INFO_VERSION = exports.ON_CHAIN_BLUEPRINTS_INFO_VERSION = 1;
+
+/**
+ * Create token information version
+ * so far we expect name and symbol
+ */
+const TOKEN_INFO_VERSION = exports.TOKEN_INFO_VERSION = 1;
+
+/**
+ * Max value (inclusive) before having to use 8 bytes: 2147483648 ~= 2.14748e+09
+ */
+const MAX_OUTPUT_VALUE_32 = exports.MAX_OUTPUT_VALUE_32 = 2n ** 31n - 1n;
+
+/**
+ * Max accepted value for an output
+ */
+const MAX_OUTPUT_VALUE = exports.MAX_OUTPUT_VALUE = 2n ** 63n;
+
+/**
+ * Entropy for the new HD wallet words
+ */
+const HD_WALLET_ENTROPY = exports.HD_WALLET_ENTROPY = 256;
+
+/**
+ * Mask to get token index from token data
+ */
+const TOKEN_INDEX_MASK = exports.TOKEN_INDEX_MASK = 0b01111111;
+
+/**
+ * Mask to check if it's authority output (first bit indicates it)
+ * For further information: https://gitlab.com/HathorNetwork/rfcs/blob/master/text/0004-tokens.md
+ */
+const TOKEN_AUTHORITY_MASK = exports.TOKEN_AUTHORITY_MASK = 0b10000000;
+
+/**
+ * Mask to check if it's mint UTXO (last bit indicates it)
+ * For further information: https://gitlab.com/HathorNetwork/rfcs/blob/master/text/0004-tokens.md
+ */
+const TOKEN_MINT_MASK = exports.TOKEN_MINT_MASK = 0b00000001n;
+
+/**
+ * Mask to check if it's melt UTXO (second to last bit indicates it)
+ * For further information: https://gitlab.com/HathorNetwork/rfcs/blob/master/text/0004-tokens.md
+ */
+const TOKEN_MELT_MASK = exports.TOKEN_MELT_MASK = 0b00000010n;
+
+/**
+ * Token data for an authority output of the first token in a transaction.
+ * As most transactions with authority outputs have only one token, it may be directly used, as a shortcut.
+ */
+const AUTHORITY_TOKEN_DATA = exports.AUTHORITY_TOKEN_DATA = TOKEN_AUTHORITY_MASK | 1;
+
+/**
+ * Native token uid
+ */
+const NATIVE_TOKEN_UID = exports.NATIVE_TOKEN_UID = '00';
+
+/**
+ * Default HTR token config
+ */
+const DEFAULT_NATIVE_TOKEN_CONFIG = exports.DEFAULT_NATIVE_TOKEN_CONFIG = {
+  name: 'Hathor',
+  symbol: 'HTR'
+};
+
+/**
+ * Hathor token default index
+ */
+const HATHOR_TOKEN_INDEX = exports.HATHOR_TOKEN_INDEX = 0;
+
+/**
+ * Default timeout for each request in milliseconds
+ */
+const TIMEOUT = exports.TIMEOUT = 10000;
+
+/**
+ * Default timeout for send tokens request in milliseconds
+ */
+const SEND_TOKENS_TIMEOUT = exports.SEND_TOKENS_TIMEOUT = 300000;
+
+/**
+ * Number of iterations to execute when hashing the password
+ *
+ * Even though NIST recommeds at least 10,000 iterations (https://pages.nist.gov/800-63-3/sp800-63b.html#sec5),
+ * some tests show that it takes ~3s in iPhone 7 and ~1,5s in Galaxy S8.
+ * That's why we have decided to keep the default as 1,000 for now.
+ */
+const HASH_ITERATIONS = exports.HASH_ITERATIONS = 1000;
+
+/**
+ * Size of the key to hash the password (in bits).
+ *
+ * CryptoJS expects the size in words so this will be converted in code.
+ * The conversion is done by dividing by 32, so HASH_KEY_SIZE needs to be a multiple of 32.
+ *
+ * Actual keySize will be 256/32 = 8 words.
+ */
+const HASH_KEY_SIZE = exports.HASH_KEY_SIZE = 256;
+
+/**
+ * Return code of the send_tokens response when there is a stratum timeout
+ */
+const STRATUM_TIMEOUT_RETURN_CODE = exports.STRATUM_TIMEOUT_RETURN_CODE = 'stratum_timeout';
+
+/**
+ * Minimum job status poll to update job data when mining a tx
+ */
+const MIN_POLLING_INTERVAL = exports.MIN_POLLING_INTERVAL = 0.5;
+
+/**
+ * Constants to calculate weight
+ */
+const TX_WEIGHT_CONSTANTS = exports.TX_WEIGHT_CONSTANTS = {
+  txMinWeight: 14,
+  txWeightCoefficient: 1.6,
+  txMinWeightK: 100
+};
+
+/**
+ * Maximum number of inputs
+ */
+const MAX_INPUTS = exports.MAX_INPUTS = 255;
+
+/**
+ * Maximum number of outputs
+ */
+const MAX_OUTPUTS = exports.MAX_OUTPUTS = 255;
+
+/**
+ * Percentage of Hathor to deposit when creating a token
+ */
+const TOKEN_DEPOSIT_PERCENTAGE = exports.TOKEN_DEPOSIT_PERCENTAGE = 0.01;
+
+/**
+ * Timeout in milliseconds to call the method to set all selected outputs of a tx as 'selected': false
+ */
+const SELECT_OUTPUTS_TIMEOUT = exports.SELECT_OUTPUTS_TIMEOUT = 1000 * 60;
+
+/**
+ * Size in bytes of a transaction hash (32 bytes)
+ */
+const TX_HASH_SIZE_BYTES = exports.TX_HASH_SIZE_BYTES = 32;
+
+/**
+ * Maximum number of retries allowed when an error different
+ * from client timeout happens when loading wallet history
+ */
+const LOAD_WALLET_MAX_RETRY = exports.LOAD_WALLET_MAX_RETRY = 5;
+
+/**
+ * Time in milliseconds between each load wallet retry
+ */
+const LOAD_WALLET_RETRY_SLEEP = exports.LOAD_WALLET_RETRY_SLEEP = 5000;
+
+/**
+ * Limit of retries when downloading token metadata
+ */
+const METADATA_RETRY_LIMIT = exports.METADATA_RETRY_LIMIT = 3;
+
+/**
+ * Interval between metadata download retries in milliseconds
+ */
+const DOWNLOAD_METADATA_RETRY_INTERVAL = exports.DOWNLOAD_METADATA_RETRY_INTERVAL = 5000;
+
+/**
+ * Maximum characters of created token name
+ */
+const MAX_TOKEN_NAME_SIZE = exports.MAX_TOKEN_NAME_SIZE = 30;
+
+/**
+ * Maximum characters of created token symbol
+ */
+const MAX_TOKEN_SYMBOL_SIZE = exports.MAX_TOKEN_SYMBOL_SIZE = 5;
+
+/**
+ * Account path for P2SH MultiSig
+ * account is the last hardened level
+ */
+const P2SH_ACCT_PATH = exports.P2SH_ACCT_PATH = `m/45'/${HATHOR_BIP44_CODE}'/0'`;
+
+/**
+ * Account path for P2PKH
+ * account is the last hardened level
+ */
+const P2PKH_ACCT_PATH = exports.P2PKH_ACCT_PATH = `m/44'/${HATHOR_BIP44_CODE}'/0'`;
+
+/**
+ * String to be prefixed before signed messages using bitcore-message
+ */
+const HATHOR_MAGIC_BYTES = exports.HATHOR_MAGIC_BYTES = 'Hathor Signed Message:\n';
+
+/**
+ * Default address scanning policy
+ */
+const DEFAULT_ADDRESS_SCANNING_POLICY = exports.DEFAULT_ADDRESS_SCANNING_POLICY = _types.SCANNING_POLICY.GAP_LIMIT;
+
+/**
+ * Max argument length in bytes (64Kib)
+ */
+const NC_ARGS_MAX_BYTES_LENGTH = exports.NC_ARGS_MAX_BYTES_LENGTH = 2n ** 16n;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/errorMessages.d.ts b/node_modules/@hathor/wallet-lib/oldLib/errorMessages.d.ts
new file mode 100644
index 0000000..80a6ce3
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/errorMessages.d.ts
@@ -0,0 +1,27 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+export declare enum ErrorMessages {
+    UNEXPECTED_PUSH_TX_ERROR = "unexpected-push-tx-error",
+    TRANSACTION_IS_NULL = "transaction-is-null",
+    INVALID_INPUT = "invalid-input",
+    NO_UTXOS_AVAILABLE = "no-utxos-available",
+    UNSUPPORTED_TX_TYPE = "unsupported-tx-type",
+    WALLET_STATUS_ERROR = "wallet-status-error",
+    DEFAULT_WALLET_ERROR = "wallet-error",
+    DECRYPTION_ERROR = "decrypt-error",
+    INVALID_PASSWD = "invalid-passwd",
+    UNSUPPORTED_HASHER = "unsupported-hasher",
+    UNINITIALIZED_WALLET = "uninitialized-wallet",
+    REQUEST_ERROR = "request-error",
+    NANO_REQUEST_ERROR = "nano-request-error",
+    NANO_REQUEST_ERROR_404 = "nano-request-error-404",
+    NANO_TRANSACTION_CREATE_ERROR = "nano-transaction-create-error",
+    NANO_TRANSACTION_PARSE_ERROR = "nano-transaction-parse-error",
+    NANO_ORACLE_PARSE_ERROR = "nano-oracle-parse-error",
+    PIN_REQUIRED = "pin-required"
+}
+//# sourceMappingURL=errorMessages.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/errorMessages.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/errorMessages.d.ts.map
new file mode 100644
index 0000000..0e5256c
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/errorMessages.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"errorMessages.d.ts","sourceRoot":"","sources":["../src/errorMessages.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;AAEH,oBAAY,aAAa;IACvB,wBAAwB,6BAA6B;IACrD,mBAAmB,wBAAwB;IAC3C,aAAa,kBAAkB;IAC/B,kBAAkB,uBAAuB;IACzC,mBAAmB,wBAAwB;IAC3C,mBAAmB,wBAAwB;IAE3C,oBAAoB,iBAAiB;IAErC,gBAAgB,kBAAkB;IAElC,cAAc,mBAAmB;IAGjC,kBAAkB,uBAAuB;IAEzC,oBAAoB,yBAAyB;IAE7C,aAAa,kBAAkB;IAE/B,kBAAkB,uBAAuB;IAEzC,sBAAsB,2BAA2B;IAEjD,6BAA6B,kCAAkC;IAE/D,4BAA4B,iCAAiC;IAE7D,uBAAuB,4BAA4B;IAEnD,YAAY,iBAAiB;CAC9B"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/errorMessages.js b/node_modules/@hathor/wallet-lib/oldLib/errorMessages.js
new file mode 100644
index 0000000..0fe9f79
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/errorMessages.js
@@ -0,0 +1,33 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.ErrorMessages = void 0;
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+let ErrorMessages = exports.ErrorMessages = /*#__PURE__*/function (ErrorMessages) {
+  ErrorMessages["UNEXPECTED_PUSH_TX_ERROR"] = "unexpected-push-tx-error";
+  ErrorMessages["TRANSACTION_IS_NULL"] = "transaction-is-null";
+  ErrorMessages["INVALID_INPUT"] = "invalid-input";
+  ErrorMessages["NO_UTXOS_AVAILABLE"] = "no-utxos-available";
+  ErrorMessages["UNSUPPORTED_TX_TYPE"] = "unsupported-tx-type";
+  ErrorMessages["WALLET_STATUS_ERROR"] = "wallet-status-error";
+  ErrorMessages["DEFAULT_WALLET_ERROR"] = "wallet-error";
+  ErrorMessages["DECRYPTION_ERROR"] = "decrypt-error";
+  ErrorMessages["INVALID_PASSWD"] = "invalid-passwd";
+  ErrorMessages["UNSUPPORTED_HASHER"] = "unsupported-hasher";
+  ErrorMessages["UNINITIALIZED_WALLET"] = "uninitialized-wallet";
+  ErrorMessages["REQUEST_ERROR"] = "request-error";
+  ErrorMessages["NANO_REQUEST_ERROR"] = "nano-request-error";
+  ErrorMessages["NANO_REQUEST_ERROR_404"] = "nano-request-error-404";
+  ErrorMessages["NANO_TRANSACTION_CREATE_ERROR"] = "nano-transaction-create-error";
+  ErrorMessages["NANO_TRANSACTION_PARSE_ERROR"] = "nano-transaction-parse-error";
+  ErrorMessages["NANO_ORACLE_PARSE_ERROR"] = "nano-oracle-parse-error";
+  ErrorMessages["PIN_REQUIRED"] = "pin-required";
+  return ErrorMessages;
+}({});
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/errors.d.ts b/node_modules/@hathor/wallet-lib/oldLib/errors.d.ts
new file mode 100644
index 0000000..561437c
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/errors.d.ts
@@ -0,0 +1,365 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+import { AxiosResponse } from 'axios';
+/**
+ * Possible errors to be thrown in wallet
+ *
+ * @namespace Errors
+ */
+/**
+ * Error thrown when address is invalid
+ *
+ * @memberof Errors
+ * @inner
+ */
+export declare class AddressError extends Error {
+}
+/**
+ * Error thrown when output value is invalid
+ *
+ * @memberof Errors
+ * @inner
+ */
+export declare class OutputValueError extends Error {
+}
+/**
+ * Error thrown when we have insufficient funds
+ *
+ * @memberof Errors
+ * @inner
+ */
+export declare class InsufficientFundsError extends Error {
+}
+/**
+ * Error thrown when a constant that we get from the server is not set
+ *
+ * @memberof Errors
+ * @inner
+ */
+export declare class ConstantNotSet extends Error {
+}
+/**
+ * Error thrown when a create token tx has invalid info
+ *
+ * @memberof Errors
+ * @inner
+ */
+export declare class CreateTokenTxInvalid extends Error {
+}
+/**
+ * Error thrown when validating a registration of new token
+ *
+ * @memberof Errors
+ * @inner
+ */
+export declare class TokenValidationError extends Error {
+}
+/**
+ * Error thrown when validating a registration of new NFT
+ *
+ * @memberof Errors
+ * @inner
+ */
+export declare class NftValidationError extends Error {
+}
+/**
+ * Error thrown when transaction has more inputs than the maximum allowed
+ *
+ * @memberof Errors
+ * @inner
+ */
+export declare class MaximumNumberInputsError extends Error {
+}
+/**
+ * Error thrown when transaction has more outputs than the maximum allowed
+ *
+ * @memberof Errors
+ * @inner
+ */
+export declare class MaximumNumberOutputsError extends Error {
+}
+/**
+ * Error thrown when transaction has invalid outputs
+ *
+ * @memberof Errors
+ * @inner
+ */
+export declare class InvalidOutputsError extends Error {
+}
+/**
+ * Error thrown when transaction has more parents than the maximum allowed
+ *
+ * @memberof Errors
+ * @inner
+ */
+export declare class MaximumNumberParentsError extends Error {
+}
+/**
+ * Error thrown when the wallet type is invalid
+ *
+ * @memberof Errors
+ * @inner
+ */
+export declare class WalletTypeError extends Error {
+}
+/**
+ * Error thrown when we are given an invalid xpubkey
+ *
+ * @memberof Errors
+ * @inner
+ */
+export declare class XPubError extends Error {
+}
+/**
+ * Error thrown when we are given an invalid uncompressed public key
+ *
+ * @memberof Errors
+ * @inner
+ */
+export declare class UncompressedPubKeyError extends Error {
+}
+/**
+ * Error thrown when the user tries to create a wallet with an invalid sequence of words
+ *
+ * @memberof Errors
+ * @inner
+ */
+export declare class InvalidWords extends Error {
+    invalidWords: string[];
+}
+/**
+ * Error thrown when parsing bytes to an object
+ *
+ * @memberof Errors
+ * @inner
+ */
+export declare class ParseError extends Error {
+}
+/**
+ * Error thrown when parsing a script bytes
+ *
+ * @memberof Errors
+ * @inner
+ */
+export declare class ParseScriptError extends ParseError {
+}
+/**
+ * Error thrown when executing wallet operations
+ *
+ * @memberof Errors
+ * @inner
+ */
+export declare class WalletError extends Error {
+    errorCode: string;
+}
+/**
+ * Error thrown when executing wallet requests
+ *
+ * @memberof Errors
+ * @inner
+ */
+export declare class WalletRequestError extends WalletError {
+    cause: unknown;
+    constructor(message: string, errorData?: {
+        cause: unknown;
+    });
+}
+/**
+ * Error thrown when get utxo fails
+ *
+ * @memberof Errors
+ * @inner
+ */
+export declare class UtxoError extends WalletError {
+}
+/**
+ * Error thrown when sending tx
+ *
+ * @memberof Errors
+ * @inner
+ */
+export declare class SendTxError extends WalletError {
+    errorData: string | {
+        txId: string;
+        index: number;
+    };
+}
+/**
+ * Error thrown when mining tx
+ *
+ * @memberof Errors
+ * @inner
+ */
+export declare class MineTxError extends WalletError {
+}
+/**
+ * Error thrown when trying to interact with an incomplete or invalid partial transaction.
+ *
+ * @memberof Errors
+ * @inner
+ */
+export declare class InvalidPartialTxError extends WalletError {
+}
+/**
+ * Error thrown when calling a protected method on an xpub inited wallet
+ * Some methods require access to the words or private key
+ *
+ * @memberof Errors
+ * @inner
+ */
+export declare class WalletFromXPubGuard extends WalletError {
+}
+/**
+ * Error thrown when there is an error getting dag metadata using wallet service
+ *
+ * @memberof Errors
+ * @inner
+ */
+export declare class GetDagMetadataApiError extends Error {
+}
+/**
+ * Base Error class for Config not set errors
+ *
+ * @memberof Errors
+ * @inner
+ */
+export declare class ConfigNotSetError extends Error {
+}
+/**
+ * Error thrown when the WalletService URL is not set and a user tries to `get` it
+ *
+ * @memberof Errors
+ * @inner
+ */
+export declare class GetWalletServiceUrlError extends ConfigNotSetError {
+}
+/**
+ * Error thrown when the WalletService WebSocket URL is not set and a user tries to `get` it
+ *
+ * @memberof Errors
+ * @inner
+ */
+export declare class GetWalletServiceWsUrlError extends ConfigNotSetError {
+}
+/**
+ *
+ *
+ * @memberof Errors
+ * @inner
+ */
+export declare class PartialTxError extends Error {
+}
+/**
+ * Error thrown when an input data for a non-existent input is added.
+ *
+ * @memberof Errors
+ * @inner
+ */
+export declare class IndexOOBError extends PartialTxError {
+}
+/**
+ * Error thrown when an output with script type other than [p2sh, p2pkh] is used on PartialTx.
+ *
+ * @memberof Errors
+ * @inner
+ */
+export declare class UnsupportedScriptError extends PartialTxError {
+}
+/**
+ * Error thrown when a requested transaction is not found
+ *
+ * @memberof Errors
+ * @inner
+ */
+export declare class TxNotFoundError extends Error {
+}
+export declare class InvalidPasswdError extends WalletError {
+    errorCode: string;
+}
+export declare class DecryptionError extends Error {
+    errorCode: string;
+}
+export declare class UnsupportedHasherError extends Error {
+    errorCode: string;
+}
+export declare class UninitializedWalletError extends WalletError {
+    errorCode: string;
+}
+/**
+ * Error thrown during any API request
+ *
+ * @memberof Errors
+ * @inner
+ */
+export declare class RequestError extends Error {
+    errorCode: string;
+}
+/**
+ * Error thrown during nano API request
+ *
+ * @memberof Errors
+ * @inner
+ */
+export declare class NanoRequestError extends RequestError {
+    errorCode: string;
+    originError: unknown | null;
+    response: AxiosResponse | null;
+    constructor(message: string, originError?: unknown | null, response?: AxiosResponse | null);
+}
+/**
+ * Error thrown during nano API request for 404
+ *
+ * @memberof Errors
+ * @inner
+ */
+export declare class NanoRequest404Error extends NanoRequestError {
+    errorCode: string;
+}
+/**
+ * Error thrown when PIN is required in a method but it's not set
+ *
+ * @memberof Errors
+ * @inner
+ */
+export declare class PinRequiredError extends Error {
+    errorCode: string;
+}
+/**
+ * Error thrown during the creation of a nano contract transaction
+ *
+ * @memberof Errors
+ * @inner
+ */
+export declare class NanoContractTransactionError extends Error {
+    errorCode: string;
+}
+/**
+ * Error thrown when parsing a nano contract transaction
+ *
+ * @memberof Errors
+ * @inner
+ */
+export declare class NanoContractTransactionParseError extends Error {
+    errorCode: string;
+}
+/**
+ * Error thrown when parsing an oracle script
+ *
+ * @memberof Errors
+ * @inner
+ */
+export declare class OracleParseError extends Error {
+    errorCode: string;
+}
+export declare class GlobalLoadLockTaskError extends Error {
+    taskId: string;
+    innerError: Error;
+    constructor(taskId: string, innerError: Error);
+}
+export declare class NanoHeaderNotFound extends Error {
+}
+//# sourceMappingURL=errors.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/errors.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/errors.d.ts.map
new file mode 100644
index 0000000..c2bfe1e
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/errors.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"errors.d.ts","sourceRoot":"","sources":["../src/errors.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/errors.js b/node_modules/@hathor/wallet-lib/oldLib/errors.js
new file mode 100644
index 0000000..282b127
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/errors.js
@@ -0,0 +1,476 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.XPubError = exports.WalletTypeError = exports.WalletRequestError = exports.WalletFromXPubGuard = exports.WalletError = exports.UtxoError = exports.UnsupportedScriptError = exports.UnsupportedHasherError = exports.UninitializedWalletError = exports.UncompressedPubKeyError = exports.TxNotFoundError = exports.TokenValidationError = exports.SendTxError = exports.RequestError = exports.PinRequiredError = exports.PartialTxError = exports.ParseScriptError = exports.ParseError = exports.OutputValueError = exports.OracleParseError = exports.NftValidationError = exports.NanoRequestError = exports.NanoRequest404Error = exports.NanoHeaderNotFound = exports.NanoContractTransactionParseError = exports.NanoContractTransactionError = exports.MineTxError = exports.MaximumNumberParentsError = exports.MaximumNumberOutputsError = exports.MaximumNumberInputsError = exports.InvalidWords = exports.InvalidPasswdError = exports.InvalidPartialTxError = exports.InvalidOutputsError = exports.InsufficientFundsError = exports.IndexOOBError = exports.GlobalLoadLockTaskError = exports.GetWalletServiceWsUrlError = exports.GetWalletServiceUrlError = exports.GetDagMetadataApiError = exports.DecryptionError = exports.CreateTokenTxInvalid = exports.ConstantNotSet = exports.ConfigNotSetError = exports.AddressError = void 0;
+var _errorMessages = require("./errorMessages");
+function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
+function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
+function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */ // eslint-disable-next-line max-classes-per-file -- This file is supposed to export classes
+/**
+ * Possible errors to be thrown in wallet
+ *
+ * @namespace Errors
+ */
+
+/**
+ * Error thrown when address is invalid
+ *
+ * @memberof Errors
+ * @inner
+ */
+class AddressError extends Error {}
+
+/**
+ * Error thrown when output value is invalid
+ *
+ * @memberof Errors
+ * @inner
+ */
+exports.AddressError = AddressError;
+class OutputValueError extends Error {}
+
+/**
+ * Error thrown when we have insufficient funds
+ *
+ * @memberof Errors
+ * @inner
+ */
+exports.OutputValueError = OutputValueError;
+class InsufficientFundsError extends Error {}
+
+/**
+ * Error thrown when a constant that we get from the server is not set
+ *
+ * @memberof Errors
+ * @inner
+ */
+exports.InsufficientFundsError = InsufficientFundsError;
+class ConstantNotSet extends Error {}
+
+/**
+ * Error thrown when a create token tx has invalid info
+ *
+ * @memberof Errors
+ * @inner
+ */
+exports.ConstantNotSet = ConstantNotSet;
+class CreateTokenTxInvalid extends Error {}
+
+/**
+ * Error thrown when validating a registration of new token
+ *
+ * @memberof Errors
+ * @inner
+ */
+exports.CreateTokenTxInvalid = CreateTokenTxInvalid;
+class TokenValidationError extends Error {}
+
+/**
+ * Error thrown when validating a registration of new NFT
+ *
+ * @memberof Errors
+ * @inner
+ */
+exports.TokenValidationError = TokenValidationError;
+class NftValidationError extends Error {}
+
+/**
+ * Error thrown when transaction has more inputs than the maximum allowed
+ *
+ * @memberof Errors
+ * @inner
+ */
+exports.NftValidationError = NftValidationError;
+class MaximumNumberInputsError extends Error {}
+
+/**
+ * Error thrown when transaction has more outputs than the maximum allowed
+ *
+ * @memberof Errors
+ * @inner
+ */
+exports.MaximumNumberInputsError = MaximumNumberInputsError;
+class MaximumNumberOutputsError extends Error {}
+
+/**
+ * Error thrown when transaction has invalid outputs
+ *
+ * @memberof Errors
+ * @inner
+ */
+exports.MaximumNumberOutputsError = MaximumNumberOutputsError;
+class InvalidOutputsError extends Error {}
+
+/**
+ * Error thrown when transaction has more parents than the maximum allowed
+ *
+ * @memberof Errors
+ * @inner
+ */
+exports.InvalidOutputsError = InvalidOutputsError;
+class MaximumNumberParentsError extends Error {}
+
+/**
+ * Error thrown when the wallet type is invalid
+ *
+ * @memberof Errors
+ * @inner
+ */
+exports.MaximumNumberParentsError = MaximumNumberParentsError;
+class WalletTypeError extends Error {}
+
+/**
+ * Error thrown when we are given an invalid xpubkey
+ *
+ * @memberof Errors
+ * @inner
+ */
+exports.WalletTypeError = WalletTypeError;
+class XPubError extends Error {}
+
+/**
+ * Error thrown when we are given an invalid uncompressed public key
+ *
+ * @memberof Errors
+ * @inner
+ */
+exports.XPubError = XPubError;
+class UncompressedPubKeyError extends Error {}
+
+/**
+ * Error thrown when the user tries to create a wallet with an invalid sequence of words
+ *
+ * @memberof Errors
+ * @inner
+ */
+exports.UncompressedPubKeyError = UncompressedPubKeyError;
+class InvalidWords extends Error {
+  constructor(...args) {
+    super(...args);
+    _defineProperty(this, "invalidWords", []);
+  }
+}
+
+/**
+ * Error thrown when parsing bytes to an object
+ *
+ * @memberof Errors
+ * @inner
+ */
+exports.InvalidWords = InvalidWords;
+class ParseError extends Error {}
+
+/**
+ * Error thrown when parsing a script bytes
+ *
+ * @memberof Errors
+ * @inner
+ */
+exports.ParseError = ParseError;
+class ParseScriptError extends ParseError {}
+
+/**
+ * Error thrown when executing wallet operations
+ *
+ * @memberof Errors
+ * @inner
+ */
+exports.ParseScriptError = ParseScriptError;
+class WalletError extends Error {
+  constructor(...args) {
+    super(...args);
+    _defineProperty(this, "errorCode", _errorMessages.ErrorMessages.DEFAULT_WALLET_ERROR);
+  }
+}
+
+/**
+ * Error thrown when executing wallet requests
+ *
+ * @memberof Errors
+ * @inner
+ */
+exports.WalletError = WalletError;
+class WalletRequestError extends WalletError {
+  constructor(message, errorData = {
+    cause: null
+  }) {
+    super(message);
+    _defineProperty(this, "cause", null);
+    this.cause = errorData.cause;
+  }
+}
+
+/**
+ * Error thrown when get utxo fails
+ *
+ * @memberof Errors
+ * @inner
+ */
+exports.WalletRequestError = WalletRequestError;
+class UtxoError extends WalletError {}
+
+/**
+ * Error thrown when sending tx
+ *
+ * @memberof Errors
+ * @inner
+ */
+exports.UtxoError = UtxoError;
+class SendTxError extends WalletError {
+  constructor(...args) {
+    super(...args);
+    // XXX: There are only two out of dozens of places where this object is used instead of a string.
+    //      This should be made consistently for strings
+    _defineProperty(this, "errorData", '');
+  }
+}
+
+/**
+ * Error thrown when mining tx
+ *
+ * @memberof Errors
+ * @inner
+ */
+exports.SendTxError = SendTxError;
+class MineTxError extends WalletError {}
+
+/**
+ * Error thrown when trying to interact with an incomplete or invalid partial transaction.
+ *
+ * @memberof Errors
+ * @inner
+ */
+exports.MineTxError = MineTxError;
+class InvalidPartialTxError extends WalletError {}
+
+/**
+ * Error thrown when calling a protected method on an xpub inited wallet
+ * Some methods require access to the words or private key
+ *
+ * @memberof Errors
+ * @inner
+ */
+exports.InvalidPartialTxError = InvalidPartialTxError;
+class WalletFromXPubGuard extends WalletError {}
+
+/**
+ * Error thrown when there is an error getting dag metadata using wallet service
+ *
+ * @memberof Errors
+ * @inner
+ */
+exports.WalletFromXPubGuard = WalletFromXPubGuard;
+class GetDagMetadataApiError extends Error {}
+
+/**
+ * Base Error class for Config not set errors
+ *
+ * @memberof Errors
+ * @inner
+ */
+exports.GetDagMetadataApiError = GetDagMetadataApiError;
+class ConfigNotSetError extends Error {}
+
+/**
+ * Error thrown when the WalletService URL is not set and a user tries to `get` it
+ *
+ * @memberof Errors
+ * @inner
+ */
+exports.ConfigNotSetError = ConfigNotSetError;
+class GetWalletServiceUrlError extends ConfigNotSetError {}
+
+/**
+ * Error thrown when the WalletService WebSocket URL is not set and a user tries to `get` it
+ *
+ * @memberof Errors
+ * @inner
+ */
+exports.GetWalletServiceUrlError = GetWalletServiceUrlError;
+class GetWalletServiceWsUrlError extends ConfigNotSetError {}
+
+/**
+ *
+ *
+ * @memberof Errors
+ * @inner
+ */
+exports.GetWalletServiceWsUrlError = GetWalletServiceWsUrlError;
+class PartialTxError extends Error {}
+
+/**
+ * Error thrown when an input data for a non-existent input is added.
+ *
+ * @memberof Errors
+ * @inner
+ */
+exports.PartialTxError = PartialTxError;
+class IndexOOBError extends PartialTxError {}
+
+/**
+ * Error thrown when an output with script type other than [p2sh, p2pkh] is used on PartialTx.
+ *
+ * @memberof Errors
+ * @inner
+ */
+exports.IndexOOBError = IndexOOBError;
+class UnsupportedScriptError extends PartialTxError {}
+
+/**
+ * Error thrown when a requested transaction is not found
+ *
+ * @memberof Errors
+ * @inner
+ */
+exports.UnsupportedScriptError = UnsupportedScriptError;
+class TxNotFoundError extends Error {}
+exports.TxNotFoundError = TxNotFoundError;
+class InvalidPasswdError extends WalletError {
+  constructor(...args) {
+    super(...args);
+    _defineProperty(this, "errorCode", _errorMessages.ErrorMessages.INVALID_PASSWD);
+  }
+}
+exports.InvalidPasswdError = InvalidPasswdError;
+class DecryptionError extends Error {
+  constructor(...args) {
+    super(...args);
+    _defineProperty(this, "errorCode", _errorMessages.ErrorMessages.DECRYPTION_ERROR);
+  }
+}
+exports.DecryptionError = DecryptionError;
+class UnsupportedHasherError extends Error {
+  constructor(...args) {
+    super(...args);
+    _defineProperty(this, "errorCode", _errorMessages.ErrorMessages.UNSUPPORTED_HASHER);
+  }
+}
+exports.UnsupportedHasherError = UnsupportedHasherError;
+class UninitializedWalletError extends WalletError {
+  constructor(...args) {
+    super(...args);
+    _defineProperty(this, "errorCode", _errorMessages.ErrorMessages.UNINITIALIZED_WALLET);
+  }
+}
+
+/**
+ * Error thrown during any API request
+ *
+ * @memberof Errors
+ * @inner
+ */
+exports.UninitializedWalletError = UninitializedWalletError;
+class RequestError extends Error {
+  constructor(...args) {
+    super(...args);
+    _defineProperty(this, "errorCode", _errorMessages.ErrorMessages.REQUEST_ERROR);
+  }
+}
+
+/**
+ * Error thrown during nano API request
+ *
+ * @memberof Errors
+ * @inner
+ */
+exports.RequestError = RequestError;
+class NanoRequestError extends RequestError {
+  constructor(message, originError = null, response = null) {
+    super(message);
+    _defineProperty(this, "errorCode", _errorMessages.ErrorMessages.NANO_REQUEST_ERROR);
+    _defineProperty(this, "originError", null);
+    _defineProperty(this, "response", null);
+    this.originError = originError;
+    this.response = response;
+  }
+}
+
+/**
+ * Error thrown during nano API request for 404
+ *
+ * @memberof Errors
+ * @inner
+ */
+exports.NanoRequestError = NanoRequestError;
+class NanoRequest404Error extends NanoRequestError {
+  constructor(...args) {
+    super(...args);
+    _defineProperty(this, "errorCode", _errorMessages.ErrorMessages.NANO_REQUEST_ERROR_404);
+  }
+}
+
+/**
+ * Error thrown when PIN is required in a method but it's not set
+ *
+ * @memberof Errors
+ * @inner
+ */
+exports.NanoRequest404Error = NanoRequest404Error;
+class PinRequiredError extends Error {
+  constructor(...args) {
+    super(...args);
+    _defineProperty(this, "errorCode", _errorMessages.ErrorMessages.PIN_REQUIRED);
+  }
+}
+
+/**
+ * Error thrown during the creation of a nano contract transaction
+ *
+ * @memberof Errors
+ * @inner
+ */
+exports.PinRequiredError = PinRequiredError;
+class NanoContractTransactionError extends Error {
+  constructor(...args) {
+    super(...args);
+    _defineProperty(this, "errorCode", _errorMessages.ErrorMessages.NANO_TRANSACTION_CREATE_ERROR);
+  }
+}
+
+/**
+ * Error thrown when parsing a nano contract transaction
+ *
+ * @memberof Errors
+ * @inner
+ */
+exports.NanoContractTransactionError = NanoContractTransactionError;
+class NanoContractTransactionParseError extends Error {
+  constructor(...args) {
+    super(...args);
+    _defineProperty(this, "errorCode", _errorMessages.ErrorMessages.NANO_TRANSACTION_PARSE_ERROR);
+  }
+}
+
+/**
+ * Error thrown when parsing an oracle script
+ *
+ * @memberof Errors
+ * @inner
+ */
+exports.NanoContractTransactionParseError = NanoContractTransactionParseError;
+class OracleParseError extends Error {
+  constructor(...args) {
+    super(...args);
+    _defineProperty(this, "errorCode", _errorMessages.ErrorMessages.NANO_ORACLE_PARSE_ERROR);
+  }
+}
+exports.OracleParseError = OracleParseError;
+class GlobalLoadLockTaskError extends Error {
+  constructor(taskId, innerError) {
+    super(`${taskId} has failed with ${innerError}`);
+    _defineProperty(this, "taskId", void 0);
+    _defineProperty(this, "innerError", void 0);
+    this.taskId = taskId;
+    this.innerError = innerError;
+  }
+}
+exports.GlobalLoadLockTaskError = GlobalLoadLockTaskError;
+class NanoHeaderNotFound extends Error {}
+exports.NanoHeaderNotFound = NanoHeaderNotFound;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/headers/base.d.ts b/node_modules/@hathor/wallet-lib/oldLib/headers/base.d.ts
new file mode 100644
index 0000000..ee45437
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/headers/base.d.ts
@@ -0,0 +1,17 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/// <reference types="node" />
+import Network from '../models/network';
+export interface HeaderStaticType {
+    deserialize(srcBuf: Buffer, network: Network): [Header, Buffer];
+}
+export default abstract class Header {
+    abstract serialize(array: Buffer[]): void;
+    abstract serializeSighash(array: Buffer[]): void;
+    static deserialize(srcBuf: Buffer, network: Network): [Header, Buffer];
+}
+//# sourceMappingURL=base.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/headers/base.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/headers/base.d.ts.map
new file mode 100644
index 0000000..41475d0
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/headers/base.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"base.d.ts","sourceRoot":"","sources":["../../src/headers/base.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;;AAEH,OAAO,OAAO,MAAM,mBAAmB,CAAC;AAExC,MAAM,WAAW,gBAAgB;IAC/B,WAAW,CAAC,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,OAAO,GAAG,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;CACjE;AAED,MAAM,CAAC,OAAO,CAAC,QAAQ,OAAO,MAAM;IAClC,QAAQ,CAAC,SAAS,CAAC,KAAK,EAAE,MAAM,EAAE,GAAG,IAAI;IAEzC,QAAQ,CAAC,gBAAgB,CAAC,KAAK,EAAE,MAAM,EAAE,GAAG,IAAI;IAGhD,MAAM,CAAC,WAAW,CAAC,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,OAAO,GAAG,CAAC,MAAM,EAAE,MAAM,CAAC;CAGvE"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/headers/base.js b/node_modules/@hathor/wallet-lib/oldLib/headers/base.js
new file mode 100644
index 0000000..200d056
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/headers/base.js
@@ -0,0 +1,20 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+class Header {
+  // XXX In typescript we can't have an abstract and static method
+  static deserialize(srcBuf, network) {
+    throw new Error('Not implemented: deserialize must be implemented in subclass');
+  }
+}
+exports.default = Header;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/headers/parser.d.ts b/node_modules/@hathor/wallet-lib/oldLib/headers/parser.d.ts
new file mode 100644
index 0000000..e2a6ed4
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/headers/parser.d.ts
@@ -0,0 +1,13 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+import { VertexHeaderId } from './types';
+import { HeaderStaticType } from './base';
+export default class HeaderParser {
+    static getSupportedHeaders(): Record<VertexHeaderId, HeaderStaticType>;
+    static getHeader(id: string): HeaderStaticType;
+}
+//# sourceMappingURL=parser.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/headers/parser.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/headers/parser.d.ts.map
new file mode 100644
index 0000000..13ae473
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/headers/parser.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"parser.d.ts","sourceRoot":"","sources":["../../src/headers/parser.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;AAEH,OAAO,EAAE,cAAc,EAAE,MAAM,SAAS,CAAC;AACzC,OAAO,EAAE,gBAAgB,EAAE,MAAM,QAAQ,CAAC;AAG1C,MAAM,CAAC,OAAO,OAAO,YAAY;IAC/B,MAAM,CAAC,mBAAmB,IAAI,MAAM,CAAC,cAAc,EAAE,gBAAgB,CAAC;IAMtE,MAAM,CAAC,SAAS,CAAC,EAAE,EAAE,MAAM,GAAG,gBAAgB;CAQ/C"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/headers/parser.js b/node_modules/@hathor/wallet-lib/oldLib/headers/parser.js
new file mode 100644
index 0000000..0bbae37
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/headers/parser.js
@@ -0,0 +1,31 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+var _types = require("./types");
+var _header = _interopRequireDefault(require("../nano_contracts/header"));
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+class HeaderParser {
+  static getSupportedHeaders() {
+    return {
+      [_types.VertexHeaderId.NANO_HEADER]: _header.default
+    };
+  }
+  static getHeader(id) {
+    const headers = HeaderParser.getSupportedHeaders();
+    if (!(id in headers)) {
+      throw new Error(`Header id not supported: ${id}`);
+    }
+    return headers[id];
+  }
+}
+exports.default = HeaderParser;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/headers/types.d.ts b/node_modules/@hathor/wallet-lib/oldLib/headers/types.d.ts
new file mode 100644
index 0000000..8f80df0
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/headers/types.d.ts
@@ -0,0 +1,18 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/// <reference types="node" />
+/**
+ * The hathor-core has a similar enum that maps to bytes.
+ * In typescript this is not easy to manipulate so I decided
+ * to have the same enum but with hex values instead.
+ */
+export declare const enum VertexHeaderId {
+    NANO_HEADER = "10"
+}
+export declare function getVertexHeaderIdBuffer(id: VertexHeaderId): Buffer;
+export declare function getVertexHeaderIdFromBuffer(buf: Buffer): VertexHeaderId;
+//# sourceMappingURL=types.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/headers/types.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/headers/types.d.ts.map
new file mode 100644
index 0000000..7e27c31
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/headers/types.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"types.d.ts","sourceRoot":"","sources":["../../src/headers/types.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;;AAEH;;;;GAIG;AACH,0BAAkB,cAAc;IAC9B,WAAW,OAAO;CACnB;AAED,wBAAgB,uBAAuB,CAAC,EAAE,EAAE,cAAc,GAAG,MAAM,CAElE;AAED,wBAAgB,2BAA2B,CAAC,GAAG,EAAE,MAAM,GAAG,cAAc,CAQvE"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/headers/types.js b/node_modules/@hathor/wallet-lib/oldLib/headers/types.js
new file mode 100644
index 0000000..842c354
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/headers/types.js
@@ -0,0 +1,35 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.VertexHeaderId = void 0;
+exports.getVertexHeaderIdBuffer = getVertexHeaderIdBuffer;
+exports.getVertexHeaderIdFromBuffer = getVertexHeaderIdFromBuffer;
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/**
+ * The hathor-core has a similar enum that maps to bytes.
+ * In typescript this is not easy to manipulate so I decided
+ * to have the same enum but with hex values instead.
+ */
+let VertexHeaderId = exports.VertexHeaderId = /*#__PURE__*/function (VertexHeaderId) {
+  VertexHeaderId["NANO_HEADER"] = "10";
+  return VertexHeaderId;
+}({});
+function getVertexHeaderIdBuffer(id) {
+  return Buffer.from(id, 'hex');
+}
+function getVertexHeaderIdFromBuffer(buf) {
+  const vertexId = buf.readUInt8().toString(16);
+  switch (vertexId) {
+    case VertexHeaderId.NANO_HEADER:
+      return VertexHeaderId.NANO_HEADER;
+    default:
+      throw new Error('Invalid VertexHeaderId');
+  }
+}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/index.d.ts b/node_modules/@hathor/wallet-lib/oldLib/index.d.ts
new file mode 100644
index 0000000..01806b1
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/index.d.ts
@@ -0,0 +1,4 @@
+import * as hathorLib from './lib';
+export default hathorLib;
+export * from './lib';
+//# sourceMappingURL=index.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/index.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/index.d.ts.map
new file mode 100644
index 0000000..271eeed
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/index.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,SAAS,MAAM,OAAO,CAAC;AAEnC,eAAe,SAAS,CAAC;AACzB,cAAc,OAAO,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/index.js b/node_modules/@hathor/wallet-lib/oldLib/index.js
new file mode 100644
index 0000000..040263b
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/index.js
@@ -0,0 +1,22 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+var _exportNames = {};
+exports.default = void 0;
+var hathorLib = _interopRequireWildcard(require("./lib"));
+Object.keys(hathorLib).forEach(function (key) {
+  if (key === "default" || key === "__esModule") return;
+  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
+  if (key in exports && exports[key] === hathorLib[key]) return;
+  Object.defineProperty(exports, key, {
+    enumerable: true,
+    get: function () {
+      return hathorLib[key];
+    }
+  });
+});
+function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
+function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
+var _default = exports.default = hathorLib;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/lib.d.ts b/node_modules/@hathor/wallet-lib/oldLib/lib.d.ts
new file mode 100644
index 0000000..75ff0b6
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/lib.d.ts
@@ -0,0 +1,58 @@
+import * as constants from './constants';
+import dateFormatter from './utils/date';
+import websocket from './websocket';
+import * as errors from './errors';
+import * as ErrorMessages from './errorMessages';
+import walletApi from './api/wallet';
+import txApi from './api/txApi';
+import txMiningApi from './api/txMining';
+import healthApi from './api/health';
+import versionApi from './api/version';
+import * as axios from './api/axiosInstance';
+import metadataApi from './api/metadataApi';
+import featuresApi from './api/featuresApi';
+import { Storage } from './storage/storage';
+import { MemoryStore } from './storage/memory_store';
+import network from './network';
+import HathorWallet from './new/wallet';
+import Connection from './new/connection';
+import WalletServiceConnection from './wallet/connection';
+import SendTransaction from './new/sendTransaction';
+import Address from './models/address';
+import Output from './models/output';
+import P2PKH from './models/p2pkh';
+import P2SH from './models/p2sh';
+import P2SHSignature from './models/p2sh_signature';
+import ScriptData from './models/script_data';
+import Input from './models/input';
+import Transaction from './models/transaction';
+import CreateTokenTransaction from './models/create_token_transaction';
+import Network from './models/network';
+import * as addressUtils from './utils/address';
+import * as cryptoUtils from './utils/crypto';
+import tokensUtils from './utils/tokens';
+import walletUtils from './utils/wallet';
+import helpersUtils from './utils/helpers';
+import * as numberUtils from './utils/numbers';
+import * as scriptsUtils from './utils/scripts';
+import transactionUtils from './utils/transaction';
+import * as bufferUtils from './utils/buffer';
+import HathorWalletServiceWallet from './wallet/wallet';
+import walletServiceApi from './wallet/api/walletApi';
+import SendTransactionWalletService from './wallet/sendTransactionWalletService';
+import config from './config';
+import * as PushNotification from './pushNotification';
+import { WalletType, HistorySyncMode } from './types';
+import { PartialTx, PartialTxInputData } from './models/partial_tx';
+import PartialTxProposal from './wallet/partialTxProposal';
+import * as swapService from './wallet/api/swapService';
+import { AtomicSwapServiceConnection } from './swapService/swapConnection';
+import ncApi from './api/nano';
+import * as nanoUtils from './nano_contracts/utils';
+import NanoContractTransactionParser from './nano_contracts/parser';
+import * as bigIntUtils from './utils/bigint';
+import { TransactionTemplate, TransactionTemplateBuilder, WalletTxTemplateInterpreter } from './template/transaction';
+export { PartialTx, PartialTxInputData, PartialTxProposal, dateFormatter, websocket, walletApi, txApi, txMiningApi, healthApi, versionApi, metadataApi, featuresApi, errors, ErrorMessages, constants, axios, Storage, MemoryStore, network, HathorWallet, Connection, AtomicSwapServiceConnection, WalletServiceConnection, SendTransaction, Address, Output, P2PKH, P2SH, P2SHSignature, ScriptData, Input, Transaction, CreateTokenTransaction, Network, addressUtils, cryptoUtils, dateFormatter as dateUtils, tokensUtils, walletUtils, numberUtils, helpersUtils, scriptsUtils, bufferUtils, transactionUtils, HathorWalletServiceWallet, walletServiceApi, SendTransactionWalletService, config, PushNotification, swapService, WalletType, HistorySyncMode, ncApi, nanoUtils, NanoContractTransactionParser, bigIntUtils, TransactionTemplate, TransactionTemplateBuilder, WalletTxTemplateInterpreter, };
+export * from './nano_contracts/types';
+export * from './models/types';
+//# sourceMappingURL=lib.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/lib.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/lib.d.ts.map
new file mode 100644
index 0000000..07f1bb4
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/lib.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"lib.d.ts","sourceRoot":"","sources":["../src/lib.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/lib.js b/node_modules/@hathor/wallet-lib/oldLib/lib.js
new file mode 100644
index 0000000..0509fa6
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/lib.js
@@ -0,0 +1,443 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+var _exportNames = {
+  constants: true,
+  dateFormatter: true,
+  dateUtils: true,
+  websocket: true,
+  errors: true,
+  ErrorMessages: true,
+  walletApi: true,
+  txApi: true,
+  txMiningApi: true,
+  healthApi: true,
+  versionApi: true,
+  axios: true,
+  metadataApi: true,
+  featuresApi: true,
+  Storage: true,
+  MemoryStore: true,
+  network: true,
+  HathorWallet: true,
+  Connection: true,
+  WalletServiceConnection: true,
+  SendTransaction: true,
+  Address: true,
+  Output: true,
+  P2PKH: true,
+  P2SH: true,
+  P2SHSignature: true,
+  ScriptData: true,
+  Input: true,
+  Transaction: true,
+  CreateTokenTransaction: true,
+  Network: true,
+  addressUtils: true,
+  cryptoUtils: true,
+  tokensUtils: true,
+  walletUtils: true,
+  helpersUtils: true,
+  numberUtils: true,
+  scriptsUtils: true,
+  transactionUtils: true,
+  bufferUtils: true,
+  HathorWalletServiceWallet: true,
+  walletServiceApi: true,
+  SendTransactionWalletService: true,
+  config: true,
+  PushNotification: true,
+  WalletType: true,
+  HistorySyncMode: true,
+  PartialTx: true,
+  PartialTxInputData: true,
+  PartialTxProposal: true,
+  swapService: true,
+  AtomicSwapServiceConnection: true,
+  ncApi: true,
+  nanoUtils: true,
+  NanoContractTransactionParser: true,
+  bigIntUtils: true,
+  TransactionTemplate: true,
+  TransactionTemplateBuilder: true,
+  WalletTxTemplateInterpreter: true
+};
+Object.defineProperty(exports, "Address", {
+  enumerable: true,
+  get: function () {
+    return _address.default;
+  }
+});
+Object.defineProperty(exports, "AtomicSwapServiceConnection", {
+  enumerable: true,
+  get: function () {
+    return _swapConnection.AtomicSwapServiceConnection;
+  }
+});
+Object.defineProperty(exports, "Connection", {
+  enumerable: true,
+  get: function () {
+    return _connection.default;
+  }
+});
+Object.defineProperty(exports, "CreateTokenTransaction", {
+  enumerable: true,
+  get: function () {
+    return _create_token_transaction.default;
+  }
+});
+exports.ErrorMessages = void 0;
+Object.defineProperty(exports, "HathorWallet", {
+  enumerable: true,
+  get: function () {
+    return _wallet2.default;
+  }
+});
+Object.defineProperty(exports, "HathorWalletServiceWallet", {
+  enumerable: true,
+  get: function () {
+    return _wallet4.default;
+  }
+});
+Object.defineProperty(exports, "HistorySyncMode", {
+  enumerable: true,
+  get: function () {
+    return _types.HistorySyncMode;
+  }
+});
+Object.defineProperty(exports, "Input", {
+  enumerable: true,
+  get: function () {
+    return _input.default;
+  }
+});
+Object.defineProperty(exports, "MemoryStore", {
+  enumerable: true,
+  get: function () {
+    return _memory_store.MemoryStore;
+  }
+});
+Object.defineProperty(exports, "NanoContractTransactionParser", {
+  enumerable: true,
+  get: function () {
+    return _parser.default;
+  }
+});
+Object.defineProperty(exports, "Network", {
+  enumerable: true,
+  get: function () {
+    return _network2.default;
+  }
+});
+Object.defineProperty(exports, "Output", {
+  enumerable: true,
+  get: function () {
+    return _output.default;
+  }
+});
+Object.defineProperty(exports, "P2PKH", {
+  enumerable: true,
+  get: function () {
+    return _p2pkh.default;
+  }
+});
+Object.defineProperty(exports, "P2SH", {
+  enumerable: true,
+  get: function () {
+    return _p2sh.default;
+  }
+});
+Object.defineProperty(exports, "P2SHSignature", {
+  enumerable: true,
+  get: function () {
+    return _p2sh_signature.default;
+  }
+});
+Object.defineProperty(exports, "PartialTx", {
+  enumerable: true,
+  get: function () {
+    return _partial_tx.PartialTx;
+  }
+});
+Object.defineProperty(exports, "PartialTxInputData", {
+  enumerable: true,
+  get: function () {
+    return _partial_tx.PartialTxInputData;
+  }
+});
+Object.defineProperty(exports, "PartialTxProposal", {
+  enumerable: true,
+  get: function () {
+    return _partialTxProposal.default;
+  }
+});
+exports.PushNotification = void 0;
+Object.defineProperty(exports, "ScriptData", {
+  enumerable: true,
+  get: function () {
+    return _script_data.default;
+  }
+});
+Object.defineProperty(exports, "SendTransaction", {
+  enumerable: true,
+  get: function () {
+    return _sendTransaction.default;
+  }
+});
+Object.defineProperty(exports, "SendTransactionWalletService", {
+  enumerable: true,
+  get: function () {
+    return _sendTransactionWalletService.default;
+  }
+});
+Object.defineProperty(exports, "Storage", {
+  enumerable: true,
+  get: function () {
+    return _storage.Storage;
+  }
+});
+Object.defineProperty(exports, "Transaction", {
+  enumerable: true,
+  get: function () {
+    return _transaction.default;
+  }
+});
+Object.defineProperty(exports, "TransactionTemplate", {
+  enumerable: true,
+  get: function () {
+    return _transaction3.TransactionTemplate;
+  }
+});
+Object.defineProperty(exports, "TransactionTemplateBuilder", {
+  enumerable: true,
+  get: function () {
+    return _transaction3.TransactionTemplateBuilder;
+  }
+});
+Object.defineProperty(exports, "WalletServiceConnection", {
+  enumerable: true,
+  get: function () {
+    return _connection2.default;
+  }
+});
+Object.defineProperty(exports, "WalletTxTemplateInterpreter", {
+  enumerable: true,
+  get: function () {
+    return _transaction3.WalletTxTemplateInterpreter;
+  }
+});
+Object.defineProperty(exports, "WalletType", {
+  enumerable: true,
+  get: function () {
+    return _types.WalletType;
+  }
+});
+exports.bufferUtils = exports.bigIntUtils = exports.axios = exports.addressUtils = void 0;
+Object.defineProperty(exports, "config", {
+  enumerable: true,
+  get: function () {
+    return _config.default;
+  }
+});
+exports.cryptoUtils = exports.constants = void 0;
+Object.defineProperty(exports, "dateFormatter", {
+  enumerable: true,
+  get: function () {
+    return _date.default;
+  }
+});
+Object.defineProperty(exports, "dateUtils", {
+  enumerable: true,
+  get: function () {
+    return _date.default;
+  }
+});
+exports.errors = void 0;
+Object.defineProperty(exports, "featuresApi", {
+  enumerable: true,
+  get: function () {
+    return _featuresApi.default;
+  }
+});
+Object.defineProperty(exports, "healthApi", {
+  enumerable: true,
+  get: function () {
+    return _health.default;
+  }
+});
+Object.defineProperty(exports, "helpersUtils", {
+  enumerable: true,
+  get: function () {
+    return _helpers.default;
+  }
+});
+Object.defineProperty(exports, "metadataApi", {
+  enumerable: true,
+  get: function () {
+    return _metadataApi.default;
+  }
+});
+exports.nanoUtils = void 0;
+Object.defineProperty(exports, "ncApi", {
+  enumerable: true,
+  get: function () {
+    return _nano.default;
+  }
+});
+Object.defineProperty(exports, "network", {
+  enumerable: true,
+  get: function () {
+    return _network.default;
+  }
+});
+exports.swapService = exports.scriptsUtils = exports.numberUtils = void 0;
+Object.defineProperty(exports, "tokensUtils", {
+  enumerable: true,
+  get: function () {
+    return _tokens.default;
+  }
+});
+Object.defineProperty(exports, "transactionUtils", {
+  enumerable: true,
+  get: function () {
+    return _transaction2.default;
+  }
+});
+Object.defineProperty(exports, "txApi", {
+  enumerable: true,
+  get: function () {
+    return _txApi.default;
+  }
+});
+Object.defineProperty(exports, "txMiningApi", {
+  enumerable: true,
+  get: function () {
+    return _txMining.default;
+  }
+});
+Object.defineProperty(exports, "versionApi", {
+  enumerable: true,
+  get: function () {
+    return _version.default;
+  }
+});
+Object.defineProperty(exports, "walletApi", {
+  enumerable: true,
+  get: function () {
+    return _wallet.default;
+  }
+});
+Object.defineProperty(exports, "walletServiceApi", {
+  enumerable: true,
+  get: function () {
+    return _walletApi.default;
+  }
+});
+Object.defineProperty(exports, "walletUtils", {
+  enumerable: true,
+  get: function () {
+    return _wallet3.default;
+  }
+});
+Object.defineProperty(exports, "websocket", {
+  enumerable: true,
+  get: function () {
+    return _websocket.default;
+  }
+});
+var constants = _interopRequireWildcard(require("./constants"));
+exports.constants = constants;
+var _date = _interopRequireDefault(require("./utils/date"));
+var _websocket = _interopRequireDefault(require("./websocket"));
+var errors = _interopRequireWildcard(require("./errors"));
+exports.errors = errors;
+var ErrorMessages = _interopRequireWildcard(require("./errorMessages"));
+exports.ErrorMessages = ErrorMessages;
+var _wallet = _interopRequireDefault(require("./api/wallet"));
+var _txApi = _interopRequireDefault(require("./api/txApi"));
+var _txMining = _interopRequireDefault(require("./api/txMining"));
+var _health = _interopRequireDefault(require("./api/health"));
+var _version = _interopRequireDefault(require("./api/version"));
+var axios = _interopRequireWildcard(require("./api/axiosInstance"));
+exports.axios = axios;
+var _metadataApi = _interopRequireDefault(require("./api/metadataApi"));
+var _featuresApi = _interopRequireDefault(require("./api/featuresApi"));
+var _storage = require("./storage/storage");
+var _memory_store = require("./storage/memory_store");
+var _network = _interopRequireDefault(require("./network"));
+var _wallet2 = _interopRequireDefault(require("./new/wallet"));
+var _connection = _interopRequireDefault(require("./new/connection"));
+var _connection2 = _interopRequireDefault(require("./wallet/connection"));
+var _sendTransaction = _interopRequireDefault(require("./new/sendTransaction"));
+var _address = _interopRequireDefault(require("./models/address"));
+var _output = _interopRequireDefault(require("./models/output"));
+var _p2pkh = _interopRequireDefault(require("./models/p2pkh"));
+var _p2sh = _interopRequireDefault(require("./models/p2sh"));
+var _p2sh_signature = _interopRequireDefault(require("./models/p2sh_signature"));
+var _script_data = _interopRequireDefault(require("./models/script_data"));
+var _input = _interopRequireDefault(require("./models/input"));
+var _transaction = _interopRequireDefault(require("./models/transaction"));
+var _create_token_transaction = _interopRequireDefault(require("./models/create_token_transaction"));
+var _network2 = _interopRequireDefault(require("./models/network"));
+var addressUtils = _interopRequireWildcard(require("./utils/address"));
+exports.addressUtils = addressUtils;
+var cryptoUtils = _interopRequireWildcard(require("./utils/crypto"));
+exports.cryptoUtils = cryptoUtils;
+var _tokens = _interopRequireDefault(require("./utils/tokens"));
+var _wallet3 = _interopRequireDefault(require("./utils/wallet"));
+var _helpers = _interopRequireDefault(require("./utils/helpers"));
+var numberUtils = _interopRequireWildcard(require("./utils/numbers"));
+exports.numberUtils = numberUtils;
+var scriptsUtils = _interopRequireWildcard(require("./utils/scripts"));
+exports.scriptsUtils = scriptsUtils;
+var _transaction2 = _interopRequireDefault(require("./utils/transaction"));
+var bufferUtils = _interopRequireWildcard(require("./utils/buffer"));
+exports.bufferUtils = bufferUtils;
+var _wallet4 = _interopRequireDefault(require("./wallet/wallet"));
+var _walletApi = _interopRequireDefault(require("./wallet/api/walletApi"));
+var _sendTransactionWalletService = _interopRequireDefault(require("./wallet/sendTransactionWalletService"));
+var _config = _interopRequireDefault(require("./config"));
+var PushNotification = _interopRequireWildcard(require("./pushNotification"));
+exports.PushNotification = PushNotification;
+var _types = require("./types");
+var _partial_tx = require("./models/partial_tx");
+var _partialTxProposal = _interopRequireDefault(require("./wallet/partialTxProposal"));
+var swapService = _interopRequireWildcard(require("./wallet/api/swapService"));
+exports.swapService = swapService;
+var _swapConnection = require("./swapService/swapConnection");
+var _nano = _interopRequireDefault(require("./api/nano"));
+var nanoUtils = _interopRequireWildcard(require("./nano_contracts/utils"));
+exports.nanoUtils = nanoUtils;
+var _parser = _interopRequireDefault(require("./nano_contracts/parser"));
+var bigIntUtils = _interopRequireWildcard(require("./utils/bigint"));
+exports.bigIntUtils = bigIntUtils;
+var _transaction3 = require("./template/transaction");
+var _types2 = require("./nano_contracts/types");
+Object.keys(_types2).forEach(function (key) {
+  if (key === "default" || key === "__esModule") return;
+  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
+  if (key in exports && exports[key] === _types2[key]) return;
+  Object.defineProperty(exports, key, {
+    enumerable: true,
+    get: function () {
+      return _types2[key];
+    }
+  });
+});
+var _types3 = require("./models/types");
+Object.keys(_types3).forEach(function (key) {
+  if (key === "default" || key === "__esModule") return;
+  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
+  if (key in exports && exports[key] === _types3[key]) return;
+  Object.defineProperty(exports, key, {
+    enumerable: true,
+    get: function () {
+      return _types3[key];
+    }
+  });
+});
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
+function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/models/address.d.ts b/node_modules/@hathor/wallet-lib/oldLib/models/address.d.ts
new file mode 100644
index 0000000..2171f49
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/models/address.d.ts
@@ -0,0 +1,75 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/// <reference types="node" />
+import Network from './network';
+declare class Address {
+    base58: string;
+    network: Network;
+    constructor(base58: string, options?: {
+        network: Network;
+    });
+    /**
+     * Check if address is a valid string
+     *
+     * @return {boolean} If address is valid
+     * @memberof Address
+     * @inner
+     */
+    isValid(): boolean;
+    /**
+     * Decode address in base58 to bytes
+     *
+     * @return {Buffer} address in bytes
+     * @memberof Address
+     * @inner
+     */
+    decode(): Buffer;
+    /**
+     * Validate address
+     *
+     * 1. Address must have 25 bytes
+     * 2. Address checksum must be valid
+     * 3. Address first byte must match one of the options for P2PKH or P2SH
+     *
+     * @throws {AddressError} Will throw an error if address is not valid
+     *
+     * @return {boolean}
+     * @memberof Address
+     * @inner
+     */
+    validateAddress({ skipNetwork }?: {
+        skipNetwork: boolean;
+    }): boolean;
+    /**
+     * Get address type
+     *
+     * Will check the version byte of the address against the network's version bytes.
+     * Valid types are p2pkh and p2sh.
+     *
+     * @throws {AddressError} Will throw an error if address is not valid
+     *
+     * @return {string}
+     * @memberof Address
+     * @inner
+     */
+    getType(): 'p2pkh' | 'p2sh';
+    /**
+     * Get address script
+     *
+     * Will get the type of the address (p2pkh or p2sh)
+     * then create the script
+     *
+     * @throws {AddressError} Will throw an error if address is not valid
+     *
+     * @return {Buffer}
+     * @memberof Address
+     * @inner
+     */
+    getScript(): Buffer;
+}
+export default Address;
+//# sourceMappingURL=address.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/models/address.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/models/address.d.ts.map
new file mode 100644
index 0000000..2e1019d
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/models/address.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"address.d.ts","sourceRoot":"","sources":["../../src/models/address.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;;AAKH,OAAO,OAAO,MAAM,WAAW,CAAC;AAKhC,cAAM,OAAO;IAEX,MAAM,EAAE,MAAM,CAAC;IAGf,OAAO,EAAE,OAAO,CAAC;gBAEL,MAAM,EAAE,MAAM,EAAE,OAAO;;KAAsC;IAWzE;;;;;;OAMG;IACH,OAAO,IAAI,OAAO;IAWlB;;;;;;OAMG;IACH,MAAM,IAAI,MAAM;IAQhB;;;;;;;;;;;;OAYG;IACH,eAAe,CAAC,EAAE,WAAW,EAAE,GAAE;QAAE,WAAW,EAAE,OAAO,CAAA;KAA2B,GAAG,OAAO;IAmC5F;;;;;;;;;;;OAWG;IACH,OAAO,IAAI,OAAO,GAAG,MAAM;IAc3B;;;;;;;;;;;OAWG;IACH,SAAS,IAAI,MAAM;CASpB;AAED,eAAe,OAAO,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/models/address.js b/node_modules/@hathor/wallet-lib/oldLib/models/address.js
new file mode 100644
index 0000000..52f3ef3
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/models/address.js
@@ -0,0 +1,166 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+var _bitcoreLib = require("bitcore-lib");
+var _lodash = _interopRequireDefault(require("lodash"));
+var _errors = require("../errors");
+var _network = _interopRequireDefault(require("./network"));
+var _p2pkh = _interopRequireDefault(require("./p2pkh"));
+var _p2sh = _interopRequireDefault(require("./p2sh"));
+var _helpers = _interopRequireDefault(require("../utils/helpers"));
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
+function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
+function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+class Address {
+  constructor(base58, options = {
+    network: new _network.default('testnet')
+  }) {
+    // String with address as base58
+    _defineProperty(this, "base58", void 0);
+    // Network to validate the address
+    _defineProperty(this, "network", void 0);
+    const {
+      network
+    } = options;
+    if (!_lodash.default.isString(base58)) {
+      throw Error('Parameter should be a string.');
+    }
+    this.base58 = base58;
+    this.network = network;
+  }
+
+  /**
+   * Check if address is a valid string
+   *
+   * @return {boolean} If address is valid
+   * @memberof Address
+   * @inner
+   */
+  isValid() {
+    try {
+      return this.validateAddress();
+    } catch (e) {
+      if (e instanceof _errors.AddressError) {
+        return false;
+      }
+      throw e;
+    }
+  }
+
+  /**
+   * Decode address in base58 to bytes
+   *
+   * @return {Buffer} address in bytes
+   * @memberof Address
+   * @inner
+   */
+  decode() {
+    try {
+      return _bitcoreLib.encoding.Base58.decode(this.base58);
+    } catch (e) {
+      throw new _errors.AddressError('Invalid base58 address');
+    }
+  }
+
+  /**
+   * Validate address
+   *
+   * 1. Address must have 25 bytes
+   * 2. Address checksum must be valid
+   * 3. Address first byte must match one of the options for P2PKH or P2SH
+   *
+   * @throws {AddressError} Will throw an error if address is not valid
+   *
+   * @return {boolean}
+   * @memberof Address
+   * @inner
+   */
+  validateAddress({
+    skipNetwork
+  } = {
+    skipNetwork: false
+  }) {
+    const addressBytes = this.decode();
+    const errorMessage = `Invalid address: ${this.base58}.`;
+
+    // Validate address length
+    if (addressBytes.length !== 25) {
+      throw new _errors.AddressError(`${errorMessage} Address has ${addressBytes.length} bytes and should have 25.`);
+    }
+
+    // Validate address checksum
+    const checksum = addressBytes.subarray(-4);
+    const addressSlice = addressBytes.subarray(0, -4);
+    const correctChecksum = _helpers.default.getChecksum(addressSlice);
+    if (!_bitcoreLib.util.buffer.equals(checksum, correctChecksum)) {
+      throw new _errors.AddressError(`${errorMessage} Invalid checksum. Expected: ${correctChecksum} != Received: ${checksum}.`);
+    }
+    if (skipNetwork) {
+      return true;
+    }
+
+    // Validate version byte. Should be the p2pkh or p2sh
+    const firstByte = addressBytes[0];
+    if (!this.network.isVersionByteValid(firstByte)) {
+      throw new _errors.AddressError(`${errorMessage} Invalid network byte. Expected: ${this.network.versionBytes.p2pkh} or ${this.network.versionBytes.p2sh} and received ${firstByte}.`);
+    }
+    return true;
+  }
+
+  /**
+   * Get address type
+   *
+   * Will check the version byte of the address against the network's version bytes.
+   * Valid types are p2pkh and p2sh.
+   *
+   * @throws {AddressError} Will throw an error if address is not valid
+   *
+   * @return {string}
+   * @memberof Address
+   * @inner
+   */
+  getType() {
+    this.validateAddress();
+    const addressBytes = this.decode();
+    const firstByte = addressBytes[0];
+    if (firstByte === this.network.versionBytes.p2pkh) {
+      return 'p2pkh';
+    }
+    if (firstByte === this.network.versionBytes.p2sh) {
+      return 'p2sh';
+    }
+    throw new _errors.AddressError('Invalid address type.');
+  }
+
+  /**
+   * Get address script
+   *
+   * Will get the type of the address (p2pkh or p2sh)
+   * then create the script
+   *
+   * @throws {AddressError} Will throw an error if address is not valid
+   *
+   * @return {Buffer}
+   * @memberof Address
+   * @inner
+   */
+  getScript() {
+    const addressType = this.getType();
+    if (addressType === 'p2pkh') {
+      const p2pkh = new _p2pkh.default(this);
+      return p2pkh.createScript();
+    }
+    const p2sh = new _p2sh.default(this);
+    return p2sh.createScript();
+  }
+}
+var _default = exports.default = Address;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/models/create_token_transaction.d.ts b/node_modules/@hathor/wallet-lib/oldLib/models/create_token_transaction.d.ts
new file mode 100644
index 0000000..5042e7e
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/models/create_token_transaction.d.ts
@@ -0,0 +1,82 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/// <reference types="node" />
+import Input from './input';
+import Output from './output';
+import Transaction from './transaction';
+import Network from './network';
+import type Header from '../headers/base';
+type optionsType = {
+    signalBits?: number;
+    weight?: number;
+    nonce?: number;
+    timestamp?: number | null;
+    parents?: string[];
+    tokens?: string[];
+    hash?: string | null;
+    headers?: Header[];
+};
+declare class CreateTokenTransaction extends Transaction {
+    name: string;
+    symbol: string;
+    constructor(name: string, symbol: string, inputs: Input[], outputs: Output[], options?: optionsType);
+    /**
+     * Serialize funds fields
+     * signal bits, version, len inputs, len outputs, inputs, outputs and token info
+     *
+     * @param {Buffer[]} array Array of buffer to push the serialized fields
+     * @param {boolean} addInputData If should add input data when serializing it
+     *
+     * @memberof Transaction
+     * @inner
+     */
+    serializeFundsFields(array: Buffer[], addInputData: boolean): void;
+    /**
+     * Serialize create token tx info to bytes
+     *
+     * @param {Buffer[]} array of bytes
+     * @memberof Transaction
+     * @inner
+     */
+    serializeTokenInfo(array: Buffer[]): void;
+    getTokenInfoFromBytes(srcBuf: Buffer): Buffer;
+    /**
+     * Gets funds fields (signalBits, version, inputs, outputs) from bytes
+     * and saves them in `this`
+     *
+     * @param srcBuf Buffer with bytes to get fields
+     * @param network Network to get output addresses first byte
+     *
+     * @return Rest of buffer after getting the fields
+     * @memberof CreateTokenTransaction
+     * @inner
+     */
+    getFundsFieldsFromBytes(srcBuf: Buffer, network: Network): Buffer;
+    /**
+     * Create transaction object from bytes
+     *
+     * @param {Buffer} buf Buffer with bytes to get transaction fields
+     * @param {Network} network Network to get output addresses first byte
+     *
+     * @return {CreateTokenTransaction} Transaction object
+     * @memberof CreateTokenTransaction
+     * @static
+     * @inner
+     */
+    static createFromBytes(buf: Buffer, network: Network): CreateTokenTransaction;
+    /**
+     * Checks if this transaction is the creation of an NFT following the NFT Standard Creation.
+     * @see https://github.com/HathorNetwork/rfcs/blob/master/text/0032-nft-standard.md#transaction-standard
+     * @throws {NftValidationError} Will throw an error if the NFT is not valid
+     *
+     * @param {Network} network Network to get output addresses first byte
+     * @returns {void} If this function does not throw, the NFT is valid
+     */
+    validateNft(network: Network): void;
+}
+export default CreateTokenTransaction;
+//# sourceMappingURL=create_token_transaction.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/models/create_token_transaction.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/models/create_token_transaction.d.ts.map
new file mode 100644
index 0000000..066b376
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/models/create_token_transaction.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"create_token_transaction.d.ts","sourceRoot":"","sources":["../../src/models/create_token_transaction.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;;AAYH,OAAO,KAAK,MAAM,SAAS,CAAC;AAC5B,OAAO,MAAM,MAAM,UAAU,CAAC;AAC9B,OAAO,WAAW,MAAM,eAAe,CAAC;AACxC,OAAO,OAAO,MAAM,WAAW,CAAC;AAIhC,OAAO,KAAK,MAAM,MAAM,iBAAiB,CAAC;AAE1C,KAAK,WAAW,GAAG;IACjB,UAAU,CAAC,EAAE,MAAM,CAAC;IACpB,MAAM,CAAC,EAAE,MAAM,CAAC;IAChB,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,SAAS,CAAC,EAAE,MAAM,GAAG,IAAI,CAAC;IAC1B,OAAO,CAAC,EAAE,MAAM,EAAE,CAAC;IACnB,MAAM,CAAC,EAAE,MAAM,EAAE,CAAC;IAClB,IAAI,CAAC,EAAE,MAAM,GAAG,IAAI,CAAC;IACrB,OAAO,CAAC,EAAE,MAAM,EAAE,CAAC;CACpB,CAAC;AAEF,cAAM,sBAAuB,SAAQ,WAAW;IAC9C,IAAI,EAAE,MAAM,CAAC;IAEb,MAAM,EAAE,MAAM,CAAC;gBAGb,IAAI,EAAE,MAAM,EACZ,MAAM,EAAE,MAAM,EACd,MAAM,EAAE,KAAK,EAAE,EACf,OAAO,EAAE,MAAM,EAAE,EACjB,OAAO,GAAE,WAAgB;IAoB3B;;;;;;;;;OASG;IACH,oBAAoB,CAAC,KAAK,EAAE,MAAM,EAAE,EAAE,YAAY,EAAE,OAAO;IAe3D;;;;;;OAMG;IACH,kBAAkB,CAAC,KAAK,EAAE,MAAM,EAAE;IAiClC,qBAAqB,CAAC,MAAM,EAAE,MAAM,GAAG,MAAM;IA0C7C;;;;;;;;;;OAUG;IACH,uBAAuB,CAAC,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,OAAO,GAAG,MAAM;IAsCjE;;;;;;;;;;OAUG;IACH,MAAM,CAAC,eAAe,CAAC,GAAG,EAAE,MAAM,EAAE,OAAO,EAAE,OAAO,GAAG,sBAAsB;IAiB7E;;;;;;;OAOG;IACH,WAAW,CAAC,OAAO,EAAE,OAAO,GAAG,IAAI;CAsDpC;AAED,eAAe,sBAAsB,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/models/create_token_transaction.js b/node_modules/@hathor/wallet-lib/oldLib/models/create_token_transaction.js
new file mode 100644
index 0000000..dbecfa0
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/models/create_token_transaction.js
@@ -0,0 +1,268 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+var _buffer = _interopRequireDefault(require("buffer"));
+var _lodash = require("lodash");
+var _constants = require("../constants");
+var _buffer2 = require("../utils/buffer");
+var _input = _interopRequireDefault(require("./input"));
+var _output = _interopRequireDefault(require("./output"));
+var _transaction = _interopRequireDefault(require("./transaction"));
+var _errors = require("../errors");
+var _script_data = _interopRequireDefault(require("./script_data"));
+var _types = require("../wallet/types");
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
+function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
+function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+class CreateTokenTransaction extends _transaction.default {
+  constructor(name, symbol, inputs, outputs, options = {}) {
+    const defaultOptions = {
+      signalBits: _constants.DEFAULT_SIGNAL_BITS,
+      weight: 0,
+      nonce: 0,
+      timestamp: null,
+      parents: [],
+      tokens: [],
+      hash: null,
+      headers: []
+    };
+    const newOptions = Object.assign(defaultOptions, options);
+    super(inputs, outputs, newOptions);
+    _defineProperty(this, "name", void 0);
+    _defineProperty(this, "symbol", void 0);
+    this.version = _constants.CREATE_TOKEN_TX_VERSION;
+    this.name = name;
+    this.symbol = symbol;
+  }
+
+  /**
+   * Serialize funds fields
+   * signal bits, version, len inputs, len outputs, inputs, outputs and token info
+   *
+   * @param {Buffer[]} array Array of buffer to push the serialized fields
+   * @param {boolean} addInputData If should add input data when serializing it
+   *
+   * @memberof Transaction
+   * @inner
+   */
+  serializeFundsFields(array, addInputData) {
+    // Signal bits
+    array.push((0, _buffer2.intToBytes)(this.signalBits, 1));
+
+    // Tx version
+    array.push((0, _buffer2.intToBytes)(this.version, 1));
+
+    // Funds len and fields
+    this.serializeFundsFieldsLen(array);
+    this.serializeInputsOutputs(array, addInputData);
+
+    // Create token tx need to add extra information
+    this.serializeTokenInfo(array);
+  }
+
+  /**
+   * Serialize create token tx info to bytes
+   *
+   * @param {Buffer[]} array of bytes
+   * @memberof Transaction
+   * @inner
+   */
+  serializeTokenInfo(array) {
+    if (!this.name || !this.symbol) {
+      throw new _errors.CreateTokenTxInvalid('Token name and symbol are required when creating a new token');
+    }
+    if (this.name.length > _constants.MAX_TOKEN_NAME_SIZE) {
+      throw new _errors.CreateTokenTxInvalid(`Token name size is ${this.name.length} but maximum size is ${_constants.MAX_TOKEN_NAME_SIZE}`);
+    }
+    if (this.symbol.length > _constants.MAX_TOKEN_SYMBOL_SIZE) {
+      throw new _errors.CreateTokenTxInvalid(`Token symbol size is ${this.symbol.length} but maximum size is ${_constants.MAX_TOKEN_SYMBOL_SIZE}`);
+    }
+    const nameBytes = _buffer.default.Buffer.from(this.name, 'utf8');
+    const symbolBytes = _buffer.default.Buffer.from(this.symbol, 'utf8');
+    // Token info version
+    array.push((0, _buffer2.intToBytes)(_constants.TOKEN_INFO_VERSION, 1));
+    // Token name size
+    array.push((0, _buffer2.intToBytes)(nameBytes.length, 1));
+    // Token name
+    array.push(nameBytes);
+    // Token symbol size
+    array.push((0, _buffer2.intToBytes)(symbolBytes.length, 1));
+    // Token symbol
+    array.push(symbolBytes);
+  }
+  getTokenInfoFromBytes(srcBuf) {
+    let tokenInfoVersion;
+    let lenName;
+    let lenSymbol;
+    let bufName;
+    let bufSymbol;
+    // Copies buffer locally, not to change the original parameter
+    let buf = Buffer.from(srcBuf);
+
+    /* eslint-disable prefer-const -- To split these declarations into const + let would be confusing */
+    [tokenInfoVersion, buf] = (0, _buffer2.unpackToInt)(1, false, buf);
+    if (tokenInfoVersion !== _constants.TOKEN_INFO_VERSION) {
+      throw new _errors.CreateTokenTxInvalid(`Unknown token info version: ${tokenInfoVersion}`);
+    }
+    [lenName, buf] = (0, _buffer2.unpackToInt)(1, false, buf);
+    if (lenName > _constants.MAX_TOKEN_NAME_SIZE) {
+      throw new _errors.CreateTokenTxInvalid(`Token name size is ${lenName} but maximum size is ${_constants.MAX_TOKEN_NAME_SIZE}`);
+    }
+    [bufName, buf] = (0, _buffer2.unpackLen)(lenName, buf);
+    this.name = bufName.toString('utf-8');
+    [lenSymbol, buf] = (0, _buffer2.unpackToInt)(1, false, buf);
+    if (lenSymbol > _constants.MAX_TOKEN_SYMBOL_SIZE) {
+      throw new _errors.CreateTokenTxInvalid(`Token symbol size is ${lenSymbol} but maximum size is ${_constants.MAX_TOKEN_SYMBOL_SIZE}`);
+    }
+    [bufSymbol, buf] = (0, _buffer2.unpackLen)(lenSymbol, buf);
+    this.symbol = bufSymbol.toString('utf-8');
+    /* eslint-enable prefer-const */
+
+    return buf;
+  }
+
+  /**
+   * Gets funds fields (signalBits, version, inputs, outputs) from bytes
+   * and saves them in `this`
+   *
+   * @param srcBuf Buffer with bytes to get fields
+   * @param network Network to get output addresses first byte
+   *
+   * @return Rest of buffer after getting the fields
+   * @memberof CreateTokenTransaction
+   * @inner
+   */
+  getFundsFieldsFromBytes(srcBuf, network) {
+    // Copies buffer locally, not to change the original parameter
+    let buf = Buffer.from(srcBuf);
+
+    // Signal bits
+    [this.signalBits, buf] = (0, _buffer2.unpackToInt)(1, false, buf);
+
+    // Tx version
+    [this.version, buf] = (0, _buffer2.unpackToInt)(1, false, buf);
+    let lenInputs;
+    let lenOutputs;
+
+    // Len inputs
+    // eslint-disable-next-line prefer-const -- To split this declaration would be confusing
+    [lenInputs, buf] = (0, _buffer2.unpackToInt)(1, false, buf);
+
+    // Len outputs
+    // eslint-disable-next-line prefer-const -- To split this declaration would be confusing
+    [lenOutputs, buf] = (0, _buffer2.unpackToInt)(1, false, buf);
+
+    // Inputs array
+    for (let i = 0; i < lenInputs; i++) {
+      let input;
+      [input, buf] = _input.default.createFromBytes(buf);
+      this.inputs.push(input);
+    }
+
+    // Outputs array
+    for (let i = 0; i < lenOutputs; i++) {
+      let output;
+      [output, buf] = _output.default.createFromBytes(buf, network);
+      this.outputs.push(output);
+    }
+    return buf;
+  }
+
+  /**
+   * Create transaction object from bytes
+   *
+   * @param {Buffer} buf Buffer with bytes to get transaction fields
+   * @param {Network} network Network to get output addresses first byte
+   *
+   * @return {CreateTokenTransaction} Transaction object
+   * @memberof CreateTokenTransaction
+   * @static
+   * @inner
+   */
+  static createFromBytes(buf, network) {
+    const tx = new CreateTokenTransaction('', '', [], []);
+
+    // Cloning buffer so we don't mutate anything sent by the user
+    // as soon as it's available natively we should use an immutable buffer
+    let txBuffer = (0, _lodash.clone)(buf);
+    txBuffer = tx.getFundsFieldsFromBytes(txBuffer, network);
+    txBuffer = tx.getTokenInfoFromBytes(txBuffer);
+    txBuffer = tx.getGraphFieldsFromBytes(txBuffer);
+    tx.getHeadersFromBytes(txBuffer, network);
+    tx.updateHash();
+    return tx;
+  }
+
+  /**
+   * Checks if this transaction is the creation of an NFT following the NFT Standard Creation.
+   * @see https://github.com/HathorNetwork/rfcs/blob/master/text/0032-nft-standard.md#transaction-standard
+   * @throws {NftValidationError} Will throw an error if the NFT is not valid
+   *
+   * @param {Network} network Network to get output addresses first byte
+   * @returns {void} If this function does not throw, the NFT is valid
+   */
+  validateNft(network) {
+    // An invalid transaction will fail here too
+    this.validate();
+
+    // No need to check the tx version, it is enforced by the class constructor
+
+    /*
+     * NFT creation must have at least a DataScript output (the first one) and a Token P2PKH output.
+     * Also validating maximum outputs of transactions in general
+     */
+    if (this.outputs.length < 2) {
+      throw new _errors.NftValidationError(`Tx has less than the minimum required amount of outputs`);
+    }
+
+    // Validating the first output
+    const firstOutput = this.outputs[0];
+
+    // NFT creation DataScript output must have value 1 and must be of HTR
+    if (firstOutput.value !== 1n || !firstOutput.isTokenHTR()) {
+      throw new _errors.NftValidationError(`First output is not a valid NFT data output`);
+    }
+    // NFT creation Datascript must be of type data
+    if (!(firstOutput.parseScript(network) instanceof _script_data.default)) {
+      throw new _errors.NftValidationError(`First output is not a DataScript`);
+    }
+
+    // Iterating on all but the first output for validation and counting authorities
+    let mintOutputs = 0;
+    let meltOutputs = 0;
+    for (let index = 1; index < this.outputs.length; ++index) {
+      const output = this.outputs[index];
+
+      // Must have a valid length
+      if (!output.hasValidLength()) {
+        throw new _errors.InvalidOutputsError(`Output at index ${index} script is too long.`);
+      }
+
+      // Ensuring the type of the output is valid
+      const validTypes = [_types.OutputType.P2PKH.toString(), _types.OutputType.P2SH.toString()];
+      const outputType = output.getType(network)?.toLowerCase() || '';
+      if (!validTypes.includes(outputType)) {
+        throw new _errors.NftValidationError(`Output at index ${index} is not of a valid type`);
+      }
+
+      // Counting authority outputs
+      mintOutputs += output.isMint() ? 1 : 0;
+      meltOutputs += output.isMelt() ? 1 : 0;
+    }
+
+    // Validating maximum of 1 mint and/or melt outputs
+    if (mintOutputs > 1 || meltOutputs > 1) {
+      throw new _errors.NftValidationError('A maximum of 1 of each mint and melt is allowed');
+    }
+  }
+}
+var _default = exports.default = CreateTokenTransaction;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/models/input.d.ts b/node_modules/@hathor/wallet-lib/oldLib/models/input.d.ts
new file mode 100644
index 0000000..3cabef4
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/models/input.d.ts
@@ -0,0 +1,42 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/// <reference types="node" />
+type optionsType = {
+    data?: Buffer | null | undefined;
+};
+declare class Input {
+    hash: string;
+    index: number;
+    data: Buffer | null;
+    constructor(hash: string, index: number, options?: optionsType);
+    /**
+     * Serialize an input to bytes
+     *
+     * @param {boolean} addData If should add the input data to the serialization
+     * The data is not used to sign/verify the transaction (see https://github.com/HathorNetwork/rfcs/blob/master/text/0015-anatomy-of-tx.md)
+     * thus it's important to have this parameter and not add the data to serialization when getting the transaction data to sign
+     *
+     * @return {Buffer[]}
+     * @memberof Input
+     * @inner
+     */
+    serialize(addData?: boolean): Buffer[];
+    setData(data: Buffer): void;
+    /**
+     * Create input object from bytes
+     *
+     * @param {Buffer} buf Buffer with bytes to get input fields
+     *
+     * @return {[Input, Buffer]} Created input and rest of buffer bytes
+     * @memberof Input
+     * @static
+     * @inner
+     */
+    static createFromBytes(buf: Buffer): [Input, Buffer];
+}
+export default Input;
+//# sourceMappingURL=input.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/models/input.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/models/input.d.ts.map
new file mode 100644
index 0000000..cbabdd0
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/models/input.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"input.d.ts","sourceRoot":"","sources":["../../src/models/input.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;;AAMH,KAAK,WAAW,GAAG;IACjB,IAAI,CAAC,EAAE,MAAM,GAAG,IAAI,GAAG,SAAS,CAAC;CAClC,CAAC;AAEF,cAAM,KAAK;IAET,IAAI,EAAE,MAAM,CAAC;IAGb,KAAK,EAAE,MAAM,CAAC;IAGd,IAAI,EAAE,MAAM,GAAG,IAAI,CAAC;gBAER,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,OAAO,GAAE,WAAgB;IAoBlE;;;;;;;;;;OAUG;IACH,SAAS,CAAC,OAAO,GAAE,OAAc,GAAG,MAAM,EAAE;IAa5C,OAAO,CAAC,IAAI,EAAE,MAAM;IAIpB;;;;;;;;;OASG;IACH,MAAM,CAAC,eAAe,CAAC,GAAG,EAAE,MAAM,GAAG,CAAC,KAAK,EAAE,MAAM,CAAC;CA2BrD;AAED,eAAe,KAAK,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/models/input.js b/node_modules/@hathor/wallet-lib/oldLib/models/input.js
new file mode 100644
index 0000000..9922b2f
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/models/input.js
@@ -0,0 +1,111 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+var _lodash = _interopRequireDefault(require("lodash"));
+var _buffer = require("../utils/buffer");
+var _constants = require("../constants");
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
+function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
+function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+class Input {
+  constructor(hash, index, options = {}) {
+    // Hash of the transaction is being spent
+    _defineProperty(this, "hash", void 0);
+    // Index of the outputs array from the output being spent
+    _defineProperty(this, "index", void 0);
+    // Input signed data for P2PKH and redeemScript for P2SH
+    _defineProperty(this, "data", void 0);
+    const defaultOptions = {
+      data: null
+    };
+    const newOptions = Object.assign(defaultOptions, options);
+    const {
+      data
+    } = newOptions;
+    if (!hash) {
+      throw Error('You must provide a hash.');
+    }
+    if (Number.isNaN(index)) {
+      throw Error('You must provide an index.');
+    }
+    this.hash = hash;
+    this.index = index;
+    this.data = data;
+  }
+
+  /**
+   * Serialize an input to bytes
+   *
+   * @param {boolean} addData If should add the input data to the serialization
+   * The data is not used to sign/verify the transaction (see https://github.com/HathorNetwork/rfcs/blob/master/text/0015-anatomy-of-tx.md)
+   * thus it's important to have this parameter and not add the data to serialization when getting the transaction data to sign
+   *
+   * @return {Buffer[]}
+   * @memberof Input
+   * @inner
+   */
+  serialize(addData = true) {
+    const arr = [];
+    arr.push((0, _buffer.hexToBuffer)(this.hash));
+    arr.push((0, _buffer.intToBytes)(this.index, 1));
+    if (this.data && addData) {
+      arr.push((0, _buffer.intToBytes)(this.data.length, 2));
+      arr.push(this.data);
+    } else {
+      arr.push((0, _buffer.intToBytes)(0, 2));
+    }
+    return arr;
+  }
+  setData(data) {
+    this.data = data;
+  }
+
+  /**
+   * Create input object from bytes
+   *
+   * @param {Buffer} buf Buffer with bytes to get input fields
+   *
+   * @return {[Input, Buffer]} Created input and rest of buffer bytes
+   * @memberof Input
+   * @static
+   * @inner
+   */
+  static createFromBytes(buf) {
+    // Cloning buffer so we don't mutate anything sent by the user
+    let inputBuffer = _lodash.default.clone(buf);
+    let hash;
+    let index;
+    let dataLen;
+    let data;
+
+    /* eslint-disable prefer-const -- To split these declarations would be confusing.
+     * In all of them the first parameter should be a const and the second a let. */
+    // Hash
+    [hash, inputBuffer] = (0, _buffer.unpackToHex)(_constants.TX_HASH_SIZE_BYTES, inputBuffer);
+
+    // Index
+    [index, inputBuffer] = (0, _buffer.unpackToInt)(1, false, inputBuffer);
+
+    // Data
+    [dataLen, inputBuffer] = (0, _buffer.unpackToInt)(2, false, inputBuffer);
+    if (dataLen) {
+      [data, inputBuffer] = (0, _buffer.unpackLen)(dataLen, inputBuffer);
+    }
+    /* eslint-enable prefer-const */
+
+    const input = new Input(hash, index, {
+      data
+    });
+    return [input, inputBuffer];
+  }
+}
+var _default = exports.default = Input;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/models/network.d.ts b/node_modules/@hathor/wallet-lib/oldLib/models/network.d.ts
new file mode 100644
index 0000000..ec7c4d0
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/models/network.d.ts
@@ -0,0 +1,39 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+import { Networks } from 'bitcore-lib';
+type versionBytesType = {
+    p2pkh: number;
+    p2sh: number;
+};
+declare class Network {
+    name: string;
+    versionBytes: versionBytesType;
+    bitcoreNetwork: Networks;
+    constructor(name: string);
+    /**
+     * Validate the network name is valid
+     */
+    validateNetwork(): void;
+    /**
+     * Method created to keep compatibility with old Network class
+     */
+    getNetwork(): Networks;
+    /**
+     * Method created to keep compatibility with old Network class
+     */
+    getVersionBytes(): versionBytesType;
+    /**
+     * Method to check that a version byte is valid
+     */
+    isVersionByteValid(version: number): boolean;
+    /**
+     * Method created to keep compatibility with old Network class
+     */
+    setNetwork(name: string): void;
+}
+export default Network;
+//# sourceMappingURL=network.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/models/network.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/models/network.d.ts.map
new file mode 100644
index 0000000..2d3de3d
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/models/network.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"network.d.ts","sourceRoot":"","sources":["../../src/models/network.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;AAEH,OAAO,EAAE,QAAQ,EAAE,MAAM,aAAa,CAAC;AA2GvC,KAAK,gBAAgB,GAAG;IACtB,KAAK,EAAE,MAAM,CAAC;IACd,IAAI,EAAE,MAAM,CAAC;CACd,CAAC;AAEF,cAAM,OAAO;IAEX,IAAI,EAAE,MAAM,CAAC;IAGb,YAAY,EAAE,gBAAgB,CAAC;IAG/B,cAAc,EAAE,QAAQ,CAAC;gBAEb,IAAI,EAAE,MAAM;IAOxB;;OAEG;IACH,eAAe;IAQf;;OAEG;IACH,UAAU,IAAI,QAAQ;IAItB;;OAEG;IACH,eAAe,IAAI,gBAAgB;IAInC;;OAEG;IACH,kBAAkB,CAAC,OAAO,EAAE,MAAM,GAAG,OAAO;IAK5C;;OAEG;IACH,UAAU,CAAC,IAAI,EAAE,MAAM;CAMxB;AAED,eAAe,OAAO,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/models/network.js b/node_modules/@hathor/wallet-lib/oldLib/models/network.js
new file mode 100644
index 0000000..fd67021
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/models/network.js
@@ -0,0 +1,176 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+var _bitcoreLib = require("bitcore-lib");
+function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
+function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
+function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+// Version bytes for address generation
+// Mainnet: P2PKH will start with H and P2SH will start with h
+// Testnet: P2PKH will start with W and P2SH will start with w
+const versionBytes = {
+  mainnet: {
+    p2pkh: 0x28,
+    p2sh: 0x64,
+    xpriv: 0x03523b05,
+    // htpr
+    xpub: 0x0488b21e // xpub // 0x03523a9c -> htpb
+  },
+  testnet: {
+    p2pkh: 0x49,
+    p2sh: 0x87,
+    xpriv: 0x0434c8c4,
+    // tnpr
+    xpub: 0x0488b21e // xpub // 0x0434c85b -> tnpb
+  },
+  privatenet: {
+    p2pkh: 0x49,
+    p2sh: 0x87,
+    xpriv: 0x0434c8c4,
+    // tnpr
+    xpub: 0x0488b21e // xpub // 0x0434c85b -> tnpb
+  }
+};
+
+/* Networks is an object of the bitcore-lib
+  Some of it's parameters are not used by us (network parameters)
+  Parameters:
+    name: network name
+    alias: another name we can use as the network name
+    pubkeyhash: prefix for p2pkh addresses
+    scripthash: prefix for p2sh addresses
+    privatekey: prefix for private key WIF (Wallet Import Format)
+    bech32prefix: prefix for bech32 addresses (we will use 'bc' for both mainnet and testnet)
+    xpubkey: prefix for xpubkeys (we will use 'xpub' for both mainnet and testnet)
+    xprivkey: prefix for xprivkeys (we will use 'xprv' for both mainnet and testnet)
+    networkMagic: used to send messages through the network (not used by us but it's important to set for bitcore-lib, so we use the same as bitcoin)
+    port: used to connect to the network (not used by us but it's important to set for bitcore-lib, so we use the same as bitcoin)
+    dnsSeed: list of dns to connect (not used by us but it's important to set for bitcore-lib, so we use the same as bitcoin)
+
+  Bitcore internally maps these parameters to the networks, so having the same parameters as bitcoin's could pose an issue
+  Ideally we would remove bitcoin networks as to not have any conflicts, but the remove itself is having some issues https://github.com/bitpay/bitcore/issues/2400
+  # xprivkey
+    it's used as a metadata on the serialized HDPrivateKey, it does not affect the privateKey and derivated private keys (public keys as well)
+    internally, bitcore uses this to bind a HDPrivateKey to a network, since we have parameters in common with bitcoin's network, we are having some issues with bitcore
+    not keeping our networks on the HDPrivateKey object when deriving or instantiating from the seed.
+  # xpubkey
+    Very similar to xprivkey but for HDPublicKey
+  # privatekey
+    The privateKey works very similarly to xprivkey but for private keys, the first byte on the WIF format is this number.
+    This also does not appear to affect generated addresses (if we specify the network when generating the address)
+
+  # WARNING
+    Our primary concern is that the generated addresses would be affected, but our address util (hathor.walletUtils.getAddresses on utils/wallet.ts) instantiate the address with our network
+    this keeps the generated addresses as ours even if the network changes on the original HDPrivateKey object (or any other).
+    So remember to pass our network when changing to addresses (i.e. pubkey.toAddress(hathorNetwork)) or use our address util.
+    If you need to use the serialized format of the HDPrivateKey or HDPublicKey be aware that later we may stop using bitcoin's prefix in favor of hathor's prefix
+*/
+const mainnet = _bitcoreLib.Networks.add({
+  name: 'htr-mainnet',
+  alias: 'production',
+  pubkeyhash: versionBytes.mainnet.p2pkh,
+  privatekey: 0x80,
+  scripthash: versionBytes.mainnet.p2sh,
+  bech32prefix: 'ht',
+  xpubkey: versionBytes.mainnet.xpub,
+  xprivkey: versionBytes.mainnet.xpriv,
+  networkMagic: 0xf9beb4d9,
+  port: 8333,
+  dnsSeeds: []
+});
+const testnet = _bitcoreLib.Networks.add({
+  name: 'htr-testnet',
+  alias: 'test',
+  pubkeyhash: versionBytes.testnet.p2pkh,
+  privatekey: 0x80,
+  scripthash: versionBytes.testnet.p2sh,
+  bech32prefix: 'tn',
+  xpubkey: versionBytes.testnet.xpub,
+  xprivkey: versionBytes.testnet.xpriv,
+  networkMagic: 0xf9beb4d9,
+  port: 8333,
+  dnsSeeds: []
+});
+const privatenet = _bitcoreLib.Networks.add({
+  name: 'htr-privatenet',
+  alias: 'privatenet',
+  pubkeyhash: versionBytes.privatenet.p2pkh,
+  privatekey: 0x80,
+  scripthash: versionBytes.privatenet.p2sh,
+  bech32prefix: 'tn',
+  xpubkey: versionBytes.privatenet.xpub,
+  xprivkey: versionBytes.privatenet.xpriv,
+  networkMagic: 0xf9beb4d9,
+  port: 8333,
+  dnsSeeds: []
+});
+const networkOptions = {
+  testnet,
+  mainnet,
+  privatenet
+};
+class Network {
+  constructor(name) {
+    // Network name (currently supports only 'testnet' and 'mainnet')
+    _defineProperty(this, "name", void 0);
+    // Version bytes of the network for the p2pkh and p2sh addresses
+    _defineProperty(this, "versionBytes", void 0);
+    // bitcore-lib Networks object with all network options
+    _defineProperty(this, "bitcoreNetwork", void 0);
+    this.name = name;
+    this.validateNetwork();
+    this.versionBytes = versionBytes[name];
+    this.bitcoreNetwork = networkOptions[name];
+  }
+
+  /**
+   * Validate the network name is valid
+   */
+  validateNetwork() {
+    const possibleNetworks = Object.keys(networkOptions);
+    if (possibleNetworks.indexOf(this.name) < 0) {
+      throw new Error(`We currently support only [${possibleNetworks}] as network.`);
+    }
+  }
+
+  /**
+   * Method created to keep compatibility with old Network class
+   */
+  getNetwork() {
+    return this.bitcoreNetwork;
+  }
+
+  /**
+   * Method created to keep compatibility with old Network class
+   */
+  getVersionBytes() {
+    return this.versionBytes;
+  }
+
+  /**
+   * Method to check that a version byte is valid
+   */
+  isVersionByteValid(version) {
+    const instanceVersionBytes = this.getVersionBytes();
+    return version === instanceVersionBytes.p2pkh || version === instanceVersionBytes.p2sh;
+  }
+
+  /**
+   * Method created to keep compatibility with old Network class
+   */
+  setNetwork(name) {
+    this.name = name;
+    this.validateNetwork();
+    this.versionBytes = versionBytes[name];
+    this.bitcoreNetwork = networkOptions[name];
+  }
+}
+var _default = exports.default = Network;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/models/output.d.ts b/node_modules/@hathor/wallet-lib/oldLib/models/output.d.ts
new file mode 100644
index 0000000..faf6ad4
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/models/output.d.ts
@@ -0,0 +1,130 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/// <reference types="node" />
+import P2PKH from './p2pkh';
+import P2SH from './p2sh';
+import ScriptData from './script_data';
+import Network from './network';
+import { OutputValueType } from '../types';
+type optionsType = {
+    tokenData?: number | undefined;
+    timelock?: number | null | undefined;
+};
+/**
+ * Maximum length of an output script
+ * @type {number}
+ */
+export declare const MAXIMUM_SCRIPT_LENGTH: number;
+declare class Output {
+    value: OutputValueType;
+    tokenData: number;
+    script: Buffer;
+    decodedScript: P2PKH | P2SH | ScriptData | null;
+    constructor(value: OutputValueType, script: Buffer, options?: optionsType);
+    /**
+     * Get the bytes from the output value
+     * If value is above the maximum for 32 bits we get from 8 bytes, otherwise only 4 bytes
+     *
+     * @throws {OutputValueError} Will throw an error if output value is invalid
+     *
+     * @return {Buffer}
+     *
+     * @memberof Transaction
+     * @inner
+     */
+    valueToBytes(): Buffer;
+    /**
+     * Returns if output is authority
+     *
+     * @return {boolean} If it's an authority output or not
+     *
+     * @memberof Output
+     * @inner
+     */
+    isAuthority(): boolean;
+    /**
+     * Verifies if output is of mint
+     *
+     * @return {boolean} if output is mint
+     *
+     * @memberof Output
+     * @inner
+     */
+    isMint(): boolean;
+    /**
+     * Verifies if output is of melt
+     *
+     * @return {boolean} if output is melt
+     *
+     * @memberof Output
+     * @inner
+     */
+    isMelt(): boolean;
+    /**
+     * Get index of token list of the output.
+     * It already subtracts 1 from the final result,
+     * so if this returns 0, it's the first token, i.e.
+     * tokenData = 1, then getTokenIndex = 0.
+     * For HTR output (tokenData = 0) it will return -1.
+     *
+     * @return {number} Index of the token of this output
+     *
+     * @memberof Output
+     * @inner
+     */
+    getTokenIndex(): number;
+    /**
+     * Checks if this output refers to the HTR token
+     *
+     * @return {boolean} True if it is HTR
+     * @memberOf Output
+     * @inner
+     */
+    isTokenHTR(): boolean;
+    /**
+     * Serialize an output to bytes
+     *
+     * @return {Buffer[]}
+     * @memberof Output
+     * @inner
+     */
+    serialize(): Buffer[];
+    parseScript(network: Network): P2PKH | P2SH | ScriptData | null;
+    /**
+     * Create output object from bytes
+     *
+     * @param {Buffer} buf Buffer with bytes to get output fields
+     * @param {Network} network Network to get output addresses first byte
+     *
+     * @return {[Output, Buffer]} Created output and rest of buffer bytes
+     * @memberof Output
+     * @static
+     * @inner
+     */
+    static createFromBytes(buf: Buffer, network: Network): [Output, Buffer];
+    /**
+     * Checks if the script length is within the valid limits
+     *
+     * @returns {boolean} True if the script is within valid limits
+     *
+     * @memberof Output
+     * @inner
+     */
+    hasValidLength(): boolean;
+    /**
+     * Returns the type of the output, according to the specified network
+     *
+     * @param {Network} network Network to get output addresses first byte
+     * @returns {string} Output type
+     *
+     * @memberof Output
+     * @inner
+     */
+    getType(network: Network): string;
+}
+export default Output;
+//# sourceMappingURL=output.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/models/output.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/models/output.d.ts.map
new file mode 100644
index 0000000..ab4dd01
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/models/output.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"output.d.ts","sourceRoot":"","sources":["../../src/models/output.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;;AAUH,OAAO,KAAK,MAAM,SAAS,CAAC;AAC5B,OAAO,IAAI,MAAM,QAAQ,CAAC;AAC1B,OAAO,UAAU,MAAM,eAAe,CAAC;AACvC,OAAO,OAAO,MAAM,WAAW,CAAC;AAShC,OAAO,EAAE,eAAe,EAAE,MAAM,UAAU,CAAC;AAE3C,KAAK,WAAW,GAAG;IACjB,SAAS,CAAC,EAAE,MAAM,GAAG,SAAS,CAAC;IAE/B,QAAQ,CAAC,EAAE,MAAM,GAAG,IAAI,GAAG,SAAS,CAAC;CACtC,CAAC;AAEF;;;GAGG;AACH,eAAO,MAAM,qBAAqB,EAAE,MAAY,CAAC;AAEjD,cAAM,MAAM;IAEV,KAAK,EAAE,eAAe,CAAC;IAGvB,SAAS,EAAE,MAAM,CAAC;IAGlB,MAAM,EAAE,MAAM,CAAC;IAGf,aAAa,EAAE,KAAK,GAAG,IAAI,GAAG,UAAU,GAAG,IAAI,CAAC;gBAEpC,KAAK,EAAE,eAAe,EAAE,MAAM,EAAE,MAAM,EAAE,OAAO,GAAE,WAAgB;IAsB7E;;;;;;;;;;OAUG;IACH,YAAY,IAAI,MAAM;IAItB;;;;;;;OAOG;IACH,WAAW,IAAI,OAAO;IAItB;;;;;;;OAOG;IACH,MAAM,IAAI,OAAO;IAIjB;;;;;;;OAOG;IACH,MAAM,IAAI,OAAO;IAIjB;;;;;;;;;;;OAWG;IACH,aAAa,IAAI,MAAM;IAIvB;;;;;;OAMG;IACH,UAAU,IAAI,OAAO;IAIrB;;;;;;OAMG;IACH,SAAS,IAAI,MAAM,EAAE;IAUrB,WAAW,CAAC,OAAO,EAAE,OAAO,GAAG,KAAK,GAAG,IAAI,GAAG,UAAU,GAAG,IAAI;IAK/D;;;;;;;;;;OAUG;IACH,MAAM,CAAC,eAAe,CAAC,GAAG,EAAE,MAAM,EAAE,OAAO,EAAE,OAAO,GAAG,CAAC,MAAM,EAAE,MAAM,CAAC;IA4BvE;;;;;;;OAOG;IACH,cAAc,IAAI,OAAO;IAKzB;;;;;;;;OAQG;IACH,OAAO,CAAC,OAAO,EAAE,OAAO,GAAG,MAAM;CAIlC;AAED,eAAe,MAAM,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/models/output.js b/node_modules/@hathor/wallet-lib/oldLib/models/output.js
new file mode 100644
index 0000000..72d2413
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/models/output.js
@@ -0,0 +1,220 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = exports.MAXIMUM_SCRIPT_LENGTH = void 0;
+var _lodash = _interopRequireDefault(require("lodash"));
+var _constants = require("../constants");
+var _errors = require("../errors");
+var _buffer = require("../utils/buffer");
+var _scripts = require("../utils/scripts");
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
+function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
+function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/**
+ * Maximum length of an output script
+ * @type {number}
+ */
+const MAXIMUM_SCRIPT_LENGTH = exports.MAXIMUM_SCRIPT_LENGTH = 256;
+class Output {
+  constructor(value, script, options = {}) {
+    // Output value as an integer
+    _defineProperty(this, "value", void 0);
+    // tokenData of the output
+    _defineProperty(this, "tokenData", void 0);
+    // Output script
+    _defineProperty(this, "script", void 0);
+    // Decoded output script
+    _defineProperty(this, "decodedScript", void 0);
+    const defaultOptions = {
+      tokenData: 0
+    };
+    const newOptions = Object.assign(defaultOptions, options);
+    const {
+      tokenData
+    } = newOptions;
+    if (!value) {
+      throw new _errors.OutputValueError('Value must be a positive number.');
+    }
+    if (!script) {
+      throw Error('You must provide a script.');
+    }
+    this.value = value;
+    this.script = script;
+    this.tokenData = tokenData;
+    this.decodedScript = null;
+  }
+
+  /**
+   * Get the bytes from the output value
+   * If value is above the maximum for 32 bits we get from 8 bytes, otherwise only 4 bytes
+   *
+   * @throws {OutputValueError} Will throw an error if output value is invalid
+   *
+   * @return {Buffer}
+   *
+   * @memberof Transaction
+   * @inner
+   */
+  valueToBytes() {
+    return (0, _buffer.outputValueToBytes)(this.value);
+  }
+
+  /**
+   * Returns if output is authority
+   *
+   * @return {boolean} If it's an authority output or not
+   *
+   * @memberof Output
+   * @inner
+   */
+  isAuthority() {
+    return (this.tokenData & _constants.TOKEN_AUTHORITY_MASK) > 0;
+  }
+
+  /**
+   * Verifies if output is of mint
+   *
+   * @return {boolean} if output is mint
+   *
+   * @memberof Output
+   * @inner
+   */
+  isMint() {
+    return this.isAuthority() && (this.value & _constants.TOKEN_MINT_MASK) > 0;
+  }
+
+  /**
+   * Verifies if output is of melt
+   *
+   * @return {boolean} if output is melt
+   *
+   * @memberof Output
+   * @inner
+   */
+  isMelt() {
+    return this.isAuthority() && (this.value & _constants.TOKEN_MELT_MASK) > 0;
+  }
+
+  /**
+   * Get index of token list of the output.
+   * It already subtracts 1 from the final result,
+   * so if this returns 0, it's the first token, i.e.
+   * tokenData = 1, then getTokenIndex = 0.
+   * For HTR output (tokenData = 0) it will return -1.
+   *
+   * @return {number} Index of the token of this output
+   *
+   * @memberof Output
+   * @inner
+   */
+  getTokenIndex() {
+    return (this.tokenData & _constants.TOKEN_INDEX_MASK) - 1;
+  }
+
+  /**
+   * Checks if this output refers to the HTR token
+   *
+   * @return {boolean} True if it is HTR
+   * @memberOf Output
+   * @inner
+   */
+  isTokenHTR() {
+    return this.getTokenIndex() === -1;
+  }
+
+  /**
+   * Serialize an output to bytes
+   *
+   * @return {Buffer[]}
+   * @memberof Output
+   * @inner
+   */
+  serialize() {
+    const arr = [];
+    arr.push(this.valueToBytes());
+    // Token data
+    arr.push((0, _buffer.intToBytes)(this.tokenData, 1));
+    arr.push((0, _buffer.intToBytes)(this.script.length, 2));
+    arr.push(this.script);
+    return arr;
+  }
+  parseScript(network) {
+    this.decodedScript = (0, _scripts.parseScript)(this.script, network);
+    return this.decodedScript;
+  }
+
+  /**
+   * Create output object from bytes
+   *
+   * @param {Buffer} buf Buffer with bytes to get output fields
+   * @param {Network} network Network to get output addresses first byte
+   *
+   * @return {[Output, Buffer]} Created output and rest of buffer bytes
+   * @memberof Output
+   * @static
+   * @inner
+   */
+  static createFromBytes(buf, network) {
+    // Cloning buffer so we don't mutate anything sent by the user
+    let outputBuffer = _lodash.default.clone(buf);
+    let value;
+    let tokenData;
+    let scriptLen;
+    let script;
+
+    /* eslint-disable prefer-const -- To split these declarations would be confusing.
+     * In all of them the first parameter should be a const and the second a let. */
+    // Value
+    [value, outputBuffer] = (0, _buffer.bytesToOutputValue)(outputBuffer);
+
+    // Token data
+    [tokenData, outputBuffer] = (0, _buffer.unpackToInt)(1, false, outputBuffer);
+
+    // Script
+    [scriptLen, outputBuffer] = (0, _buffer.unpackToInt)(2, false, outputBuffer);
+    [script, outputBuffer] = (0, _buffer.unpackLen)(scriptLen, outputBuffer);
+    /* eslint-enable prefer-const */
+
+    const output = new Output(value, script, {
+      tokenData
+    });
+    output.parseScript(network);
+    return [output, outputBuffer];
+  }
+
+  /**
+   * Checks if the script length is within the valid limits
+   *
+   * @returns {boolean} True if the script is within valid limits
+   *
+   * @memberof Output
+   * @inner
+   */
+  hasValidLength() {
+    // No script can have more than the maximum length
+    return this.script.length <= MAXIMUM_SCRIPT_LENGTH;
+  }
+
+  /**
+   * Returns the type of the output, according to the specified network
+   *
+   * @param {Network} network Network to get output addresses first byte
+   * @returns {string} Output type
+   *
+   * @memberof Output
+   * @inner
+   */
+  getType(network) {
+    const decodedScript = this.decodedScript || this.parseScript(network);
+    return decodedScript?.getType() || '';
+  }
+}
+var _default = exports.default = Output;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/models/p2pkh.d.ts b/node_modules/@hathor/wallet-lib/oldLib/models/p2pkh.d.ts
new file mode 100644
index 0000000..da05efe
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/models/p2pkh.d.ts
@@ -0,0 +1,49 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/// <reference types="node" />
+import Address from './address';
+import { IHistoryOutputDecoded } from '../types';
+type optionsType = {
+    timelock?: number | null | undefined;
+};
+declare class P2PKH {
+    address: Address;
+    timelock: number | null;
+    constructor(address: Address, options?: optionsType);
+    /**
+     * Get script type
+     *
+     * @return {string}
+     * @memberof P2PKH
+     * @inner
+     */
+    getType(): 'p2pkh';
+    /**
+     * Create a P2PKH script
+     *
+     * @return {Buffer}
+     * @memberof P2PKH
+     * @inner
+     */
+    createScript(): Buffer;
+    /**
+     * Build the original decoded script
+     */
+    toData(): IHistoryOutputDecoded;
+    /**
+     * Identify a script as P2PKH or not.
+     *
+     * @param {Buffer} buf Script as buffer.
+     *
+     * @return {Boolean}
+     * @memberof P2PKH
+     * @inner
+     */
+    static identify(buf: Buffer): boolean;
+}
+export default P2PKH;
+//# sourceMappingURL=p2pkh.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/models/p2pkh.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/models/p2pkh.d.ts.map
new file mode 100644
index 0000000..b82671a
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/models/p2pkh.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"p2pkh.d.ts","sourceRoot":"","sources":["../../src/models/p2pkh.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;;AAYH,OAAO,OAAO,MAAM,WAAW,CAAC;AAChC,OAAO,EAAE,qBAAqB,EAAE,MAAM,UAAU,CAAC;AAEjD,KAAK,WAAW,GAAG;IACjB,QAAQ,CAAC,EAAE,MAAM,GAAG,IAAI,GAAG,SAAS,CAAC;CACtC,CAAC;AAEF,cAAM,KAAK;IAET,OAAO,EAAE,OAAO,CAAC;IAGjB,QAAQ,EAAE,MAAM,GAAG,IAAI,CAAC;gBAEZ,OAAO,EAAE,OAAO,EAAE,OAAO,GAAE,WAAgB;IAgBvD;;;;;;OAMG;IAEH,OAAO,IAAI,OAAO;IAIlB;;;;;;OAMG;IACH,YAAY,IAAI,MAAM;IAmBtB;;OAEG;IACH,MAAM,IAAI,qBAAqB;IAQ/B;;;;;;;;OAQG;IACH,MAAM,CAAC,QAAQ,CAAC,GAAG,EAAE,MAAM,GAAG,OAAO;CAsCtC;AAED,eAAe,KAAK,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/models/p2pkh.js b/node_modules/@hathor/wallet-lib/oldLib/models/p2pkh.js
new file mode 100644
index 0000000..f2a4745
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/models/p2pkh.js
@@ -0,0 +1,137 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+var _bitcoreLib = require("bitcore-lib");
+var _opcodes = require("../opcodes");
+var _buffer = require("../utils/buffer");
+var _helpers = _interopRequireDefault(require("../utils/helpers"));
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
+function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
+function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+class P2PKH {
+  constructor(address, options = {}) {
+    // Address object of the value destination
+    _defineProperty(this, "address", void 0);
+    // Timestamp of the timelock of the output
+    _defineProperty(this, "timelock", void 0);
+    const defaultOptions = {
+      timelock: null
+    };
+    const newOptions = Object.assign(defaultOptions, options);
+    const {
+      timelock
+    } = newOptions;
+    if (!address) {
+      throw Error('You must provide an address.');
+    }
+    this.address = address;
+    this.timelock = timelock;
+  }
+
+  /**
+   * Get script type
+   *
+   * @return {string}
+   * @memberof P2PKH
+   * @inner
+   */
+  // eslint-disable-next-line class-methods-use-this -- This method returns a hardcoded constant
+  getType() {
+    return 'p2pkh';
+  }
+
+  /**
+   * Create a P2PKH script
+   *
+   * @return {Buffer}
+   * @memberof P2PKH
+   * @inner
+   */
+  createScript() {
+    const arr = [];
+    const addressBytes = this.address.decode();
+    const addressHash = addressBytes.slice(1, -4);
+    if (this.timelock) {
+      const timelockBytes = (0, _buffer.intToBytes)(this.timelock, 4);
+      _helpers.default.pushDataToStack(arr, timelockBytes);
+      arr.push(_opcodes.OP_GREATERTHAN_TIMESTAMP);
+    }
+    arr.push(_opcodes.OP_DUP);
+    arr.push(_opcodes.OP_HASH160);
+    // addressHash has a fixed size of 20 bytes, so no need to push OP_PUSHDATA1
+    arr.push((0, _buffer.intToBytes)(addressHash.length, 1));
+    arr.push(addressHash);
+    arr.push(_opcodes.OP_EQUALVERIFY);
+    arr.push(_opcodes.OP_CHECKSIG);
+    return _bitcoreLib.util.buffer.concat(arr);
+  }
+
+  /**
+   * Build the original decoded script
+   */
+  toData() {
+    return {
+      type: this.getType().toUpperCase(),
+      address: this.address.base58,
+      timelock: this.timelock
+    };
+  }
+
+  /**
+   * Identify a script as P2PKH or not.
+   *
+   * @param {Buffer} buf Script as buffer.
+   *
+   * @return {Boolean}
+   * @memberof P2PKH
+   * @inner
+   */
+  static identify(buf) {
+    const op_greaterthan_timestamp = _opcodes.OP_GREATERTHAN_TIMESTAMP.readUInt8(0);
+    const op_dup = _opcodes.OP_DUP.readUInt8(0);
+    const op_hash160 = _opcodes.OP_HASH160.readUInt8(0);
+    const op_equalverify = _opcodes.OP_EQUALVERIFY.readUInt8(0);
+    const op_checksig = _opcodes.OP_CHECKSIG.readUInt8(0);
+    if (buf.length !== 31 && buf.length !== 25) {
+      // this is not a P2PKH script
+      return false;
+    }
+    let ptr = 0;
+    if (buf.length === 31) {
+      // with timelock, we begin with timestamp
+      if (buf.readUInt8(ptr++) !== 4) {
+        return false;
+      }
+      ptr += 4;
+      // next byte is OP_GREATERTHAN_TIMESTAMP
+      if (buf.readUInt8(ptr++) !== op_greaterthan_timestamp) {
+        return false;
+      }
+    }
+
+    // OP_DUP OP_HASH160
+    if (buf.readUInt8(ptr++) !== op_dup || buf.readUInt8(ptr++) !== op_hash160) {
+      return false;
+    }
+    // address hash
+    if (buf.readUInt8(ptr++) !== 20) {
+      return false;
+    }
+    ptr += 20;
+    // OP_EQUALVERIFY OP_CHECKSIG
+    if (buf.readUInt8(ptr++) !== op_equalverify || buf.readUInt8(ptr++) !== op_checksig) {
+      return false;
+    }
+    return true;
+  }
+}
+var _default = exports.default = P2PKH;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/models/p2sh.d.ts b/node_modules/@hathor/wallet-lib/oldLib/models/p2sh.d.ts
new file mode 100644
index 0000000..03dda14
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/models/p2sh.d.ts
@@ -0,0 +1,49 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/// <reference types="node" />
+import Address from './address';
+import { IHistoryOutputDecoded } from '../types';
+type optionsType = {
+    timelock?: number | null | undefined;
+};
+declare class P2SH {
+    address: Address;
+    timelock: number | null;
+    constructor(address: Address, options?: optionsType);
+    /**
+     * Get script type
+     *
+     * @return {string}
+     * @memberof P2SH
+     * @inner
+     */
+    getType(): 'p2sh';
+    /**
+     * Build the original decoded script
+     */
+    toData(): IHistoryOutputDecoded;
+    /**
+     * Create a P2SH script
+     *
+     * @return {Buffer}
+     * @memberof P2SH
+     * @inner
+     */
+    createScript(): Buffer;
+    /**
+     * Identify a script as P2SH or not.
+     *
+     * @param {Buffer} buf Script as buffer.
+     *
+     * @return {Boolean}
+     * @memberof P2SH
+     * @inner
+     */
+    static identify(buf: Buffer): boolean;
+}
+export default P2SH;
+//# sourceMappingURL=p2sh.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/models/p2sh.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/models/p2sh.d.ts.map
new file mode 100644
index 0000000..f2ee385
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/models/p2sh.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"p2sh.d.ts","sourceRoot":"","sources":["../../src/models/p2sh.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;;AAMH,OAAO,OAAO,MAAM,WAAW,CAAC;AAChC,OAAO,EAAE,qBAAqB,EAAE,MAAM,UAAU,CAAC;AAEjD,KAAK,WAAW,GAAG;IACjB,QAAQ,CAAC,EAAE,MAAM,GAAG,IAAI,GAAG,SAAS,CAAC;CACtC,CAAC;AAEF,cAAM,IAAI;IAER,OAAO,EAAE,OAAO,CAAC;IAGjB,QAAQ,EAAE,MAAM,GAAG,IAAI,CAAC;gBAEZ,OAAO,EAAE,OAAO,EAAE,OAAO,GAAE,WAAgB;IAevD;;;;;;OAMG;IAEH,OAAO,IAAI,MAAM;IAIjB;;OAEG;IACH,MAAM,IAAI,qBAAqB;IAQ/B;;;;;;OAMG;IACH,YAAY,IAAI,MAAM;IAiBtB;;;;;;;;OAQG;IACH,MAAM,CAAC,QAAQ,CAAC,GAAG,EAAE,MAAM,GAAG,OAAO;CAoCtC;AAED,eAAe,IAAI,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/models/p2sh.js b/node_modules/@hathor/wallet-lib/oldLib/models/p2sh.js
new file mode 100644
index 0000000..06167f7
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/models/p2sh.js
@@ -0,0 +1,133 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+var _bitcoreLib = require("bitcore-lib");
+var _opcodes = require("../opcodes");
+var _helpers = _interopRequireDefault(require("../utils/helpers"));
+var _buffer = require("../utils/buffer");
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
+function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
+function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+class P2SH {
+  constructor(address, options = {}) {
+    // Address object of the value destination
+    _defineProperty(this, "address", void 0);
+    // Timestamp of the timelock of the output
+    _defineProperty(this, "timelock", void 0);
+    const newOptions = {
+      timelock: null,
+      ...options
+    };
+    const {
+      timelock
+    } = newOptions;
+    if (!address) {
+      throw Error('You must provide an address.');
+    }
+    this.address = address;
+    this.timelock = timelock;
+  }
+
+  /**
+   * Get script type
+   *
+   * @return {string}
+   * @memberof P2SH
+   * @inner
+   */
+  // eslint-disable-next-line class-methods-use-this -- This method returns a hardcoded constant
+  getType() {
+    return 'p2sh';
+  }
+
+  /**
+   * Build the original decoded script
+   */
+  toData() {
+    return {
+      type: this.getType().toUpperCase(),
+      address: this.address.base58,
+      timelock: this.timelock
+    };
+  }
+
+  /**
+   * Create a P2SH script
+   *
+   * @return {Buffer}
+   * @memberof P2SH
+   * @inner
+   */
+  createScript() {
+    const arr = [];
+    const addressBytes = this.address.decode();
+    const addressHash = addressBytes.slice(1, -4);
+    if (this.timelock) {
+      const timelockBytes = (0, _buffer.intToBytes)(this.timelock, 4);
+      _helpers.default.pushDataToStack(arr, timelockBytes);
+      arr.push(_opcodes.OP_GREATERTHAN_TIMESTAMP);
+    }
+    arr.push(_opcodes.OP_HASH160);
+    // addressHash has a fixed size of 20 bytes, so no need to push OP_PUSHDATA1
+    arr.push((0, _buffer.intToBytes)(addressHash.length, 1));
+    arr.push(addressHash);
+    arr.push(_opcodes.OP_EQUAL);
+    return _bitcoreLib.util.buffer.concat(arr);
+  }
+
+  /**
+   * Identify a script as P2SH or not.
+   *
+   * @param {Buffer} buf Script as buffer.
+   *
+   * @return {Boolean}
+   * @memberof P2SH
+   * @inner
+   */
+  static identify(buf) {
+    const op_greaterthan_timestamp = _opcodes.OP_GREATERTHAN_TIMESTAMP.readUInt8(0);
+    const op_hash160 = _opcodes.OP_HASH160.readUInt8(0);
+    const op_equal = _opcodes.OP_EQUAL.readUInt8(0);
+    if (buf.length !== 29 && buf.length !== 23) {
+      // this is not a P2PKH script
+      return false;
+    }
+    let ptr = 0;
+    if (buf.length === 29) {
+      // with timelock, we begin with timestamp
+      if (buf.readUInt8(ptr++) !== 4) {
+        return false;
+      }
+      ptr += 4;
+      // next byte is OP_GREATERTHAN_TIMESTAMP
+      if (buf.readUInt8(ptr++) !== op_greaterthan_timestamp) {
+        return false;
+      }
+    }
+
+    // OP_HASH160
+    if (buf.readUInt8(ptr++) !== op_hash160) {
+      return false;
+    }
+    // address hash
+    if (buf.readUInt8(ptr++) !== 20) {
+      return false;
+    }
+    ptr += 20;
+    // OP_EQUAL
+    if (buf.readUInt8(ptr++) !== op_equal) {
+      return false;
+    }
+    return true;
+  }
+}
+var _default = exports.default = P2SH;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/models/p2sh_signature.d.ts b/node_modules/@hathor/wallet-lib/oldLib/models/p2sh_signature.d.ts
new file mode 100644
index 0000000..70ee1e8
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/models/p2sh_signature.d.ts
@@ -0,0 +1,39 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/**
+ * This class purpose is serialization/deserialization of signatures from a MultiSig participant
+ * The structure of the serialized signature string is:
+ * "<pubkey>|<index>:<signature>|<index>:<signature>|..."
+ *
+ * The `pubkey` is required so we can identify the original signer (and his position on the redeemScript)
+ * The `<index>:<signature>` pair is the input index and the signature for that input.
+ * The signature is formatted to DER and hex encoded.
+ *
+ * With this information we will be able to encode the signatures for all inputs on one string.
+ * It also has all information needed to assemble the input data if you have enough participants' P2SHSignature serialized signatures.
+ */
+declare class P2SHSignature {
+    pubkey: string;
+    signatures: Record<number, string>;
+    constructor(pubkey: string, signatures: Record<number, string>);
+    /**
+     * Serialize P2SH signatures
+     *
+     * @memberof P2SHSignature
+     * @inner
+     */
+    serialize(): string;
+    /**
+     * Deserialize P2SH signatures
+     *
+     * @memberof P2SHSignature
+     * @static
+     */
+    static deserialize(p2shSig: string): P2SHSignature;
+}
+export default P2SHSignature;
+//# sourceMappingURL=p2sh_signature.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/models/p2sh_signature.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/models/p2sh_signature.d.ts.map
new file mode 100644
index 0000000..0e7c30d
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/models/p2sh_signature.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"p2sh_signature.d.ts","sourceRoot":"","sources":["../../src/models/p2sh_signature.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;AAEH;;;;;;;;;;;GAWG;AACH,cAAM,aAAa;IACjB,MAAM,EAAE,MAAM,CAAC;IAEf,UAAU,EAAE,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;gBAEvB,MAAM,EAAE,MAAM,EAAE,UAAU,EAAE,MAAM,CAAC,MAAM,EAAE,MAAM,CAAC;IAS9D;;;;;OAKG;IACH,SAAS;IAQT;;;;;OAKG;IACH,MAAM,CAAC,WAAW,CAAC,OAAO,EAAE,MAAM;CAUnC;AAED,eAAe,aAAa,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/models/p2sh_signature.js b/node_modules/@hathor/wallet-lib/oldLib/models/p2sh_signature.js
new file mode 100644
index 0000000..ef47b7b
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/models/p2sh_signature.js
@@ -0,0 +1,71 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
+function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
+function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+/**
+ * This class purpose is serialization/deserialization of signatures from a MultiSig participant
+ * The structure of the serialized signature string is:
+ * "<pubkey>|<index>:<signature>|<index>:<signature>|..."
+ *
+ * The `pubkey` is required so we can identify the original signer (and his position on the redeemScript)
+ * The `<index>:<signature>` pair is the input index and the signature for that input.
+ * The signature is formatted to DER and hex encoded.
+ *
+ * With this information we will be able to encode the signatures for all inputs on one string.
+ * It also has all information needed to assemble the input data if you have enough participants' P2SHSignature serialized signatures.
+ */
+class P2SHSignature {
+  constructor(pubkey, signatures) {
+    _defineProperty(this, "pubkey", void 0);
+    _defineProperty(this, "signatures", void 0);
+    if (!pubkey) {
+      throw Error('You must provide a pubkey.');
+    }
+    this.pubkey = pubkey;
+    this.signatures = signatures;
+  }
+
+  /**
+   * Serialize P2SH signatures
+   *
+   * @memberof P2SHSignature
+   * @inner
+   */
+  serialize() {
+    const arr = [this.pubkey];
+    for (const [index, sig] of Object.entries(this.signatures)) {
+      arr.push(`${index}:${sig}`);
+    }
+    return arr.join('|');
+  }
+
+  /**
+   * Deserialize P2SH signatures
+   *
+   * @memberof P2SHSignature
+   * @static
+   */
+  static deserialize(p2shSig) {
+    const arr = p2shSig.split('|');
+    const xpub = arr[0];
+    const signatures = {};
+    for (const sig of arr.slice(1)) {
+      const [key, value] = sig.split(':');
+      signatures[+key] = value;
+    }
+    return new P2SHSignature(xpub, signatures);
+  }
+}
+var _default = exports.default = P2SHSignature;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/models/partial_tx.d.ts b/node_modules/@hathor/wallet-lib/oldLib/models/partial_tx.d.ts
new file mode 100644
index 0000000..56cf4f8
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/models/partial_tx.d.ts
@@ -0,0 +1,258 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/// <reference types="node" />
+import Input from './input';
+import Output from './output';
+import Transaction from './transaction';
+import Network from './network';
+import { IDataInput, IDataOutput, IDataTx, OutputValueType } from '../types';
+/**
+ * Extended version of the Input class with extra data
+ * We need the extra data to calculate the balance of the PartialTx
+ */
+export declare class ProposalInput extends Input {
+    token: string;
+    authorities: OutputValueType;
+    value: OutputValueType;
+    address: string;
+    constructor(hash: string, index: number, value: OutputValueType, address: string, { token, authorities, }?: {
+        token?: string;
+        authorities?: OutputValueType;
+    });
+    /**
+     * Return an object with the relevant input data
+     *
+     * @return {IDataInput}
+     * @memberof ProposalInput
+     * @inner
+     */
+    toData(): IDataInput;
+    isAuthority(): boolean;
+}
+/**
+ * Extended version of the Output class with extra data
+ * We need the extra data to calculate the token_data of the
+ * output on the final transaction and to track which outputs are change.
+ */
+export declare class ProposalOutput extends Output {
+    token: string;
+    isChange: boolean;
+    authorities: OutputValueType;
+    constructor(value: OutputValueType, script: Buffer, { isChange, token, authorities, }?: {
+        token?: string;
+        isChange?: boolean;
+        authorities?: OutputValueType;
+    });
+    /**
+     * Set the value of the property tokenData
+     *
+     * @param {number} tokenData
+     */
+    setTokenData(tokenData: number): void;
+    /**
+     * Return an object with the relevant output data
+     *
+     * @param {number} tokenIndex Index of the token on the tokens array plus 1 (0 meaning HTR)
+     * @param {Network} network Network used to generate addresses in
+     *
+     * @returns {IDataOutput}
+     *
+     * @throws {UnsupportedScriptError} Script must be P2SH or P2PKH
+     * @memberof ProposalOutput
+     * @inner
+     */
+    toData(tokenIndex: number, network: Network): IDataOutput;
+}
+export declare const PartialTxPrefix = "PartialTx";
+/**
+ * This class purpose is to hold and modify the state of the partial transaction.
+ * It is also used to serialize and deserialize the partial transaction state.
+ */
+export declare class PartialTx {
+    inputs: ProposalInput[];
+    outputs: ProposalOutput[];
+    network: Network;
+    constructor(network: Network);
+    /**
+     * Convert the PartialTx into a complete TxData ready to be signed or serialized.
+     *
+     * @returns {TxData}
+     *
+     * @throws {UnsupportedScriptError} All output scripts must be P2SH or P2PKH
+     * @memberof PartialTx
+     * @inner
+     */
+    getTxData(): IDataTx;
+    /**
+     * Create a Transaction instance from the PartialTx.
+     *
+     * @returns {Transaction}
+     *
+     * @throws {UnsupportedScriptError} All output scripts must be P2SH or P2PKH
+     * @memberof PartialTx
+     * @inner
+     */
+    getTx(): Transaction;
+    /**
+     * Calculate balance for all tokens from inputs and outputs.
+     *
+     * @returns {Record<string, {inputs: number, outputs: number}}
+     * @memberof PartialTx
+     * @inner
+     */
+    calculateTokenBalance(): Record<string, {
+        inputs: OutputValueType;
+        outputs: OutputValueType;
+    }>;
+    /**
+     * Return true if the balance of the outputs match the balance of the inputs for all tokens.
+     *
+     * @returns {boolean}
+     * @memberof PartialTx
+     * @inner
+     */
+    isComplete(): boolean;
+    /**
+     * Add an UTXO as input on the PartialTx.
+     *
+     * @param {string} txId The transaction id of the UTXO.
+     * @param {number} index The index of the UTXO.
+     * @param {OutputValueType} value Value of the UTXO.
+     * @param {OutputValueType} authorities The authority information of the utxo.
+     * @param {string} address base58 address
+     * @param {Object} [options]
+     * @param {string} [options.token='00'] The token UID.
+     *
+     * @memberof PartialTx
+     * @inner
+     */
+    addInput(txId: string, index: number, value: OutputValueType, address: string, { token, authorities, }?: {
+        token?: string;
+        authorities?: OutputValueType;
+    }): void;
+    /**
+     * Add an output to the PartialTx.
+     *
+     * @param {OutputValueType} value The amount of tokens on the output.
+     * @param {Buffer} script The output script.
+     * @param {OutputValueType} authorities The authority information of the output.
+     * @param {Object} [options]
+     * @param {string} [options.token='00'] The token UID.
+     * @param {boolean|null} [options.isChange=false] isChange If this is a change output.
+     *
+     * @memberof PartialTx
+     * @inner
+     */
+    addOutput(value: OutputValueType, script: Buffer, { token, authorities, isChange, }?: {
+        token?: string;
+        isChange?: boolean;
+        authorities?: OutputValueType;
+    }): void;
+    /**
+     * Serialize the current PartialTx into an UTF8 string.
+     *
+     * The serialization will join 4 parts:
+     * - Fixed prefix
+     * - transaction: in hex format
+     * - inputs metadata: a colon-separated list of address, token, authorities and value
+     * - outputs metadata: change outputs indexes
+     *
+     * Example: PartialTx|00010102...ce|W...vjPi,00,0,1b:W...vjPi,0000389...8c,1,d|1:2
+     * Obs: ellipsis were used to abreviate long parts, there are no ellipsis on the serialized string
+     *
+     *
+     * @returns {string}
+     *
+     * @throws {UnsupportedScriptError} All output scripts must be P2SH or P2PKH
+     * @memberof PartialTx
+     * @inner
+     */
+    serialize(): string;
+    /**
+     * Deserialize and create an instance of PartialTx
+     *
+     * @param {string} serialized The serialized PartialTx
+     * @param {Network} network Network used when parsing the output scripts
+     *
+     * @returns {PartialTx}
+     *
+     * @throws {SyntaxError} serialized argument should be valid.
+     * @throws {UnsupportedScriptError} All outputs should be P2SH or P2PKH
+     * @memberof PartialTx
+     * @static
+     */
+    static deserialize(serialized: string, network: Network): PartialTx;
+    /**
+     * Check the content of the current PartialTx with the fullnode
+     *
+     * @returns {Promise<boolean>}
+     */
+    validate(): Promise<boolean>;
+}
+export declare const PartialTxInputDataPrefix = "PartialTxInputData";
+/**
+ * This class is meant to aggregate input data for a transaction.
+ *
+ * The `hash` is an identifier of the transaction (usually the dataToSign in hex format)
+ * this way any input data added should identify that it is from the same transaction.
+ *
+ * The input data is saved instead of the signature to allow collecting from MultiSig wallets
+ * since for an input we can have multiple signatures.
+ */
+export declare class PartialTxInputData {
+    data: Record<number, Buffer>;
+    hash: string;
+    inputsLen: number;
+    constructor(hash: string, inputsLen: number);
+    /**
+     * Add an input data to the record.
+     *
+     * @param {number} index The input index this data relates to.
+     * @param {Buffer} inputData Input data bytes.
+     *
+     * @throws {IndexOOBError} index should be inside the inputs array.
+     *
+     * @memberof PartialTxInputData
+     * @inner
+     */
+    addData(index: number, inputData: Buffer): void;
+    /**
+     * Return true if we have an input data for each input.
+     *
+     * @returns {boolean}
+     * @memberof PartialTxInputData
+     * @inner
+     */
+    isComplete(): boolean;
+    /**
+     * Serialize the current PartialTxInputData into an UTF8 string.
+     *
+     * The serialization will join 3 informations:
+     * - Fixed prefix
+     * - hash: to identify the transaction which these signatures belong to
+     * - inputs data: index and data
+     *
+     * Example: PartialTxInputData|000ca...fe|0:00abc|1:00123
+     * Obs: ellipsis is used to abreviate, there are no ellipsis on the serialized string
+     *
+     * @returns {string}
+     * @memberof PartialTxInputData
+     * @inner
+     */
+    serialize(): string;
+    /**
+     * Deserialize the PartialTxInputData and merge with local data.
+     *
+     * @param {string} serialized The serialized PartialTxInputData
+     *
+     * @throws {SyntaxError} serialized argument should be valid.
+     * @memberof PartialTxInputData
+     * @static
+     */
+    addSignatures(serialized: string): void;
+}
+//# sourceMappingURL=partial_tx.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/models/partial_tx.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/models/partial_tx.d.ts.map
new file mode 100644
index 0000000..8d96040
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/models/partial_tx.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"partial_tx.d.ts","sourceRoot":"","sources":["../../src/models/partial_tx.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/models/partial_tx.js b/node_modules/@hathor/wallet-lib/oldLib/models/partial_tx.js
new file mode 100644
index 0000000..50e27d6
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/models/partial_tx.js
@@ -0,0 +1,540 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.ProposalOutput = exports.ProposalInput = exports.PartialTxPrefix = exports.PartialTxInputDataPrefix = exports.PartialTxInputData = exports.PartialTx = void 0;
+var _lodash = require("lodash");
+var _input = _interopRequireDefault(require("./input"));
+var _output = _interopRequireDefault(require("./output"));
+var _p2pkh = _interopRequireDefault(require("./p2pkh"));
+var _p2sh = _interopRequireDefault(require("./p2sh"));
+var _transaction = _interopRequireDefault(require("../utils/transaction"));
+var _helpers = _interopRequireDefault(require("../utils/helpers"));
+var _errors = require("../errors");
+var _txApi = _interopRequireDefault(require("../api/txApi"));
+var _constants = require("../constants");
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
+function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
+function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */ // eslint-disable-next-line max-classes-per-file -- These classes are well organized within this file
+/**
+ * Extended version of the Input class with extra data
+ * We need the extra data to calculate the balance of the PartialTx
+ */
+class ProposalInput extends _input.default {
+  constructor(hash, index, value, address, {
+    token = _constants.NATIVE_TOKEN_UID,
+    authorities = 0n
+  } = {}) {
+    super(hash, index);
+    _defineProperty(this, "token", void 0);
+    _defineProperty(this, "authorities", void 0);
+    _defineProperty(this, "value", void 0);
+    _defineProperty(this, "address", void 0);
+    this.value = value;
+    this.authorities = authorities;
+    this.token = token;
+    this.address = address;
+  }
+
+  /**
+   * Return an object with the relevant input data
+   *
+   * @return {IDataInput}
+   * @memberof ProposalInput
+   * @inner
+   */
+  toData() {
+    const data = {
+      txId: this.hash,
+      index: this.index,
+      address: this.address,
+      token: this.token,
+      value: this.value,
+      authorities: this.authorities
+    };
+    if (this.data) {
+      data.data = this.data.toString('hex');
+    }
+    return data;
+  }
+  isAuthority() {
+    return this.authorities > 0;
+  }
+}
+
+/**
+ * Extended version of the Output class with extra data
+ * We need the extra data to calculate the token_data of the
+ * output on the final transaction and to track which outputs are change.
+ */
+exports.ProposalInput = ProposalInput;
+class ProposalOutput extends _output.default {
+  constructor(value, script, {
+    isChange = false,
+    token = _constants.NATIVE_TOKEN_UID,
+    authorities = 0n
+  } = {}) {
+    let tokenData = 0;
+    if (authorities > 0) {
+      tokenData |= _constants.TOKEN_AUTHORITY_MASK;
+    }
+    if (token !== _constants.NATIVE_TOKEN_UID) {
+      // We set this to avoid isTokenHTR from returning true
+      tokenData |= 1;
+    }
+    super(value, script, {
+      tokenData
+    });
+    _defineProperty(this, "token", void 0);
+    _defineProperty(this, "isChange", void 0);
+    _defineProperty(this, "authorities", void 0);
+    this.token = token;
+    this.isChange = isChange;
+    this.authorities = authorities;
+  }
+
+  /**
+   * Set the value of the property tokenData
+   *
+   * @param {number} tokenData
+   */
+  setTokenData(tokenData) {
+    this.tokenData = tokenData;
+  }
+
+  /**
+   * Return an object with the relevant output data
+   *
+   * @param {number} tokenIndex Index of the token on the tokens array plus 1 (0 meaning HTR)
+   * @param {Network} network Network used to generate addresses in
+   *
+   * @returns {IDataOutput}
+   *
+   * @throws {UnsupportedScriptError} Script must be P2SH or P2PKH
+   * @memberof ProposalOutput
+   * @inner
+   */
+  toData(tokenIndex, network) {
+    const script = this.parseScript(network);
+    if (!(script instanceof _p2pkh.default || script instanceof _p2sh.default)) {
+      throw new _errors.UnsupportedScriptError('Unsupported script type');
+    }
+    const tokenData = (this.authorities > 0 ? _constants.TOKEN_AUTHORITY_MASK : 0) | tokenIndex;
+
+    // This will keep authority bit while updating the index bits
+    this.setTokenData(tokenData);
+    const data = {
+      type: script.getType(),
+      value: this.value,
+      address: script.address.base58,
+      authorities: this.authorities,
+      token: this.token,
+      timelock: script.timelock
+    };
+    return data;
+  }
+}
+exports.ProposalOutput = ProposalOutput;
+const PartialTxPrefix = exports.PartialTxPrefix = 'PartialTx';
+/**
+ * This class purpose is to hold and modify the state of the partial transaction.
+ * It is also used to serialize and deserialize the partial transaction state.
+ */
+class PartialTx {
+  constructor(network) {
+    _defineProperty(this, "inputs", void 0);
+    _defineProperty(this, "outputs", void 0);
+    _defineProperty(this, "network", void 0);
+    this.inputs = [];
+    this.outputs = [];
+    this.network = network;
+  }
+
+  /**
+   * Convert the PartialTx into a complete TxData ready to be signed or serialized.
+   *
+   * @returns {TxData}
+   *
+   * @throws {UnsupportedScriptError} All output scripts must be P2SH or P2PKH
+   * @memberof PartialTx
+   * @inner
+   */
+  getTxData() {
+    const tokenSet = new Set();
+    for (const output of this.outputs) {
+      tokenSet.add(output.token);
+    }
+    for (const input of this.inputs) {
+      tokenSet.add(input.token);
+    }
+
+    // Remove HTR from tokens array
+    tokenSet.delete(_constants.NATIVE_TOKEN_UID);
+    const tokens = Array.from(tokenSet);
+    const data = {
+      version: _constants.DEFAULT_TX_VERSION,
+      tokens,
+      inputs: this.inputs.map(i => i.toData()),
+      outputs: this.outputs.map(o => o.toData(tokens.indexOf(o.token) + 1, this.network))
+    };
+    return data;
+  }
+
+  /**
+   * Create a Transaction instance from the PartialTx.
+   *
+   * @returns {Transaction}
+   *
+   * @throws {UnsupportedScriptError} All output scripts must be P2SH or P2PKH
+   * @memberof PartialTx
+   * @inner
+   */
+  getTx() {
+    return _transaction.default.createTransactionFromData(this.getTxData(), this.network);
+  }
+
+  /**
+   * Calculate balance for all tokens from inputs and outputs.
+   *
+   * @returns {Record<string, {inputs: number, outputs: number}}
+   * @memberof PartialTx
+   * @inner
+   */
+  calculateTokenBalance() {
+    const tokenBalance = {};
+    for (const input of this.inputs) {
+      if (!tokenBalance[input.token]) {
+        tokenBalance[input.token] = {
+          inputs: 0n,
+          outputs: 0n
+        };
+      }
+
+      // Ignore authority inputs for token balance
+      if (!input.isAuthority()) {
+        tokenBalance[input.token].inputs += input.value;
+      }
+    }
+    for (const output of this.outputs) {
+      if (!tokenBalance[output.token]) {
+        tokenBalance[output.token] = {
+          inputs: 0n,
+          outputs: 0n
+        };
+      }
+
+      // Ignore authority outputs for token balance
+      if (!output.isAuthority()) {
+        tokenBalance[output.token].outputs += output.value;
+      }
+    }
+    return tokenBalance;
+  }
+
+  /**
+   * Return true if the balance of the outputs match the balance of the inputs for all tokens.
+   *
+   * @returns {boolean}
+   * @memberof PartialTx
+   * @inner
+   */
+  isComplete() {
+    const tokenBalance = this.calculateTokenBalance();
+
+    // Calculated the final balance for all tokens
+    // return if all are 0
+    return Object.values(tokenBalance).every(v => v.inputs === v.outputs);
+  }
+
+  /**
+   * Add an UTXO as input on the PartialTx.
+   *
+   * @param {string} txId The transaction id of the UTXO.
+   * @param {number} index The index of the UTXO.
+   * @param {OutputValueType} value Value of the UTXO.
+   * @param {OutputValueType} authorities The authority information of the utxo.
+   * @param {string} address base58 address
+   * @param {Object} [options]
+   * @param {string} [options.token='00'] The token UID.
+   *
+   * @memberof PartialTx
+   * @inner
+   */
+  addInput(txId, index, value, address, {
+    token = _constants.NATIVE_TOKEN_UID,
+    authorities = 0n
+  } = {}) {
+    this.inputs.push(new ProposalInput(txId, index, value, address, {
+      token,
+      authorities
+    }));
+  }
+
+  /**
+   * Add an output to the PartialTx.
+   *
+   * @param {OutputValueType} value The amount of tokens on the output.
+   * @param {Buffer} script The output script.
+   * @param {OutputValueType} authorities The authority information of the output.
+   * @param {Object} [options]
+   * @param {string} [options.token='00'] The token UID.
+   * @param {boolean|null} [options.isChange=false] isChange If this is a change output.
+   *
+   * @memberof PartialTx
+   * @inner
+   */
+  addOutput(value, script, {
+    token = _constants.NATIVE_TOKEN_UID,
+    authorities = 0n,
+    isChange = false
+  } = {}) {
+    this.outputs.push(new ProposalOutput(value, script, {
+      token,
+      authorities,
+      isChange
+    }));
+  }
+
+  /**
+   * Serialize the current PartialTx into an UTF8 string.
+   *
+   * The serialization will join 4 parts:
+   * - Fixed prefix
+   * - transaction: in hex format
+   * - inputs metadata: a colon-separated list of address, token, authorities and value
+   * - outputs metadata: change outputs indexes
+   *
+   * Example: PartialTx|00010102...ce|W...vjPi,00,0,1b:W...vjPi,0000389...8c,1,d|1:2
+   * Obs: ellipsis were used to abreviate long parts, there are no ellipsis on the serialized string
+   *
+   *
+   * @returns {string}
+   *
+   * @throws {UnsupportedScriptError} All output scripts must be P2SH or P2PKH
+   * @memberof PartialTx
+   * @inner
+   */
+  serialize() {
+    const changeOutputs = [];
+    this.outputs.forEach((output, index) => {
+      if (output.isChange) {
+        changeOutputs.push(index);
+      }
+    });
+    const tx = this.getTx();
+    const inputArr = this.inputs.map(i => [i.address, i.token, i.authorities.toString(16), i.value.toString(16)].join(','));
+    const arr = [PartialTxPrefix, tx.toHex(), inputArr.join(':'), changeOutputs.map(o => o.toString(16)).join(':') // array of change outputs
+    ];
+    return arr.join('|');
+  }
+
+  /**
+   * Deserialize and create an instance of PartialTx
+   *
+   * @param {string} serialized The serialized PartialTx
+   * @param {Network} network Network used when parsing the output scripts
+   *
+   * @returns {PartialTx}
+   *
+   * @throws {SyntaxError} serialized argument should be valid.
+   * @throws {UnsupportedScriptError} All outputs should be P2SH or P2PKH
+   * @memberof PartialTx
+   * @static
+   */
+  static deserialize(serialized, network) {
+    const dataArr = serialized.split('|');
+    const txHex = dataArr[1];
+    if (dataArr.length !== 4 || dataArr[0] !== PartialTxPrefix) {
+      throw new SyntaxError('Invalid PartialTx');
+    }
+    const inputArr = dataArr[2] && dataArr[2].split(':').map(h => {
+      const parts = h.split(',');
+      const meta = {
+        address: parts[0],
+        token: parts[1],
+        authorities: BigInt(`0x${parts[2]}`),
+        value: BigInt(`0x${parts[3]}`)
+      };
+      if (Number.isNaN(meta.value) || Number.isNaN(meta.authorities)) {
+        throw new SyntaxError('Invalid PartialTx');
+      }
+      return meta;
+    }) || [];
+    const changeOutputs = dataArr[3].split(':').map(x => parseInt(x, 16));
+    const tx = _helpers.default.createTxFromHex(txHex, network);
+    const instance = new PartialTx(network);
+    for (const [index, input] of tx.inputs.entries()) {
+      const inputMeta = inputArr[index];
+      instance.addInput(input.hash, input.index, inputMeta.value, inputMeta.address, {
+        token: inputMeta.token,
+        authorities: inputMeta.authorities
+      });
+    }
+    for (const [index, output] of tx.outputs.entries()) {
+      // validate script
+      const script = output.parseScript(network);
+      if (!(script instanceof _p2pkh.default || script instanceof _p2sh.default)) {
+        throw new _errors.UnsupportedScriptError('Unsupported script type');
+      }
+      let authorities = 0n;
+      if (output.isMint()) {
+        authorities += _constants.TOKEN_MINT_MASK;
+      }
+      if (output.isMelt()) {
+        authorities += _constants.TOKEN_MELT_MASK;
+      }
+      const token = output.isTokenHTR() ? _constants.NATIVE_TOKEN_UID : tx.tokens[output.getTokenIndex()];
+      instance.addOutput(output.value, output.script, {
+        token,
+        authorities,
+        isChange: changeOutputs.indexOf(index) > -1
+      });
+    }
+    return instance;
+  }
+
+  /**
+   * Check the content of the current PartialTx with the fullnode
+   *
+   * @returns {Promise<boolean>}
+   */
+  async validate() {
+    const promises = [];
+    for (const input of this.inputs) {
+      const p = new Promise((resolve, reject) => {
+        _txApi.default.getTransaction(input.hash, data => {
+          if (!data.success) {
+            return resolve(false);
+          }
+          if (data.tx.outputs.length <= input.index) {
+            return resolve(false);
+          }
+          const utxo = data.tx.outputs[input.index];
+          const tokenUid = utxo.token_data === 0 ? _constants.NATIVE_TOKEN_UID : (0, _lodash.get)(data, `tx.tokens[${(utxo.token_data & _constants.TOKEN_INDEX_MASK) - 1}].uid`);
+          const isAuthority = (utxo.token_data & _constants.TOKEN_AUTHORITY_MASK) > 0;
+          const isMint = isAuthority && (utxo.value & _constants.TOKEN_MINT_MASK) > 0;
+          const isMelt = isAuthority && (utxo.value & _constants.TOKEN_MELT_MASK) > 0;
+          const authorityCheck = isAuthority === input.authorities > 0 && isMint === (input.authorities & _constants.TOKEN_MINT_MASK) > 0 && isMelt === (input.authorities & _constants.TOKEN_MELT_MASK) > 0;
+          return resolve(authorityCheck && input.token === tokenUid && input.value === utxo.value && input.address === utxo.decoded.address);
+        }).then(_ => {
+          // should have already resolved
+          reject(new Error('API client did not use the callback'));
+        }).catch(err => reject(err));
+      });
+      promises.push(p);
+    }
+
+    // Check that every promise returns true
+    return Promise.all(promises).then(responses => responses.every(x => x));
+  }
+}
+exports.PartialTx = PartialTx;
+const PartialTxInputDataPrefix = exports.PartialTxInputDataPrefix = 'PartialTxInputData';
+
+/**
+ * This class is meant to aggregate input data for a transaction.
+ *
+ * The `hash` is an identifier of the transaction (usually the dataToSign in hex format)
+ * this way any input data added should identify that it is from the same transaction.
+ *
+ * The input data is saved instead of the signature to allow collecting from MultiSig wallets
+ * since for an input we can have multiple signatures.
+ */
+class PartialTxInputData {
+  constructor(hash, inputsLen) {
+    _defineProperty(this, "data", void 0);
+    _defineProperty(this, "hash", void 0);
+    _defineProperty(this, "inputsLen", void 0);
+    this.data = {};
+    this.hash = hash;
+    this.inputsLen = inputsLen;
+  }
+
+  /**
+   * Add an input data to the record.
+   *
+   * @param {number} index The input index this data relates to.
+   * @param {Buffer} inputData Input data bytes.
+   *
+   * @throws {IndexOOBError} index should be inside the inputs array.
+   *
+   * @memberof PartialTxInputData
+   * @inner
+   */
+  addData(index, inputData) {
+    if (index >= this.inputsLen) {
+      throw new _errors.IndexOOBError(`Index ${index} is out of bounds for the ${this.inputsLen} inputs`);
+    }
+    this.data[index] = inputData;
+  }
+
+  /**
+   * Return true if we have an input data for each input.
+   *
+   * @returns {boolean}
+   * @memberof PartialTxInputData
+   * @inner
+   */
+  isComplete() {
+    return Object.values(this.data).length === this.inputsLen;
+  }
+
+  /**
+   * Serialize the current PartialTxInputData into an UTF8 string.
+   *
+   * The serialization will join 3 informations:
+   * - Fixed prefix
+   * - hash: to identify the transaction which these signatures belong to
+   * - inputs data: index and data
+   *
+   * Example: PartialTxInputData|000ca...fe|0:00abc|1:00123
+   * Obs: ellipsis is used to abreviate, there are no ellipsis on the serialized string
+   *
+   * @returns {string}
+   * @memberof PartialTxInputData
+   * @inner
+   */
+  serialize() {
+    const arr = [PartialTxInputDataPrefix, this.hash];
+    for (const [index, buf] of Object.entries(this.data)) {
+      arr.push(`${index}:${buf.toString('hex')}`);
+    }
+    return arr.join('|');
+  }
+
+  /**
+   * Deserialize the PartialTxInputData and merge with local data.
+   *
+   * @param {string} serialized The serialized PartialTxInputData
+   *
+   * @throws {SyntaxError} serialized argument should be valid.
+   * @memberof PartialTxInputData
+   * @static
+   */
+  addSignatures(serialized) {
+    const arr = serialized.split('|');
+    if (arr.length < 2 || arr[0] !== PartialTxInputDataPrefix || arr[1] !== this.hash) {
+      // Only the first 2 parts are required, the third onward are the signatures which can be empty
+      // When collecting the input data from atomic-swap participants a participant may not have inputs to sign
+      // allowing the empty input data array case will make this a noop instead of throwing an error.
+      throw new SyntaxError('Invalid PartialTxInputData');
+    }
+    for (const part of arr.slice(2)) {
+      const parts = part.split(':');
+      if (parts.length !== 2) {
+        throw new SyntaxError('Invalid PartialTxInputData');
+      }
+
+      // This may overwrite an input data but we are allowing this
+      this.data[+parts[0]] = Buffer.from(parts[1], 'hex');
+    }
+  }
+}
+exports.PartialTxInputData = PartialTxInputData;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/models/priority_queue.d.ts b/node_modules/@hathor/wallet-lib/oldLib/models/priority_queue.d.ts
new file mode 100644
index 0000000..0324472
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/models/priority_queue.d.ts
@@ -0,0 +1,89 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+interface PriorityQueueNode<T> {
+    value: T;
+    priority: number;
+}
+/**
+ * Priority queue implementation using an underlying heap for performance.
+ * @example
+ * const prioQ = new PriorityQueue<string>();
+ * prioQ.push(prioQ.makeNode(0, 'lower prio'));
+ * prioQ.push(prioQ.makeNode(10, 'higher prio'));
+ * prioQ.push(prioQ.makeNode(5, 'medium prio'));
+ * // Returns 'higher prio'
+ * prioQ.pop()
+ * // Returns 'medium prio'
+ * prioQ.pop()
+ * // Returns 'lower prio'
+ * prioQ.pop()
+ *
+ * @template [T=unknown]
+ */
+export default class PriorityQueue<T = unknown> {
+    #private;
+    constructor();
+    /**
+     * Utility to create a node from a value and priority.
+     * @example
+     * // returns { value: 'foobar', 'priority': 10 }
+     * prioQueue.makeNode(10, 'foobar');
+     */
+    static makeNode<N>(priority: number, value: N): PriorityQueueNode<N>;
+    /**
+     * Get the number of elements on the priority queue.
+     */
+    get size(): number;
+    /**
+     * Check if the priority queue is empty
+     */
+    isEmpty(): boolean;
+    /**
+     * Get the top value of the queue without removing it from the queue.
+     */
+    peek(): T | undefined;
+    /**
+     * Add a node to the priority queue and maintain the priority order.
+     */
+    push(value: PriorityQueueNode<T>): void;
+    /**
+     * Add multiple values to the priority queue while maintaining the priority order.
+     */
+    add(...nodes: PriorityQueueNode<T>[]): number;
+    /**
+     * Get the node with highest priority and remove it from the priority queue.
+     */
+    pop(): T | undefined;
+    /** Compare 2 nodes and return true if the left one has higher priority. */
+    private comparator;
+    /** Given a node index on the heap get the parent index */
+    private parent;
+    /** Given a node index on the heap get the left child index */
+    private left;
+    /** Given a node index on the heap get the right child index */
+    private right;
+    /**
+     * Compare the nodes at index `i`, `j` on the heap
+     * Return true if the node at `i` is higher priority than the node at `j`
+     * Return false otherwise.
+     */
+    private _greater;
+    /** swap the nodes at index `i` and `j` on the heap */
+    private _swap;
+    /**
+     * The last node of the heap will work its way up the heap until it meets a node
+     * of higher priority or reaches the top of the heap.
+     */
+    private _siftUp;
+    /**
+     * The top node of the heap will work its way down until no child is of higher
+     * priority or it reaches the bottom of the heap.
+     */
+    private _siftDown;
+}
+export {};
+//# sourceMappingURL=priority_queue.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/models/priority_queue.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/models/priority_queue.d.ts.map
new file mode 100644
index 0000000..299a22e
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/models/priority_queue.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"priority_queue.d.ts","sourceRoot":"","sources":["../../src/models/priority_queue.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;AAGH,UAAU,iBAAiB,CAAC,CAAC;IAC3B,KAAK,EAAE,CAAC,CAAC;IACT,QAAQ,EAAE,MAAM,CAAC;CAClB;AAED;;;;;;;;;;;;;;;GAeG;AACH,MAAM,CAAC,OAAO,OAAO,aAAa,CAAC,CAAC,GAAG,OAAO;;;IAU5C;;;;;OAKG;IACH,MAAM,CAAC,QAAQ,CAAC,CAAC,EAAE,QAAQ,EAAE,MAAM,EAAE,KAAK,EAAE,CAAC,GAAG,iBAAiB,CAAC,CAAC,CAAC;IAIpE;;OAEG;IACH,IAAW,IAAI,WAEd;IAED;;OAEG;IACI,OAAO;IAId;;OAEG;IACI,IAAI;IAQX;;OAEG;IACI,IAAI,CAAC,KAAK,EAAE,iBAAiB,CAAC,CAAC,CAAC;IAKvC;;OAEG;IACI,GAAG,CAAC,GAAG,KAAK,EAAE,iBAAiB,CAAC,CAAC,CAAC,EAAE;IAO3C;;OAEG;IACI,GAAG;IAgBV,2EAA2E;IAC3E,OAAO,CAAC,UAAU;IAIlB,0DAA0D;IAC1D,OAAO,CAAC,MAAM;IAId,8DAA8D;IAC9D,OAAO,CAAC,IAAI;IAIZ,+DAA+D;IAC/D,OAAO,CAAC,KAAK;IAIb;;;;OAIG;IACH,OAAO,CAAC,QAAQ;IAIhB,sDAAsD;IACtD,OAAO,CAAC,KAAK;IAIb;;;OAGG;IACH,OAAO,CAAC,OAAO;IAaf;;;OAGG;IACH,OAAO,CAAC,SAAS;CAmBlB"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/models/priority_queue.js b/node_modules/@hathor/wallet-lib/oldLib/models/priority_queue.js
new file mode 100644
index 0000000..e342fda
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/models/priority_queue.js
@@ -0,0 +1,190 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
+function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
+function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
+function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
+function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); }
+var _heap = /*#__PURE__*/new WeakMap();
+var _top = /*#__PURE__*/new WeakMap();
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/* eslint class-methods-use-this: ["error", { "exceptMethods": ["parent", "left", "right", "comparator"] }] */
+
+/**
+ * Priority queue implementation using an underlying heap for performance.
+ * @example
+ * const prioQ = new PriorityQueue<string>();
+ * prioQ.push(prioQ.makeNode(0, 'lower prio'));
+ * prioQ.push(prioQ.makeNode(10, 'higher prio'));
+ * prioQ.push(prioQ.makeNode(5, 'medium prio'));
+ * // Returns 'higher prio'
+ * prioQ.pop()
+ * // Returns 'medium prio'
+ * prioQ.pop()
+ * // Returns 'lower prio'
+ * prioQ.pop()
+ *
+ * @template [T=unknown]
+ */
+class PriorityQueue {
+  constructor() {
+    _classPrivateFieldInitSpec(this, _heap, void 0);
+    _classPrivateFieldInitSpec(this, _top, void 0);
+    _classPrivateFieldSet(_heap, this, []);
+    _classPrivateFieldSet(_top, this, 0);
+  }
+
+  /**
+   * Utility to create a node from a value and priority.
+   * @example
+   * // returns { value: 'foobar', 'priority': 10 }
+   * prioQueue.makeNode(10, 'foobar');
+   */
+  static makeNode(priority, value) {
+    return {
+      value,
+      priority
+    };
+  }
+
+  /**
+   * Get the number of elements on the priority queue.
+   */
+  get size() {
+    return _classPrivateFieldGet(_heap, this).length;
+  }
+
+  /**
+   * Check if the priority queue is empty
+   */
+  isEmpty() {
+    return this.size === 0;
+  }
+
+  /**
+   * Get the top value of the queue without removing it from the queue.
+   */
+  peek() {
+    if (this.size === 0) {
+      // Heap is empty
+      return undefined;
+    }
+    return _classPrivateFieldGet(_heap, this)[_classPrivateFieldGet(_top, this)].value;
+  }
+
+  /**
+   * Add a node to the priority queue and maintain the priority order.
+   */
+  push(value) {
+    _classPrivateFieldGet(_heap, this).push(value);
+    this._siftUp();
+  }
+
+  /**
+   * Add multiple values to the priority queue while maintaining the priority order.
+   */
+  add(...nodes) {
+    nodes.forEach(node => {
+      this.push(node);
+    });
+    return this.size;
+  }
+
+  /**
+   * Get the node with highest priority and remove it from the priority queue.
+   */
+  pop() {
+    if (this.isEmpty()) {
+      // Queue is empty
+      return undefined;
+    }
+    // This may be undefined if the queue is empty, but we already checked for that.
+    const poppedValue = this.peek();
+    const bottom = this.size - 1;
+    if (bottom > _classPrivateFieldGet(_top, this)) {
+      this._swap(_classPrivateFieldGet(_top, this), bottom);
+    }
+    _classPrivateFieldGet(_heap, this).pop();
+    this._siftDown();
+    return poppedValue;
+  }
+
+  /** Compare 2 nodes and return true if the left one has higher priority. */
+  comparator(a, b) {
+    return a.priority > b.priority;
+  }
+
+  /** Given a node index on the heap get the parent index */
+  parent(i) {
+    return (i + 1 >>> 1) - 1;
+  }
+
+  /** Given a node index on the heap get the left child index */
+  left(i) {
+    return (i << 1) + 1;
+  }
+
+  /** Given a node index on the heap get the right child index */
+  right(i) {
+    return i + 1 << 1;
+  }
+
+  /**
+   * Compare the nodes at index `i`, `j` on the heap
+   * Return true if the node at `i` is higher priority than the node at `j`
+   * Return false otherwise.
+   */
+  _greater(i, j) {
+    return this.comparator(_classPrivateFieldGet(_heap, this)[i], _classPrivateFieldGet(_heap, this)[j]);
+  }
+
+  /** swap the nodes at index `i` and `j` on the heap */
+  _swap(i, j) {
+    [_classPrivateFieldGet(_heap, this)[i], _classPrivateFieldGet(_heap, this)[j]] = [_classPrivateFieldGet(_heap, this)[j], _classPrivateFieldGet(_heap, this)[i]];
+  }
+
+  /**
+   * The last node of the heap will work its way up the heap until it meets a node
+   * of higher priority or reaches the top of the heap.
+   */
+  _siftUp() {
+    // Start from the last index and work our way up the heap
+    let node = this.size - 1;
+    // While the current node is not at the top and the priority is greater
+    // than the parent we continue sifting up
+    while (node > _classPrivateFieldGet(_top, this) && this._greater(node, this.parent(node))) {
+      // parent is lower priority, swap with child (current node)
+      this._swap(node, this.parent(node));
+      // Start from the parent
+      node = this.parent(node);
+    }
+  }
+
+  /**
+   * The top node of the heap will work its way down until no child is of higher
+   * priority or it reaches the bottom of the heap.
+   */
+  _siftDown() {
+    // Start from the top index and work our way down the heap
+    let node = _classPrivateFieldGet(_top, this);
+    // If a child is in the heap and has higher priority, swap with parent and go down
+    while (this.left(node) < this.size && this._greater(this.left(node), node) || this.right(node) < this.size && this._greater(this.right(node), node)) {
+      // Get the child with higher priority
+      const maxChild = this.right(node) < this.size && this._greater(this.right(node), this.left(node)) ? this.right(node) : this.left(node);
+      // Swap with parent and continue sifting down from the child
+      this._swap(node, maxChild);
+      // Start from the child
+      node = maxChild;
+    }
+  }
+}
+exports.default = PriorityQueue;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/models/promise_queue.d.ts b/node_modules/@hathor/wallet-lib/oldLib/models/promise_queue.d.ts
new file mode 100644
index 0000000..f466bcb
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/models/promise_queue.d.ts
@@ -0,0 +1,75 @@
+/// <reference types="node" />
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+import EventEmitter from 'events';
+type TaskOptions = {
+    signal?: AbortSignal;
+};
+type Task<TaskResultType> = ((options?: TaskOptions) => PromiseLike<TaskResultType>) | ((options?: TaskOptions) => TaskResultType);
+type AddTaskOptions = {
+    priority?: number;
+    signal?: AbortSignal;
+};
+/**
+ * PromiseQueue is a task executor that allows a certain number of concurrent
+ * tasks to run at any time.
+ * When a task is added it returns a promise that resolves when the underlying task resolves.
+ *
+ * PromiseQueue is also an EventEmitter for the events:
+ * - new_job: When a new job is added to the queue.
+ * - finished_job: When a job is finished.
+ * - next: When we try to start the next job.
+ * - queue_empty: When the last job on queue start running.
+ * - idle: When all jobs are done and there is no more jobs to run.
+ * - job_start: When we start running a new job.
+ */
+export default class PromiseQueue extends EventEmitter {
+    #private;
+    constructor();
+    /**
+     * Check if the PromiseQueue is paused.
+     */
+    get isPaused(): boolean;
+    /**
+     * Pause or stop processing the tasks.
+     * Does not stop any running tasks.
+     */
+    stop(): void;
+    /**
+     * Unpause or continue processing tasks.
+     */
+    continue(): void;
+    /**
+     * Getter for how many jobs are currently running.
+     */
+    get jobsRunning(): number;
+    /**
+     * Getter for how many concurrent jobs can run.
+     */
+    get concurrent(): number;
+    /**
+     * Setter for concurrent jobs.
+     */
+    set concurrent(value: number);
+    /**
+     * When the signal emits an abort event we should reject with the same reason.
+     */
+    static throwOnAbort(signal: AbortSignal): Promise<never>;
+    /**
+     * Try to start jobs until the concurrency limit is reached.
+     */
+    processQueue(): void;
+    /**
+     * Add a new task to the queue, the returned promise will resolve when the task resolves.
+     * @param task The underlying job to run.
+     * @param options.priority The task priority, the higher it is the sooner the task will run.
+     * @param option.signal The `AbortSignal` that can be used to abort the task from the caller.
+     */
+    add<TaskResultType>(task: Task<TaskResultType>, options?: AddTaskOptions): Promise<unknown>;
+}
+export {};
+//# sourceMappingURL=promise_queue.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/models/promise_queue.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/models/promise_queue.d.ts.map
new file mode 100644
index 0000000..063b280
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/models/promise_queue.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"promise_queue.d.ts","sourceRoot":"","sources":["../../src/models/promise_queue.ts"],"names":[],"mappings":";AAAA;;;;;GAKG;AACH,OAAO,YAAY,MAAM,QAAQ,CAAC;AAGlC,KAAK,WAAW,GAAG;IAAE,MAAM,CAAC,EAAE,WAAW,CAAA;CAAE,CAAC;AAE5C,KAAK,IAAI,CAAC,cAAc,IACpB,CAAC,CAAC,OAAO,CAAC,EAAE,WAAW,KAAK,WAAW,CAAC,cAAc,CAAC,CAAC,GACxD,CAAC,CAAC,OAAO,CAAC,EAAE,WAAW,KAAK,cAAc,CAAC,CAAC;AAEhD,KAAK,cAAc,GAAG;IACpB,QAAQ,CAAC,EAAE,MAAM,CAAC;IAClB,MAAM,CAAC,EAAE,WAAW,CAAC;CACtB,CAAC;AAEF;;;;;;;;;;;;GAYG;AACH,MAAM,CAAC,OAAO,OAAO,YAAa,SAAQ,YAAY;;;IA4CpD;;OAEG;IACH,IAAW,QAAQ,YAElB;IAED;;;OAGG;IACI,IAAI;IAKX;;OAEG;IACI,QAAQ;IAKf;;OAEG;IACH,IAAW,WAAW,WAErB;IAkBD;;OAEG;IACH,IAAW,UAAU,WAEpB;IAED;;OAEG;IACH,IAAW,UAAU,CAAC,KAAK,QAAA,EAK1B;IAgCD;;OAEG;WACU,YAAY,CAAC,MAAM,EAAE,WAAW,GAAG,OAAO,CAAC,KAAK,CAAC;IAY9D;;OAEG;IACH,YAAY,IAAI,IAAI;IAKpB;;;;;OAKG;IACG,GAAG,CAAC,cAAc,EAAE,IAAI,EAAE,IAAI,CAAC,cAAc,CAAC,EAAE,OAAO,CAAC,EAAE,cAAc;CAgC/E"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/models/promise_queue.js b/node_modules/@hathor/wallet-lib/oldLib/models/promise_queue.js
new file mode 100644
index 0000000..6fbe0ff
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/models/promise_queue.js
@@ -0,0 +1,231 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+var _events = _interopRequireDefault(require("events"));
+var _priority_queue = _interopRequireDefault(require("./priority_queue"));
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+function _classPrivateMethodInitSpec(e, a) { _checkPrivateRedeclaration(e, a), a.add(e); }
+function _classPrivateFieldInitSpec(e, t, a) { _checkPrivateRedeclaration(e, t), t.set(e, a); }
+function _checkPrivateRedeclaration(e, t) { if (t.has(e)) throw new TypeError("Cannot initialize the same private elements twice on an object"); }
+function _classPrivateGetter(s, r, a) { return a(_assertClassBrand(s, r)); }
+function _classPrivateFieldGet(s, a) { return s.get(_assertClassBrand(s, a)); }
+function _classPrivateFieldSet(s, a, r) { return s.set(_assertClassBrand(s, a), r), r; }
+function _assertClassBrand(e, t, n) { if ("function" == typeof e ? e === t : e.has(t)) return arguments.length < 3 ? t : n; throw new TypeError("Private element is not present on this object"); } /**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+var _queue = /*#__PURE__*/new WeakMap();
+var _jobsRunning = /*#__PURE__*/new WeakMap();
+var _allowedConcurrentJobs = /*#__PURE__*/new WeakMap();
+var _isPaused = /*#__PURE__*/new WeakMap();
+var _intervalId = /*#__PURE__*/new WeakMap();
+var _PromiseQueue_brand = /*#__PURE__*/new WeakSet();
+/**
+ * PromiseQueue is a task executor that allows a certain number of concurrent
+ * tasks to run at any time.
+ * When a task is added it returns a promise that resolves when the underlying task resolves.
+ *
+ * PromiseQueue is also an EventEmitter for the events:
+ * - new_job: When a new job is added to the queue.
+ * - finished_job: When a job is finished.
+ * - next: When we try to start the next job.
+ * - queue_empty: When the last job on queue start running.
+ * - idle: When all jobs are done and there is no more jobs to run.
+ * - job_start: When we start running a new job.
+ */
+class PromiseQueue extends _events.default {
+  constructor() {
+    super();
+    /**
+     * Try to start any jobs we can and set a timeout for the next interval.
+     * Will stop the interval if the PromiseQueue is paused.
+     */
+    _classPrivateMethodInitSpec(this, _PromiseQueue_brand);
+    _classPrivateFieldInitSpec(this, _queue, void 0);
+    // Number of active jobs currently running.
+    _classPrivateFieldInitSpec(this, _jobsRunning, void 0);
+    _classPrivateFieldInitSpec(this, _allowedConcurrentJobs, 1);
+    _classPrivateFieldInitSpec(this, _isPaused, false);
+    _classPrivateFieldInitSpec(this, _intervalId, null);
+    _classPrivateFieldSet(_queue, this, new _priority_queue.default());
+    _classPrivateFieldSet(_jobsRunning, this, 0);
+    _assertClassBrand(_PromiseQueue_brand, this, _startInterval).call(this);
+  }
+  /**
+   * Check if the PromiseQueue is paused.
+   */
+  get isPaused() {
+    return _classPrivateFieldGet(_isPaused, this);
+  }
+
+  /**
+   * Pause or stop processing the tasks.
+   * Does not stop any running tasks.
+   */
+  stop() {
+    _classPrivateFieldSet(_isPaused, this, true);
+    _assertClassBrand(_PromiseQueue_brand, this, _clearInterval).call(this);
+  }
+
+  /**
+   * Unpause or continue processing tasks.
+   */
+  continue() {
+    _classPrivateFieldSet(_isPaused, this, false);
+    _assertClassBrand(_PromiseQueue_brand, this, _startInterval).call(this);
+  }
+
+  /**
+   * Getter for how many jobs are currently running.
+   */
+  get jobsRunning() {
+    return _classPrivateFieldGet(_jobsRunning, this);
+  }
+
+  /**
+   * Called after a task is done, will try to start a new task.
+   */
+
+  /**
+   * Getter for how many concurrent jobs can run.
+   */
+  get concurrent() {
+    return _classPrivateFieldGet(_allowedConcurrentJobs, this);
+  }
+
+  /**
+   * Setter for concurrent jobs.
+   */
+  set concurrent(value) {
+    if (value < 1) {
+      throw new Error('Cannot have less than 1 job running.');
+    }
+    _classPrivateFieldSet(_allowedConcurrentJobs, this, value);
+  }
+
+  /**
+   * Check if we can start a new job and start it.
+   */
+
+  /**
+   * When the signal emits an abort event we should reject with the same reason.
+   */
+  static async throwOnAbort(signal) {
+    return new Promise((_resolve, reject) => {
+      signal.addEventListener('abort', () => {
+        reject(signal.reason);
+      }, {
+        once: true
+      });
+    });
+  }
+
+  /**
+   * Try to start jobs until the concurrency limit is reached.
+   */
+  processQueue() {
+    // eslint-disable-next-line no-empty
+    while (_assertClassBrand(_PromiseQueue_brand, this, _tryToStartNextJob).call(this)) {}
+  }
+
+  /**
+   * Add a new task to the queue, the returned promise will resolve when the task resolves.
+   * @param task The underlying job to run.
+   * @param options.priority The task priority, the higher it is the sooner the task will run.
+   * @param option.signal The `AbortSignal` that can be used to abort the task from the caller.
+   */
+  async add(task, options) {
+    this.emit('new_job');
+    return new Promise((resolve, reject) => {
+      _classPrivateFieldGet(_queue, this).push(_priority_queue.default.makeNode(options?.priority || 0, async () => {
+        var _this$jobsRunning3, _this$jobsRunning4;
+        _classPrivateFieldSet(_jobsRunning, this, (_this$jobsRunning3 = _classPrivateFieldGet(_jobsRunning, this), _this$jobsRunning4 = _this$jobsRunning3++, _this$jobsRunning3)), _this$jobsRunning4;
+        try {
+          // Throw if the operation was aborted and don't run.
+          options?.signal?.throwIfAborted();
+
+          // Run the task until completion or until the task aborts.
+          let operation = task({
+            signal: options?.signal
+          });
+          // If a signal was passed, we may abort the operation from the outside.
+          // This does not abort internally the task, it has to also manage the abort signal.
+          if (options?.signal) {
+            operation = Promise.race([operation, PromiseQueue.throwOnAbort(options.signal)]);
+          }
+          const result = await operation;
+          resolve(result);
+          // Completed task
+        } catch (error) {
+          reject(error);
+        } finally {
+          this.emit('finished_job');
+          _assertClassBrand(_PromiseQueue_brand, this, _next).call(this);
+        }
+      }));
+      // Try to start the job we enqueued and any other we can start
+      this.processQueue();
+    });
+  }
+}
+exports.default = PromiseQueue;
+function _startInterval() {
+  this.processQueue();
+  _classPrivateFieldSet(_intervalId, this, setTimeout(() => {
+    if (_classPrivateFieldGet(_isPaused, this)) {
+      _assertClassBrand(_PromiseQueue_brand, this, _clearInterval).call(this);
+      return;
+    }
+    _assertClassBrand(_PromiseQueue_brand, this, _startInterval).call(this);
+  }, 1000));
+}
+/**
+ * If there is an interval scheduled to run, stop and clear internal state.
+ */
+function _clearInterval() {
+  if (_classPrivateFieldGet(_intervalId, this)) {
+    clearInterval(_classPrivateFieldGet(_intervalId, this));
+    _classPrivateFieldSet(_intervalId, this, null);
+  }
+}
+function _next() {
+  var _this$jobsRunning, _this$jobsRunning2;
+  this.emit('next');
+  _classPrivateFieldSet(_jobsRunning, this, (_this$jobsRunning = _classPrivateFieldGet(_jobsRunning, this), _this$jobsRunning2 = _this$jobsRunning--, _this$jobsRunning)), _this$jobsRunning2;
+  _assertClassBrand(_PromiseQueue_brand, this, _tryToStartNextJob).call(this);
+}
+/**
+ * Whether we can start a new job.
+ */
+function _get_canStartJob(_this) {
+  return _classPrivateFieldGet(_jobsRunning, _this) < _this.concurrent;
+}
+function _tryToStartNextJob() {
+  if (_classPrivateFieldGet(_isPaused, this)) {
+    return false;
+  }
+  if (_classPrivateFieldGet(_queue, this).isEmpty()) {
+    // No more tasks to run
+    this.emit('queue_empty');
+    if (_classPrivateFieldGet(_jobsRunning, this) === 0) {
+      this.emit('idle');
+    }
+    return false;
+  }
+  if (_classPrivateGetter(_PromiseQueue_brand, this, _get_canStartJob)) {
+    const job = _classPrivateFieldGet(_queue, this).pop();
+    if (!job) {
+      // Should never happen, but treating for typing
+      return false;
+    }
+    this.emit('job_start');
+    job();
+    return true;
+  }
+  return false;
+}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/models/queue.d.ts b/node_modules/@hathor/wallet-lib/oldLib/models/queue.d.ts
new file mode 100644
index 0000000..72d29eb
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/models/queue.d.ts
@@ -0,0 +1,38 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/**
+ * This is a simple queue using an underlying linked list for O(1) enqueue and dequeue operations.
+ *
+ * @template [T=Object]
+ */
+export default class Queue<T = unknown> {
+    private head?;
+    private last?;
+    private length;
+    constructor();
+    /**
+     * Add to the queue.
+     * @param {T} value An item to enqueue
+     */
+    enqueue(value: T): void;
+    /**
+     * Remove the first item and return it.
+     * @returns {T|undefined} The first element on the queue if there is any.
+     */
+    dequeue(): T | undefined;
+    /**
+     * Peek the first element on queue without dequeuing.
+     * @returns {T|undefined} The first element on queue if there is any.
+     */
+    peek(): T | undefined;
+    /**
+     * Get the size of the current queue
+     * @returns {number} The size of the current queue
+     */
+    size(): number;
+}
+//# sourceMappingURL=queue.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/models/queue.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/models/queue.d.ts.map
new file mode 100644
index 0000000..d49332e
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/models/queue.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"queue.d.ts","sourceRoot":"","sources":["../../src/models/queue.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;AAOH;;;;GAIG;AACH,MAAM,CAAC,OAAO,OAAO,KAAK,CAAC,CAAC,GAAG,OAAO;IACpC,OAAO,CAAC,IAAI,CAAC,CAAe;IAE5B,OAAO,CAAC,IAAI,CAAC,CAAe;IAE5B,OAAO,CAAC,MAAM,CAAS;;IAMvB;;;OAGG;IACH,OAAO,CAAC,KAAK,EAAE,CAAC;IAehB;;;OAGG;IACH,OAAO,IAAI,CAAC,GAAG,SAAS;IAWxB;;;OAGG;IACH,IAAI,IAAI,CAAC,GAAG,SAAS;IAIrB;;;OAGG;IACH,IAAI,IAAI,MAAM;CAGf"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/models/queue.js b/node_modules/@hathor/wallet-lib/oldLib/models/queue.js
new file mode 100644
index 0000000..6d85ac7
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/models/queue.js
@@ -0,0 +1,82 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
+function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
+function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+/**
+ * This is a simple queue using an underlying linked list for O(1) enqueue and dequeue operations.
+ *
+ * @template [T=Object]
+ */
+class Queue {
+  constructor() {
+    _defineProperty(this, "head", void 0);
+    _defineProperty(this, "last", void 0);
+    _defineProperty(this, "length", void 0);
+    this.length = 0;
+  }
+
+  /**
+   * Add to the queue.
+   * @param {T} value An item to enqueue
+   */
+  enqueue(value) {
+    const node = {
+      value,
+      next: undefined
+    };
+    if (this.head) {
+      if (this.last === undefined || this.last.next !== undefined) {
+        // This shouldn't happen
+        throw new Error('Queue: last element in bad state');
+      }
+      this.last.next = node;
+    } else {
+      this.head = node;
+    }
+    this.last = node;
+    this.length++;
+  }
+
+  /**
+   * Remove the first item and return it.
+   * @returns {T|undefined} The first element on the queue if there is any.
+   */
+  dequeue() {
+    if (!this.head) {
+      return undefined;
+    }
+    const first = this.head.value;
+    this.head = this.head.next;
+    this.length--;
+    return first;
+  }
+
+  /**
+   * Peek the first element on queue without dequeuing.
+   * @returns {T|undefined} The first element on queue if there is any.
+   */
+  peek() {
+    return this.head?.value;
+  }
+
+  /**
+   * Get the size of the current queue
+   * @returns {number} The size of the current queue
+   */
+  size() {
+    return this.length;
+  }
+}
+exports.default = Queue;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/models/script_data.d.ts b/node_modules/@hathor/wallet-lib/oldLib/models/script_data.d.ts
new file mode 100644
index 0000000..58a61c9
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/models/script_data.d.ts
@@ -0,0 +1,34 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/// <reference types="node" />
+import { IHistoryOutputDecoded } from '../types';
+declare class ScriptData {
+    data: string;
+    constructor(data: string);
+    /**
+     * Get script type
+     *
+     * @return {String}
+     * @memberof ScriptData
+     * @inner
+     */
+    getType(): string;
+    /**
+     * Build the original decoded script
+     */
+    toData(): IHistoryOutputDecoded;
+    /**
+     * Create an output script from data
+     *
+     * @return {Buffer}
+     * @memberof ScriptData
+     * @inner
+     */
+    createScript(): Buffer;
+}
+export default ScriptData;
+//# sourceMappingURL=script_data.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/models/script_data.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/models/script_data.d.ts.map
new file mode 100644
index 0000000..f881b73
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/models/script_data.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"script_data.d.ts","sourceRoot":"","sources":["../../src/models/script_data.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;;AAMH,OAAO,EAAE,qBAAqB,EAAE,MAAM,UAAU,CAAC;AAEjD,cAAM,UAAU;IAEd,IAAI,EAAE,MAAM,CAAC;gBAED,IAAI,EAAE,MAAM;IAQxB;;;;;;OAMG;IAEH,OAAO,IAAI,MAAM;IAIjB;;OAEG;IACH,MAAM,IAAI,qBAAqB;IAO/B;;;;;;OAMG;IACH,YAAY,IAAI,MAAM;CAOvB;AAED,eAAe,UAAU,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/models/script_data.js b/node_modules/@hathor/wallet-lib/oldLib/models/script_data.js
new file mode 100644
index 0000000..389ec30
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/models/script_data.js
@@ -0,0 +1,67 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+var _bitcoreLib = require("bitcore-lib");
+var _buffer = _interopRequireDefault(require("buffer"));
+var _opcodes = require("../opcodes");
+var _helpers = _interopRequireDefault(require("../utils/helpers"));
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
+function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
+function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+class ScriptData {
+  constructor(data) {
+    // String of data to store on the script
+    _defineProperty(this, "data", void 0);
+    if (!data) {
+      throw Error('You must provide data.');
+    }
+    this.data = data;
+  }
+
+  /**
+   * Get script type
+   *
+   * @return {String}
+   * @memberof ScriptData
+   * @inner
+   */
+  // eslint-disable-next-line class-methods-use-this -- This method returns a hardcoded constant
+  getType() {
+    return 'data';
+  }
+
+  /**
+   * Build the original decoded script
+   */
+  toData() {
+    return {
+      type: this.getType().toUpperCase(),
+      data: this.data
+    };
+  }
+
+  /**
+   * Create an output script from data
+   *
+   * @return {Buffer}
+   * @memberof ScriptData
+   * @inner
+   */
+  createScript() {
+    const arr = [];
+    const dataBytes = _buffer.default.Buffer.from(this.data, 'utf8');
+    _helpers.default.pushDataToStack(arr, dataBytes);
+    arr.push(_opcodes.OP_CHECKSIG);
+    return _bitcoreLib.util.buffer.concat(arr);
+  }
+}
+var _default = exports.default = ScriptData;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/models/transaction.d.ts b/node_modules/@hathor/wallet-lib/oldLib/models/transaction.d.ts
new file mode 100644
index 0000000..f2627be
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/models/transaction.d.ts
@@ -0,0 +1,324 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/// <reference types="node" />
+/// <reference types="node" />
+import buffer from 'buffer';
+import crypto from 'crypto';
+import Input from './input';
+import Output from './output';
+import Network from './network';
+import { OutputValueType } from '../types';
+import type Header from '../headers/base';
+import NanoContractHeader from '../nano_contracts/header';
+type optionsType = {
+    signalBits?: number;
+    version?: number;
+    weight?: number;
+    nonce?: number;
+    timestamp?: number | null;
+    parents?: string[];
+    tokens?: string[];
+    hash?: string | null;
+    headers?: Header[];
+};
+/**
+ * Representation of a transaction with helper methods.
+ *
+ * Besides the class `constructor`, there are some helper methods are available to build instances of this class
+ * according to context:
+ * - `Transaction.createFromBytes`: creates a transaction from a buffer and a network
+ * - `helpers.createTxFromData`: creates from a standard lib data object
+ * - `helpers.createTxFromHistoryObject`: creates from a tx populated by the HathorWallet history methods
+ */
+declare class Transaction {
+    inputs: Input[];
+    outputs: Output[];
+    signalBits: number;
+    version: number;
+    weight: number;
+    nonce: number;
+    timestamp: number | null;
+    parents: string[];
+    tokens: string[];
+    hash: string | null;
+    headers: Header[];
+    protected _dataToSignCache: Buffer | null;
+    constructor(inputs: Input[], outputs: Output[], options?: optionsType);
+    /**
+     * Returns a string with the short version of the tx hash
+     * Returns {first12Chars}...{last12Chars}
+     *
+     * @return {string}
+     * @memberof Transaction
+     * @inner
+     *
+     */
+    getShortHash(): string;
+    /**
+     * Return transaction data to sign in inputs
+     *
+     * @return {Buffer}
+     * @memberof Transaction
+     * @inner
+     */
+    getDataToSign(): Buffer;
+    /**
+     * Serialize funds fields
+     * signal bits, version, len tokens, len inputs, len outputs, tokens array, inputs and outputs
+     *
+     * @param {Buffer[]} array Array of buffer to push the serialized fields
+     * @param {boolean} addInputData If should add input data when serializing it
+     *
+     * @memberof Transaction
+     * @inner
+     */
+    serializeFundsFields(array: Buffer[], addInputData: boolean): void;
+    /**
+     * Add to buffer array the serialization of the tokens array
+     *
+     * @memberof Transaction
+     * @inner
+     */
+    serializeTokensArray(array: Buffer[]): void;
+    /**
+     * Add to buffer array the serialization of funds fields len (len of inputs and outputs)
+     *
+     * @memberof Transaction
+     * @inner
+     */
+    serializeFundsFieldsLen(array: Buffer[]): void;
+    /**
+     * Add to buffer array the serialization of funds fields (inputs and outputs)
+     *
+     * @memberof Transaction
+     * @inner
+     */
+    serializeInputsOutputs(array: Buffer[], addInputData: boolean): void;
+    /**
+     * Add to buffer array the serialization of graph fields and other serialization fields (weight, timestamp, parents and nonce)
+     *
+     * @memberof Transaction
+     * @inner
+     */
+    serializeGraphFields(array: Buffer[]): void;
+    /**
+     * Serializes nonce
+     *
+     * @param {Buffer[]} array Array of buffer to push serialized nonce
+     *
+     * @memberof Transaction
+     * @inner
+     */
+    serializeNonce(array: Buffer[]): void;
+    /**
+     * Serializes transaction headers
+     *
+     * @param {Buffer[]} array Array of buffer to push serialized headers
+     *
+     * @memberof Transaction
+     * @inner
+     */
+    serializeHeaders(array: Buffer[]): void;
+    getDataToSignHash(): Buffer;
+    /**
+     * Calculate the minimum tx weight
+     *
+     * @throws {ConstantNotSet} If the weight constants are not set yet
+     *
+     * @return {number} Minimum weight calculated (float)
+     * @memberof Transaction
+     * @inner
+     */
+    calculateWeight(): number;
+    /**
+     * Calculate the sum of outputs. Authority outputs are ignored.
+     *
+     * @return {number} Sum of outputs
+     * @memberof Transaction
+     * @inner
+     */
+    getOutputsSum(): OutputValueType;
+    /**
+     * Serialize tx to bytes
+     *
+     * @return {Buffer}
+     * @memberof Transaction
+     * @inner
+     */
+    toBytes(): Buffer;
+    /**
+     * Validate transaction information.
+     * For now, we only verify the maximum number of inputs and outputs.
+     *
+     * @throws {MaximumNumberInputsError} If the tx has more inputs than the maximum allowed
+     * @throws {MaximumNumberOutputsError} If the tx has more outputs than the maximum allowed
+     *
+     * @memberof Transaction
+     * @inner
+     */
+    validate(): void;
+    /**
+     * Get tx data and return it in hexadecimal
+     *
+     * @return {String} Hexadecimal of a serialized tx
+     * @memberof Transaction
+     * @inner
+     */
+    toHex(): string;
+    /**
+     * Get object type (Transaction or Block)
+     *
+     * @return {string} Type of the object
+     *
+     * @memberof Transaction
+     * @inner
+     */
+    getType(): string;
+    /**
+     * Check if object is a block or a transaction
+     *
+     * @return {boolean} true if object is a block, false otherwise
+     *
+     * @memberof Transaction
+     * @inner
+     */
+    isBlock(): boolean;
+    /**
+     * Set tx timestamp and weight
+     *
+     * @memberof Transaction
+     * @inner
+     */
+    prepareToSend(): void;
+    /**
+     * Update transaction timestamp
+     * If timestamp parameter is not sent, we use now
+     *
+     * @memberof Transaction
+     * @inner
+     */
+    updateTimestamp(timestamp?: number | null): void;
+    /**
+     * Gets funds fields (signalBits, version, tokens, inputs, outputs) from bytes
+     * and saves them in `this`
+     *
+     * @param srcBuf Buffer with bytes to get fields
+     * @param network Network to get output addresses first byte
+     *
+     * @return Rest of buffer after getting the fields
+     * @memberof Transaction
+     * @inner
+     */
+    getFundsFieldsFromBytes(srcBuf: Buffer, network: Network): Buffer;
+    /**
+     * Gets graph fields (weight, timestamp, parents, nonce) from bytes
+     * and saves them in `this`
+     *
+     * @param srcBuf Buffer with bytes to get fields
+     *
+     * @return Rest of buffer after getting the fields
+     * @memberof Transaction
+     * @inner
+     */
+    getGraphFieldsFromBytes(srcBuf: Buffer): Buffer;
+    /**
+     * Gets headers objects from bytes
+     * and pushes them in `this.headers`
+     *
+     * @param srcBuf Buffer with bytes to get headers data
+     * @param network Network used to deserialize headers
+     *
+     * @return Rest of buffer after getting the fields
+     * @memberof Transaction
+     * @inner
+     */
+    getHeadersFromBytes(srcBuf: Buffer, network: Network): void;
+    /**
+     * Create transaction object from bytes
+     *
+     * @param {Buffer} buf Buffer with bytes to get transaction fields
+     * @param {Network} network Network to get output addresses first byte
+     *
+     * @return {Transaction} Transaction object
+     * @memberof Transaction
+     * @static
+     * @inner
+     */
+    static createFromBytes(buf: Buffer, network: Network): Transaction;
+    /**
+     * Get funds fields hash to be used when calculating the tx hash
+     *
+     * @return The sha256 hash digest
+     * @memberof Transaction
+     * @inner
+     */
+    getFundsHash(): Buffer;
+    /**
+     * Get graph and headers fields hash to be used when calculating the tx hash
+     *
+     * @return The sha256 hash digest
+     * @memberof Transaction
+     * @inner
+     */
+    getGraphAndHeadersHash(): buffer.Buffer;
+    /**
+     * Calculate first part of transaction hash
+     *
+     * @return {object} Sha256 hash object of part1
+     *
+     * @memberof Transaction
+     * @inner
+     */
+    calculateHashPart1(): crypto.Hash;
+    /**
+     * Calculate transaction hash from part1
+     *
+     * @return {Buffer} Transaction hash in bytes
+     *
+     * @memberof Transaction
+     * @inner
+     */
+    calculateHashPart2(part1: crypto.Hash): Buffer;
+    /**
+     * Calculate transaction hash and return it
+     *
+     * @return {string} Transaction hash in hexadecimal
+     *
+     * @memberof Transaction
+     * @inner
+     */
+    calculateHash(): string;
+    /**
+     * Update transaction hash
+     *
+     * @memberof Transaction
+     * @inner
+     */
+    updateHash(): void;
+    /**
+     * Return if the tx is a nano contract (if it has nano header)
+     *
+     * @return If the transaction object is a nano contract
+     *
+     * @memberof Transaction
+     * @inner
+     */
+    isNanoContract(): boolean;
+    /**
+     * Get the nano contract header from the list of headers.
+     *
+     * @throws NanoHeaderNotFound in case the tx does not have a nano header
+     *
+     * @return The nano header object
+     *
+     * @memberof Transaction
+     * @inner
+     */
+    getNanoHeaders(): NanoContractHeader[];
+}
+export default Transaction;
+//# sourceMappingURL=transaction.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/models/transaction.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/models/transaction.d.ts.map
new file mode 100644
index 0000000..77b7218
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/models/transaction.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"transaction.d.ts","sourceRoot":"","sources":["../../src/models/transaction.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/models/transaction.js b/node_modules/@hathor/wallet-lib/oldLib/models/transaction.js
new file mode 100644
index 0000000..c3c5a1e
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/models/transaction.js
@@ -0,0 +1,722 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+var _bitcoreLib = require("bitcore-lib");
+var _buffer = _interopRequireDefault(require("buffer"));
+var _lodash = require("lodash");
+var _crypto = _interopRequireDefault(require("crypto"));
+var _constants = require("../constants");
+var _buffer2 = require("../utils/buffer");
+var _input = _interopRequireDefault(require("./input"));
+var _output = _interopRequireDefault(require("./output"));
+var _errors = require("../errors");
+var _header = _interopRequireDefault(require("../nano_contracts/header"));
+var _parser = _interopRequireDefault(require("../headers/parser"));
+var _types = require("../headers/types");
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
+function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
+function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+var txType = /*#__PURE__*/function (txType) {
+  txType["BLOCK"] = "Block";
+  txType["TRANSACTION"] = "Transaction";
+  txType["CREATE_TOKEN_TRANSACTION"] = "Create Token Transaction";
+  txType["MERGED_MINING_BLOCK"] = "Merged Mining Block";
+  return txType;
+}(txType || {});
+/**
+ * Representation of a transaction with helper methods.
+ *
+ * Besides the class `constructor`, there are some helper methods are available to build instances of this class
+ * according to context:
+ * - `Transaction.createFromBytes`: creates a transaction from a buffer and a network
+ * - `helpers.createTxFromData`: creates from a standard lib data object
+ * - `helpers.createTxFromHistoryObject`: creates from a tx populated by the HathorWallet history methods
+ */
+class Transaction {
+  constructor(inputs, outputs, options = {}) {
+    _defineProperty(this, "inputs", void 0);
+    _defineProperty(this, "outputs", void 0);
+    _defineProperty(this, "signalBits", void 0);
+    _defineProperty(this, "version", void 0);
+    _defineProperty(this, "weight", void 0);
+    _defineProperty(this, "nonce", void 0);
+    _defineProperty(this, "timestamp", void 0);
+    _defineProperty(this, "parents", void 0);
+    _defineProperty(this, "tokens", void 0);
+    _defineProperty(this, "hash", void 0);
+    _defineProperty(this, "headers", void 0);
+    _defineProperty(this, "_dataToSignCache", void 0);
+    const defaultOptions = {
+      signalBits: _constants.DEFAULT_SIGNAL_BITS,
+      version: _constants.DEFAULT_TX_VERSION,
+      weight: 0,
+      nonce: 0,
+      timestamp: null,
+      parents: [],
+      tokens: [],
+      hash: null,
+      headers: []
+    };
+    const newOptions = Object.assign(defaultOptions, options);
+    const {
+      signalBits,
+      version,
+      weight,
+      nonce,
+      timestamp,
+      parents,
+      tokens,
+      hash,
+      headers
+    } = newOptions;
+    this.inputs = inputs;
+    this.outputs = outputs;
+    this.signalBits = signalBits;
+    this.version = version;
+    this.weight = weight;
+    this.nonce = nonce;
+    this.timestamp = timestamp;
+    this.parents = parents;
+    this.tokens = tokens;
+    this.hash = hash;
+    this.headers = headers;
+
+    // All inputs sign the same data, so we cache it in the first getDataToSign method call
+    this._dataToSignCache = null;
+  }
+
+  /**
+   * Returns a string with the short version of the tx hash
+   * Returns {first12Chars}...{last12Chars}
+   *
+   * @return {string}
+   * @memberof Transaction
+   * @inner
+   *
+   */
+  getShortHash() {
+    return this.hash === null ? '' : `${this.hash.substring(0, 12)}...${this.hash.substring(52, 64)}`;
+  }
+
+  /**
+   * Return transaction data to sign in inputs
+   *
+   * @return {Buffer}
+   * @memberof Transaction
+   * @inner
+   */
+  getDataToSign() {
+    if (this._dataToSignCache !== null) {
+      return this._dataToSignCache;
+    }
+    const arr = [];
+    this.serializeFundsFields(arr, false);
+    for (const header of this.headers) {
+      // For the dataToSign we use only the sighash serialization
+      header.serializeSighash(arr);
+    }
+    this._dataToSignCache = _bitcoreLib.util.buffer.concat(arr);
+    return this._dataToSignCache;
+  }
+
+  /**
+   * Serialize funds fields
+   * signal bits, version, len tokens, len inputs, len outputs, tokens array, inputs and outputs
+   *
+   * @param {Buffer[]} array Array of buffer to push the serialized fields
+   * @param {boolean} addInputData If should add input data when serializing it
+   *
+   * @memberof Transaction
+   * @inner
+   */
+  serializeFundsFields(array, addInputData) {
+    // Signal bits
+    array.push((0, _buffer2.intToBytes)(this.signalBits, 1));
+
+    // Tx version
+    array.push((0, _buffer2.intToBytes)(this.version, 1));
+
+    // Len tokens
+    array.push((0, _buffer2.intToBytes)(this.tokens.length, 1));
+
+    // Len of inputs and outputs
+    this.serializeFundsFieldsLen(array);
+
+    // Tokens array
+    this.serializeTokensArray(array);
+
+    // Inputs and outputs
+    this.serializeInputsOutputs(array, addInputData);
+  }
+
+  /**
+   * Add to buffer array the serialization of the tokens array
+   *
+   * @memberof Transaction
+   * @inner
+   */
+  serializeTokensArray(array) {
+    // Tokens data
+    for (const token of this.tokens) {
+      array.push((0, _buffer2.hexToBuffer)(token));
+    }
+  }
+
+  /**
+   * Add to buffer array the serialization of funds fields len (len of inputs and outputs)
+   *
+   * @memberof Transaction
+   * @inner
+   */
+  serializeFundsFieldsLen(array) {
+    // Len inputs
+    array.push((0, _buffer2.intToBytes)(this.inputs.length, 1));
+
+    // Len outputs
+    array.push((0, _buffer2.intToBytes)(this.outputs.length, 1));
+  }
+
+  /**
+   * Add to buffer array the serialization of funds fields (inputs and outputs)
+   *
+   * @memberof Transaction
+   * @inner
+   */
+  serializeInputsOutputs(array, addInputData) {
+    for (const inputTx of this.inputs) {
+      array.push(...inputTx.serialize(addInputData));
+    }
+    for (const outputTx of this.outputs) {
+      array.push(...outputTx.serialize());
+    }
+  }
+
+  /**
+   * Add to buffer array the serialization of graph fields and other serialization fields (weight, timestamp, parents and nonce)
+   *
+   * @memberof Transaction
+   * @inner
+   */
+  serializeGraphFields(array) {
+    // Now serialize the graph part
+    //
+    // Weight is a float with 8 bytes
+    array.push((0, _buffer2.floatToBytes)(this.weight, 8));
+    // Timestamp
+    array.push((0, _buffer2.intToBytes)(this.timestamp, 4));
+    if (this.parents) {
+      array.push((0, _buffer2.intToBytes)(this.parents.length, 1));
+      for (const parent of this.parents) {
+        array.push((0, _buffer2.hexToBuffer)(parent));
+      }
+    } else {
+      // Len parents (parents will be calculated in the backend)
+      array.push((0, _buffer2.intToBytes)(0, 1));
+    }
+  }
+
+  /**
+   * Serializes nonce
+   *
+   * @param {Buffer[]} array Array of buffer to push serialized nonce
+   *
+   * @memberof Transaction
+   * @inner
+   */
+  serializeNonce(array) {
+    // Add nonce in the end
+    array.push((0, _buffer2.intToBytes)(this.nonce, 4));
+  }
+
+  /**
+   * Serializes transaction headers
+   *
+   * @param {Buffer[]} array Array of buffer to push serialized headers
+   *
+   * @memberof Transaction
+   * @inner
+   */
+  serializeHeaders(array) {
+    for (const h of this.headers) {
+      h.serialize(array);
+    }
+  }
+
+  /*
+   * Execute hash of the data to sign
+   *
+   * @return {Buffer} data to sign hashed
+   *
+   * @memberof Transaction
+   * @inner
+   */
+  getDataToSignHash() {
+    const dataToSign = this.getDataToSign();
+    return _bitcoreLib.crypto.Hash.sha256sha256(dataToSign);
+  }
+
+  /**
+   * Calculate the minimum tx weight
+   *
+   * @throws {ConstantNotSet} If the weight constants are not set yet
+   *
+   * @return {number} Minimum weight calculated (float)
+   * @memberof Transaction
+   * @inner
+   */
+  calculateWeight() {
+    let txSize = this.toBytes().length;
+
+    // If parents are not in txData, we need to consider them here
+    if (!this.parents || !this.parents.length || this.parents.length === 0) {
+      // Parents are always two and have 32 bytes each
+      txSize += 64;
+    }
+
+    // Here we have to explicitly convert a bigint to a number (a double), which loses precision,
+    // but is exactly compatible with the reference Python implementation because of the calculations below.
+    let sumOutputs = Number(this.getOutputsSum());
+
+    // Preventing division by 0 when handling authority methods that have no outputs
+    sumOutputs = Math.max(1, sumOutputs);
+
+    // We need to take into consideration the decimal places because it is inside the amount.
+    // For instance, if one wants to transfer 20 HTRs, the amount will be 2000.
+    const amount = sumOutputs / 10 ** _constants.DECIMAL_PLACES;
+    let weight = _constants.TX_WEIGHT_CONSTANTS.txWeightCoefficient * Math.log2(txSize) + 4 / (1 + _constants.TX_WEIGHT_CONSTANTS.txMinWeightK / amount) + 4;
+
+    // Make sure the calculated weight is at least the minimum
+    weight = Math.max(weight, _constants.TX_WEIGHT_CONSTANTS.txMinWeight);
+    // FIXME precision difference between backend and frontend (weight (17.76246721531992) is smaller than the minimum weight (17.762467215319923))
+    // Even though it must be fixed, there is no practical effect when mining the transaction
+    return weight + 1e-6;
+  }
+
+  /**
+   * Calculate the sum of outputs. Authority outputs are ignored.
+   *
+   * @return {number} Sum of outputs
+   * @memberof Transaction
+   * @inner
+   */
+  getOutputsSum() {
+    let sumOutputs = 0n;
+    for (const output of this.outputs) {
+      if (output.isAuthority()) {
+        continue;
+      }
+      sumOutputs += output.value;
+    }
+    return sumOutputs;
+  }
+
+  /**
+   * Serialize tx to bytes
+   *
+   * @return {Buffer}
+   * @memberof Transaction
+   * @inner
+   */
+  toBytes() {
+    const arr = [];
+    // Serialize first the funds part
+    //
+    this.serializeFundsFields(arr, true);
+
+    // Weight, timestamp, parents
+    this.serializeGraphFields(arr);
+
+    // Nonce
+    this.serializeNonce(arr);
+
+    // Headers
+    this.serializeHeaders(arr);
+    return _bitcoreLib.util.buffer.concat(arr);
+  }
+
+  /**
+   * Validate transaction information.
+   * For now, we only verify the maximum number of inputs and outputs.
+   *
+   * @throws {MaximumNumberInputsError} If the tx has more inputs than the maximum allowed
+   * @throws {MaximumNumberOutputsError} If the tx has more outputs than the maximum allowed
+   *
+   * @memberof Transaction
+   * @inner
+   */
+  validate() {
+    if (this.inputs.length > _constants.MAX_INPUTS) {
+      throw new _errors.MaximumNumberInputsError(`Transaction has ${this.inputs.length} inputs and can have at most ${_constants.MAX_INPUTS}.`);
+    }
+    if (this.outputs.length > _constants.MAX_OUTPUTS) {
+      throw new _errors.MaximumNumberOutputsError(`Transaction has ${this.outputs.length} outputs and can have at most ${_constants.MAX_OUTPUTS}.`);
+    }
+  }
+
+  /**
+   * Get tx data and return it in hexadecimal
+   *
+   * @return {String} Hexadecimal of a serialized tx
+   * @memberof Transaction
+   * @inner
+   */
+  toHex() {
+    const txBytes = this.toBytes();
+    return _bitcoreLib.util.buffer.bufferToHex(txBytes);
+  }
+
+  /**
+   * Get object type (Transaction or Block)
+   *
+   * @return {string} Type of the object
+   *
+   * @memberof Transaction
+   * @inner
+   */
+  getType() {
+    if (this.isBlock()) {
+      if (this.version === _constants.BLOCK_VERSION) {
+        return txType.BLOCK;
+      }
+      if (this.version === _constants.MERGED_MINED_BLOCK_VERSION) {
+        return txType.MERGED_MINING_BLOCK;
+      }
+    } else {
+      if (this.version === _constants.DEFAULT_TX_VERSION) {
+        return txType.TRANSACTION;
+      }
+      if (this.version === _constants.CREATE_TOKEN_TX_VERSION) {
+        return txType.CREATE_TOKEN_TRANSACTION;
+      }
+    }
+
+    // If there is no match
+    return 'Unknown';
+  }
+
+  /**
+   * Check if object is a block or a transaction
+   *
+   * @return {boolean} true if object is a block, false otherwise
+   *
+   * @memberof Transaction
+   * @inner
+   */
+  isBlock() {
+    return this.version === _constants.BLOCK_VERSION || this.version === _constants.MERGED_MINED_BLOCK_VERSION;
+  }
+
+  /**
+   * Set tx timestamp and weight
+   *
+   * @memberof Transaction
+   * @inner
+   */
+  prepareToSend() {
+    this.updateTimestamp();
+    this.weight = this.calculateWeight();
+  }
+
+  /**
+   * Update transaction timestamp
+   * If timestamp parameter is not sent, we use now
+   *
+   * @memberof Transaction
+   * @inner
+   */
+  updateTimestamp(timestamp = null) {
+    let timestampToSet = timestamp;
+    if (!timestamp) {
+      timestampToSet = Math.floor(Date.now() / 1000);
+    }
+    this.timestamp = timestampToSet;
+  }
+
+  /**
+   * Gets funds fields (signalBits, version, tokens, inputs, outputs) from bytes
+   * and saves them in `this`
+   *
+   * @param srcBuf Buffer with bytes to get fields
+   * @param network Network to get output addresses first byte
+   *
+   * @return Rest of buffer after getting the fields
+   * @memberof Transaction
+   * @inner
+   */
+  getFundsFieldsFromBytes(srcBuf, network) {
+    // Copies buffer locally, not to change the original parameter
+    let buf = Buffer.from(srcBuf);
+
+    // Signal bits
+    [this.signalBits, buf] = (0, _buffer2.unpackToInt)(1, false, buf);
+
+    // Tx version
+    [this.version, buf] = (0, _buffer2.unpackToInt)(1, false, buf);
+    let lenTokens;
+    let lenInputs;
+    let lenOutputs;
+
+    /* eslint-disable prefer-const -- To split these declarations would be confusing.
+     * In all of them the first parameter should be a const and the second a let. */
+    // Len tokens
+    [lenTokens, buf] = (0, _buffer2.unpackToInt)(1, false, buf);
+
+    // Len inputs
+    [lenInputs, buf] = (0, _buffer2.unpackToInt)(1, false, buf);
+
+    // Len outputs
+    [lenOutputs, buf] = (0, _buffer2.unpackToInt)(1, false, buf);
+    /* eslint-enable prefer-const */
+
+    // Tokens array
+    for (let i = 0; i < lenTokens; i++) {
+      let tokenUid;
+      [tokenUid, buf] = (0, _buffer2.unpackToHex)(_constants.TX_HASH_SIZE_BYTES, buf);
+      this.tokens.push(tokenUid);
+    }
+
+    // Inputs array
+    for (let i = 0; i < lenInputs; i++) {
+      let input;
+      [input, buf] = _input.default.createFromBytes(buf);
+      this.inputs.push(input);
+    }
+
+    // Outputs array
+    for (let i = 0; i < lenOutputs; i++) {
+      let output;
+      [output, buf] = _output.default.createFromBytes(buf, network);
+      this.outputs.push(output);
+    }
+    return buf;
+  }
+
+  /**
+   * Gets graph fields (weight, timestamp, parents, nonce) from bytes
+   * and saves them in `this`
+   *
+   * @param srcBuf Buffer with bytes to get fields
+   *
+   * @return Rest of buffer after getting the fields
+   * @memberof Transaction
+   * @inner
+   */
+  getGraphFieldsFromBytes(srcBuf) {
+    // Copies buffer locally, not to change the original parameter
+    let buf = Buffer.from(srcBuf);
+
+    // Weight
+    [this.weight, buf] = (0, _buffer2.unpackToFloat)(buf);
+
+    // Timestamp
+    [this.timestamp, buf] = (0, _buffer2.unpackToInt)(4, false, buf);
+
+    // Parents
+    let parentsLen;
+    // eslint-disable-next-line prefer-const -- To split this declaration would be confusing
+    [parentsLen, buf] = (0, _buffer2.unpackToInt)(1, false, buf);
+    for (let i = 0; i < parentsLen; i++) {
+      let p;
+      [p, buf] = (0, _buffer2.unpackToHex)(_constants.TX_HASH_SIZE_BYTES, buf);
+      this.parents.push(p);
+    }
+
+    // Nonce
+    [this.nonce, buf] = (0, _buffer2.unpackToInt)(4, false, buf);
+    return buf;
+  }
+
+  /**
+   * Gets headers objects from bytes
+   * and pushes them in `this.headers`
+   *
+   * @param srcBuf Buffer with bytes to get headers data
+   * @param network Network used to deserialize headers
+   *
+   * @return Rest of buffer after getting the fields
+   * @memberof Transaction
+   * @inner
+   */
+  getHeadersFromBytes(srcBuf, network) {
+    // Creates a new subarray buffer not to change anything of the source buffer
+    let buf = srcBuf.subarray();
+    if (srcBuf.length <= 1) {
+      // We need 1 byte for the header type and more for the header itself
+      return;
+    }
+
+    // The header serialization doesn't have the headers length
+    // so we must exhaust the buffer until it's empty
+    // or we will throw an error
+    while (buf.length > 0) {
+      const headerId = (0, _types.getVertexHeaderIdFromBuffer)(buf);
+      const headerClass = _parser.default.getHeader(headerId);
+      let header;
+      // eslint-disable-next-line prefer-const -- To split this declaration would be confusing
+      [header, buf] = headerClass.deserialize(buf, network);
+      this.headers.push(header);
+    }
+  }
+
+  /**
+   * Create transaction object from bytes
+   *
+   * @param {Buffer} buf Buffer with bytes to get transaction fields
+   * @param {Network} network Network to get output addresses first byte
+   *
+   * @return {Transaction} Transaction object
+   * @memberof Transaction
+   * @static
+   * @inner
+   */
+  static createFromBytes(buf, network) {
+    const tx = new Transaction([], []);
+
+    // Cloning buffer so we don't mutate anything sent by the user
+    // as soon as it's available natively we should use an immutable buffer
+    let txBuffer = (0, _lodash.clone)(buf);
+    txBuffer = tx.getFundsFieldsFromBytes(txBuffer, network);
+    txBuffer = tx.getGraphFieldsFromBytes(txBuffer);
+
+    // The header serialization doesn't have the headers length
+    // so we must exhaust the buffer until it's empty
+    // or we will throw an error
+    tx.getHeadersFromBytes(txBuffer, network);
+    tx.updateHash();
+    return tx;
+  }
+
+  /**
+   * Get funds fields hash to be used when calculating the tx hash
+   *
+   * @return The sha256 hash digest
+   * @memberof Transaction
+   * @inner
+   */
+  getFundsHash() {
+    const arrFunds = [];
+    this.serializeFundsFields(arrFunds, true);
+    const fundsHash = _crypto.default.createHash('sha256');
+    fundsHash.update(_buffer.default.Buffer.concat(arrFunds));
+    return fundsHash.digest();
+  }
+
+  /**
+   * Get graph and headers fields hash to be used when calculating the tx hash
+   *
+   * @return The sha256 hash digest
+   * @memberof Transaction
+   * @inner
+   */
+  getGraphAndHeadersHash() {
+    const arrGraph = [];
+    this.serializeGraphFields(arrGraph);
+    const hash = _crypto.default.createHash('sha256');
+    hash.update(_buffer.default.Buffer.concat(arrGraph));
+    if (this.headers.length !== 0) {
+      // The hathor-core method returns b'' here if there are no headers
+      const arrHeaders = [];
+      this.serializeHeaders(arrHeaders);
+      hash.update(_buffer.default.Buffer.concat(arrHeaders));
+    }
+    return hash.digest();
+  }
+
+  /**
+   * Calculate first part of transaction hash
+   *
+   * @return {object} Sha256 hash object of part1
+   *
+   * @memberof Transaction
+   * @inner
+   */
+  calculateHashPart1() {
+    const digestedFunds = this.getFundsHash();
+    const digestedGraphAndHeaders = this.getGraphAndHeadersHash();
+    const bufferPart1 = _buffer.default.Buffer.concat([digestedFunds, digestedGraphAndHeaders]);
+    const part1 = _crypto.default.createHash('sha256');
+    part1.update(bufferPart1);
+    return part1;
+  }
+
+  /**
+   * Calculate transaction hash from part1
+   *
+   * @return {Buffer} Transaction hash in bytes
+   *
+   * @memberof Transaction
+   * @inner
+   */
+  calculateHashPart2(part1) {
+    const arrNonce = [];
+    this.serializeNonce(arrNonce);
+    const bufferFill = _buffer.default.Buffer.alloc(12);
+    const fullNonceBytes = _buffer.default.Buffer.concat([bufferFill, _buffer.default.Buffer.concat(arrNonce)]);
+    part1.update(fullNonceBytes);
+    const part2 = _crypto.default.createHash('sha256');
+    part2.update(part1.digest());
+    return part2.digest().reverse();
+  }
+
+  /**
+   * Calculate transaction hash and return it
+   *
+   * @return {string} Transaction hash in hexadecimal
+   *
+   * @memberof Transaction
+   * @inner
+   */
+  calculateHash() {
+    const hashPart1 = this.calculateHashPart1();
+    const hashPart2 = this.calculateHashPart2(hashPart1);
+    return (0, _buffer2.bufferToHex)(hashPart2);
+  }
+
+  /**
+   * Update transaction hash
+   *
+   * @memberof Transaction
+   * @inner
+   */
+  updateHash() {
+    this.hash = this.calculateHash();
+  }
+
+  /**
+   * Return if the tx is a nano contract (if it has nano header)
+   *
+   * @return If the transaction object is a nano contract
+   *
+   * @memberof Transaction
+   * @inner
+   */
+  isNanoContract() {
+    const nanoHeaders = this.getNanoHeaders();
+    if (nanoHeaders.length === 0) return false;
+    return true;
+  }
+
+  /**
+   * Get the nano contract header from the list of headers.
+   *
+   * @throws NanoHeaderNotFound in case the tx does not have a nano header
+   *
+   * @return The nano header object
+   *
+   * @memberof Transaction
+   * @inner
+   */
+  getNanoHeaders() {
+    return _header.default.getHeadersFromTx(this);
+  }
+}
+var _default = exports.default = Transaction;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/models/types.d.ts b/node_modules/@hathor/wallet-lib/oldLib/models/types.d.ts
new file mode 100644
index 0000000..d547632
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/models/types.d.ts
@@ -0,0 +1,93 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+import { OutputValueType } from '../types';
+/**
+ * An output object enriched by the wallet's history methods
+ */
+export type HistoryTransactionOutput = {
+    value: OutputValueType;
+    token_data: number;
+    script: string;
+    decoded: {
+        type?: string;
+        address?: string;
+        timelock?: number | null;
+    };
+    token: string;
+    spent_by?: string | null;
+    selected_as_input?: boolean;
+};
+/**
+ * An input object enriched by the wallet's history methods
+ */
+export type HistoryTransactionInput = {
+    value: OutputValueType;
+    token_data: number;
+    script: string;
+    decoded: {
+        type?: string;
+        address?: string;
+        timelock?: number | null;
+    };
+    token: string;
+    tx_id: string;
+    index: number;
+};
+/**
+ * A populated object from the wallet's history methods,
+ * containing decoded outputs and enriched input objects.
+ */
+export type HistoryTransaction = {
+    tx_id: string;
+    signalBits: number;
+    version: number;
+    weight: number;
+    timestamp: number;
+    is_voided: boolean;
+    nonce: number;
+    inputs: HistoryTransactionInput[];
+    outputs: HistoryTransactionOutput[];
+    parents: string[];
+    token_name?: string;
+    token_symbol?: string;
+    tokens: string[];
+};
+/**
+ * A balance object for a token on a transaction or across transactions
+ * containing token and authority balances.
+ */
+export interface Balance {
+    balance: TokenBalance;
+    authority: AuthorityBalance;
+}
+export interface TokenBalance {
+    unlocked: OutputValueType;
+    locked: OutputValueType;
+}
+export interface AuthorityBalance {
+    unlocked: Authority;
+    locked: Authority;
+}
+export interface Authority {
+    mint: OutputValueType;
+    melt: OutputValueType;
+}
+/**
+ * A backend-mediated Atomic Swap proposal, containing backend metadata such as id, version and history
+ */
+export interface AtomicSwapProposal {
+    proposalId: string;
+    partialTx: string;
+    signatures: string | null;
+    timestamp: string;
+    version: number;
+    history: {
+        partialTx: string;
+        timestamp: string;
+    }[];
+}
+//# sourceMappingURL=types.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/models/types.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/models/types.d.ts.map
new file mode 100644
index 0000000..7f606b2
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/models/types.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"types.d.ts","sourceRoot":"","sources":["../../src/models/types.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;AAEH,OAAO,EAAE,eAAe,EAAE,MAAM,UAAU,CAAC;AAE3C;;GAEG;AACH,MAAM,MAAM,wBAAwB,GAAG;IACrC,KAAK,EAAE,eAAe,CAAC;IACvB,UAAU,EAAE,MAAM,CAAC;IACnB,MAAM,EAAE,MAAM,CAAC;IACf,OAAO,EAAE;QACP,IAAI,CAAC,EAAE,MAAM,CAAC;QACd,OAAO,CAAC,EAAE,MAAM,CAAC;QACjB,QAAQ,CAAC,EAAE,MAAM,GAAG,IAAI,CAAC;KAC1B,CAAC;IACF,KAAK,EAAE,MAAM,CAAC;IACd,QAAQ,CAAC,EAAE,MAAM,GAAG,IAAI,CAAC;IACzB,iBAAiB,CAAC,EAAE,OAAO,CAAC;CAC7B,CAAC;AAEF;;GAEG;AACH,MAAM,MAAM,uBAAuB,GAAG;IACpC,KAAK,EAAE,eAAe,CAAC;IACvB,UAAU,EAAE,MAAM,CAAC;IACnB,MAAM,EAAE,MAAM,CAAC;IACf,OAAO,EAAE;QACP,IAAI,CAAC,EAAE,MAAM,CAAC;QACd,OAAO,CAAC,EAAE,MAAM,CAAC;QACjB,QAAQ,CAAC,EAAE,MAAM,GAAG,IAAI,CAAC;KAC1B,CAAC;IACF,KAAK,EAAE,MAAM,CAAC;IACd,KAAK,EAAE,MAAM,CAAC;IACd,KAAK,EAAE,MAAM,CAAC;CACf,CAAC;AAEF;;;GAGG;AACH,MAAM,MAAM,kBAAkB,GAAG;IAC/B,KAAK,EAAE,MAAM,CAAC;IACd,UAAU,EAAE,MAAM,CAAC;IACnB,OAAO,EAAE,MAAM,CAAC;IAChB,MAAM,EAAE,MAAM,CAAC;IACf,SAAS,EAAE,MAAM,CAAC;IAClB,SAAS,EAAE,OAAO,CAAC;IACnB,KAAK,EAAE,MAAM,CAAC;IACd,MAAM,EAAE,uBAAuB,EAAE,CAAC;IAClC,OAAO,EAAE,wBAAwB,EAAE,CAAC;IACpC,OAAO,EAAE,MAAM,EAAE,CAAC;IAClB,UAAU,CAAC,EAAE,MAAM,CAAC;IACpB,YAAY,CAAC,EAAE,MAAM,CAAC;IACtB,MAAM,EAAE,MAAM,EAAE,CAAC;CAClB,CAAC;AAEF;;;GAGG;AACH,MAAM,WAAW,OAAO;IACtB,OAAO,EAAE,YAAY,CAAC;IACtB,SAAS,EAAE,gBAAgB,CAAC;CAC7B;AAED,MAAM,WAAW,YAAY;IAC3B,QAAQ,EAAE,eAAe,CAAC;IAC1B,MAAM,EAAE,eAAe,CAAC;CACzB;AAED,MAAM,WAAW,gBAAgB;IAC/B,QAAQ,EAAE,SAAS,CAAC;IACpB,MAAM,EAAE,SAAS,CAAC;CACnB;AAED,MAAM,WAAW,SAAS;IACxB,IAAI,EAAE,eAAe,CAAC;IACtB,IAAI,EAAE,eAAe,CAAC;CACvB;AAED;;GAEG;AACH,MAAM,WAAW,kBAAkB;IACjC,UAAU,EAAE,MAAM,CAAC;IACnB,SAAS,EAAE,MAAM,CAAC;IAClB,UAAU,EAAE,MAAM,GAAG,IAAI,CAAC;IAC1B,SAAS,EAAE,MAAM,CAAC;IAClB,OAAO,EAAE,MAAM,CAAC;IAChB,OAAO,EAAE;QAAE,SAAS,EAAE,MAAM,CAAC;QAAC,SAAS,EAAE,MAAM,CAAA;KAAE,EAAE,CAAC;CACrD"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/models/types.js b/node_modules/@hathor/wallet-lib/oldLib/models/types.js
new file mode 100644
index 0000000..430afc1
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/models/types.js
@@ -0,0 +1,5 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/builder.d.ts b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/builder.d.ts
new file mode 100644
index 0000000..02c1e6e
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/builder.d.ts
@@ -0,0 +1,203 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/// <reference types="node" />
+import Transaction from '../models/transaction';
+import CreateTokenTransaction from '../models/create_token_transaction';
+import HathorWallet from '../new/wallet';
+import { NanoContractAction, NanoContractBuilderCreateTokenOptions, NanoContractVertexType, IArgumentField } from './types';
+import { IDataInput, IDataOutput } from '../types';
+import Address from '../models/address';
+declare class NanoContractTransactionBuilder {
+    blueprintId: string | null | undefined;
+    ncId: string | null | undefined;
+    method: string | null;
+    actions: NanoContractAction[] | null;
+    caller: Address | null;
+    args: unknown[] | null;
+    parsedArgs: IArgumentField[] | null;
+    serializedArgs: Buffer | null;
+    wallet: HathorWallet | null;
+    vertexType: NanoContractVertexType | null;
+    createTokenOptions: NanoContractBuilderCreateTokenOptions | null;
+    tokenFeeAddedInDeposit: boolean;
+    constructor();
+    /**
+     * Set object method attribute
+     *
+     * @param method Method name
+     *
+     * @memberof NanoContractTransactionBuilder
+     * @inner
+     */
+    setMethod(method: string): this;
+    /**
+     * Set object actions attribute
+     *
+     * @param actions List of actions
+     *
+     * @memberof NanoContractTransactionBuilder
+     * @inner
+     */
+    setActions(actions: NanoContractAction[] | null | undefined): this;
+    /**
+     * Set object args attribute
+     *
+     * @param args List of arguments
+     *
+     * @memberof NanoContractTransactionBuilder
+     * @inner
+     */
+    setArgs(args: unknown[] | null): this;
+    /**
+     * Set object caller attribute
+     *
+     * @param caller Caller address
+     *
+     * @memberof NanoContractTransactionBuilder
+     * @inner
+     */
+    setCaller(caller: Address): this;
+    /**
+     * Set object blueprintId attribute
+     *
+     * @param blueprintId Blueprint id
+     *
+     * @memberof NanoContractTransactionBuilder
+     * @inner
+     */
+    setBlueprintId(blueprintId: string): this;
+    /**
+     * Set object ncId attribute
+     *
+     * @param {ncId} Nano contract id
+     *
+     * @memberof NanoContractTransactionBuilder
+     * @inner
+     */
+    setNcId(ncId: string): this;
+    /**
+     * Set object wallet attribute
+     *
+     * @param {wallet} Wallet object building this transaction
+     *
+     * @memberof NanoContractTransactionBuilder
+     * @inner
+     */
+    setWallet(wallet: HathorWallet): this;
+    /**
+     * Set vertex type
+     *
+     * @param {vertexType} The vertex type
+     * @param {createTokenOptions} Options for the token creation tx
+     *
+     * @memberof NanoContractTransactionBuilder
+     * @inner
+     */
+    setVertexType(vertexType: NanoContractVertexType, createTokenOptions?: NanoContractBuilderCreateTokenOptions | null): this;
+    /**
+     * Execute a deposit action
+     * Create inputs (and maybe change outputs) to complete the deposit
+     *
+     * @param {action} Action to be completed (must be a deposit type)
+     *
+     * @memberof NanoContractTransactionBuilder
+     * @inner
+     */
+    executeDeposit(action: NanoContractAction): Promise<{
+        inputs: IDataInput[];
+        outputs: IDataOutput[];
+    }>;
+    /**
+     * Execute a withdrawal action
+     * Create outputs to complete the withdrawal
+     * If the transaction is a token creation and
+     * the contract will pay for the deposit fee,
+     * then creates the output only of the difference
+     *
+     * @param {action} Action to be completed (must be a withdrawal type)
+     *
+     * @memberof NanoContractTransactionBuilder
+     * @inner
+     */
+    executeWithdrawal(action: NanoContractAction): IDataOutput | null;
+    /**
+     * Execute a grant authority action
+     * Create inputs (and maybe change output) to complete the action
+     *
+     * @param {action} Action to be completed (must be a grant authority type)
+     *
+     * @memberof NanoContractTransactionBuilder
+     * @inner
+     */
+    executeGrantAuthority(action: NanoContractAction): Promise<{
+        inputs: IDataInput[];
+        outputs: IDataOutput[];
+    }>;
+    /**
+     * Execute an acquire authority action
+     *
+     * @param {action} Action to be completed (must be an acquire authority type)
+     *
+     * @memberof NanoContractTransactionBuilder
+     * @inner
+     */
+    executeAcquireAuthority(action: NanoContractAction): IDataOutput | null;
+    /**
+     * Verify if the builder attributes are valid for the nano build
+     *
+     * @throws {NanoContractTransactionError} In case the attributes are not valid
+     *
+     * @memberof NanoContractTransactionBuilder
+     * @inner
+     */
+    verify(): Promise<void>;
+    /**
+     * Serialize nano arguments in an array of Buffer
+     * and store the serialized data in this.serializedArgs
+     *
+     * @throws {NanoContractTransactionError} In case the arguments are not valid
+     *
+     * @memberof NanoContractTransactionBuilder
+     * @inner
+     */
+    serializeArgs(): Promise<void>;
+    /**
+     * Build inputs and outputs from nano actions
+     *
+     * @throws {Error} If a nano action type is invalid
+     *
+     * @memberof NanoContractTransactionBuilder
+     * @inner
+     */
+    buildInputsOutputs(): Promise<{
+        inputs: IDataInput[];
+        outputs: IDataOutput[];
+        tokens: string[];
+    }>;
+    /**
+     * Build a transaction object from the built inputs/outputs/tokens
+     *
+     * It will create a Transaction or CreateTokenTransaction, depending on the vertex type
+     *
+     * @throws {NanoContractTransactionError} In case the create token options is null
+     *
+     * @memberof NanoContractTransactionBuilder
+     * @inner
+     */
+    buildTransaction(inputs: IDataInput[], outputs: IDataOutput[], tokens: string[]): Promise<Transaction | CreateTokenTransaction>;
+    /**
+     * Build a full transaction with nano headers from nano contract data
+     *
+     * @throws {NanoContractTransactionError} In case the arguments to build the tx are invalid
+     *
+     * @memberof NanoContractTransactionBuilder
+     * @inner
+     */
+    build(): Promise<Transaction>;
+}
+export default NanoContractTransactionBuilder;
+//# sourceMappingURL=builder.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/builder.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/builder.d.ts.map
new file mode 100644
index 0000000..588ff1a
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/builder.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"builder.d.ts","sourceRoot":"","sources":["../../src/nano_contracts/builder.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/builder.js b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/builder.js
new file mode 100644
index 0000000..f0e22b7
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/builder.js
@@ -0,0 +1,631 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+var _lodash = require("lodash");
+var _address = require("../utils/address");
+var _tokens = _interopRequireDefault(require("../utils/tokens"));
+var _transaction = _interopRequireDefault(require("../utils/transaction"));
+var _constants = require("../constants");
+var _errors = require("../errors");
+var _types = require("./types");
+var _utils = require("./utils");
+var _header = _interopRequireDefault(require("./header"));
+var _leb = _interopRequireDefault(require("../utils/leb128"));
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
+function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
+function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+class NanoContractTransactionBuilder {
+  constructor() {
+    _defineProperty(this, "blueprintId", void 0);
+    // nano contract ID, null if initialize
+    _defineProperty(this, "ncId", void 0);
+    _defineProperty(this, "method", void 0);
+    _defineProperty(this, "actions", void 0);
+    _defineProperty(this, "caller", void 0);
+    _defineProperty(this, "args", void 0);
+    _defineProperty(this, "parsedArgs", void 0);
+    _defineProperty(this, "serializedArgs", void 0);
+    _defineProperty(this, "wallet", void 0);
+    // So far we support Transaction or CreateTokenTransaction
+    _defineProperty(this, "vertexType", void 0);
+    // In case of a CreateTokenTransaction, these are the options
+    // for the tx creation used by the tokens utils method
+    _defineProperty(this, "createTokenOptions", void 0);
+    // This parameter is used for token creation transactions
+    // and indicates if the token deposit utxo was already added
+    // in the action deposit phase
+    _defineProperty(this, "tokenFeeAddedInDeposit", void 0);
+    this.blueprintId = null;
+    this.ncId = null;
+    this.method = null;
+    this.actions = null;
+    this.caller = null;
+    this.args = null;
+    this.parsedArgs = null;
+    this.serializedArgs = null;
+    this.wallet = null;
+    this.vertexType = null;
+    this.createTokenOptions = null;
+    this.tokenFeeAddedInDeposit = false;
+  }
+
+  /**
+   * Set object method attribute
+   *
+   * @param method Method name
+   *
+   * @memberof NanoContractTransactionBuilder
+   * @inner
+   */
+  setMethod(method) {
+    this.method = method;
+    return this;
+  }
+
+  /**
+   * Set object actions attribute
+   *
+   * @param actions List of actions
+   *
+   * @memberof NanoContractTransactionBuilder
+   * @inner
+   */
+  setActions(actions) {
+    if (!actions) {
+      return this;
+    }
+    const parseResult = _types.INanoContractActionSchema.array().safeParse(actions);
+    if (!parseResult.success) {
+      throw new _errors.NanoContractTransactionError(`Invalid actions. Error: ${parseResult.error.message}.`);
+    }
+    this.actions = parseResult.data;
+    return this;
+  }
+
+  /**
+   * Set object args attribute
+   *
+   * @param args List of arguments
+   *
+   * @memberof NanoContractTransactionBuilder
+   * @inner
+   */
+  setArgs(args) {
+    this.args = args ?? [];
+    return this;
+  }
+
+  /**
+   * Set object caller attribute
+   *
+   * @param caller Caller address
+   *
+   * @memberof NanoContractTransactionBuilder
+   * @inner
+   */
+  setCaller(caller) {
+    this.caller = caller;
+    return this;
+  }
+
+  /**
+   * Set object blueprintId attribute
+   *
+   * @param blueprintId Blueprint id
+   *
+   * @memberof NanoContractTransactionBuilder
+   * @inner
+   */
+  setBlueprintId(blueprintId) {
+    this.blueprintId = blueprintId;
+    return this;
+  }
+
+  /**
+   * Set object ncId attribute
+   *
+   * @param {ncId} Nano contract id
+   *
+   * @memberof NanoContractTransactionBuilder
+   * @inner
+   */
+  setNcId(ncId) {
+    this.ncId = ncId;
+    return this;
+  }
+
+  /**
+   * Set object wallet attribute
+   *
+   * @param {wallet} Wallet object building this transaction
+   *
+   * @memberof NanoContractTransactionBuilder
+   * @inner
+   */
+  setWallet(wallet) {
+    this.wallet = wallet;
+    return this;
+  }
+
+  /**
+   * Set vertex type
+   *
+   * @param {vertexType} The vertex type
+   * @param {createTokenOptions} Options for the token creation tx
+   *
+   * @memberof NanoContractTransactionBuilder
+   * @inner
+   */
+  setVertexType(vertexType, createTokenOptions = null) {
+    this.vertexType = vertexType;
+    this.createTokenOptions = createTokenOptions;
+    return this;
+  }
+
+  /**
+   * Execute a deposit action
+   * Create inputs (and maybe change outputs) to complete the deposit
+   *
+   * @param {action} Action to be completed (must be a deposit type)
+   *
+   * @memberof NanoContractTransactionBuilder
+   * @inner
+   */
+  async executeDeposit(action) {
+    if (action.type !== _types.NanoContractActionType.DEPOSIT) {
+      throw new _errors.NanoContractTransactionError("Can't execute a deposit with an action which type is different than deposit.");
+    }
+    if (!action.amount || !action.token) {
+      throw new _errors.NanoContractTransactionError('Amount and token are required for deposit action.');
+    }
+    const changeAddressParam = action.changeAddress;
+    if (changeAddressParam && !(await this.wallet.isAddressMine(changeAddressParam))) {
+      throw new _errors.NanoContractTransactionError('Change address must belong to the same wallet.');
+    }
+    let {
+      amount
+    } = action;
+    if (action.token === _constants.NATIVE_TOKEN_UID && this.vertexType === _types.NanoContractVertexType.CREATE_TOKEN_TRANSACTION && !this.createTokenOptions.contractPaysTokenDeposit) {
+      // We will query for HTR utxos to fill the deposit action
+      // and this is a transaction that creates a token and the contract
+      // won't pay for the deposit fee, so we also add in this utxo query
+      // the token deposit fee and data output fee
+      const dataArray = this.createTokenOptions.data ?? [];
+      const htrToCreateToken = _tokens.default.getTransactionHTRDeposit(this.createTokenOptions.amount, dataArray.length, this.wallet.storage);
+      amount += htrToCreateToken;
+      this.tokenFeeAddedInDeposit = true;
+    }
+
+    // Get the utxos with the amount of the deposit and create the inputs
+    const utxoOptions = {
+      token: action.token
+    };
+    if (action.address) {
+      utxoOptions.filter_address = action.address;
+    }
+    let utxosData;
+    try {
+      utxosData = await this.wallet.getUtxosForAmount(amount, utxoOptions);
+    } catch (e) {
+      if (e instanceof _errors.UtxoError) {
+        throw new _errors.NanoContractTransactionError('Not enough utxos to execute the deposit.');
+      }
+      throw e;
+    }
+    const inputs = [];
+    for (const utxo of utxosData.utxos) {
+      await this.wallet.markUtxoSelected(utxo.txId, utxo.index, true);
+      inputs.push({
+        txId: utxo.txId,
+        index: utxo.index,
+        value: utxo.value,
+        authorities: utxo.authorities,
+        token: utxo.tokenId,
+        address: utxo.address
+      });
+    }
+    const outputs = [];
+    // If there's a change amount left in the utxos, create the change output
+    if (utxosData.changeAmount) {
+      const changeAddressStr = changeAddressParam || (await this.wallet.getCurrentAddress()).address;
+      outputs.push({
+        type: (0, _address.getAddressType)(changeAddressStr, this.wallet.getNetworkObject()),
+        address: changeAddressStr,
+        value: utxosData.changeAmount,
+        timelock: null,
+        token: action.token,
+        authorities: 0n,
+        isChange: true
+      });
+    }
+    return {
+      inputs,
+      outputs
+    };
+  }
+
+  /**
+   * Execute a withdrawal action
+   * Create outputs to complete the withdrawal
+   * If the transaction is a token creation and
+   * the contract will pay for the deposit fee,
+   * then creates the output only of the difference
+   *
+   * @param {action} Action to be completed (must be a withdrawal type)
+   *
+   * @memberof NanoContractTransactionBuilder
+   * @inner
+   */
+  executeWithdrawal(action) {
+    if (action.type !== _types.NanoContractActionType.WITHDRAWAL) {
+      throw new _errors.NanoContractTransactionError("Can't execute a withdrawal with an action which type is different than withdrawal.");
+    }
+    if (!action.amount || !action.token) {
+      throw new _errors.NanoContractTransactionError('Amount and token are required for withdrawal action.');
+    }
+
+    // If it's a token creation creation tx and the contract is paying the deposit fee, then
+    // we must reduce the amount created for the output from the total action amount
+    let withdrawalAmount = action.amount;
+    if (this.vertexType === _types.NanoContractVertexType.CREATE_TOKEN_TRANSACTION) {
+      if (this.createTokenOptions === null) {
+        throw new _errors.NanoContractTransactionError('For a token creation transaction we must have the options defined.');
+      }
+
+      // We pay the deposit in native token uid
+      if (this.createTokenOptions.contractPaysTokenDeposit && action.token === _constants.NATIVE_TOKEN_UID) {
+        const dataArray = this.createTokenOptions.data ?? [];
+        const htrToCreateToken = _tokens.default.getTransactionHTRDeposit(this.createTokenOptions.amount, dataArray.length, this.wallet.storage);
+        withdrawalAmount -= htrToCreateToken;
+      }
+    }
+    if (withdrawalAmount === 0n) {
+      // The whole withdrawal amount was used to pay deposit token fee
+      return null;
+    }
+    if (!action.address) {
+      throw new _errors.NanoContractTransactionError('Address is required for withdrawal action that creates outputs.');
+    }
+
+    // Create the output with the withdrawal address and amount
+    return {
+      type: (0, _address.getAddressType)(action.address, this.wallet.getNetworkObject()),
+      address: action.address,
+      value: withdrawalAmount,
+      timelock: null,
+      token: action.token,
+      authorities: 0n
+    };
+  }
+
+  /**
+   * Execute a grant authority action
+   * Create inputs (and maybe change output) to complete the action
+   *
+   * @param {action} Action to be completed (must be a grant authority type)
+   *
+   * @memberof NanoContractTransactionBuilder
+   * @inner
+   */
+  async executeGrantAuthority(action) {
+    if (action.type !== _types.NanoContractActionType.GRANT_AUTHORITY) {
+      throw new _errors.NanoContractTransactionError("Can't execute a grant authority with an action which type is different than grant authority.");
+    }
+    if (!action.authority || !action.token) {
+      throw new _errors.NanoContractTransactionError('Authority and token are required for grant authority action.');
+    }
+    const authorityAddressParam = action.authorityAddress;
+    if (authorityAddressParam && !(await this.wallet.isAddressMine(authorityAddressParam))) {
+      throw new _errors.NanoContractTransactionError('Authority address must belong to the same wallet.');
+    }
+
+    // Get the utxos with the authority of the action and create the input
+    const utxos = await this.wallet.getAuthorityUtxo(action.token, action.authority, {
+      many: false,
+      only_available_utxos: true,
+      filter_address: action.address
+    });
+    if (!utxos || utxos.length === 0) {
+      throw new _errors.NanoContractTransactionError('Not enough authority utxos to execute the grant authority.');
+    }
+    const inputs = [];
+    // The method gets only one utxo
+    const utxo = utxos[0];
+    await this.wallet.markUtxoSelected(utxo.txId, utxo.index, true);
+    inputs.push({
+      txId: utxo.txId,
+      index: utxo.index,
+      value: utxo.value,
+      authorities: utxo.authorities,
+      token: utxo.token,
+      address: utxo.address
+    });
+    const outputs = [];
+    // If there's the authorityAddress param, then we must create another authority output for this address
+    if (action.authorityAddress) {
+      outputs.push({
+        type: (0, _address.getAddressType)(action.authorityAddress, this.wallet.getNetworkObject()),
+        address: action.authorityAddress,
+        value: action.authority === 'mint' ? _constants.TOKEN_MINT_MASK : _constants.TOKEN_MELT_MASK,
+        timelock: null,
+        token: action.token,
+        authorities: action.authority === 'mint' ? _constants.TOKEN_MINT_MASK : _constants.TOKEN_MELT_MASK
+      });
+    }
+    return {
+      inputs,
+      outputs
+    };
+  }
+
+  /**
+   * Execute an acquire authority action
+   *
+   * @param {action} Action to be completed (must be an acquire authority type)
+   *
+   * @memberof NanoContractTransactionBuilder
+   * @inner
+   */
+  executeAcquireAuthority(action) {
+    if (action.type !== _types.NanoContractActionType.ACQUIRE_AUTHORITY) {
+      throw new _errors.NanoContractTransactionError("Can't execute an acquire authority with an action which type is different than acquire authority.");
+    }
+    if (!action.address || !action.authority || !action.token) {
+      throw new _errors.NanoContractTransactionError('Address, authority, and token are required for acquire authority action.');
+    }
+
+    // Create the output with the authority of the action
+    return {
+      type: (0, _address.getAddressType)(action.address, this.wallet.getNetworkObject()),
+      address: action.address,
+      value: action.authority === 'mint' ? _constants.TOKEN_MINT_MASK : _constants.TOKEN_MELT_MASK,
+      timelock: null,
+      token: action.token,
+      authorities: action.authority === 'mint' ? _constants.TOKEN_MINT_MASK : _constants.TOKEN_MELT_MASK
+    };
+  }
+
+  /**
+   * Verify if the builder attributes are valid for the nano build
+   *
+   * @throws {NanoContractTransactionError} In case the attributes are not valid
+   *
+   * @memberof NanoContractTransactionBuilder
+   * @inner
+   */
+  async verify() {
+    if (this.method === _constants.NANO_CONTRACTS_INITIALIZE_METHOD && !this.blueprintId) {
+      // Initialize needs the blueprint ID
+      throw new _errors.NanoContractTransactionError('Missing blueprint id. Parameter blueprintId in data');
+    }
+    if (this.method !== _constants.NANO_CONTRACTS_INITIALIZE_METHOD) {
+      // Get the blueprint id from the nano transaction in the full node
+      if (!this.ncId) {
+        throw new _errors.NanoContractTransactionError(`Nano contract ID cannot be null for method ${this.method}`);
+      }
+      let response;
+      try {
+        response = await this.wallet.getFullTxById(this.ncId);
+      } catch {
+        // Error getting nano contract transaction data from the full node
+        throw new _errors.NanoContractTransactionError(`Error getting nano contract transaction data with id ${this.ncId} from the full node`);
+      }
+      if (!response.tx.nc_id) {
+        throw new _errors.NanoContractTransactionError(`Transaction with id ${this.ncId} is not a nano contract transaction.`);
+      }
+      this.blueprintId = response.tx.nc_blueprint_id;
+    }
+    if (!this.blueprintId || !this.method || !this.caller) {
+      throw new _errors.NanoContractTransactionError('Must have blueprint id, method and caller.');
+    }
+    try {
+      this.caller.validateAddress();
+    } catch (err) {
+      const message = err instanceof Error ? err.message : 'Could not validate caller address';
+      throw new _errors.NanoContractTransactionError(message);
+    }
+
+    // Validate if the arguments match the expected method arguments
+    this.parsedArgs = await (0, _utils.validateAndParseBlueprintMethodArgs)(this.blueprintId, this.method, this.args, this.wallet.getNetworkObject());
+  }
+
+  /**
+   * Serialize nano arguments in an array of Buffer
+   * and store the serialized data in this.serializedArgs
+   *
+   * @throws {NanoContractTransactionError} In case the arguments are not valid
+   *
+   * @memberof NanoContractTransactionBuilder
+   * @inner
+   */
+  async serializeArgs() {
+    if (!this.parsedArgs) {
+      throw new _errors.NanoContractTransactionError('Arguments should be parsed and validated before serialization.');
+    }
+    const serializedArray = [_leb.default.encodeUnsigned(this.parsedArgs?.length ?? 0)];
+    if (this.args) {
+      for (const arg of this.parsedArgs) {
+        serializedArray.push(arg.field.toBuffer());
+      }
+    }
+    this.serializedArgs = Buffer.concat(serializedArray);
+  }
+
+  /**
+   * Build inputs and outputs from nano actions
+   *
+   * @throws {Error} If a nano action type is invalid
+   *
+   * @memberof NanoContractTransactionBuilder
+   * @inner
+   */
+  async buildInputsOutputs() {
+    let inputs = [];
+    let outputs = [];
+    let tokens = [];
+    if (this.actions) {
+      const tokenSet = new Set();
+      for (const action of this.actions) {
+        // Get token list
+        if (action.token !== _constants.NATIVE_TOKEN_UID) {
+          tokenSet.add(action.token);
+        }
+      }
+      tokens = Array.from(tokenSet);
+      for (const action of this.actions) {
+        // Call action
+        switch (action.type) {
+          case _types.NanoContractActionType.DEPOSIT:
+            {
+              const {
+                inputs: depositInputs,
+                outputs: depositOutputs
+              } = await this.executeDeposit(action);
+              inputs = (0, _lodash.concat)(inputs, depositInputs);
+              outputs = (0, _lodash.concat)(outputs, depositOutputs);
+              break;
+            }
+          case _types.NanoContractActionType.WITHDRAWAL:
+            {
+              const outputWithdrawal = this.executeWithdrawal(action);
+              if (outputWithdrawal) {
+                outputs = (0, _lodash.concat)(outputs, outputWithdrawal);
+              }
+              break;
+            }
+          case _types.NanoContractActionType.GRANT_AUTHORITY:
+            {
+              const {
+                inputs: grantInputs,
+                outputs: grantOutputs
+              } = await this.executeGrantAuthority(action);
+              inputs = (0, _lodash.concat)(inputs, grantInputs);
+              outputs = (0, _lodash.concat)(outputs, grantOutputs);
+              break;
+            }
+          case _types.NanoContractActionType.ACQUIRE_AUTHORITY:
+            {
+              const outputAcquire = this.executeAcquireAuthority(action);
+              if (outputAcquire) {
+                outputs = (0, _lodash.concat)(outputs, outputAcquire);
+              }
+              break;
+            }
+          default:
+            throw new Error('Invalid type for nano contract action.');
+        }
+      }
+    }
+    return {
+      inputs,
+      outputs,
+      tokens
+    };
+  }
+
+  /**
+   * Build a transaction object from the built inputs/outputs/tokens
+   *
+   * It will create a Transaction or CreateTokenTransaction, depending on the vertex type
+   *
+   * @throws {NanoContractTransactionError} In case the create token options is null
+   *
+   * @memberof NanoContractTransactionBuilder
+   * @inner
+   */
+  async buildTransaction(inputs, outputs, tokens) {
+    if (this.vertexType === _types.NanoContractVertexType.TRANSACTION) {
+      return _transaction.default.createTransactionFromData({
+        version: _constants.DEFAULT_TX_VERSION,
+        inputs,
+        outputs,
+        tokens
+      }, this.wallet.getNetworkObject());
+    }
+    if (this.vertexType === _types.NanoContractVertexType.CREATE_TOKEN_TRANSACTION) {
+      if (this.createTokenOptions === null) {
+        throw new _errors.NanoContractTransactionError('Create token options cannot be null when creating a create token transaction.');
+      }
+
+      // It's a token creation transaction
+      // then we get the token creation data from the utils method
+      // and concatenate the nano actions inputs/outputs/tokens
+      const data = await _tokens.default.prepareCreateTokenData(this.createTokenOptions.mintAddress, this.createTokenOptions.name, this.createTokenOptions.symbol, this.createTokenOptions.amount, this.wallet.storage, {
+        changeAddress: this.createTokenOptions.changeAddress,
+        createMint: this.createTokenOptions.createMint,
+        mintAuthorityAddress: this.createTokenOptions.mintAuthorityAddress,
+        createMelt: this.createTokenOptions.createMelt,
+        meltAuthorityAddress: this.createTokenOptions.meltAuthorityAddress,
+        data: this.createTokenOptions.data,
+        isCreateNFT: this.createTokenOptions.isCreateNFT,
+        skipDepositFee: this.createTokenOptions.contractPaysTokenDeposit || this.tokenFeeAddedInDeposit
+      });
+      data.inputs = (0, _lodash.concat)(data.inputs, inputs);
+      data.outputs = (0, _lodash.concat)(data.outputs, outputs);
+      data.tokens = (0, _lodash.uniq)((0, _lodash.concat)(data.tokens, tokens));
+      return _transaction.default.createTransactionFromData(data, this.wallet.getNetworkObject());
+    }
+    throw new _errors.NanoContractTransactionError('Invalid vertex type.');
+  }
+
+  /**
+   * Build a full transaction with nano headers from nano contract data
+   *
+   * @throws {NanoContractTransactionError} In case the arguments to build the tx are invalid
+   *
+   * @memberof NanoContractTransactionBuilder
+   * @inner
+   */
+  async build() {
+    let inputs;
+    let outputs;
+    let tokens;
+    try {
+      await this.verify();
+
+      // Transform actions into inputs and outputs
+      ({
+        inputs,
+        outputs,
+        tokens
+      } = await this.buildInputsOutputs());
+
+      // Serialize the method arguments
+      await this.serializeArgs();
+      const ncId = this.method === _constants.NANO_CONTRACTS_INITIALIZE_METHOD ? this.blueprintId : this.ncId;
+      if (ncId == null) {
+        // This was validated in the beginning of the method but the linter was complaining about it
+        throw new Error('This should never happen.');
+      }
+      const tx = await this.buildTransaction(inputs, outputs, tokens);
+      const seqnum = await this.wallet.getNanoHeaderSeqnum(this.caller);
+      let nanoHeaderActions = [];
+      if (this.actions) {
+        nanoHeaderActions = this.actions.map(action => {
+          return (0, _utils.mapActionToActionHeader)(action, tokens);
+        });
+      }
+      const nanoHeader = new _header.default(ncId, this.method, this.serializedArgs, nanoHeaderActions, seqnum, this.caller, null);
+      tx.headers.push(nanoHeader);
+      return tx;
+    } catch (e) {
+      if (!inputs) {
+        throw e;
+      }
+      for (const input of inputs) {
+        await this.wallet.markUtxoSelected(input.txId, input.index, false);
+      }
+      throw e;
+    }
+  }
+}
+var _default = exports.default = NanoContractTransactionBuilder;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/address.d.ts b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/address.d.ts
new file mode 100644
index 0000000..810a08d
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/address.d.ts
@@ -0,0 +1,38 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/// <reference types="node" />
+import { z } from 'zod';
+import { BufferROExtract } from '../types';
+import { NCFieldBase } from './base';
+import Address from '../../models/address';
+import Network from '../../models/network';
+export declare const AddressSchema: z.ZodString;
+export declare class AddressField extends NCFieldBase<string, Address> {
+    value: Address | null;
+    network: Network;
+    constructor(network: Network, value?: Address | null);
+    getType(): string;
+    /**
+     * Create an instance of AddressField, may be empty to allow reading from other sources.
+     * @example
+     * ```ts
+     * const testnet = new Network('testnet');
+     * const buf = Buffer.from('4969ffb1549f2e00f30bfc0cf0b9207ed96f7f33ba578d4852', 'hex');
+     *
+     * const field = AddressField.new(testnet);
+     * const parseData = field.fromBuffer(buf);
+     * const fieldFromUser = AddressField.new(testnet).fromUser('WYLW8ujPemSuLJwbeNvvH6y7nakaJ6cEwT');
+     * ```
+     */
+    static new(network: Network): AddressField;
+    createNew(): AddressField;
+    fromBuffer(buf: Buffer): BufferROExtract<Address>;
+    toBuffer(): Buffer;
+    fromUser(data: unknown): AddressField;
+    toUser(): string;
+}
+//# sourceMappingURL=address.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/address.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/address.d.ts.map
new file mode 100644
index 0000000..bb78624
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/address.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"address.d.ts","sourceRoot":"","sources":["../../../src/nano_contracts/fields/address.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;;AAGH,OAAO,EAAE,CAAC,EAAE,MAAM,KAAK,CAAC;AACxB,OAAO,EAAE,eAAe,EAAE,MAAM,UAAU,CAAC;AAC3C,OAAO,EAAE,WAAW,EAAE,MAAM,QAAQ,CAAC;AACrC,OAAO,OAAO,MAAM,sBAAsB,CAAC;AAC3C,OAAO,OAAO,MAAM,sBAAsB,CAAC;AAG3C,eAAO,MAAM,aAAa,aAEuD,CAAC;AAElF,qBAAa,YAAa,SAAQ,WAAW,CAAC,MAAM,EAAE,OAAO,CAAC;IAC5D,KAAK,EAAE,OAAO,GAAG,IAAI,CAAC;IAEtB,OAAO,EAAE,OAAO,CAAC;gBAEL,OAAO,EAAE,OAAO,EAAE,KAAK,GAAE,OAAO,GAAG,IAAW;IAM1D,OAAO;IAIP;;;;;;;;;;;OAWG;IACH,MAAM,CAAC,GAAG,CAAC,OAAO,EAAE,OAAO,GAAG,YAAY;IAI1C,SAAS;IAIT,UAAU,CAAC,GAAG,EAAE,MAAM,GAAG,eAAe,CAAC,OAAO,CAAC;IAgCjD,QAAQ,IAAI,MAAM;IASlB,QAAQ,CAAC,IAAI,EAAE,OAAO,GAAG,YAAY;IASrC,MAAM,IAAI,MAAM;CAOjB"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/address.js b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/address.js
new file mode 100644
index 0000000..44ac0a1
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/address.js
@@ -0,0 +1,104 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.AddressSchema = exports.AddressField = void 0;
+var _zod = require("zod");
+var _base = require("./base");
+var _address = _interopRequireDefault(require("../../models/address"));
+var _helpers = _interopRequireDefault(require("../../utils/helpers"));
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
+function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
+function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */ /* eslint class-methods-use-this: ["error", { "exceptMethods": ["getType"] }] */
+const AddressSchema = exports.AddressSchema = _zod.z.string().regex(/^[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{34,35}$/);
+class AddressField extends _base.NCFieldBase {
+  constructor(network, value = null) {
+    super();
+    _defineProperty(this, "value", void 0);
+    _defineProperty(this, "network", void 0);
+    this.value = value;
+    this.network = network;
+  }
+  getType() {
+    return 'Address';
+  }
+
+  /**
+   * Create an instance of AddressField, may be empty to allow reading from other sources.
+   * @example
+   * ```ts
+   * const testnet = new Network('testnet');
+   * const buf = Buffer.from('4969ffb1549f2e00f30bfc0cf0b9207ed96f7f33ba578d4852', 'hex');
+   *
+   * const field = AddressField.new(testnet);
+   * const parseData = field.fromBuffer(buf);
+   * const fieldFromUser = AddressField.new(testnet).fromUser('WYLW8ujPemSuLJwbeNvvH6y7nakaJ6cEwT');
+   * ```
+   */
+  static new(network) {
+    return new AddressField(network, null);
+  }
+  createNew() {
+    return AddressField.new(this.network);
+  }
+  fromBuffer(buf) {
+    if (buf.length < 25) {
+      throw new Error('Not enough bytes to read address');
+    }
+    // First we get the 20 bytes (hash) of the address without the version byte and checksum
+    const hashBytes = buf.subarray(1, 21);
+    const address = _helpers.default.encodeAddress(hashBytes, this.network);
+    address.validateAddress();
+    const decoded = address.decode();
+    // We need to check that the metadata of the address received match the one we generated
+    // Check network version
+    if (decoded[0] !== buf[0]) {
+      throw new Error(`Asked to deserialize an address with version byte ${buf[0]} but the network from the deserializer object has version byte ${decoded[0]}.`);
+    }
+    // Check checksum bytes
+    const calcChecksum = decoded.subarray(21, 25);
+    const recvChecksum = buf.subarray(21, 25);
+    if (!calcChecksum.equals(recvChecksum)) {
+      // Checksum value generated does not match value from fullnode
+      throw new Error(`When parsing and Address(${address.base58}) we calculated checksum(${calcChecksum.toString('hex')}) but it does not match the checksum it came with ${recvChecksum.toString('hex')}.`);
+    }
+    this.value = address;
+    return {
+      value: address,
+      bytesRead: 25
+    };
+  }
+  toBuffer() {
+    if (this.value === null) {
+      throw new Error('No value to encode');
+    }
+    this.value.validateAddress();
+    // Address has fixed 25 byte serialization, so no need to add length
+    return this.value.decode();
+  }
+  fromUser(data) {
+    // Value is a valid base58 string
+    const value = AddressSchema.parse(data);
+    const address = new _address.default(value, {
+      network: this.network
+    });
+    address.validateAddress();
+    this.value = address;
+    return this;
+  }
+  toUser() {
+    if (this.value === null) {
+      throw new Error('No value to encode');
+    }
+    this.value.validateAddress();
+    return this.value.base58;
+  }
+}
+exports.AddressField = AddressField;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/amount.d.ts b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/amount.d.ts
new file mode 100644
index 0000000..b5eddd1
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/amount.d.ts
@@ -0,0 +1,21 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/// <reference types="node" />
+import { BufferROExtract } from '../types';
+import { NCFieldBase } from './base';
+export declare class AmountField extends NCFieldBase<number | bigint | string, bigint> {
+    value: bigint;
+    constructor(value: bigint);
+    getType(): string;
+    static new(): AmountField;
+    createNew(): AmountField;
+    fromBuffer(buf: Buffer): BufferROExtract<bigint>;
+    toBuffer(): Buffer;
+    fromUser(data: unknown): AmountField;
+    toUser(): string;
+}
+//# sourceMappingURL=amount.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/amount.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/amount.d.ts.map
new file mode 100644
index 0000000..37e7a28
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/amount.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"amount.d.ts","sourceRoot":"","sources":["../../../src/nano_contracts/fields/amount.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;;AAIH,OAAO,EAAE,eAAe,EAAE,MAAM,UAAU,CAAC;AAC3C,OAAO,EAAE,WAAW,EAAE,MAAM,QAAQ,CAAC;AAGrC,qBAAa,WAAY,SAAQ,WAAW,CAAC,MAAM,GAAG,MAAM,GAAG,MAAM,EAAE,MAAM,CAAC;IAC5E,KAAK,EAAE,MAAM,CAAC;gBAEF,KAAK,EAAE,MAAM;IAKzB,OAAO;IAIP,MAAM,CAAC,GAAG,IAAI,WAAW;IAIzB,SAAS;IAIT,UAAU,CAAC,GAAG,EAAE,MAAM,GAAG,eAAe,CAAC,MAAM,CAAC;IAMhD,QAAQ,IAAI,MAAM;IAIlB,QAAQ,CAAC,IAAI,EAAE,OAAO,GAAG,WAAW;IAMpC,MAAM,IAAI,MAAM;CAGjB"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/amount.js b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/amount.js
new file mode 100644
index 0000000..3cd9e85
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/amount.js
@@ -0,0 +1,50 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.AmountField = void 0;
+var _zod = require("zod");
+var _base = require("./base");
+var _encoding = require("./encoding");
+function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
+function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
+function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */ /* eslint class-methods-use-this: ["error", { "exceptMethods": ["getType", "createNew"] }] */
+class AmountField extends _base.NCFieldBase {
+  constructor(value) {
+    super();
+    _defineProperty(this, "value", void 0);
+    this.value = value;
+  }
+  getType() {
+    return 'Amount';
+  }
+  static new() {
+    return new AmountField(0n);
+  }
+  createNew() {
+    return AmountField.new();
+  }
+  fromBuffer(buf) {
+    const parsed = _encoding.leb128.decode_unsigned(buf);
+    this.value = parsed.value;
+    return parsed;
+  }
+  toBuffer() {
+    return _encoding.leb128.encode_unsigned(this.value);
+  }
+  fromUser(data) {
+    const value = _zod.z.coerce.bigint().positive().parse(data);
+    this.value = value;
+    return this;
+  }
+  toUser() {
+    return String(this.value);
+  }
+}
+exports.AmountField = AmountField;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/base.d.ts b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/base.d.ts
new file mode 100644
index 0000000..d861aeb
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/base.d.ts
@@ -0,0 +1,38 @@
+/// <reference types="node" />
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+import { BufferROExtract } from '../types';
+export declare abstract class NCFieldBase<U = unknown, T = unknown> {
+    value: unknown;
+    /**
+     * Read an instance of the field from a buffer
+     */
+    abstract fromBuffer(buffer: Buffer, options?: unknown): BufferROExtract<T>;
+    /**
+     * Serialize field value into a buffer
+     */
+    abstract toBuffer(): Buffer;
+    /**
+     * Parse field from user value.
+     */
+    abstract fromUser(data: unknown): NCFieldBase;
+    /**
+     * Show the value as user readable.
+     */
+    abstract toUser(): U;
+    /**
+     * Get an identifier for the field class.
+     * This may not be the same as the field type since
+     * some types use the same field, e.g. bytes, TxOutputScript are both BytesField.
+     */
+    abstract getType(): string;
+    /**
+     * Create a new empty instance.
+     */
+    abstract createNew(): NCFieldBase;
+}
+//# sourceMappingURL=base.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/base.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/base.d.ts.map
new file mode 100644
index 0000000..e746e77
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/base.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"base.d.ts","sourceRoot":"","sources":["../../../src/nano_contracts/fields/base.ts"],"names":[],"mappings":";AAAA;;;;;GAKG;AACH,OAAO,EAAE,eAAe,EAAE,MAAM,UAAU,CAAC;AAE3C,8BAAsB,WAAW,CAAC,CAAC,GAAG,OAAO,EAAE,CAAC,GAAG,OAAO;IACxD,KAAK,EAAE,OAAO,CAAC;IAEf;;OAEG;IACH,QAAQ,CAAC,UAAU,CAAC,MAAM,EAAE,MAAM,EAAE,OAAO,CAAC,EAAE,OAAO,GAAG,eAAe,CAAC,CAAC,CAAC;IAE1E;;OAEG;IACH,QAAQ,CAAC,QAAQ,IAAI,MAAM;IAE3B;;OAEG;IACH,QAAQ,CAAC,QAAQ,CAAC,IAAI,EAAE,OAAO,GAAG,WAAW;IAE7C;;OAEG;IACH,QAAQ,CAAC,MAAM,IAAI,CAAC;IAEpB;;;;OAIG;IACH,QAAQ,CAAC,OAAO,IAAI,MAAM;IAE1B;;OAEG;IACH,QAAQ,CAAC,SAAS,IAAI,WAAW;CAClC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/base.js b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/base.js
new file mode 100644
index 0000000..d00e050
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/base.js
@@ -0,0 +1,42 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.NCFieldBase = void 0;
+function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
+function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
+function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+class NCFieldBase {
+  constructor() {
+    _defineProperty(this, "value", void 0);
+  }
+  /**
+   * Read an instance of the field from a buffer
+   */
+  /**
+   * Serialize field value into a buffer
+   */
+  /**
+   * Parse field from user value.
+   */
+  /**
+   * Show the value as user readable.
+   */
+  /**
+   * Get an identifier for the field class.
+   * This may not be the same as the field type since
+   * some types use the same field, e.g. bytes, TxOutputScript are both BytesField.
+   */
+  /**
+   * Create a new empty instance.
+   */
+}
+exports.NCFieldBase = NCFieldBase;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/bool.d.ts b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/bool.d.ts
new file mode 100644
index 0000000..ce9467c
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/bool.d.ts
@@ -0,0 +1,21 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/// <reference types="node" />
+import { BufferROExtract } from '../types';
+import { NCFieldBase } from './base';
+export declare class BoolField extends NCFieldBase<boolean | string, boolean> {
+    value: boolean;
+    constructor(value: boolean);
+    getType(): string;
+    static new(): BoolField;
+    createNew(): BoolField;
+    fromBuffer(buf: Buffer): BufferROExtract<boolean>;
+    toBuffer(): Buffer;
+    fromUser(data: unknown): BoolField;
+    toUser(): 'true' | 'false';
+}
+//# sourceMappingURL=bool.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/bool.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/bool.d.ts.map
new file mode 100644
index 0000000..1d5f409
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/bool.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"bool.d.ts","sourceRoot":"","sources":["../../../src/nano_contracts/fields/bool.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;;AAIH,OAAO,EAAE,eAAe,EAAE,MAAM,UAAU,CAAC;AAC3C,OAAO,EAAE,WAAW,EAAE,MAAM,QAAQ,CAAC;AAGrC,qBAAa,SAAU,SAAQ,WAAW,CAAC,OAAO,GAAG,MAAM,EAAE,OAAO,CAAC;IACnE,KAAK,EAAE,OAAO,CAAC;gBAEH,KAAK,EAAE,OAAO;IAK1B,OAAO;IAIP,MAAM,CAAC,GAAG,IAAI,SAAS;IAIvB,SAAS;IAIT,UAAU,CAAC,GAAG,EAAE,MAAM,GAAG,eAAe,CAAC,OAAO,CAAC;IASjD,QAAQ,IAAI,MAAM;IAIlB,QAAQ,CAAC,IAAI,EAAE,OAAO,GAAG,SAAS;IAUlC,MAAM,IAAI,MAAM,GAAG,OAAO;CAG3B"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/bool.js b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/bool.js
new file mode 100644
index 0000000..d0faa7b
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/bool.js
@@ -0,0 +1,53 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.BoolField = void 0;
+var _zod = require("zod");
+var _base = require("./base");
+var _encoding = require("./encoding");
+function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
+function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
+function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */ /* eslint class-methods-use-this: ["error", { "exceptMethods": ["getType", "createNew"] }] */
+class BoolField extends _base.NCFieldBase {
+  constructor(value) {
+    super();
+    _defineProperty(this, "value", void 0);
+    this.value = value;
+  }
+  getType() {
+    return 'bool';
+  }
+  static new() {
+    return new BoolField(false);
+  }
+  createNew() {
+    return BoolField.new();
+  }
+  fromBuffer(buf) {
+    if (buf.length === 0) {
+      throw new Error('No data left to read');
+    }
+    const result = _encoding.bool.decode(buf);
+    this.value = result.value;
+    return result;
+  }
+  toBuffer() {
+    return _encoding.bool.encode(this.value);
+  }
+  fromUser(data) {
+    const value = _zod.z.boolean().or(_zod.z.union([_zod.z.literal('true'), _zod.z.literal('false')]).transform(val => val === 'true')).parse(data);
+    this.value = value;
+    return this;
+  }
+  toUser() {
+    return this.value ? 'true' : 'false';
+  }
+}
+exports.BoolField = BoolField;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/bytes.d.ts b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/bytes.d.ts
new file mode 100644
index 0000000..eeb259e
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/bytes.d.ts
@@ -0,0 +1,21 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/// <reference types="node" />
+import { BufferROExtract } from '../types';
+import { NCFieldBase } from './base';
+export declare class BytesField extends NCFieldBase<string, Buffer> {
+    value: Buffer;
+    constructor(value: Buffer);
+    getType(): string;
+    static new(): BytesField;
+    createNew(): BytesField;
+    fromBuffer(buf: Buffer): BufferROExtract<Buffer>;
+    toBuffer(): Buffer;
+    fromUser(data: unknown): BytesField;
+    toUser(): string;
+}
+//# sourceMappingURL=bytes.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/bytes.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/bytes.d.ts.map
new file mode 100644
index 0000000..f89940c
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/bytes.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"bytes.d.ts","sourceRoot":"","sources":["../../../src/nano_contracts/fields/bytes.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;;AAIH,OAAO,EAAE,eAAe,EAAE,MAAM,UAAU,CAAC;AAC3C,OAAO,EAAE,WAAW,EAAE,MAAM,QAAQ,CAAC;AAGrC,qBAAa,UAAW,SAAQ,WAAW,CAAC,MAAM,EAAE,MAAM,CAAC;IACzD,KAAK,EAAE,MAAM,CAAC;gBAEF,KAAK,EAAE,MAAM;IAKzB,OAAO;IAIP,MAAM,CAAC,GAAG,IAAI,UAAU;IAIxB,SAAS;IAIT,UAAU,CAAC,GAAG,EAAE,MAAM,GAAG,eAAe,CAAC,MAAM,CAAC;IAMhD,QAAQ,IAAI,MAAM;IAIlB,QAAQ,CAAC,IAAI,EAAE,OAAO,GAAG,UAAU;IASnC,MAAM,IAAI,MAAM;CAGjB"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/bytes.js b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/bytes.js
new file mode 100644
index 0000000..14b8ea8
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/bytes.js
@@ -0,0 +1,50 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.BytesField = void 0;
+var _zod = require("zod");
+var _base = require("./base");
+var _encoding = require("./encoding");
+function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
+function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
+function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */ /* eslint class-methods-use-this: ["error", { "exceptMethods": ["getType", "createNew"] }] */
+class BytesField extends _base.NCFieldBase {
+  constructor(value) {
+    super();
+    _defineProperty(this, "value", void 0);
+    this.value = value;
+  }
+  getType() {
+    return 'bytes';
+  }
+  static new() {
+    return new BytesField(Buffer.alloc(0));
+  }
+  createNew() {
+    return BytesField.new();
+  }
+  fromBuffer(buf) {
+    const parsed = _encoding.bytes.decode(buf);
+    this.value = parsed.value;
+    return parsed;
+  }
+  toBuffer() {
+    return _encoding.bytes.encode(this.value);
+  }
+  fromUser(data) {
+    const value = _zod.z.string().regex(/^[a-fA-F0-9]*$/).parse(data);
+    this.value = Buffer.from(value, 'hex');
+    return this;
+  }
+  toUser() {
+    return this.value.toString('hex');
+  }
+}
+exports.BytesField = BytesField;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/bytes32.d.ts b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/bytes32.d.ts
new file mode 100644
index 0000000..3a3ecda
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/bytes32.d.ts
@@ -0,0 +1,21 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/// <reference types="node" />
+import { BufferROExtract } from '../types';
+import { NCFieldBase } from './base';
+export declare class Bytes32Field extends NCFieldBase<string, Buffer> {
+    value: Buffer;
+    constructor(value: Buffer);
+    getType(): string;
+    static new(): Bytes32Field;
+    createNew(): Bytes32Field;
+    fromBuffer(buf: Buffer): BufferROExtract<Buffer>;
+    toBuffer(): Buffer;
+    fromUser(data: unknown): Bytes32Field;
+    toUser(): string;
+}
+//# sourceMappingURL=bytes32.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/bytes32.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/bytes32.d.ts.map
new file mode 100644
index 0000000..71aea9c
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/bytes32.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"bytes32.d.ts","sourceRoot":"","sources":["../../../src/nano_contracts/fields/bytes32.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;;AAIH,OAAO,EAAE,eAAe,EAAE,MAAM,UAAU,CAAC;AAC3C,OAAO,EAAE,WAAW,EAAE,MAAM,QAAQ,CAAC;AAGrC,qBAAa,YAAa,SAAQ,WAAW,CAAC,MAAM,EAAE,MAAM,CAAC;IAC3D,KAAK,EAAE,MAAM,CAAC;gBAEF,KAAK,EAAE,MAAM;IAKzB,OAAO;IAIP,MAAM,CAAC,GAAG,IAAI,YAAY;IAI1B,SAAS;IAIT,UAAU,CAAC,GAAG,EAAE,MAAM,GAAG,eAAe,CAAC,MAAM,CAAC;IAMhD,QAAQ,IAAI,MAAM;IAIlB,QAAQ,CAAC,IAAI,EAAE,OAAO,GAAG,YAAY;IASrC,MAAM,IAAI,MAAM;CAGjB"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/bytes32.js b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/bytes32.js
new file mode 100644
index 0000000..8266d55
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/bytes32.js
@@ -0,0 +1,50 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.Bytes32Field = void 0;
+var _zod = require("zod");
+var _base = require("./base");
+var _encoding = require("./encoding");
+function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
+function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
+function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */ /* eslint class-methods-use-this: ["error", { "exceptMethods": ["getType", "createNew"] }] */
+class Bytes32Field extends _base.NCFieldBase {
+  constructor(value) {
+    super();
+    _defineProperty(this, "value", void 0);
+    this.value = value;
+  }
+  getType() {
+    return 'bytes32';
+  }
+  static new() {
+    return new Bytes32Field(Buffer.alloc(0));
+  }
+  createNew() {
+    return Bytes32Field.new();
+  }
+  fromBuffer(buf) {
+    const parsed = _encoding.sizedBytes.decode(32, buf);
+    this.value = parsed.value;
+    return parsed;
+  }
+  toBuffer() {
+    return _encoding.sizedBytes.encode(32, this.value);
+  }
+  fromUser(data) {
+    const value = _zod.z.string().regex(/^[a-fA-F0-9]{64}$/).parse(data);
+    this.value = Buffer.from(value, 'hex');
+    return this;
+  }
+  toUser() {
+    return this.value.toString('hex');
+  }
+}
+exports.Bytes32Field = Bytes32Field;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/collection.d.ts b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/collection.d.ts
new file mode 100644
index 0000000..c099a43
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/collection.d.ts
@@ -0,0 +1,23 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/// <reference types="node" />
+import { BufferROExtract } from '../types';
+import { NCFieldBase } from './base';
+export declare class CollectionField extends NCFieldBase<unknown[], unknown[]> {
+    value: unknown[];
+    kind: NCFieldBase;
+    inner: NCFieldBase[];
+    constructor(kind: NCFieldBase);
+    getType(): string;
+    static new(kind: NCFieldBase): CollectionField;
+    createNew(): CollectionField;
+    fromBuffer(buf: Buffer): BufferROExtract<unknown[]>;
+    toBuffer(): Buffer;
+    fromUser(data: unknown): CollectionField;
+    toUser(): unknown[];
+}
+//# sourceMappingURL=collection.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/collection.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/collection.d.ts.map
new file mode 100644
index 0000000..89e7431
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/collection.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"collection.d.ts","sourceRoot":"","sources":["../../../src/nano_contracts/fields/collection.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;;AAGH,OAAO,EAAE,eAAe,EAAE,MAAM,UAAU,CAAC;AAC3C,OAAO,EAAE,WAAW,EAAE,MAAM,QAAQ,CAAC;AAGrC,qBAAa,eAAgB,SAAQ,WAAW,CAAC,OAAO,EAAE,EAAE,OAAO,EAAE,CAAC;IACpE,KAAK,EAAE,OAAO,EAAE,CAAC;IAEjB,IAAI,EAAE,WAAW,CAAC;IAElB,KAAK,EAAE,WAAW,EAAE,CAAC;gBAET,IAAI,EAAE,WAAW;IAO7B,OAAO;IAIP,MAAM,CAAC,GAAG,CAAC,IAAI,EAAE,WAAW,GAAG,eAAe;IAI9C,SAAS;IAIT,UAAU,CAAC,GAAG,EAAE,MAAM,GAAG,eAAe,CAAC,OAAO,EAAE,CAAC;IAuBnD,QAAQ,IAAI,MAAM;IAQlB,QAAQ,CAAC,IAAI,EAAE,OAAO,GAAG,eAAe;IAkBxC,MAAM,IAAI,OAAO,EAAE;CAGpB"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/collection.js b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/collection.js
new file mode 100644
index 0000000..be9f791
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/collection.js
@@ -0,0 +1,84 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.CollectionField = void 0;
+var _base = require("./base");
+var _encoding = require("./encoding");
+function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
+function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
+function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */ /* eslint class-methods-use-this: ["error", { "exceptMethods": ["getType"] }] */
+class CollectionField extends _base.NCFieldBase {
+  constructor(kind) {
+    super();
+    _defineProperty(this, "value", void 0);
+    _defineProperty(this, "kind", void 0);
+    _defineProperty(this, "inner", void 0);
+    this.kind = kind;
+    this.value = [];
+    this.inner = [];
+  }
+  getType() {
+    return 'Collection';
+  }
+  static new(kind) {
+    return new CollectionField(kind);
+  }
+  createNew() {
+    return CollectionField.new(this.kind.createNew());
+  }
+  fromBuffer(buf) {
+    const values = [];
+    let bytesReadTotal = 0;
+    const lenRead = _encoding.leb128.decode_unsigned(buf);
+    const len = lenRead.value;
+    let listBuf = buf.subarray(lenRead.bytesRead);
+    for (let i = 0n; i < len; i++) {
+      const field = this.kind.createNew();
+      const result = field.fromBuffer(listBuf);
+      values.push(result.value);
+      bytesReadTotal += result.bytesRead;
+      listBuf = listBuf.subarray(result.bytesRead);
+      this.inner.push(field);
+    }
+    this.value = values;
+    return {
+      value: values,
+      bytesRead: bytesReadTotal
+    };
+  }
+  toBuffer() {
+    const serialized = [_encoding.leb128.encode_unsigned(this.inner.length)];
+    for (const el of this.inner) {
+      serialized.push(el.toBuffer());
+    }
+    return Buffer.concat(serialized);
+  }
+  fromUser(data) {
+    function isIterable(d) {
+      return d != null && typeof d[Symbol.iterator] === 'function';
+    }
+    if (!isIterable(data)) {
+      throw new Error('Provided data is not iterable, so it cannot be a list.');
+    }
+    const values = [];
+    for (const el of data) {
+      const field = this.kind.createNew();
+      field.fromUser(el);
+      values.push(field.value);
+      this.inner.push(field);
+    }
+    this.value = values;
+    return this;
+  }
+  toUser() {
+    return this.inner.map(el => el.toUser());
+  }
+}
+exports.CollectionField = CollectionField;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/dict.d.ts b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/dict.d.ts
new file mode 100644
index 0000000..f9063f9
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/dict.d.ts
@@ -0,0 +1,24 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/// <reference types="node" />
+import { BufferROExtract } from '../types';
+import { NCFieldBase } from './base';
+export declare class DictField extends NCFieldBase<Record<any, unknown>, Record<any, unknown>> {
+    value: unknown;
+    keyField: NCFieldBase;
+    valueField: NCFieldBase;
+    inner: [NCFieldBase, NCFieldBase][];
+    constructor(keyField: NCFieldBase, valueField: NCFieldBase);
+    getType(): string;
+    static new(key: NCFieldBase, value: NCFieldBase): DictField;
+    createNew(): DictField;
+    fromBuffer(buf: Buffer): BufferROExtract<Record<any, unknown>>;
+    toBuffer(): Buffer;
+    fromUser(data: unknown): DictField;
+    toUser(): Record<any, unknown>;
+}
+//# sourceMappingURL=dict.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/dict.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/dict.d.ts.map
new file mode 100644
index 0000000..ba63e28
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/dict.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"dict.d.ts","sourceRoot":"","sources":["../../../src/nano_contracts/fields/dict.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;;AAIH,OAAO,EAAE,eAAe,EAAE,MAAM,UAAU,CAAC;AAC3C,OAAO,EAAE,WAAW,EAAE,MAAM,QAAQ,CAAC;AAGrC,qBAAa,SAAU,SAAQ,WAAW,CAAC,MAAM,CAAC,GAAG,EAAE,OAAO,CAAC,EAAE,MAAM,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC;IACpF,KAAK,EAAE,OAAO,CAAC;IAEf,QAAQ,EAAE,WAAW,CAAC;IAEtB,UAAU,EAAE,WAAW,CAAC;IAGxB,KAAK,EAAE,CAAC,WAAW,EAAE,WAAW,CAAC,EAAE,CAAC;gBAExB,QAAQ,EAAE,WAAW,EAAE,UAAU,EAAE,WAAW;IAQ1D,OAAO;IAIP,MAAM,CAAC,GAAG,CAAC,GAAG,EAAE,WAAW,EAAE,KAAK,EAAE,WAAW,GAAG,SAAS;IAI3D,SAAS;IAIT,UAAU,CAAC,GAAG,EAAE,MAAM,GAAG,eAAe,CAAC,MAAM,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC;IA8B9D,QAAQ,IAAI,MAAM;IASlB,QAAQ,CAAC,IAAI,EAAE,OAAO,GAAG,SAAS;IAuBlC,MAAM,IAAI,MAAM,CAAC,GAAG,EAAE,OAAO,CAAC;CAG/B"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/dict.js b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/dict.js
new file mode 100644
index 0000000..694cc9f
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/dict.js
@@ -0,0 +1,97 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.DictField = void 0;
+var _base = require("./base");
+var _encoding = require("./encoding");
+function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
+function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
+function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */ /* eslint class-methods-use-this: ["error", { "exceptMethods": ["getType"] }] */ /* eslint-disable @typescript-eslint/no-explicit-any */
+class DictField extends _base.NCFieldBase {
+  constructor(keyField, valueField) {
+    super();
+    _defineProperty(this, "value", void 0);
+    _defineProperty(this, "keyField", void 0);
+    _defineProperty(this, "valueField", void 0);
+    // Save inner fields as entries array.
+    _defineProperty(this, "inner", void 0);
+    this.value = undefined;
+    this.keyField = keyField;
+    this.valueField = valueField;
+    this.inner = [];
+  }
+  getType() {
+    return 'Dict';
+  }
+  static new(key, value) {
+    return new DictField(key, value);
+  }
+  createNew() {
+    return DictField.new(this.keyField.createNew(), this.valueField.createNew());
+  }
+  fromBuffer(buf) {
+    this.inner = [];
+    let bytesReadTotal = 0;
+    const lenRead = _encoding.leb128.decode_unsigned(buf);
+    bytesReadTotal += lenRead.bytesRead;
+    const len = lenRead.value;
+    const values = {};
+    let dictBuf = buf.subarray(lenRead.bytesRead);
+    for (let i = 0n; i < len; i++) {
+      const keyF = this.keyField.createNew();
+      const valueF = this.valueField.createNew();
+      const key = keyF.fromBuffer(dictBuf);
+      dictBuf = dictBuf.subarray(key.bytesRead);
+      bytesReadTotal += key.bytesRead;
+      const val = valueF.fromBuffer(dictBuf);
+      dictBuf = dictBuf.subarray(val.bytesRead);
+      bytesReadTotal += val.bytesRead;
+      values[key.value] = val.value;
+      this.inner.push([keyF, valueF]);
+    }
+    this.value = values;
+    return {
+      value: values,
+      bytesRead: bytesReadTotal
+    };
+  }
+  toBuffer() {
+    const serialized = [_encoding.leb128.encode_unsigned(this.inner.length)];
+    for (const el of this.inner) {
+      serialized.push(el[0].toBuffer());
+      serialized.push(el[1].toBuffer());
+    }
+    return Buffer.concat(serialized);
+  }
+  fromUser(data) {
+    function isRecord(d) {
+      return typeof d === 'object' && d !== null;
+    }
+    if (!isRecord(data)) {
+      throw new Error('Provided data is not a valid object');
+    }
+    this.inner = [];
+    const value = {};
+    for (const [k, v] of Object.entries(data)) {
+      const keyF = this.keyField.createNew();
+      const valueF = this.valueField.createNew();
+      const key = keyF.fromUser(k);
+      const val = valueF.fromUser(v);
+      value[key.value] = val.value;
+      this.inner.push([keyF, valueF]);
+    }
+    this.value = value;
+    return this;
+  }
+  toUser() {
+    return Object.fromEntries(this.inner.map(el => [el[0].toUser(), el[1].toUser()]));
+  }
+}
+exports.DictField = DictField;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/encoding/bool.d.ts b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/encoding/bool.d.ts
new file mode 100644
index 0000000..caaa816
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/encoding/bool.d.ts
@@ -0,0 +1,11 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/// <reference types="node" />
+import { BufferROExtract } from '../../types';
+export declare function encode(value: boolean): Buffer;
+export declare function decode(buf: Buffer): BufferROExtract<boolean>;
+//# sourceMappingURL=bool.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/encoding/bool.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/encoding/bool.d.ts.map
new file mode 100644
index 0000000..c62aeb9
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/encoding/bool.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"bool.d.ts","sourceRoot":"","sources":["../../../../src/nano_contracts/fields/encoding/bool.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;;AAEH,OAAO,EAAE,eAAe,EAAE,MAAM,aAAa,CAAC;AAE9C,wBAAgB,MAAM,CAAC,KAAK,EAAE,OAAO,UAEpC;AAED,wBAAgB,MAAM,CAAC,GAAG,EAAE,MAAM,GAAG,eAAe,CAAC,OAAO,CAAC,CAe5D"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/encoding/bool.js b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/encoding/bool.js
new file mode 100644
index 0000000..802155b
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/encoding/bool.js
@@ -0,0 +1,33 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.decode = decode;
+exports.encode = encode;
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+function encode(value) {
+  return Buffer.from([value ? 1 : 0]);
+}
+function decode(buf) {
+  switch (buf[0]) {
+    case 0:
+      return {
+        value: false,
+        bytesRead: 1
+      };
+    case 1:
+      return {
+        value: true,
+        bytesRead: 1
+      };
+    default:
+      throw new Error('Invalid boolean tag');
+  }
+}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/encoding/bytes.d.ts b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/encoding/bytes.d.ts
new file mode 100644
index 0000000..f12c386
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/encoding/bytes.d.ts
@@ -0,0 +1,11 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/// <reference types="node" />
+import { BufferROExtract } from '../../types';
+export declare function encode(buf: Buffer): Buffer;
+export declare function decode(buf: Buffer): BufferROExtract<Buffer>;
+//# sourceMappingURL=bytes.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/encoding/bytes.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/encoding/bytes.d.ts.map
new file mode 100644
index 0000000..8707a2e
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/encoding/bytes.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"bytes.d.ts","sourceRoot":"","sources":["../../../../src/nano_contracts/fields/encoding/bytes.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;;AAGH,OAAO,EAAE,eAAe,EAAE,MAAM,aAAa,CAAC;AAG9C,wBAAgB,MAAM,CAAC,GAAG,EAAE,MAAM,UAEjC;AAED,wBAAgB,MAAM,CAAC,GAAG,EAAE,MAAM,GAAG,eAAe,CAAC,MAAM,CAAC,CAmB3D"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/encoding/bytes.js b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/encoding/bytes.js
new file mode 100644
index 0000000..dbf08d6
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/encoding/bytes.js
@@ -0,0 +1,43 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.decode = decode;
+exports.encode = encode;
+var _constants = require("../../../constants");
+var leb128 = _interopRequireWildcard(require("./leb128"));
+function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
+function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+function encode(buf) {
+  return Buffer.concat([leb128.encode_unsigned(buf.length), Buffer.from(buf)]);
+}
+function decode(buf) {
+  // INFO: maxBytes is set to 3 because the max allowed length in bytes for a string is
+  // NC_ARGS_MAX_BYTES_LENGTH which is encoded as 3 bytes in leb128 unsigned.
+  // If we read a fourth byte we are definetely reading a higher number than allowed.
+  const {
+    value: lengthBN,
+    bytesRead: bytesReadForLength
+  } = leb128.decode_unsigned(buf, 3);
+  const rest = buf.subarray(bytesReadForLength);
+  if (lengthBN > BigInt(_constants.NC_ARGS_MAX_BYTES_LENGTH)) {
+    throw new Error('length in bytes is higher than max allowed');
+  }
+  // If lengthBN is lower than 64 KiB than its safe to convert to Number
+  const length = Number(lengthBN);
+  if (rest.length < length) {
+    throw new Error('Do not have enough bytes to read the expected length');
+  }
+  return {
+    value: rest.subarray(0, length),
+    bytesRead: length + bytesReadForLength
+  };
+}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/encoding/index.d.ts b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/encoding/index.d.ts
new file mode 100644
index 0000000..894b6fb
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/encoding/index.d.ts
@@ -0,0 +1,6 @@
+export * as bytes from './bytes';
+export * as utf8 from './utf8';
+export * as sizedBytes from './sizedBytes';
+export * as bool from './bool';
+export * as leb128 from './leb128';
+//# sourceMappingURL=index.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/encoding/index.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/encoding/index.d.ts.map
new file mode 100644
index 0000000..e87d387
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/encoding/index.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../../../src/nano_contracts/fields/encoding/index.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,KAAK,MAAM,SAAS,CAAC;AACjC,OAAO,KAAK,IAAI,MAAM,QAAQ,CAAC;AAC/B,OAAO,KAAK,UAAU,MAAM,cAAc,CAAC;AAC3C,OAAO,KAAK,IAAI,MAAM,QAAQ,CAAC;AAC/B,OAAO,KAAK,MAAM,MAAM,UAAU,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/encoding/index.js b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/encoding/index.js
new file mode 100644
index 0000000..de0b2c7
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/encoding/index.js
@@ -0,0 +1,18 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.utf8 = exports.sizedBytes = exports.leb128 = exports.bytes = exports.bool = void 0;
+var _bytes = _interopRequireWildcard(require("./bytes"));
+exports.bytes = _bytes;
+var _utf = _interopRequireWildcard(require("./utf8"));
+exports.utf8 = _utf;
+var _sizedBytes = _interopRequireWildcard(require("./sizedBytes"));
+exports.sizedBytes = _sizedBytes;
+var _bool = _interopRequireWildcard(require("./bool"));
+exports.bool = _bool;
+var _leb = _interopRequireWildcard(require("./leb128"));
+exports.leb128 = _leb;
+function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
+function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/encoding/leb128.d.ts b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/encoding/leb128.d.ts
new file mode 100644
index 0000000..8e62acc
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/encoding/leb128.d.ts
@@ -0,0 +1,13 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/// <reference types="node" />
+import { BufferROExtract } from '../../types';
+export declare function encode_unsigned(value: bigint | number, maxBytes?: number | null): Buffer;
+export declare function decode_unsigned(value: Buffer, maxBytes?: number | null): BufferROExtract<bigint>;
+export declare function encode_signed(value: bigint | number, maxBytes?: number | null): Buffer;
+export declare function decode_signed(value: Buffer, maxBytes?: number | null): BufferROExtract<bigint>;
+//# sourceMappingURL=leb128.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/encoding/leb128.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/encoding/leb128.d.ts.map
new file mode 100644
index 0000000..e851bd8
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/encoding/leb128.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"leb128.d.ts","sourceRoot":"","sources":["../../../../src/nano_contracts/fields/encoding/leb128.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;;AAGH,OAAO,EAAE,eAAe,EAAE,MAAM,aAAa,CAAC;AAE9C,wBAAgB,eAAe,CAAC,KAAK,EAAE,MAAM,GAAG,MAAM,EAAE,QAAQ,GAAE,MAAM,GAAG,IAAW,UAErF;AAED,wBAAgB,eAAe,CAC7B,KAAK,EAAE,MAAM,EACb,QAAQ,GAAE,MAAM,GAAG,IAAW,GAC7B,eAAe,CAAC,MAAM,CAAC,CAEzB;AAED,wBAAgB,aAAa,CAAC,KAAK,EAAE,MAAM,GAAG,MAAM,EAAE,QAAQ,GAAE,MAAM,GAAG,IAAW,UAEnF;AAED,wBAAgB,aAAa,CAC3B,KAAK,EAAE,MAAM,EACb,QAAQ,GAAE,MAAM,GAAG,IAAW,GAC7B,eAAe,CAAC,MAAM,CAAC,CAEzB"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/encoding/leb128.js b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/encoding/leb128.js
new file mode 100644
index 0000000..77bb922
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/encoding/leb128.js
@@ -0,0 +1,30 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.decode_signed = decode_signed;
+exports.decode_unsigned = decode_unsigned;
+exports.encode_signed = encode_signed;
+exports.encode_unsigned = encode_unsigned;
+var _leb = _interopRequireDefault(require("../../../utils/leb128"));
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+function encode_unsigned(value, maxBytes = null) {
+  return _leb.default.encodeUnsigned(value, maxBytes);
+}
+function decode_unsigned(value, maxBytes = null) {
+  return _leb.default.decodeUnsigned(value, maxBytes);
+}
+function encode_signed(value, maxBytes = null) {
+  return _leb.default.encodeSigned(value, maxBytes);
+}
+function decode_signed(value, maxBytes = null) {
+  return _leb.default.decodeSigned(value, maxBytes);
+}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/encoding/sizedBytes.d.ts b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/encoding/sizedBytes.d.ts
new file mode 100644
index 0000000..211b9f4
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/encoding/sizedBytes.d.ts
@@ -0,0 +1,11 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/// <reference types="node" />
+import { BufferROExtract } from '../../types';
+export declare function encode(len: number, buf: Buffer): Buffer;
+export declare function decode(len: number, buf: Buffer): BufferROExtract<Buffer>;
+//# sourceMappingURL=sizedBytes.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/encoding/sizedBytes.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/encoding/sizedBytes.d.ts.map
new file mode 100644
index 0000000..fb6a3f1
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/encoding/sizedBytes.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"sizedBytes.d.ts","sourceRoot":"","sources":["../../../../src/nano_contracts/fields/encoding/sizedBytes.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;;AAEH,OAAO,EAAE,eAAe,EAAE,MAAM,aAAa,CAAC;AAE9C,wBAAgB,MAAM,CAAC,GAAG,EAAE,MAAM,EAAE,GAAG,EAAE,MAAM,UAE9C;AAED,wBAAgB,MAAM,CAAC,GAAG,EAAE,MAAM,EAAE,GAAG,EAAE,MAAM,GAAG,eAAe,CAAC,MAAM,CAAC,CAQxE"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/encoding/sizedBytes.js b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/encoding/sizedBytes.js
new file mode 100644
index 0000000..9377055
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/encoding/sizedBytes.js
@@ -0,0 +1,26 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.decode = decode;
+exports.encode = encode;
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+function encode(len, buf) {
+  return Buffer.from(buf.subarray(0, len));
+}
+function decode(len, buf) {
+  if (buf.length < len) {
+    throw new Error('Do not have enough bytes to read the expected length');
+  }
+  return {
+    value: buf.subarray(0, len),
+    bytesRead: len
+  };
+}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/encoding/utf8.d.ts b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/encoding/utf8.d.ts
new file mode 100644
index 0000000..1fae5cf
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/encoding/utf8.d.ts
@@ -0,0 +1,11 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/// <reference types="node" />
+import { BufferROExtract } from '../../types';
+export declare function encode(value: string): Buffer;
+export declare function decode(buf: Buffer): BufferROExtract<string>;
+//# sourceMappingURL=utf8.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/encoding/utf8.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/encoding/utf8.d.ts.map
new file mode 100644
index 0000000..4c992e5
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/encoding/utf8.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"utf8.d.ts","sourceRoot":"","sources":["../../../../src/nano_contracts/fields/encoding/utf8.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;;AAEH,OAAO,EAAE,eAAe,EAAE,MAAM,aAAa,CAAC;AAG9C,wBAAgB,MAAM,CAAC,KAAK,EAAE,MAAM,UAEnC;AAED,wBAAgB,MAAM,CAAC,GAAG,EAAE,MAAM,GAAG,eAAe,CAAC,MAAM,CAAC,CAO3D"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/encoding/utf8.js b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/encoding/utf8.js
new file mode 100644
index 0000000..a2f9198
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/encoding/utf8.js
@@ -0,0 +1,30 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.decode = decode;
+exports.encode = encode;
+var bytes = _interopRequireWildcard(require("./bytes"));
+function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
+function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+function encode(value) {
+  return bytes.encode(Buffer.from(value, 'utf-8'));
+}
+function decode(buf) {
+  const {
+    value,
+    bytesRead
+  } = bytes.decode(buf);
+  return {
+    value: value.toString('utf-8'),
+    bytesRead
+  };
+}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/index.d.ts b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/index.d.ts
new file mode 100644
index 0000000..7c1ca84
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/index.d.ts
@@ -0,0 +1,48 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+import { StrField } from './str';
+import { IntField } from './int';
+import { BytesField } from './bytes';
+import { Bytes32Field } from './bytes32';
+import { BoolField } from './bool';
+import { AddressField } from './address';
+import { TimestampField } from './timestamp';
+import { AmountField } from './amount';
+import { TokenUidField } from './token';
+import { OptionalField } from './optional';
+import { TupleField } from './tuple';
+import { SignedDataField } from './signedData';
+import { NCFieldBase } from './base';
+import { DictField } from './dict';
+import { CollectionField } from './collection';
+export { NCFieldBase } from './base';
+export declare function isSignedDataField(value: NCFieldBase): value is SignedDataField;
+declare const _default: {
+    StrField: typeof StrField;
+    IntField: typeof IntField;
+    BoolField: typeof BoolField;
+    AddressField: typeof AddressField;
+    TimestampField: typeof TimestampField;
+    AmountField: typeof AmountField;
+    TokenUidField: typeof TokenUidField;
+    BytesField: typeof BytesField;
+    TxOutputScriptField: typeof BytesField;
+    VertexIdField: typeof Bytes32Field;
+    ContractIdField: typeof Bytes32Field;
+    BlueprintIdField: typeof Bytes32Field;
+    OptionalField: typeof OptionalField;
+    TupleField: typeof TupleField;
+    SignedDataField: typeof SignedDataField;
+    RawSignedDataField: typeof SignedDataField;
+    DictField: typeof DictField;
+    ListField: typeof CollectionField;
+    SetField: typeof CollectionField;
+    DequeField: typeof CollectionField;
+    FrozenSetField: typeof CollectionField;
+};
+export default _default;
+//# sourceMappingURL=index.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/index.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/index.d.ts.map
new file mode 100644
index 0000000..80dc114
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/index.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../../src/nano_contracts/fields/index.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;AAEH,OAAO,EAAE,QAAQ,EAAE,MAAM,OAAO,CAAC;AACjC,OAAO,EAAE,QAAQ,EAAE,MAAM,OAAO,CAAC;AACjC,OAAO,EAAE,UAAU,EAAE,MAAM,SAAS,CAAC;AACrC,OAAO,EAAE,YAAY,EAAE,MAAM,WAAW,CAAC;AACzC,OAAO,EAAE,SAAS,EAAE,MAAM,QAAQ,CAAC;AACnC,OAAO,EAAE,YAAY,EAAE,MAAM,WAAW,CAAC;AACzC,OAAO,EAAE,cAAc,EAAE,MAAM,aAAa,CAAC;AAC7C,OAAO,EAAE,WAAW,EAAE,MAAM,UAAU,CAAC;AACvC,OAAO,EAAE,aAAa,EAAE,MAAM,SAAS,CAAC;AACxC,OAAO,EAAE,aAAa,EAAE,MAAM,YAAY,CAAC;AAC3C,OAAO,EAAE,UAAU,EAAE,MAAM,SAAS,CAAC;AACrC,OAAO,EAAE,eAAe,EAAE,MAAM,cAAc,CAAC;AAC/C,OAAO,EAAE,WAAW,EAAE,MAAM,QAAQ,CAAC;AACrC,OAAO,EAAE,SAAS,EAAE,MAAM,QAAQ,CAAC;AACnC,OAAO,EAAE,eAAe,EAAE,MAAM,cAAc,CAAC;AAE/C,OAAO,EAAE,WAAW,EAAE,MAAM,QAAQ,CAAC;AAErC,wBAAgB,iBAAiB,CAAC,KAAK,EAAE,WAAW,GAAG,KAAK,IAAI,eAAe,CAE9E;;;;;;;;;;;;;;;;;;;;;;;;AAED,wBA2BE"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/index.js b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/index.js
new file mode 100644
index 0000000..82068ba
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/index.js
@@ -0,0 +1,63 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+Object.defineProperty(exports, "NCFieldBase", {
+  enumerable: true,
+  get: function () {
+    return _base.NCFieldBase;
+  }
+});
+exports.default = void 0;
+exports.isSignedDataField = isSignedDataField;
+var _str = require("./str");
+var _int = require("./int");
+var _bytes = require("./bytes");
+var _bytes2 = require("./bytes32");
+var _bool = require("./bool");
+var _address = require("./address");
+var _timestamp = require("./timestamp");
+var _amount = require("./amount");
+var _token = require("./token");
+var _optional = require("./optional");
+var _tuple = require("./tuple");
+var _signedData = require("./signedData");
+var _dict = require("./dict");
+var _collection = require("./collection");
+var _base = require("./base");
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+function isSignedDataField(value) {
+  return value.getType() === 'SignedData';
+}
+var _default = exports.default = {
+  StrField: _str.StrField,
+  IntField: _int.IntField,
+  BoolField: _bool.BoolField,
+  AddressField: _address.AddressField,
+  TimestampField: _timestamp.TimestampField,
+  AmountField: _amount.AmountField,
+  TokenUidField: _token.TokenUidField,
+  // Bytes fields
+  BytesField: _bytes.BytesField,
+  TxOutputScriptField: _bytes.BytesField,
+  // sized bytes (32)
+  VertexIdField: _bytes2.Bytes32Field,
+  ContractIdField: _bytes2.Bytes32Field,
+  BlueprintIdField: _bytes2.Bytes32Field,
+  OptionalField: _optional.OptionalField,
+  TupleField: _tuple.TupleField,
+  SignedDataField: _signedData.SignedDataField,
+  RawSignedDataField: _signedData.SignedDataField,
+  DictField: _dict.DictField,
+  ListField: _collection.CollectionField,
+  SetField: _collection.CollectionField,
+  DequeField: _collection.CollectionField,
+  FrozenSetField: _collection.CollectionField
+};
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/int.d.ts b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/int.d.ts
new file mode 100644
index 0000000..e0fb7fa
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/int.d.ts
@@ -0,0 +1,23 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/// <reference types="node" />
+import { z } from 'zod';
+import { BufferROExtract } from '../types';
+import { NCFieldBase } from './base';
+export declare class IntField extends NCFieldBase<number | bigint | string, bigint> {
+    value: bigint;
+    schema: z.ZodBigInt;
+    constructor(value: bigint);
+    getType(): string;
+    static new(): IntField;
+    createNew(): IntField;
+    fromBuffer(buf: Buffer): BufferROExtract<bigint>;
+    toBuffer(): Buffer;
+    fromUser(data: unknown): IntField;
+    toUser(): string;
+}
+//# sourceMappingURL=int.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/int.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/int.d.ts.map
new file mode 100644
index 0000000..2da8d1b
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/int.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"int.d.ts","sourceRoot":"","sources":["../../../src/nano_contracts/fields/int.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;;AAGH,OAAO,EAAE,CAAC,EAAE,MAAM,KAAK,CAAC;AACxB,OAAO,EAAE,eAAe,EAAE,MAAM,UAAU,CAAC;AAC3C,OAAO,EAAE,WAAW,EAAE,MAAM,QAAQ,CAAC;AAGrC,qBAAa,QAAS,SAAQ,WAAW,CAAC,MAAM,GAAG,MAAM,GAAG,MAAM,EAAE,MAAM,CAAC;IACzE,KAAK,EAAE,MAAM,CAAC;IAEd,MAAM,cAAqB;gBAEf,KAAK,EAAE,MAAM;IAKzB,OAAO;IAIP,MAAM,CAAC,GAAG,IAAI,QAAQ;IAItB,SAAS;IAIT,UAAU,CAAC,GAAG,EAAE,MAAM,GAAG,eAAe,CAAC,MAAM,CAAC;IAMhD,QAAQ,IAAI,MAAM;IAIlB,QAAQ,CAAC,IAAI,EAAE,OAAO,GAAG,QAAQ;IAMjC,MAAM,IAAI,MAAM;CAGjB"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/int.js b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/int.js
new file mode 100644
index 0000000..27a03bf
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/int.js
@@ -0,0 +1,51 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.IntField = void 0;
+var _zod = require("zod");
+var _base = require("./base");
+var _encoding = require("./encoding");
+function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
+function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
+function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */ /* eslint class-methods-use-this: ["error", { "exceptMethods": ["getType", "createNew"] }] */
+class IntField extends _base.NCFieldBase {
+  constructor(value) {
+    super();
+    _defineProperty(this, "value", void 0);
+    _defineProperty(this, "schema", _zod.z.coerce.bigint());
+    this.value = value;
+  }
+  getType() {
+    return 'int';
+  }
+  static new() {
+    return new IntField(0n);
+  }
+  createNew() {
+    return IntField.new();
+  }
+  fromBuffer(buf) {
+    const parsed = _encoding.leb128.decode_signed(buf);
+    this.value = parsed.value;
+    return parsed;
+  }
+  toBuffer() {
+    return _encoding.leb128.encode_signed(this.value);
+  }
+  fromUser(data) {
+    const value = this.schema.parse(data);
+    this.value = value;
+    return this;
+  }
+  toUser() {
+    return String(this.value);
+  }
+}
+exports.IntField = IntField;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/optional.d.ts b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/optional.d.ts
new file mode 100644
index 0000000..a72280a
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/optional.d.ts
@@ -0,0 +1,23 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/// <reference types="node" />
+import { BufferROExtract } from '../types';
+import { NCFieldBase } from './base';
+export declare class OptionalField extends NCFieldBase<unknown | null, unknown | null> {
+    value: unknown | null;
+    inner: NCFieldBase;
+    constructor(inner: NCFieldBase, value: unknown | null);
+    get is_null(): boolean;
+    getType(): string;
+    static new(inner: NCFieldBase): OptionalField;
+    createNew(): OptionalField;
+    fromBuffer(buf: Buffer): BufferROExtract<unknown | null>;
+    toBuffer(): Buffer;
+    fromUser(data: unknown): OptionalField;
+    toUser(): unknown | null;
+}
+//# sourceMappingURL=optional.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/optional.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/optional.d.ts.map
new file mode 100644
index 0000000..117aafa
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/optional.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"optional.d.ts","sourceRoot":"","sources":["../../../src/nano_contracts/fields/optional.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;;AAGH,OAAO,EAAE,eAAe,EAAE,MAAM,UAAU,CAAC;AAC3C,OAAO,EAAE,WAAW,EAAE,MAAM,QAAQ,CAAC;AAErC,qBAAa,aAAc,SAAQ,WAAW,CAAC,OAAO,GAAG,IAAI,EAAE,OAAO,GAAG,IAAI,CAAC;IAC5E,KAAK,EAAE,OAAO,GAAG,IAAI,CAAC;IAEtB,KAAK,EAAE,WAAW,CAAC;gBAEP,KAAK,EAAE,WAAW,EAAE,KAAK,EAAE,OAAO,GAAG,IAAI;IAMrD,IAAI,OAAO,YAEV;IAED,OAAO;IAIP,MAAM,CAAC,GAAG,CAAC,KAAK,EAAE,WAAW,GAAG,aAAa;IAI7C,SAAS;IAIT,UAAU,CAAC,GAAG,EAAE,MAAM,GAAG,eAAe,CAAC,OAAO,GAAG,IAAI,CAAC;IAgBxD,QAAQ,IAAI,MAAM;IAOlB,QAAQ,CAAC,IAAI,EAAE,OAAO,GAAG,aAAa;IAUtC,MAAM,IAAI,OAAO,GAAG,IAAI;CAMzB"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/optional.js b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/optional.js
new file mode 100644
index 0000000..3f83701
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/optional.js
@@ -0,0 +1,73 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.OptionalField = void 0;
+var _base = require("./base");
+function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
+function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
+function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */ /* eslint class-methods-use-this: ["error", { "exceptMethods": ["getType"] }] */
+class OptionalField extends _base.NCFieldBase {
+  constructor(inner, value) {
+    super();
+    _defineProperty(this, "value", void 0);
+    _defineProperty(this, "inner", void 0);
+    this.value = value;
+    this.inner = inner;
+  }
+  get is_null() {
+    return this.value === null;
+  }
+  getType() {
+    return 'Optional';
+  }
+  static new(inner) {
+    return new OptionalField(inner, null);
+  }
+  createNew() {
+    return OptionalField.new(this.inner.createNew());
+  }
+  fromBuffer(buf) {
+    if (buf[0] === 0) {
+      this.value = null;
+      return {
+        value: null,
+        bytesRead: 1
+      };
+    }
+    const parsed = this.inner.fromBuffer(buf.subarray(1));
+    this.value = parsed.value;
+    return {
+      value: parsed.value,
+      bytesRead: parsed.bytesRead + 1
+    };
+  }
+  toBuffer() {
+    if (this.is_null) {
+      return Buffer.from([0]);
+    }
+    return Buffer.concat([Buffer.from([1]), this.inner.toBuffer()]);
+  }
+  fromUser(data) {
+    if (data === null) {
+      this.value = null;
+      return this;
+    }
+    this.inner.fromUser(data);
+    this.value = this.inner.value;
+    return this;
+  }
+  toUser() {
+    if (this.is_null) {
+      return null;
+    }
+    return this.inner.toUser();
+  }
+}
+exports.OptionalField = OptionalField;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/signedData.d.ts b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/signedData.d.ts
new file mode 100644
index 0000000..19efeae
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/signedData.d.ts
@@ -0,0 +1,37 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/// <reference types="node" />
+import { z } from 'zod';
+import { BufferROExtract } from '../types';
+import { NCFieldBase } from './base';
+export interface ISignedData {
+    type: string;
+    signature: Buffer;
+    value: unknown;
+}
+export interface IUserSignedData {
+    type: string;
+    signature: string;
+    value: unknown;
+}
+/**
+ * A schema to validate that the user sent unknown data is a valid IUserSignedData.
+ */
+export declare const UserSignedDataSchema: z.ZodType<IUserSignedData, z.ZodTypeDef, unknown>;
+export declare class SignedDataField extends NCFieldBase<IUserSignedData, ISignedData> {
+    value: ISignedData;
+    inner: NCFieldBase;
+    constructor(inner: NCFieldBase, type: string, signature: Buffer, value: unknown);
+    getType(): string;
+    static new(inner: NCFieldBase, type: string): SignedDataField;
+    createNew(): SignedDataField;
+    fromBuffer(buf: Buffer): BufferROExtract<ISignedData>;
+    toBuffer(): Buffer;
+    fromUser(data: unknown): SignedDataField;
+    toUser(): IUserSignedData;
+}
+//# sourceMappingURL=signedData.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/signedData.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/signedData.d.ts.map
new file mode 100644
index 0000000..3fe4832
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/signedData.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"signedData.d.ts","sourceRoot":"","sources":["../../../src/nano_contracts/fields/signedData.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;;AAGH,OAAO,EAAE,CAAC,EAAE,MAAM,KAAK,CAAC;AACxB,OAAO,EAAE,eAAe,EAAE,MAAM,UAAU,CAAC;AAC3C,OAAO,EAAE,WAAW,EAAE,MAAM,QAAQ,CAAC;AAGrC,MAAM,WAAW,WAAW;IAC1B,IAAI,EAAE,MAAM,CAAC;IACb,SAAS,EAAE,MAAM,CAAC;IAClB,KAAK,EAAE,OAAO,CAAC;CAChB;AAED,MAAM,WAAW,eAAe;IAC9B,IAAI,EAAE,MAAM,CAAC;IACb,SAAS,EAAE,MAAM,CAAC;IAClB,KAAK,EAAE,OAAO,CAAC;CAChB;AAED;;GAEG;AACH,eAAO,MAAM,oBAAoB,EAAE,CAAC,CAAC,OAAO,CAAC,eAAe,EAAE,CAAC,CAAC,UAAU,EAAE,OAAO,CAMK,CAAC;AAEzF,qBAAa,eAAgB,SAAQ,WAAW,CAAC,eAAe,EAAE,WAAW,CAAC;IAC5E,KAAK,EAAE,WAAW,CAAC;IAEnB,KAAK,EAAE,WAAW,CAAC;gBAEP,KAAK,EAAE,WAAW,EAAE,IAAI,EAAE,MAAM,EAAE,SAAS,EAAE,MAAM,EAAE,KAAK,EAAE,OAAO;IAU/E,OAAO;IAIP,MAAM,CAAC,GAAG,CAAC,KAAK,EAAE,WAAW,EAAE,IAAI,EAAE,MAAM,GAAG,eAAe;IAI7D,SAAS;IAIT,UAAU,CAAC,GAAG,EAAE,MAAM,GAAG,eAAe,CAAC,WAAW,CAAC;IAarD,QAAQ,IAAI,MAAM;IAMlB,QAAQ,CAAC,IAAI,EAAE,OAAO,GAAG,eAAe;IAqBxC,MAAM,IAAI,eAAe;CAO1B"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/signedData.js b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/signedData.js
new file mode 100644
index 0000000..c70b10c
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/signedData.js
@@ -0,0 +1,89 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.UserSignedDataSchema = exports.SignedDataField = void 0;
+var _zod = require("zod");
+var _base = require("./base");
+var _bytes = require("./bytes");
+function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
+function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
+function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */ /* eslint class-methods-use-this: ["error", { "exceptMethods": ["getType"] }] */
+/**
+ * A schema to validate that the user sent unknown data is a valid IUserSignedData.
+ */
+const UserSignedDataSchema = exports.UserSignedDataSchema = _zod.z.object({
+  type: _zod.z.string(),
+  signature: _zod.z.string().regex(/^[a-fA-F0-9]*$/),
+  value: _zod.z.unknown()
+}).transform(data => ({
+  ...data,
+  value: data.value === undefined ? null : data.value
+}));
+class SignedDataField extends _base.NCFieldBase {
+  constructor(inner, type, signature, value) {
+    super();
+    _defineProperty(this, "value", void 0);
+    _defineProperty(this, "inner", void 0);
+    this.value = {
+      type,
+      signature,
+      value
+    };
+    this.inner = inner;
+  }
+  getType() {
+    return 'SignedData';
+  }
+  static new(inner, type) {
+    return new SignedDataField(inner, type, Buffer.alloc(0), undefined);
+  }
+  createNew() {
+    return SignedDataField.new(this.inner.createNew(), this.value.type);
+  }
+  fromBuffer(buf) {
+    const result = this.inner.fromBuffer(buf);
+    const sigBuf = buf.subarray(result.bytesRead);
+    const sigResult = _bytes.BytesField.new().fromBuffer(sigBuf);
+    this.value.signature = sigResult.value;
+    this.value.value = result.value;
+    return {
+      value: {
+        ...this.value
+      },
+      bytesRead: result.bytesRead + sigResult.bytesRead
+    };
+  }
+  toBuffer() {
+    const signature = new _bytes.BytesField(this.value.signature);
+    return Buffer.concat([this.inner.toBuffer(), signature.toBuffer()]);
+  }
+  fromUser(data) {
+    const parsed = UserSignedDataSchema.parse(data);
+    if (parsed.type !== this.value.type) {
+      throw new Error(`Expected ${this.value.type} but received ${parsed.type}`);
+    }
+    this.inner.fromUser(parsed.value);
+    const signature = _zod.z.string().regex(/^[a-fA-F0-9]*$/).transform(s => Buffer.from(s, 'hex')).parse(parsed.signature);
+    this.value = {
+      type: parsed.type,
+      signature,
+      value: this.inner.value
+    };
+    return this;
+  }
+  toUser() {
+    return {
+      type: this.value.type,
+      signature: this.value.signature.toString('hex'),
+      value: this.inner.toUser()
+    };
+  }
+}
+exports.SignedDataField = SignedDataField;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/str.d.ts b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/str.d.ts
new file mode 100644
index 0000000..ce3575d
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/str.d.ts
@@ -0,0 +1,21 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/// <reference types="node" />
+import { BufferROExtract } from '../types';
+import { NCFieldBase } from './base';
+export declare class StrField extends NCFieldBase<string, string> {
+    value: string;
+    constructor(value: string);
+    getType(): string;
+    static new(): StrField;
+    createNew(): StrField;
+    fromBuffer(buf: Buffer): BufferROExtract<string>;
+    toBuffer(): Buffer;
+    fromUser(data: unknown): StrField;
+    toUser(): string;
+}
+//# sourceMappingURL=str.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/str.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/str.d.ts.map
new file mode 100644
index 0000000..66f6e92
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/str.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"str.d.ts","sourceRoot":"","sources":["../../../src/nano_contracts/fields/str.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;;AAIH,OAAO,EAAE,eAAe,EAAE,MAAM,UAAU,CAAC;AAC3C,OAAO,EAAE,WAAW,EAAE,MAAM,QAAQ,CAAC;AAGrC,qBAAa,QAAS,SAAQ,WAAW,CAAC,MAAM,EAAE,MAAM,CAAC;IACvD,KAAK,EAAE,MAAM,CAAC;gBAEF,KAAK,EAAE,MAAM;IAKzB,OAAO;IAIP,MAAM,CAAC,GAAG,IAAI,QAAQ;IAItB,SAAS;IAIT,UAAU,CAAC,GAAG,EAAE,MAAM,GAAG,eAAe,CAAC,MAAM,CAAC;IAMhD,QAAQ,IAAI,MAAM;IAIlB,QAAQ,CAAC,IAAI,EAAE,OAAO,GAAG,QAAQ;IAKjC,MAAM,IAAI,MAAM;CAGjB"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/str.js b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/str.js
new file mode 100644
index 0000000..eba5634
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/str.js
@@ -0,0 +1,49 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.StrField = void 0;
+var _zod = require("zod");
+var _base = require("./base");
+var _encoding = require("./encoding");
+function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
+function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
+function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */ /* eslint class-methods-use-this: ["error", { "exceptMethods": ["getType", "createNew"] }] */
+class StrField extends _base.NCFieldBase {
+  constructor(value) {
+    super();
+    _defineProperty(this, "value", void 0);
+    this.value = value;
+  }
+  getType() {
+    return 'str';
+  }
+  static new() {
+    return new StrField('');
+  }
+  createNew() {
+    return StrField.new();
+  }
+  fromBuffer(buf) {
+    const parsed = _encoding.utf8.decode(buf);
+    this.value = parsed.value;
+    return parsed;
+  }
+  toBuffer() {
+    return _encoding.utf8.encode(this.value);
+  }
+  fromUser(data) {
+    this.value = _zod.z.string().parse(data);
+    return this;
+  }
+  toUser() {
+    return this.value;
+  }
+}
+exports.StrField = StrField;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/timestamp.d.ts b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/timestamp.d.ts
new file mode 100644
index 0000000..599e220
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/timestamp.d.ts
@@ -0,0 +1,21 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/// <reference types="node" />
+import { BufferROExtract } from '../types';
+import { NCFieldBase } from './base';
+export declare class TimestampField extends NCFieldBase<number, number> {
+    value: number;
+    constructor(value: number);
+    getType(): string;
+    static new(): TimestampField;
+    createNew(): TimestampField;
+    fromBuffer(buf: Buffer): BufferROExtract<number>;
+    toBuffer(): Buffer;
+    fromUser(data: unknown): TimestampField;
+    toUser(): number;
+}
+//# sourceMappingURL=timestamp.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/timestamp.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/timestamp.d.ts.map
new file mode 100644
index 0000000..53bccd7
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/timestamp.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"timestamp.d.ts","sourceRoot":"","sources":["../../../src/nano_contracts/fields/timestamp.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;;AAIH,OAAO,EAAE,eAAe,EAAE,MAAM,UAAU,CAAC;AAC3C,OAAO,EAAE,WAAW,EAAE,MAAM,QAAQ,CAAC;AAGrC,qBAAa,cAAe,SAAQ,WAAW,CAAC,MAAM,EAAE,MAAM,CAAC;IAC7D,KAAK,EAAE,MAAM,CAAC;gBAEF,KAAK,EAAE,MAAM;IAKzB,OAAO;IAIP,MAAM,CAAC,GAAG,IAAI,cAAc;IAI5B,SAAS;IAIT,UAAU,CAAC,GAAG,EAAE,MAAM,GAAG,eAAe,CAAC,MAAM,CAAC;IAShD,QAAQ,IAAI,MAAM;IAIlB,QAAQ,CAAC,IAAI,EAAE,OAAO,GAAG,cAAc;IAMvC,MAAM,IAAI,MAAM;CAGjB"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/timestamp.js b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/timestamp.js
new file mode 100644
index 0000000..6ef5db2
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/timestamp.js
@@ -0,0 +1,53 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.TimestampField = void 0;
+var _zod = require("zod");
+var _base = require("./base");
+var _buffer = require("../../utils/buffer");
+function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
+function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
+function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */ /* eslint class-methods-use-this: ["error", { "exceptMethods": ["getType", "createNew"] }] */
+class TimestampField extends _base.NCFieldBase {
+  constructor(value) {
+    super();
+    _defineProperty(this, "value", void 0);
+    this.value = value;
+  }
+  getType() {
+    return 'Timestamp';
+  }
+  static new() {
+    return new TimestampField(0);
+  }
+  createNew() {
+    return TimestampField.new();
+  }
+  fromBuffer(buf) {
+    const value = (0, _buffer.unpackToInt)(4, true, buf)[0];
+    this.value = value;
+    return {
+      value,
+      bytesRead: 4
+    };
+  }
+  toBuffer() {
+    return (0, _buffer.signedIntToBytes)(this.value, 4);
+  }
+  fromUser(data) {
+    const value = _zod.z.number().parse(data);
+    this.value = value;
+    return this;
+  }
+  toUser() {
+    return this.value;
+  }
+}
+exports.TimestampField = TimestampField;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/token.d.ts b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/token.d.ts
new file mode 100644
index 0000000..2d9db33
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/token.d.ts
@@ -0,0 +1,21 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/// <reference types="node" />
+import { BufferROExtract } from '../types';
+import { NCFieldBase } from './base';
+export declare class TokenUidField extends NCFieldBase<string, string> {
+    value: string;
+    constructor(value: string);
+    getType(): string;
+    static new(): TokenUidField;
+    createNew(): TokenUidField;
+    fromBuffer(buf: Buffer): BufferROExtract<string>;
+    toBuffer(): Buffer;
+    fromUser(data: unknown): TokenUidField;
+    toUser(): string;
+}
+//# sourceMappingURL=token.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/token.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/token.d.ts.map
new file mode 100644
index 0000000..fe328bd
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/token.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"token.d.ts","sourceRoot":"","sources":["../../../src/nano_contracts/fields/token.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;;AAKH,OAAO,EAAE,eAAe,EAAE,MAAM,UAAU,CAAC;AAC3C,OAAO,EAAE,WAAW,EAAE,MAAM,QAAQ,CAAC;AAKrC,qBAAa,aAAc,SAAQ,WAAW,CAAC,MAAM,EAAE,MAAM,CAAC;IAC5D,KAAK,EAAE,MAAM,CAAC;gBAEF,KAAK,EAAE,MAAM;IAKzB,OAAO;IAIP,MAAM,CAAC,GAAG,IAAI,aAAa;IAI3B,SAAS;IAIT,UAAU,CAAC,GAAG,EAAE,MAAM,GAAG,eAAe,CAAC,MAAM,CAAC;IAoBhD,QAAQ,IAAI,MAAM;IAQlB,QAAQ,CAAC,IAAI,EAAE,OAAO,GAAG,aAAa;IAMtC,MAAM,IAAI,MAAM;CAGjB"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/token.js b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/token.js
new file mode 100644
index 0000000..3512dc4
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/token.js
@@ -0,0 +1,70 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.TokenUidField = void 0;
+var _zod = require("zod");
+var _constants = require("../../constants");
+var _base = require("./base");
+var _encoding = require("./encoding");
+function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
+function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
+function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */ /* eslint class-methods-use-this: ["error", { "exceptMethods": ["getType", "createNew"] }] */
+const TokenUidSchema = _zod.z.union([_zod.z.literal('00'), _zod.z.string().regex(/^[a-fA-F0-9]{64}$/)]);
+class TokenUidField extends _base.NCFieldBase {
+  constructor(value) {
+    super();
+    _defineProperty(this, "value", void 0);
+    this.value = value;
+  }
+  getType() {
+    return 'TokenUid';
+  }
+  static new() {
+    return new TokenUidField(_constants.NATIVE_TOKEN_UID);
+  }
+  createNew() {
+    return TokenUidField.new();
+  }
+  fromBuffer(buf) {
+    if (buf[0] === 0x00) {
+      this.value = _constants.NATIVE_TOKEN_UID;
+      return {
+        value: _constants.NATIVE_TOKEN_UID,
+        bytesRead: 1
+      };
+    }
+    if (buf[0] === 0x01) {
+      const parsed = _encoding.sizedBytes.decode(32, buf.subarray(1));
+      const value = parsed.value.toString('hex');
+      this.value = value;
+      return {
+        value,
+        bytesRead: 33
+      };
+    }
+    throw new Error('Invalid TokenUid tag');
+  }
+  toBuffer() {
+    TokenUidSchema.parse(this.value);
+    if (this.value === _constants.NATIVE_TOKEN_UID) {
+      return Buffer.from([0]);
+    }
+    return Buffer.concat([Buffer.from([1]), Buffer.from(this.value, 'hex')]);
+  }
+  fromUser(data) {
+    const value = TokenUidSchema.parse(data);
+    this.value = value;
+    return this;
+  }
+  toUser() {
+    return this.value;
+  }
+}
+exports.TokenUidField = TokenUidField;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/tuple.d.ts b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/tuple.d.ts
new file mode 100644
index 0000000..c8ff41b
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/tuple.d.ts
@@ -0,0 +1,22 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/// <reference types="node" />
+import { BufferROExtract } from '../types';
+import { NCFieldBase } from './base';
+export declare class TupleField extends NCFieldBase<unknown[], unknown[]> {
+    value: unknown[];
+    elements: NCFieldBase[];
+    constructor(elements: NCFieldBase[], value: unknown[]);
+    getType(): string;
+    static new(elements: NCFieldBase[]): TupleField;
+    createNew(): TupleField;
+    fromBuffer(buf: Buffer): BufferROExtract<unknown[]>;
+    toBuffer(): Buffer;
+    fromUser(data: unknown): TupleField;
+    toUser(): unknown[];
+}
+//# sourceMappingURL=tuple.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/tuple.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/tuple.d.ts.map
new file mode 100644
index 0000000..97a776a
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/tuple.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"tuple.d.ts","sourceRoot":"","sources":["../../../src/nano_contracts/fields/tuple.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;;AAGH,OAAO,EAAE,eAAe,EAAE,MAAM,UAAU,CAAC;AAC3C,OAAO,EAAE,WAAW,EAAE,MAAM,QAAQ,CAAC;AAErC,qBAAa,UAAW,SAAQ,WAAW,CAAC,OAAO,EAAE,EAAE,OAAO,EAAE,CAAC;IAC/D,KAAK,EAAE,OAAO,EAAE,CAAC;IAEjB,QAAQ,EAAE,WAAW,EAAE,CAAC;gBAEZ,QAAQ,EAAE,WAAW,EAAE,EAAE,KAAK,EAAE,OAAO,EAAE;IAMrD,OAAO;IAIP,MAAM,CAAC,GAAG,CAAC,QAAQ,EAAE,WAAW,EAAE,GAAG,UAAU;IAI/C,SAAS;IAIT,UAAU,CAAC,GAAG,EAAE,MAAM,GAAG,eAAe,CAAC,OAAO,EAAE,CAAC;IAiBnD,QAAQ,IAAI,MAAM;IAQlB,QAAQ,CAAC,IAAI,EAAE,OAAO,GAAG,UAAU;IAmBnC,MAAM,IAAI,OAAO,EAAE;CAGpB"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/tuple.js b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/tuple.js
new file mode 100644
index 0000000..dbe8fec
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/fields/tuple.js
@@ -0,0 +1,78 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.TupleField = void 0;
+var _base = require("./base");
+function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
+function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
+function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */ /* eslint class-methods-use-this: ["error", { "exceptMethods": ["getType"] }] */
+class TupleField extends _base.NCFieldBase {
+  constructor(elements, value) {
+    super();
+    _defineProperty(this, "value", void 0);
+    _defineProperty(this, "elements", void 0);
+    this.value = value;
+    this.elements = elements;
+  }
+  getType() {
+    return 'Tuple';
+  }
+  static new(elements) {
+    return new TupleField(elements, []);
+  }
+  createNew() {
+    return TupleField.new(this.elements.map(el => el.createNew()));
+  }
+  fromBuffer(buf) {
+    const values = [];
+    let bytesReadTotal = 0;
+    let tupleBuf = buf.subarray();
+    for (const el of this.elements) {
+      const result = el.fromBuffer(tupleBuf);
+      values.push(result.value);
+      bytesReadTotal += result.bytesRead;
+      tupleBuf = tupleBuf.subarray(result.bytesRead);
+    }
+    this.value = values;
+    return {
+      value: values,
+      bytesRead: bytesReadTotal
+    };
+  }
+  toBuffer() {
+    const serialized = [];
+    for (const el of this.elements) {
+      serialized.push(el.toBuffer());
+    }
+    return Buffer.concat(serialized);
+  }
+  fromUser(data) {
+    function isArray(d) {
+      return typeof d === 'object' && d != null && Array.isArray(d);
+    }
+    if (!isArray(data)) {
+      throw new Error('Provided data is not iterable, so it cannot be a list.');
+    }
+    const values = [];
+    if (this.elements.length !== data.length) {
+      throw new Error('Mismatched number of values from type');
+    }
+    for (const [index, el] of this.elements.entries()) {
+      el.fromUser(data[index]);
+      values.push(el.value);
+    }
+    this.value = values;
+    return this;
+  }
+  toUser() {
+    return this.elements.map(el => el.toUser());
+  }
+}
+exports.TupleField = TupleField;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/header.d.ts b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/header.d.ts
new file mode 100644
index 0000000..a9baf3b
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/header.d.ts
@@ -0,0 +1,72 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/// <reference types="node" />
+import { NanoContractActionHeader } from './types';
+import type Transaction from '../models/transaction';
+import Header from '../headers/base';
+import Address from '../models/address';
+import Network from '../models/network';
+declare class NanoContractHeader extends Header {
+    id: string;
+    method: string;
+    args: Buffer;
+    actions: NanoContractActionHeader[];
+    address: Address;
+    seqnum: number;
+    /**
+     * script with signature(s) of the transaction owner(s)/caller(s).
+     * Supports P2PKH and P2SH
+     */
+    script: Buffer | null;
+    constructor(id: string, method: string, args: Buffer, actions: NanoContractActionHeader[], seqnum: number, address: Address, script?: Buffer | null);
+    /**
+     * Serialize funds fields
+     * Add the serialized fields to the array parameter
+     *
+     * @param array Array of buffer to push the serialized fields
+     * @param addScript If should add the script with the signature(s) when serializing it
+     *
+     * @memberof NanoContract
+     * @inner
+     */
+    serializeFields(array: Buffer[], addScript: boolean): void;
+    /**
+     * Serialize sighash data to bytes
+     *
+     * @memberof NanoContractHeader
+     * @inner
+     */
+    serializeSighash(array: Buffer[]): void;
+    /**
+     * Serialize header to bytes
+     *
+     * @memberof NanoContractHeader
+     * @inner
+     */
+    serialize(array: Buffer[]): void;
+    /**
+     * Deserialize buffer to Header object and
+     * return the rest of the buffer data
+     *
+     * @return Header object deserialized and the rest of buffer data
+     *
+     * @memberof NanoContractHeader
+     * @inner
+     */
+    static deserialize(srcBuf: Buffer, network: Network): [Header, Buffer];
+    /**
+     * Get the nano contract header from the list of headers.
+     *
+     * @return The nano header object
+     *
+     * @memberof Transaction
+     * @inner
+     */
+    static getHeadersFromTx(tx: Transaction): NanoContractHeader[];
+}
+export default NanoContractHeader;
+//# sourceMappingURL=header.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/header.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/header.d.ts.map
new file mode 100644
index 0000000..04cec16
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/header.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"header.d.ts","sourceRoot":"","sources":["../../src/nano_contracts/header.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;;AAEH,OAAO,EAAE,wBAAwB,EAAE,MAAM,SAAS,CAAC;AACnD,OAAO,KAAK,WAAW,MAAM,uBAAuB,CAAC;AAgBrD,OAAO,MAAM,MAAM,iBAAiB,CAAC;AACrC,OAAO,OAAO,MAAM,mBAAmB,CAAC;AACxC,OAAO,OAAO,MAAM,mBAAmB,CAAC;AAGxC,cAAM,kBAAmB,SAAQ,MAAM;IAGrC,EAAE,EAAE,MAAM,CAAC;IAGX,MAAM,EAAE,MAAM,CAAC;IAGf,IAAI,EAAE,MAAM,CAAC;IAGb,OAAO,EAAE,wBAAwB,EAAE,CAAC;IAGpC,OAAO,EAAE,OAAO,CAAC;IAGjB,MAAM,EAAE,MAAM,CAAC;IAEf;;;OAGG;IACH,MAAM,EAAE,MAAM,GAAG,IAAI,CAAC;gBAGpB,EAAE,EAAE,MAAM,EACV,MAAM,EAAE,MAAM,EACd,IAAI,EAAE,MAAM,EACZ,OAAO,EAAE,wBAAwB,EAAE,EACnC,MAAM,EAAE,MAAM,EACd,OAAO,EAAE,OAAO,EAChB,MAAM,GAAE,MAAM,GAAG,IAAW;IAY9B;;;;;;;;;OASG;IACH,eAAe,CAAC,KAAK,EAAE,MAAM,EAAE,EAAE,SAAS,EAAE,OAAO;IAsCnD;;;;;OAKG;IACH,gBAAgB,CAAC,KAAK,EAAE,MAAM,EAAE;IAIhC;;;;;OAKG;IACH,SAAS,CAAC,KAAK,EAAE,MAAM,EAAE;IAQzB;;;;;;;;OAQG;IACH,MAAM,CAAC,WAAW,CAAC,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,OAAO,GAAG,CAAC,MAAM,EAAE,MAAM,CAAC;IA8EtE;;;;;;;OAOG;IACH,MAAM,CAAC,gBAAgB,CAAC,EAAE,EAAE,WAAW,GAAG,kBAAkB,EAAE;CAU/D;AAED,eAAe,kBAAkB,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/header.js b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/header.js
new file mode 100644
index 0000000..b60c632
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/header.js
@@ -0,0 +1,225 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+var _buffer = require("../utils/buffer");
+var _helpers = _interopRequireDefault(require("../utils/helpers"));
+var _leb = _interopRequireDefault(require("../utils/leb128"));
+var _types = require("../headers/types");
+var _base = _interopRequireDefault(require("../headers/base"));
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
+function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
+function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+class NanoContractHeader extends _base.default {
+  constructor(id, method, args, actions, seqnum, address, script = null) {
+    super();
+    // It's the blueprint id when this header is calling a initialize method
+    // and it's the nano contract id when it's executing another method of a nano
+    _defineProperty(this, "id", void 0);
+    // Name of the method to be called. When creating a new Nano Contract, it must be equal to 'initialize'
+    _defineProperty(this, "method", void 0);
+    // Serialized arguments to the method being called
+    _defineProperty(this, "args", void 0);
+    // List of actions for this nano
+    _defineProperty(this, "actions", void 0);
+    // Address of the transaction owner(s)/caller(s)
+    _defineProperty(this, "address", void 0);
+    // Sequential number for the nano header
+    _defineProperty(this, "seqnum", void 0);
+    /**
+     * script with signature(s) of the transaction owner(s)/caller(s).
+     * Supports P2PKH and P2SH
+     */
+    _defineProperty(this, "script", void 0);
+    this.id = id;
+    this.method = method;
+    this.args = args;
+    this.actions = actions;
+    this.address = address;
+    this.script = script;
+    this.seqnum = seqnum;
+  }
+
+  /**
+   * Serialize funds fields
+   * Add the serialized fields to the array parameter
+   *
+   * @param array Array of buffer to push the serialized fields
+   * @param addScript If should add the script with the signature(s) when serializing it
+   *
+   * @memberof NanoContract
+   * @inner
+   */
+  serializeFields(array, addScript) {
+    // nano contract id
+    array.push((0, _buffer.hexToBuffer)(this.id));
+
+    // Seqnum
+    array.push(_leb.default.encodeUnsigned(this.seqnum));
+    const methodBytes = Buffer.from(this.method, 'ascii');
+    array.push((0, _buffer.intToBytes)(methodBytes.length, 1));
+    array.push(methodBytes);
+    array.push((0, _buffer.intToBytes)(this.args.length, 2));
+    array.push(this.args);
+    array.push((0, _buffer.intToBytes)(this.actions.length, 1));
+    for (const action of this.actions) {
+      const arrAction = [];
+      arrAction.push((0, _buffer.intToBytes)(action.type, 1));
+      arrAction.push((0, _buffer.intToBytes)(action.tokenIndex, 1));
+      arrAction.push((0, _buffer.outputValueToBytes)(action.amount));
+      array.push(Buffer.concat(arrAction));
+    }
+    if (!this.address) {
+      throw new Error('Header caller address was not provided');
+    }
+    const addressBytes = this.address.decode();
+    array.push(addressBytes);
+    if (addScript && this.script !== null) {
+      array.push(_leb.default.encodeUnsigned(this.script.length, 2));
+      array.push(this.script);
+    } else {
+      // Script with length 0 indicates there is no script.
+      array.push(_leb.default.encodeUnsigned(0, 2));
+    }
+  }
+
+  /**
+   * Serialize sighash data to bytes
+   *
+   * @memberof NanoContractHeader
+   * @inner
+   */
+  serializeSighash(array) {
+    this.serializeFields(array, false);
+  }
+
+  /**
+   * Serialize header to bytes
+   *
+   * @memberof NanoContractHeader
+   * @inner
+   */
+  serialize(array) {
+    // First add the header ID
+    array.push((0, _types.getVertexHeaderIdBuffer)(_types.VertexHeaderId.NANO_HEADER));
+
+    // Then the serialized header
+    this.serializeFields(array, true);
+  }
+
+  /**
+   * Deserialize buffer to Header object and
+   * return the rest of the buffer data
+   *
+   * @return Header object deserialized and the rest of buffer data
+   *
+   * @memberof NanoContractHeader
+   * @inner
+   */
+  static deserialize(srcBuf, network) {
+    // Copies buffer locally, not to change the original parameter
+    let buf = Buffer.from(srcBuf);
+    if ((0, _types.getVertexHeaderIdFromBuffer)(buf) !== _types.VertexHeaderId.NANO_HEADER) {
+      throw new Error('Invalid vertex header id for nano header.');
+    }
+    buf = buf.subarray(1);
+    let ncId;
+    let method;
+    let args;
+    const actions = [];
+    let address;
+
+    /* eslint-disable prefer-const -- To split these declarations would be confusing.
+     * In all of them the first parameter should be a const and the second a let. */
+
+    // NC ID is 32 bytes in hex
+    let ncIdBuffer;
+    [ncIdBuffer, buf] = (0, _buffer.unpackLen)(32, buf);
+    ncId = ncIdBuffer.toString('hex');
+
+    // Seqnum has variable length with maximum of 8 bytes
+    let seqnum;
+    ({
+      value: seqnum,
+      rest: buf
+    } = _leb.default.decodeUnsigned(buf, 8));
+
+    // nc method
+    let methodLen;
+    let methodBuffer;
+    [methodLen, buf] = (0, _buffer.unpackToInt)(1, false, buf);
+    [methodBuffer, buf] = (0, _buffer.unpackLen)(methodLen, buf);
+    method = methodBuffer.toString('ascii');
+
+    // nc args
+    let argsLen;
+    [argsLen, buf] = (0, _buffer.unpackToInt)(2, false, buf);
+    [args, buf] = (0, _buffer.unpackLen)(argsLen, buf);
+
+    // nc actions
+    let actionsLen;
+    [actionsLen, buf] = (0, _buffer.unpackToInt)(1, false, buf);
+    for (let i = 0; i < actionsLen; i++) {
+      let actionTypeBytes;
+      let actionType;
+      let tokenIndex;
+      let amount;
+      [actionTypeBytes, buf] = [buf.subarray(0, 1), buf.subarray(1)];
+      [actionType] = (0, _buffer.unpackToInt)(1, false, actionTypeBytes);
+      [tokenIndex, buf] = (0, _buffer.unpackToInt)(1, false, buf);
+      [amount, buf] = (0, _buffer.bytesToOutputValue)(buf);
+      actions.push({
+        type: actionType,
+        tokenIndex,
+        amount
+      });
+    }
+
+    // nc address
+    let addressBytes;
+    [addressBytes, buf] = (0, _buffer.unpackLen)(25, buf);
+    address = _helpers.default.getAddressFromBytes(addressBytes, network);
+
+    // nc script
+    let scriptLen;
+    ({
+      value: scriptLen,
+      rest: buf
+    } = _leb.default.decodeUnsigned(buf, 2));
+    const header = new NanoContractHeader(ncId, method, args, actions, Number(seqnum), address);
+    if (scriptLen !== 0n) {
+      // script might be null
+      [header.script, buf] = (0, _buffer.unpackLen)(Number(scriptLen), buf);
+    }
+    /* eslint-enable prefer-const */
+
+    return [header, buf];
+  }
+
+  /**
+   * Get the nano contract header from the list of headers.
+   *
+   * @return The nano header object
+   *
+   * @memberof Transaction
+   * @inner
+   */
+  static getHeadersFromTx(tx) {
+    const headers = [];
+    for (const header of tx.headers) {
+      if (header instanceof NanoContractHeader) {
+        headers.push(header);
+      }
+    }
+    return headers;
+  }
+}
+var _default = exports.default = NanoContractHeader;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/ncTypes/parser.d.ts b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/ncTypes/parser.d.ts
new file mode 100644
index 0000000..d5b36ff
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/ncTypes/parser.d.ts
@@ -0,0 +1,11 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+import { NCFieldBase } from '../fields';
+import Network from '../../models/network';
+import { ILogger } from '../../types';
+export declare function getFieldParser(typeStr: string, network: Network, logger?: ILogger): NCFieldBase<unknown, unknown>;
+//# sourceMappingURL=parser.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/ncTypes/parser.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/ncTypes/parser.d.ts.map
new file mode 100644
index 0000000..667787c
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/ncTypes/parser.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"parser.d.ts","sourceRoot":"","sources":["../../../src/nano_contracts/ncTypes/parser.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;AAGH,OAAiB,EAAE,WAAW,EAAE,MAAM,WAAW,CAAC;AAClD,OAAO,OAAO,MAAM,sBAAsB,CAAC;AAC3C,OAAO,EAAE,OAAO,EAAE,MAAM,aAAa,CAAC;AAgCtC,wBAAgB,cAAc,CAAC,OAAO,EAAE,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,MAAM,CAAC,EAAE,OAAO,iCAIjF"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/ncTypes/parser.js b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/ncTypes/parser.js
new file mode 100644
index 0000000..092fac1
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/ncTypes/parser.js
@@ -0,0 +1,228 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.getFieldParser = getFieldParser;
+var _zod = require("zod");
+var _fields = _interopRequireDefault(require("../fields"));
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+const simpleTypes = _zod.z.enum(['str', 'int', 'bool', 'Address', 'Timestamp', 'Amount', 'TokenUid',
+// bytes
+'bytes', 'TxOutputScript', 'BlueprintId', 'ContractId', 'VertexId']);
+// e.g., frozenset[int];
+
+function getFieldParser(typeStr, network, logger) {
+  const type = parseTypeString(typeStr);
+  logger?.debug(`[nc type] type parsed: ${JSON.stringify(type)}`);
+  return fieldFromTypeNode(type, network);
+}
+
+/**
+ * Convert the TypeNode into a NCField which can be used to (de)serialize nano contract arguments.
+ */
+function fieldFromTypeNode(type, network, logger) {
+  switch (type.kind) {
+    case 'simple':
+      logger?.debug(`[nc type] simple field: ${type.name}`);
+      switch (type.name) {
+        case 'str':
+          return _fields.default.StrField.new();
+        case 'int':
+          return _fields.default.IntField.new();
+        case 'bool':
+          return _fields.default.BoolField.new();
+        case 'Address':
+          return _fields.default.AddressField.new(network);
+        case 'Timestamp':
+          return _fields.default.TimestampField.new();
+        case 'Amount':
+          return _fields.default.AmountField.new();
+        case 'TokenUid':
+          return _fields.default.TokenUidField.new();
+        case 'bytes':
+          return _fields.default.BytesField.new();
+        case 'TxOutputScript':
+          return _fields.default.TxOutputScriptField.new();
+        case 'BlueprintId':
+          return _fields.default.BlueprintIdField.new();
+        case 'ContractId':
+          return _fields.default.ContractIdField.new();
+        case 'VertexId':
+          return _fields.default.VertexIdField.new();
+        default:
+          throw new Error('Invalid simple type');
+      }
+    case 'optional':
+      logger?.debug(`[nc type] field: optional`);
+      return _fields.default.OptionalField.new(fieldFromTypeNode(type.inner, network));
+    case 'tuple':
+      logger?.debug(`[nc type] field: tuple`);
+      return _fields.default.TupleField.new(type.elements.map(el => fieldFromTypeNode(el, network)));
+    case 'signed_data':
+      logger?.debug(`[nc type] field: signed_data`);
+      return _fields.default.SignedDataField.new(fieldFromTypeNode(type.inner, network), type.subtype);
+    case 'raw_signed_data':
+      logger?.debug(`[nc type] field: raw_signed_data`);
+      return _fields.default.RawSignedDataField.new(fieldFromTypeNode(type.inner, network), type.subtype);
+    case 'dict':
+      return _fields.default.DictField.new(fieldFromTypeNode(type.key, network), fieldFromTypeNode(type.value, network));
+    case 'list':
+      return _fields.default.ListField.new(fieldFromTypeNode(type.element, network));
+    case 'set':
+      return _fields.default.SetField.new(fieldFromTypeNode(type.element, network));
+    case 'deque':
+      return _fields.default.DequeField.new(fieldFromTypeNode(type.element, network));
+    case 'frozenset':
+      return _fields.default.FrozenSetField.new(fieldFromTypeNode(type.element, network));
+    default:
+      logger?.error(`[nc type] could not identify: ${JSON.stringify(type)}`);
+      throw new Error('Unsupported TypeNode');
+  }
+}
+
+/**
+ * Parse a type string into a parsed TypeNode.
+ * The TypeNode is used to understand the structure of the type.
+ *
+ * @example
+ * ```ts
+ * // { kind: 'tuple', elements: [ {kind: 'simple', name: 'Address'}, {kind: 'simple', name: 'Amount'} ]}
+ * const type1 = parseTypeString('Tuple[Address, Amount]');
+ *
+ * // { kind: 'simple', name: 'TxOutputScript' }
+ * const type2 = parseTypeString('TxOutputScript');
+ *
+ * // { kind: 'dict', key: {kind: 'simple', name: 'Address'}, value: {kind: 'simple', name: 'Amount'} }
+ * const type3 = parseTypeString('Dict[Address, Amount]');
+ * ```
+ */
+function parseTypeString(typeStrIn) {
+  // Remove whitespace and normalize
+  const typeStr = typeStrIn.trim();
+
+  // Base case: simple types
+  const simple = simpleTypes.safeParse(typeStr);
+  if (simple.success) {
+    return {
+      kind: 'simple',
+      name: simple.data
+    };
+  }
+
+  // Handle optional `type?`
+  if (typeStr.endsWith('?')) {
+    const innerStr = typeStr.slice(0, -1); // Remove trailing '?'
+    return {
+      kind: 'optional',
+      inner: parseTypeString(innerStr)
+    };
+  }
+
+  // Handle container type `Type[...]`
+
+  const match = typeStr.match(/^(.*?)\[(.*)\]/);
+  if (match === null) {
+    throw new Error(`Unsupported type: ${typeStr}`);
+  }
+  const containerType = match[1].trim();
+  const innerTypeStr = match[2].trim();
+  if (containerType === 'SignedData') {
+    return {
+      kind: 'signed_data',
+      inner: parseTypeString(innerTypeStr),
+      subtype: innerTypeStr
+    };
+  }
+  if (containerType === 'RawSignedData') {
+    return {
+      kind: 'raw_signed_data',
+      inner: parseTypeString(innerTypeStr),
+      subtype: innerTypeStr
+    };
+  }
+
+  // Handles Dict and dict
+  if (containerType.toLowerCase() === 'dict') {
+    const [keyStr, valueStr] = splitTopLevel(innerTypeStr, ',');
+    return {
+      kind: 'dict',
+      key: parseTypeString(keyStr),
+      value: parseTypeString(valueStr)
+    };
+  }
+
+  // handles Tuple and tuple
+  if (containerType.toLowerCase() === 'tuple') {
+    const elements = splitTopLevel(innerTypeStr, ',').map(s => parseTypeString(s));
+    return {
+      kind: 'tuple',
+      elements
+    };
+  }
+  if (containerType.toLowerCase() === 'list') {
+    return {
+      kind: 'list',
+      element: parseTypeString(innerTypeStr)
+    };
+  }
+  if (containerType.toLowerCase() === 'set') {
+    return {
+      kind: 'set',
+      element: parseTypeString(innerTypeStr)
+    };
+  }
+  if (containerType.toLowerCase() === 'deque') {
+    return {
+      kind: 'deque',
+      element: parseTypeString(innerTypeStr)
+    };
+  }
+  if (containerType.toLowerCase() === 'frozenset') {
+    return {
+      kind: 'frozenset',
+      element: parseTypeString(innerTypeStr)
+    };
+  }
+  throw new Error(`Unsupported type: ${typeStr}`);
+}
+
+/**
+ * Helper function to split top-level comma-separated elements
+ * respecting nested brackets boundaries.
+ *
+ * @example
+ * ```ts
+ * // [ 'Tuple[str?, int]', 'int', 'Dict[str, Set[int]]?' ]
+ * splitTopLevel('Tuple[str?, int], int, Dict[str, Set[int]]?');
+ * ```
+ */
+function splitTopLevel(str, separator) {
+  const result = [];
+  let current = '';
+  let bracketDepth = 0;
+  for (let i = 0; i < str.length; i++) {
+    const char = str[i];
+    if (char === '[' && (str[i - 1] === undefined || /[a-zA-Z]/.test(str[i - 1]))) {
+      bracketDepth++;
+    } else if (char === ']') {
+      bracketDepth--;
+    } else if (char === separator && bracketDepth === 0) {
+      result.push(current.trim());
+      current = '';
+      continue;
+    }
+    current += char;
+  }
+  if (current.trim()) {
+    result.push(current.trim());
+  }
+  return result;
+}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/on_chain_blueprint.d.ts b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/on_chain_blueprint.d.ts
new file mode 100644
index 0000000..a16c51b
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/on_chain_blueprint.d.ts
@@ -0,0 +1,45 @@
+/// <reference types="node" />
+import Transaction from '../models/transaction';
+export declare enum CodeKind {
+    PYTHON_ZLIB = 1
+}
+export declare class Code {
+    kind: CodeKind;
+    content: Buffer;
+    constructor(kind: CodeKind, content: Buffer);
+    serialize(): Buffer;
+}
+/**
+ * The OnChainBlueprint class inherits the Transaction class, so it has all its attributes.
+ *
+ * We currently don't have support for creating an ocb object with inputs/outputs, so we receive as
+ * parameters in the constructor only the data related to the ocb class itself.
+ *
+ * The code and the public key that will be used as caller to sign the transaction (just like the nano contract class).
+ */
+declare class OnChainBlueprint extends Transaction {
+    code: Code;
+    pubkey: Buffer;
+    signature: Buffer | null;
+    constructor(code: Code, pubkey: Buffer, signature?: Buffer | null);
+    /**
+     * Serialize funds fields
+     * Add the serialized fields to the array parameter
+     *
+     * @param {array} Array of buffer to push the serialized fields
+     * @param {addInputData} If should add input data or signature when serializing it
+     *
+     * @memberof OnChainBlueprint
+     * @inner
+     */
+    serializeFundsFields(array: Buffer[], addInputData: boolean): void;
+    /**
+     * Serialize tx to bytes
+     *
+     * @memberof OnChainBlueprint
+     * @inner
+     */
+    toBytes(): Buffer;
+}
+export default OnChainBlueprint;
+//# sourceMappingURL=on_chain_blueprint.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/on_chain_blueprint.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/on_chain_blueprint.d.ts.map
new file mode 100644
index 0000000..c793938
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/on_chain_blueprint.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"on_chain_blueprint.d.ts","sourceRoot":"","sources":["../../src/nano_contracts/on_chain_blueprint.ts"],"names":[],"mappings":";AAWA,OAAO,WAAW,MAAM,uBAAuB,CAAC;AAGhD,oBAAY,QAAQ;IAClB,WAAW,IAAI;CAChB;AAED,qBAAa,IAAI;IACf,IAAI,EAAE,QAAQ,CAAC;IAEf,OAAO,EAAE,MAAM,CAAC;gBAEJ,IAAI,EAAE,QAAQ,EAAE,OAAO,EAAE,MAAM;IAK3C,SAAS,IAAI,MAAM;CAYpB;AAED;;;;;;;GAOG;AACH,cAAM,gBAAiB,SAAQ,WAAW;IAExC,IAAI,EAAE,IAAI,CAAC;IAEX,MAAM,EAAE,MAAM,CAAC;IAEf,SAAS,EAAE,MAAM,GAAG,IAAI,CAAC;gBAEb,IAAI,EAAE,IAAI,EAAE,MAAM,EAAE,MAAM,EAAE,SAAS,GAAE,MAAM,GAAG,IAAW;IASvE;;;;;;;;;OASG;IACH,oBAAoB,CAAC,KAAK,EAAE,MAAM,EAAE,EAAE,YAAY,EAAE,OAAO;IAuB3D;;;;;OAKG;IACH,OAAO,IAAI,MAAM;CAalB;AAED,eAAe,gBAAgB,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/on_chain_blueprint.js b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/on_chain_blueprint.js
new file mode 100644
index 0000000..56e9d91
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/on_chain_blueprint.js
@@ -0,0 +1,117 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = exports.CodeKind = exports.Code = void 0;
+var _zlib = _interopRequireDefault(require("zlib"));
+var _constants = require("../constants");
+var _transaction = _interopRequireDefault(require("../models/transaction"));
+var _buffer = require("../utils/buffer");
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
+function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
+function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /* eslint-disable max-classes-per-file */ /**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+let CodeKind = exports.CodeKind = /*#__PURE__*/function (CodeKind) {
+  CodeKind[CodeKind["PYTHON_ZLIB"] = 1] = "PYTHON_ZLIB";
+  return CodeKind;
+}({});
+class Code {
+  constructor(kind, content) {
+    _defineProperty(this, "kind", void 0);
+    _defineProperty(this, "content", void 0);
+    this.kind = kind;
+    this.content = content;
+  }
+  serialize() {
+    // Code serialization format: [kind:variable bytes][null byte][data:variable bytes]
+    const arr = [];
+    if (this.kind !== CodeKind.PYTHON_ZLIB) {
+      throw new Error('Invalid code kind value');
+    }
+    const zcode = _zlib.default.deflateSync(this.content);
+    arr.push((0, _buffer.intToBytes)(this.kind, 1));
+    arr.push(zcode);
+    return Buffer.concat(arr);
+  }
+}
+
+/**
+ * The OnChainBlueprint class inherits the Transaction class, so it has all its attributes.
+ *
+ * We currently don't have support for creating an ocb object with inputs/outputs, so we receive as
+ * parameters in the constructor only the data related to the ocb class itself.
+ *
+ * The code and the public key that will be used as caller to sign the transaction (just like the nano contract class).
+ */
+exports.Code = Code;
+class OnChainBlueprint extends _transaction.default {
+  constructor(code, pubkey, signature = null) {
+    super([], []);
+    // Code object with content
+    _defineProperty(this, "code", void 0);
+    _defineProperty(this, "pubkey", void 0);
+    _defineProperty(this, "signature", void 0);
+    this.version = _constants.ON_CHAIN_BLUEPRINTS_VERSION;
+    this.code = code;
+    this.pubkey = pubkey;
+    this.signature = signature;
+  }
+
+  /**
+   * Serialize funds fields
+   * Add the serialized fields to the array parameter
+   *
+   * @param {array} Array of buffer to push the serialized fields
+   * @param {addInputData} If should add input data or signature when serializing it
+   *
+   * @memberof OnChainBlueprint
+   * @inner
+   */
+  serializeFundsFields(array, addInputData) {
+    super.serializeFundsFields(array, addInputData);
+
+    // Info version
+    array.push((0, _buffer.intToBytes)(_constants.ON_CHAIN_BLUEPRINTS_INFO_VERSION, 1));
+
+    // Code
+    const serializedCode = this.code.serialize();
+    array.push((0, _buffer.intToBytes)(serializedCode.length, 4));
+    array.push(serializedCode);
+
+    // Pubkey and signature
+    array.push((0, _buffer.intToBytes)(this.pubkey.length, 1));
+    array.push(this.pubkey);
+    if (this.signature !== null && addInputData) {
+      array.push((0, _buffer.intToBytes)(this.signature.length, 1));
+      array.push(this.signature);
+    } else {
+      array.push((0, _buffer.intToBytes)(0, 1));
+    }
+  }
+
+  /**
+   * Serialize tx to bytes
+   *
+   * @memberof OnChainBlueprint
+   * @inner
+   */
+  toBytes() {
+    const arr = [];
+    // Serialize first the funds part
+    this.serializeFundsFields(arr, true);
+
+    // Graph fields
+    this.serializeGraphFields(arr);
+
+    // Nonce
+    this.serializeNonce(arr);
+    return Buffer.concat(arr);
+  }
+}
+var _default = exports.default = OnChainBlueprint;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/parser.d.ts b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/parser.d.ts
new file mode 100644
index 0000000..e488bf6
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/parser.d.ts
@@ -0,0 +1,27 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+import Address from '../models/address';
+import Network from '../models/network';
+import { IParsedArgument } from './types';
+declare class NanoContractTransactionParser {
+    blueprintId: string;
+    method: string;
+    network: Network;
+    address: Address;
+    args: string | null;
+    parsedArgs: IParsedArgument[] | null;
+    constructor(blueprintId: string, method: string, address: string, network: Network, args: string | null);
+    /**
+     * Parse the arguments in hex into a list of parsed arguments
+     *
+     * @memberof NanoContractTransactionParser
+     * @inner
+     */
+    parseArguments(): Promise<void>;
+}
+export default NanoContractTransactionParser;
+//# sourceMappingURL=parser.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/parser.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/parser.d.ts.map
new file mode 100644
index 0000000..06060f3
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/parser.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"parser.d.ts","sourceRoot":"","sources":["../../src/nano_contracts/parser.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;AAGH,OAAO,OAAO,MAAM,mBAAmB,CAAC;AACxC,OAAO,OAAO,MAAM,mBAAmB,CAAC;AAGxC,OAAO,EAAiB,eAAe,EAAE,MAAM,SAAS,CAAC;AAIzD,cAAM,6BAA6B;IACjC,WAAW,EAAE,MAAM,CAAC;IAEpB,MAAM,EAAE,MAAM,CAAC;IAEf,OAAO,EAAE,OAAO,CAAC;IAEjB,OAAO,EAAE,OAAO,CAAC;IAEjB,IAAI,EAAE,MAAM,GAAG,IAAI,CAAC;IAEpB,UAAU,EAAE,eAAe,EAAE,GAAG,IAAI,CAAC;gBAGnC,WAAW,EAAE,MAAM,EACnB,MAAM,EAAE,MAAM,EACd,OAAO,EAAE,MAAM,EACf,OAAO,EAAE,OAAO,EAChB,IAAI,EAAE,MAAM,GAAG,IAAI;IAUrB;;;;;OAKG;IACG,cAAc;CAuDrB;AAED,eAAe,6BAA6B,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/parser.js b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/parser.js
new file mode 100644
index 0000000..4720af5
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/parser.js
@@ -0,0 +1,94 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+var _lodash = require("lodash");
+var _address = _interopRequireDefault(require("../models/address"));
+var _nano = _interopRequireDefault(require("../api/nano"));
+var _errors = require("../errors");
+var _leb = _interopRequireDefault(require("../utils/leb128"));
+var _parser = require("./ncTypes/parser");
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
+function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
+function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+class NanoContractTransactionParser {
+  constructor(blueprintId, method, address, network, args) {
+    _defineProperty(this, "blueprintId", void 0);
+    _defineProperty(this, "method", void 0);
+    _defineProperty(this, "network", void 0);
+    _defineProperty(this, "address", void 0);
+    _defineProperty(this, "args", void 0);
+    _defineProperty(this, "parsedArgs", void 0);
+    this.blueprintId = blueprintId;
+    this.method = method;
+    this.args = args;
+    this.network = network;
+    this.address = new _address.default(address, {
+      network: this.network
+    });
+    this.parsedArgs = null;
+  }
+
+  /**
+   * Parse the arguments in hex into a list of parsed arguments
+   *
+   * @memberof NanoContractTransactionParser
+   * @inner
+   */
+  async parseArguments() {
+    const parsedArgs = [];
+    if (!this.args) {
+      return;
+    }
+
+    // Get the blueprint data from full node
+    const blueprintInformation = await _nano.default.getBlueprintInformation(this.blueprintId);
+    if (!(0, _lodash.has)(blueprintInformation, `public_methods.${this.method}`)) {
+      // If this.method is not in the blueprint information public methods, then there's an error
+      throw new _errors.NanoContractTransactionParseError('Failed to parse nano contract transaction. Method not found.');
+    }
+    const methodArgs = (0, _lodash.get)(blueprintInformation, `public_methods.${this.method}.args`, []);
+    let argsBuffer = Buffer.from(this.args, 'hex');
+
+    // Number of arguments
+    const numArgsReadResult = _leb.default.decodeUnsigned(argsBuffer);
+    const numArgs = Number(numArgsReadResult.value);
+    argsBuffer = numArgsReadResult.rest;
+    if (numArgs !== methodArgs.length) {
+      throw new _errors.NanoContractTransactionParseError(`Number of arguments do not match blueprint.`);
+    }
+    if (methodArgs.length === 0) {
+      return;
+    }
+    for (const arg of methodArgs) {
+      let parsed;
+      let size;
+      try {
+        const field = (0, _parser.getFieldParser)(arg.type, this.network);
+        const result = field.fromBuffer(argsBuffer);
+        parsed = {
+          ...arg,
+          value: field.toUser()
+        };
+        size = result.bytesRead;
+      } catch (err) {
+        throw new _errors.NanoContractTransactionParseError(`Failed to deserialize argument ${arg.type}.`);
+      }
+      parsedArgs.push(parsed);
+      argsBuffer = argsBuffer.subarray(size);
+    }
+    if (argsBuffer.length !== 0) {
+      throw new Error(`${argsBuffer.length} bytes left after parsing all arguments.`);
+    }
+    this.parsedArgs = parsedArgs;
+  }
+}
+var _default = exports.default = NanoContractTransactionParser;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/types.d.ts b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/types.d.ts
new file mode 100644
index 0000000..01f59c1
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/types.d.ts
@@ -0,0 +1,325 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+import { z } from 'zod';
+import { IHistoryTx, OutputValueType } from '../types';
+import { NCFieldBase } from './fields';
+export interface IArgumentField {
+    name: string;
+    type: string;
+    field: NCFieldBase;
+}
+export interface IParsedArgument {
+    name: string;
+    type: string;
+    value: unknown;
+}
+export declare enum NanoContractVertexType {
+    TRANSACTION = "transaction",
+    CREATE_TOKEN_TRANSACTION = "createTokenTransaction"
+}
+export declare enum NanoContractActionType {
+    DEPOSIT = "deposit",
+    WITHDRAWAL = "withdrawal",
+    GRANT_AUTHORITY = "grant_authority",
+    ACQUIRE_AUTHORITY = "acquire_authority"
+}
+export declare enum NanoContractHeaderActionType {
+    DEPOSIT = 1,
+    WITHDRAWAL = 2,
+    GRANT_AUTHORITY = 3,
+    ACQUIRE_AUTHORITY = 4
+}
+export declare const ActionTypeToActionHeaderType: Record<NanoContractActionType, NanoContractHeaderActionType>;
+export interface NanoContractActionHeader {
+    type: NanoContractHeaderActionType;
+    tokenIndex: number;
+    amount: OutputValueType;
+}
+export declare const INanoContractActionBase: z.ZodObject<{
+    token: z.ZodString;
+}, "strip", z.ZodTypeAny, {
+    token: string;
+}, {
+    token: string;
+}>;
+export declare const INanoContractActionTokenBase: z.ZodObject<z.objectUtil.extendShape<{
+    token: z.ZodString;
+}, {
+    amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+}>, "strip", z.ZodTypeAny, {
+    token: string;
+    amount: bigint;
+}, {
+    token: string;
+    amount: string | number | bigint;
+}>;
+export declare const INanoContractActionAuthorityBase: z.ZodObject<z.objectUtil.extendShape<{
+    token: z.ZodString;
+}, {
+    authority: z.ZodString;
+}>, "strip", z.ZodTypeAny, {
+    token: string;
+    authority: string;
+}, {
+    token: string;
+    authority: string;
+}>;
+export declare const INanoContractActionWithdrawalSchema: z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+    token: z.ZodString;
+}, {
+    amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+}>, {
+    type: z.ZodLiteral<"withdrawal">;
+    address: z.ZodString;
+}>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+    token: z.ZodString;
+}, {
+    amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+}>, {
+    type: z.ZodLiteral<"withdrawal">;
+    address: z.ZodString;
+}>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+    token: z.ZodString;
+}, {
+    amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+}>, {
+    type: z.ZodLiteral<"withdrawal">;
+    address: z.ZodString;
+}>, z.ZodTypeAny, "passthrough">>;
+export declare const INanoContractActionDepositSchema: z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+    token: z.ZodString;
+}, {
+    amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+}>, {
+    type: z.ZodLiteral<"deposit">;
+    address: z.ZodOptional<z.ZodString>;
+    changeAddress: z.ZodOptional<z.ZodString>;
+}>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+    token: z.ZodString;
+}, {
+    amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+}>, {
+    type: z.ZodLiteral<"deposit">;
+    address: z.ZodOptional<z.ZodString>;
+    changeAddress: z.ZodOptional<z.ZodString>;
+}>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+    token: z.ZodString;
+}, {
+    amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+}>, {
+    type: z.ZodLiteral<"deposit">;
+    address: z.ZodOptional<z.ZodString>;
+    changeAddress: z.ZodOptional<z.ZodString>;
+}>, z.ZodTypeAny, "passthrough">>;
+export declare const INanoContractActionGrantAuthoritySchema: z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+    token: z.ZodString;
+}, {
+    authority: z.ZodString;
+}>, {
+    type: z.ZodLiteral<"grant_authority">;
+    address: z.ZodOptional<z.ZodString>;
+    authorityAddress: z.ZodOptional<z.ZodString>;
+}>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+    token: z.ZodString;
+}, {
+    authority: z.ZodString;
+}>, {
+    type: z.ZodLiteral<"grant_authority">;
+    address: z.ZodOptional<z.ZodString>;
+    authorityAddress: z.ZodOptional<z.ZodString>;
+}>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+    token: z.ZodString;
+}, {
+    authority: z.ZodString;
+}>, {
+    type: z.ZodLiteral<"grant_authority">;
+    address: z.ZodOptional<z.ZodString>;
+    authorityAddress: z.ZodOptional<z.ZodString>;
+}>, z.ZodTypeAny, "passthrough">>;
+export declare const INanoContractActionAcquireAuthoritySchema: z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+    token: z.ZodString;
+}, {
+    authority: z.ZodString;
+}>, {
+    type: z.ZodLiteral<"acquire_authority">;
+    address: z.ZodString;
+}>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+    token: z.ZodString;
+}, {
+    authority: z.ZodString;
+}>, {
+    type: z.ZodLiteral<"acquire_authority">;
+    address: z.ZodString;
+}>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+    token: z.ZodString;
+}, {
+    authority: z.ZodString;
+}>, {
+    type: z.ZodLiteral<"acquire_authority">;
+    address: z.ZodString;
+}>, z.ZodTypeAny, "passthrough">>;
+export declare const INanoContractActionSchema: z.ZodDiscriminatedUnion<"type", [z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+    token: z.ZodString;
+}, {
+    amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+}>, {
+    type: z.ZodLiteral<"withdrawal">;
+    address: z.ZodString;
+}>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+    token: z.ZodString;
+}, {
+    amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+}>, {
+    type: z.ZodLiteral<"withdrawal">;
+    address: z.ZodString;
+}>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+    token: z.ZodString;
+}, {
+    amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+}>, {
+    type: z.ZodLiteral<"withdrawal">;
+    address: z.ZodString;
+}>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+    token: z.ZodString;
+}, {
+    amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+}>, {
+    type: z.ZodLiteral<"deposit">;
+    address: z.ZodOptional<z.ZodString>;
+    changeAddress: z.ZodOptional<z.ZodString>;
+}>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+    token: z.ZodString;
+}, {
+    amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+}>, {
+    type: z.ZodLiteral<"deposit">;
+    address: z.ZodOptional<z.ZodString>;
+    changeAddress: z.ZodOptional<z.ZodString>;
+}>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+    token: z.ZodString;
+}, {
+    amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+}>, {
+    type: z.ZodLiteral<"deposit">;
+    address: z.ZodOptional<z.ZodString>;
+    changeAddress: z.ZodOptional<z.ZodString>;
+}>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+    token: z.ZodString;
+}, {
+    authority: z.ZodString;
+}>, {
+    type: z.ZodLiteral<"grant_authority">;
+    address: z.ZodOptional<z.ZodString>;
+    authorityAddress: z.ZodOptional<z.ZodString>;
+}>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+    token: z.ZodString;
+}, {
+    authority: z.ZodString;
+}>, {
+    type: z.ZodLiteral<"grant_authority">;
+    address: z.ZodOptional<z.ZodString>;
+    authorityAddress: z.ZodOptional<z.ZodString>;
+}>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+    token: z.ZodString;
+}, {
+    authority: z.ZodString;
+}>, {
+    type: z.ZodLiteral<"grant_authority">;
+    address: z.ZodOptional<z.ZodString>;
+    authorityAddress: z.ZodOptional<z.ZodString>;
+}>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+    token: z.ZodString;
+}, {
+    authority: z.ZodString;
+}>, {
+    type: z.ZodLiteral<"acquire_authority">;
+    address: z.ZodString;
+}>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+    token: z.ZodString;
+}, {
+    authority: z.ZodString;
+}>, {
+    type: z.ZodLiteral<"acquire_authority">;
+    address: z.ZodString;
+}>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+    token: z.ZodString;
+}, {
+    authority: z.ZodString;
+}>, {
+    type: z.ZodLiteral<"acquire_authority">;
+    address: z.ZodString;
+}>, z.ZodTypeAny, "passthrough">>]>;
+export type NanoContractAction = z.output<typeof INanoContractActionSchema>;
+export interface MethodArgInfo {
+    name: string;
+    type: string;
+}
+interface MethodInfo {
+    args: MethodArgInfo[];
+    return_type?: string;
+}
+export interface NanoContractBlueprintInformationAPIResponse {
+    id: string;
+    name: string;
+    attributes: Map<string, string>;
+    public_methods: Map<string, MethodInfo>;
+    private_methods: Map<string, MethodInfo>;
+}
+export interface NanoContractHistoryAPIResponse {
+    success: boolean;
+    count: number;
+    after?: string;
+    history: IHistoryTx[];
+}
+interface StateValueSuccess {
+    value: unknown;
+}
+interface StateValueError {
+    errmsg: string;
+}
+export interface NanoContractStateAPIResponse {
+    success: boolean;
+    nc_id: string;
+    blueprint_name: string;
+    fields: Map<string, StateValueSuccess | StateValueError>;
+    balances: Map<string, StateValueSuccess | StateValueError>;
+    calls: Map<string, StateValueSuccess | StateValueError>;
+}
+export interface NanoContractStateAPIParameters {
+    id: string;
+    fields: string[];
+    balances: string[];
+    calls: string[];
+    block_hash?: string;
+    block_height?: number;
+}
+/**
+ * Buffer Read Only (RO) Extract value.
+ * For methods that read a value from a buffer without altering the input buffer (read-only).
+ * The method should return the value (T) extracted and the number of bytes read.
+ * This way the caller has full control of the buffer since the method does not alter the inputs.
+ */
+export type BufferROExtract<T = unknown> = {
+    value: T;
+    bytesRead: number;
+};
+export interface NanoContractBuilderCreateTokenOptions {
+    name: string;
+    symbol: string;
+    amount: OutputValueType;
+    mintAddress: string;
+    contractPaysTokenDeposit: boolean;
+    changeAddress: string | null;
+    createMint: boolean;
+    mintAuthorityAddress: string | null;
+    createMelt: boolean;
+    meltAuthorityAddress: string | null;
+    data: string[] | null;
+    isCreateNFT: boolean;
+}
+export {};
+//# sourceMappingURL=types.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/types.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/types.d.ts.map
new file mode 100644
index 0000000..4bd28fd
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/types.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"types.d.ts","sourceRoot":"","sources":["../../src/nano_contracts/types.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/types.js b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/types.js
new file mode 100644
index 0000000..5cf2ebb
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/types.js
@@ -0,0 +1,79 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.NanoContractVertexType = exports.NanoContractHeaderActionType = exports.NanoContractActionType = exports.INanoContractActionWithdrawalSchema = exports.INanoContractActionTokenBase = exports.INanoContractActionSchema = exports.INanoContractActionGrantAuthoritySchema = exports.INanoContractActionDepositSchema = exports.INanoContractActionBase = exports.INanoContractActionAuthorityBase = exports.INanoContractActionAcquireAuthoritySchema = exports.ActionTypeToActionHeaderType = void 0;
+var _zod = require("zod");
+var _bigint = require("../utils/bigint");
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+let NanoContractVertexType = exports.NanoContractVertexType = /*#__PURE__*/function (NanoContractVertexType) {
+  NanoContractVertexType["TRANSACTION"] = "transaction";
+  NanoContractVertexType["CREATE_TOKEN_TRANSACTION"] = "createTokenTransaction";
+  return NanoContractVertexType;
+}({});
+let NanoContractActionType = exports.NanoContractActionType = /*#__PURE__*/function (NanoContractActionType) {
+  NanoContractActionType["DEPOSIT"] = "deposit";
+  NanoContractActionType["WITHDRAWAL"] = "withdrawal";
+  NanoContractActionType["GRANT_AUTHORITY"] = "grant_authority";
+  NanoContractActionType["ACQUIRE_AUTHORITY"] = "acquire_authority";
+  return NanoContractActionType;
+}({});
+let NanoContractHeaderActionType = exports.NanoContractHeaderActionType = /*#__PURE__*/function (NanoContractHeaderActionType) {
+  NanoContractHeaderActionType[NanoContractHeaderActionType["DEPOSIT"] = 1] = "DEPOSIT";
+  NanoContractHeaderActionType[NanoContractHeaderActionType["WITHDRAWAL"] = 2] = "WITHDRAWAL";
+  NanoContractHeaderActionType[NanoContractHeaderActionType["GRANT_AUTHORITY"] = 3] = "GRANT_AUTHORITY";
+  NanoContractHeaderActionType[NanoContractHeaderActionType["ACQUIRE_AUTHORITY"] = 4] = "ACQUIRE_AUTHORITY";
+  return NanoContractHeaderActionType;
+}({});
+const ActionTypeToActionHeaderType = exports.ActionTypeToActionHeaderType = {
+  [NanoContractActionType.DEPOSIT]: NanoContractHeaderActionType.DEPOSIT,
+  [NanoContractActionType.WITHDRAWAL]: NanoContractHeaderActionType.WITHDRAWAL,
+  [NanoContractActionType.GRANT_AUTHORITY]: NanoContractHeaderActionType.GRANT_AUTHORITY,
+  [NanoContractActionType.ACQUIRE_AUTHORITY]: NanoContractHeaderActionType.ACQUIRE_AUTHORITY
+};
+
+// The action in the header is serialized/deserialized in the class
+// and it's used only to help calculate the token balance
+// That's why it's simple and with less fields
+
+const INanoContractActionBase = exports.INanoContractActionBase = _zod.z.object({
+  token: _zod.z.string()
+});
+const INanoContractActionTokenBase = exports.INanoContractActionTokenBase = INanoContractActionBase.extend({
+  amount: _bigint.bigIntCoercibleSchema
+});
+const INanoContractActionAuthorityBase = exports.INanoContractActionAuthorityBase = INanoContractActionBase.extend({
+  authority: _zod.z.string()
+});
+const INanoContractActionWithdrawalSchema = exports.INanoContractActionWithdrawalSchema = INanoContractActionTokenBase.extend({
+  type: _zod.z.literal('withdrawal'),
+  address: _zod.z.string()
+}).passthrough();
+const INanoContractActionDepositSchema = exports.INanoContractActionDepositSchema = INanoContractActionTokenBase.extend({
+  type: _zod.z.literal('deposit'),
+  address: _zod.z.string().optional(),
+  changeAddress: _zod.z.string().optional()
+}).passthrough();
+const INanoContractActionGrantAuthoritySchema = exports.INanoContractActionGrantAuthoritySchema = INanoContractActionAuthorityBase.extend({
+  type: _zod.z.literal('grant_authority'),
+  address: _zod.z.string().optional(),
+  authorityAddress: _zod.z.string().optional()
+}).passthrough();
+const INanoContractActionAcquireAuthoritySchema = exports.INanoContractActionAcquireAuthoritySchema = INanoContractActionAuthorityBase.extend({
+  type: _zod.z.literal('acquire_authority'),
+  address: _zod.z.string()
+}).passthrough();
+const INanoContractActionSchema = exports.INanoContractActionSchema = _zod.z.discriminatedUnion('type', [INanoContractActionWithdrawalSchema, INanoContractActionDepositSchema, INanoContractActionGrantAuthoritySchema, INanoContractActionAcquireAuthoritySchema]);
+
+/**
+ * Buffer Read Only (RO) Extract value.
+ * For methods that read a value from a buffer without altering the input buffer (read-only).
+ * The method should return the value (T) extracted and the number of bytes read.
+ * This way the caller has full control of the buffer since the method does not alter the inputs.
+ */
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/utils.d.ts b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/utils.d.ts
new file mode 100644
index 0000000..96bedd9
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/utils.d.ts
@@ -0,0 +1,85 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/// <reference types="node" />
+import SendTransaction from '../new/sendTransaction';
+import HathorWallet from '../new/wallet';
+import Network from '../models/network';
+import Transaction from '../models/transaction';
+import { IHistoryTx, IStorage } from '../types';
+import { NanoContractAction, NanoContractActionHeader, IArgumentField } from './types';
+/**
+ * Sign a transaction and create a send transaction object
+ *
+ * @param tx Transaction to sign and send
+ * @param pin Pin to decrypt data
+ * @param storage Wallet storage object
+ */
+export declare const prepareNanoSendTransaction: (tx: Transaction, pin: string, storage: IStorage) => Promise<SendTransaction>;
+/**
+ * Get oracle buffer from oracle string (address in base58 or oracle data directly in hex)
+ *
+ * @param oracle Address in base58 or oracle data directly in hex
+ * @param network Network to calculate the address
+ */
+export declare const getOracleBuffer: (oracle: string, network: Network) => Buffer;
+/**
+ * Get SignedData argument to use with a nano contract.
+ *
+ * @param oracleData Oracle data
+ * @param contractId Id of the nano contract being invoked
+ * @param argType Full method argument type string, e.g. 'SignedData[str]'
+ * @param value Value to sign
+ * @param wallet Hathor Wallet object
+ */
+export declare function getOracleSignedDataFromUser(oracleData: Buffer, contractId: string, argType: string, value: unknown, wallet: HathorWallet): Promise<import("./fields/signedData").IUserSignedData>;
+/**
+ * Get oracle input data
+ *
+ * @param oracleData Oracle data
+ * @param contractId Id of the nano contract being invoked
+ * @param resultSerialized Result to sign with oracle data already serialized
+ * @param wallet Hathor Wallet object
+ */
+export declare const getOracleInputData: (oracleData: Buffer, contractId: string, resultSerialized: Buffer, wallet: HathorWallet) => Promise<Buffer>;
+/**
+ * [unsafe] Get oracle input data, signs received data raw.
+ * This is meant to be used for RawSignedData
+ *
+ * @param oracleData Oracle data
+ * @param resultSerialized Result to sign with oracle data already serialized
+ * @param wallet Hathor Wallet object
+ */
+export declare const unsafeGetOracleInputData: (oracleData: Buffer, resultSerialized: Buffer, wallet: HathorWallet) => Promise<Buffer>;
+/**
+ * Validate if nano contracts arguments match the expected ones from the blueprint method
+ * It also converts arguments that come from clients in a different type than the expected,
+ * e.g., bytes come as hexadecimal strings and address (bytes) come as base58 string.
+ * We convert them to the expected type and update the original array of arguments
+ *
+ * @param blueprintId Blueprint ID
+ * @param method Method name
+ * @param args Arguments of the method to check if have the expected types
+ *
+ * @throws NanoRequest404Error in case the blueprint ID does not exist on the full node
+ */
+export declare const validateAndParseBlueprintMethodArgs: (blueprintId: string, method: string, args: unknown[] | null, network: Network) => Promise<IArgumentField[]>;
+/**
+ * Checks if a transaction is a nano contract create transaction
+ *
+ * @param tx History object from hathor core to check if it's a nano create tx
+ */
+export declare const isNanoContractCreateTx: (tx: IHistoryTx) => boolean;
+/**
+ * Map a NanoContractAction object to NanoContractActionHeader
+ *
+ * @param action The action object to be mapped
+ * @param tokens The tokens array to be used in the mapping
+ *
+ * @return The mapped action header object
+ */
+export declare const mapActionToActionHeader: (action: NanoContractAction, tokens: string[]) => NanoContractActionHeader;
+//# sourceMappingURL=utils.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/utils.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/utils.d.ts.map
new file mode 100644
index 0000000..d1f3bcc
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/utils.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"utils.d.ts","sourceRoot":"","sources":["../../src/nano_contracts/utils.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;;AAOH,OAAO,eAAe,MAAM,wBAAwB,CAAC;AACrD,OAAO,YAAY,MAAM,eAAe,CAAC;AACzC,OAAO,OAAO,MAAM,mBAAmB,CAAC;AAOxC,OAAO,WAAW,MAAM,uBAAuB,CAAC;AAGhD,OAAO,EAAE,UAAU,EAAE,QAAQ,EAA+B,MAAM,UAAU,CAAC;AAE7E,OAAO,EAGL,kBAAkB,EAClB,wBAAwB,EAExB,cAAc,EACf,MAAM,SAAS,CAAC;AAKjB;;;;;;GAMG;AACH,eAAO,MAAM,0BAA0B,OACjC,WAAW,OACV,MAAM,WACF,QAAQ,KAChB,QAAQ,eAAe,CAUzB,CAAC;AAEF;;;;;GAKG;AACH,eAAO,MAAM,eAAe,WAAY,MAAM,WAAW,OAAO,KAAG,MAyBlE,CAAC;AAEF;;;;;;;;GAQG;AACH,wBAAsB,2BAA2B,CAC/C,UAAU,EAAE,MAAM,EAClB,UAAU,EAAE,MAAM,EAClB,OAAO,EAAE,MAAM,EACf,KAAK,EAAE,OAAO,EACd,MAAM,EAAE,YAAY,0DAmBrB;AAED;;;;;;;GAOG;AACH,eAAO,MAAM,kBAAkB,eACjB,MAAM,cACN,MAAM,oBACA,MAAM,0CAMzB,CAAC;AAEF;;;;;;;GAOG;AACH,eAAO,MAAM,wBAAwB,eACvB,MAAM,oBACA,MAAM,2BAEvB,QAAQ,MAAM,CAyBhB,CAAC;AAEF;;;;;;;;;;;GAWG;AACH,eAAO,MAAM,mCAAmC,gBACjC,MAAM,UACX,MAAM,QACR,OAAO,EAAE,GAAG,IAAI,WACb,OAAO,KACf,QAAQ,cAAc,EAAE,CAyC1B,CAAC;AAEF;;;;GAIG;AACH,eAAO,MAAM,sBAAsB,OAAQ,UAAU,KAAG,OAEvD,CAAC;AAEF;;;;;;;GAOG;AACH,eAAO,MAAM,uBAAuB,WAC1B,kBAAkB,UAClB,MAAM,EAAE,KACf,wBA+BF,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/utils.js b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/utils.js
new file mode 100644
index 0000000..cb92ba4
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/nano_contracts/utils.js
@@ -0,0 +1,255 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.getOracleInputData = exports.getOracleBuffer = void 0;
+exports.getOracleSignedDataFromUser = getOracleSignedDataFromUser;
+exports.validateAndParseBlueprintMethodArgs = exports.unsafeGetOracleInputData = exports.prepareNanoSendTransaction = exports.mapActionToActionHeader = exports.isNanoContractCreateTx = void 0;
+var _lodash = require("lodash");
+var _bitcoreLib = require("bitcore-lib");
+var _zod = require("zod");
+var _transaction = _interopRequireDefault(require("../utils/transaction"));
+var _tokens = _interopRequireDefault(require("../utils/tokens"));
+var _sendTransaction = _interopRequireDefault(require("../new/sendTransaction"));
+var _script_data = _interopRequireDefault(require("../models/script_data"));
+var _nano = _interopRequireDefault(require("../api/nano"));
+var _buffer = require("../utils/buffer");
+var _p2pkh = _interopRequireDefault(require("../models/p2pkh"));
+var _p2sh = _interopRequireDefault(require("../models/p2sh"));
+var _address = _interopRequireDefault(require("../models/address"));
+var _errors = require("../errors");
+var _types = require("../wallet/types");
+var _scripts = require("../utils/scripts");
+var _types2 = require("./types");
+var _constants = require("../constants");
+var _parser = require("./ncTypes/parser");
+var _fields = require("./fields");
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+/**
+ * Sign a transaction and create a send transaction object
+ *
+ * @param tx Transaction to sign and send
+ * @param pin Pin to decrypt data
+ * @param storage Wallet storage object
+ */
+const prepareNanoSendTransaction = async (tx, pin, storage) => {
+  await _transaction.default.signTransaction(tx, storage, pin);
+  tx.prepareToSend();
+
+  // Create and return a send transaction object
+  return new _sendTransaction.default({
+    storage,
+    transaction: tx,
+    pin
+  });
+};
+
+/**
+ * Get oracle buffer from oracle string (address in base58 or oracle data directly in hex)
+ *
+ * @param oracle Address in base58 or oracle data directly in hex
+ * @param network Network to calculate the address
+ */
+exports.prepareNanoSendTransaction = prepareNanoSendTransaction;
+const getOracleBuffer = (oracle, network) => {
+  const address = new _address.default(oracle, {
+    network
+  });
+  // First check if the oracle is a base58 address
+  // In case of success, set the output script as oracle
+  // Otherwise, it's a custom script in hexadecimal
+  if (address.isValid()) {
+    const outputScriptType = address.getType();
+    let outputScript;
+    if (outputScriptType === _types.OutputType.P2PKH) {
+      outputScript = new _p2pkh.default(address);
+    } else if (outputScriptType === _types.OutputType.P2SH) {
+      outputScript = new _p2sh.default(address);
+    } else {
+      throw new _errors.OracleParseError('Invalid output script type.');
+    }
+    return outputScript.createScript();
+  }
+
+  // Oracle script is a custom script
+  try {
+    return (0, _buffer.hexToBuffer)(oracle);
+  } catch (err) {
+    // Invalid hex
+    throw new _errors.OracleParseError('Invalid hex value for oracle script.');
+  }
+};
+
+/**
+ * Get SignedData argument to use with a nano contract.
+ *
+ * @param oracleData Oracle data
+ * @param contractId Id of the nano contract being invoked
+ * @param argType Full method argument type string, e.g. 'SignedData[str]'
+ * @param value Value to sign
+ * @param wallet Hathor Wallet object
+ */
+exports.getOracleBuffer = getOracleBuffer;
+async function getOracleSignedDataFromUser(oracleData, contractId, argType, value, wallet) {
+  const field = (0, _parser.getFieldParser)(argType, wallet.getNetworkObject());
+  if (!(0, _fields.isSignedDataField)(field)) {
+    throw new Error('Type is not SignedData');
+  }
+  // Read user value.
+  field.inner.fromUser(value);
+  // Serialize user value
+  const serialized = field.inner.toBuffer();
+  // Sign user value
+  const signature = await getOracleInputData(oracleData, contractId, serialized, wallet);
+  field.fromUser({
+    type: field.value.type,
+    // Type is pre-filled during parser contruction
+    signature: signature.toString('hex'),
+    value
+  });
+  return field.toUser();
+}
+
+/**
+ * Get oracle input data
+ *
+ * @param oracleData Oracle data
+ * @param contractId Id of the nano contract being invoked
+ * @param resultSerialized Result to sign with oracle data already serialized
+ * @param wallet Hathor Wallet object
+ */
+const getOracleInputData = async (oracleData, contractId, resultSerialized, wallet) => {
+  const ncId = Buffer.from(contractId, 'hex');
+  const actualValue = Buffer.concat([ncId, resultSerialized]);
+  return unsafeGetOracleInputData(oracleData, actualValue, wallet);
+};
+
+/**
+ * [unsafe] Get oracle input data, signs received data raw.
+ * This is meant to be used for RawSignedData
+ *
+ * @param oracleData Oracle data
+ * @param resultSerialized Result to sign with oracle data already serialized
+ * @param wallet Hathor Wallet object
+ */
+exports.getOracleInputData = getOracleInputData;
+const unsafeGetOracleInputData = async (oracleData, resultSerialized, wallet) => {
+  // Parse oracle script to validate if it's an address of this wallet
+  const parsedOracleScript = (0, _scripts.parseScript)(oracleData, wallet.getNetworkObject());
+  if (parsedOracleScript && !(parsedOracleScript instanceof _script_data.default)) {
+    if (await wallet.storage.isReadonly()) {
+      throw new _errors.WalletFromXPubGuard('getOracleInputData');
+    }
+
+    // This is only when the oracle is an address, otherwise we will have the signed input data
+    const address = parsedOracleScript.address.base58;
+    if (!wallet.isAddressMine(address)) {
+      throw new _errors.OracleParseError('Oracle address is not from the loaded wallet.');
+    }
+    const oracleKey = await wallet.getPrivateKeyFromAddress(address);
+    const signatureOracle = _transaction.default.getSignature(_bitcoreLib.crypto.Hash.sha256(resultSerialized), oracleKey);
+    const oraclePubKeyBuffer = oracleKey.publicKey.toBuffer();
+    return _transaction.default.createInputData(signatureOracle, oraclePubKeyBuffer);
+  }
+
+  // If it's not an address, we use the oracleInputData as the inputData directly
+  return oracleData;
+};
+
+/**
+ * Validate if nano contracts arguments match the expected ones from the blueprint method
+ * It also converts arguments that come from clients in a different type than the expected,
+ * e.g., bytes come as hexadecimal strings and address (bytes) come as base58 string.
+ * We convert them to the expected type and update the original array of arguments
+ *
+ * @param blueprintId Blueprint ID
+ * @param method Method name
+ * @param args Arguments of the method to check if have the expected types
+ *
+ * @throws NanoRequest404Error in case the blueprint ID does not exist on the full node
+ */
+exports.unsafeGetOracleInputData = unsafeGetOracleInputData;
+const validateAndParseBlueprintMethodArgs = async (blueprintId, method, args, network) => {
+  // Get the blueprint data from full node
+  const blueprintInformation = await _nano.default.getBlueprintInformation(blueprintId);
+  const methodArgs = (0, _lodash.get)(blueprintInformation, `public_methods.${method}.args`, []);
+  if (!methodArgs) {
+    throw new _errors.NanoContractTransactionError(`Blueprint does not have method ${method}.`);
+  }
+  if (args == null) {
+    throw new _errors.NanoContractTransactionError(`No arguments were received.`);
+  }
+  const argsLen = args.length;
+  if (argsLen !== methodArgs.length) {
+    throw new _errors.NanoContractTransactionError(`Method needs ${methodArgs.length} parameters but data has ${args.length}.`);
+  }
+  try {
+    const parsedArgs = [];
+    for (const [index, arg] of methodArgs.entries()) {
+      const field = (0, _parser.getFieldParser)(arg.type, network);
+      field.fromUser(args[index]);
+      parsedArgs.push({
+        ...arg,
+        field
+      });
+    }
+    return parsedArgs;
+  } catch (err) {
+    if (err instanceof _zod.z.ZodError || err instanceof Error) {
+      throw new _errors.NanoContractTransactionError(err.message);
+    }
+    throw err;
+  }
+};
+
+/**
+ * Checks if a transaction is a nano contract create transaction
+ *
+ * @param tx History object from hathor core to check if it's a nano create tx
+ */
+exports.validateAndParseBlueprintMethodArgs = validateAndParseBlueprintMethodArgs;
+const isNanoContractCreateTx = tx => {
+  return tx.nc_method === _constants.NANO_CONTRACTS_INITIALIZE_METHOD;
+};
+
+/**
+ * Map a NanoContractAction object to NanoContractActionHeader
+ *
+ * @param action The action object to be mapped
+ * @param tokens The tokens array to be used in the mapping
+ *
+ * @return The mapped action header object
+ */
+exports.isNanoContractCreateTx = isNanoContractCreateTx;
+const mapActionToActionHeader = (action, tokens) => {
+  const headerActionType = _types2.ActionTypeToActionHeaderType[action.type];
+  const mappedTokens = tokens.map(token => {
+    return {
+      uid: token,
+      name: '',
+      symbol: ''
+    };
+  });
+  let amount;
+  if (action.type === _types2.NanoContractActionType.GRANT_AUTHORITY || action.type === _types2.NanoContractActionType.ACQUIRE_AUTHORITY) {
+    amount = action.authority === 'mint' ? _constants.TOKEN_MINT_MASK : _constants.TOKEN_MELT_MASK;
+  } else if (action.type === _types2.NanoContractActionType.DEPOSIT || action.type === _types2.NanoContractActionType.WITHDRAWAL) {
+    amount = action.amount;
+  } else {
+    throw new Error('Invalid nano contract action type');
+  }
+  return {
+    type: headerActionType,
+    amount,
+    tokenIndex: _tokens.default.getTokenIndex(mappedTokens, action.token)
+  };
+};
+exports.mapActionToActionHeader = mapActionToActionHeader;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/network.d.ts b/node_modules/@hathor/wallet-lib/oldLib/network.d.ts
new file mode 100644
index 0000000..c819baf
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/network.d.ts
@@ -0,0 +1,16 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+import Network from './models/network';
+/**
+ * Extend the network to be able to set config when setNetwork is called on the singleton
+ */
+declare class ExtendedNetwork extends Network {
+    setNetwork(name: any, skipConfig?: boolean): void;
+}
+declare const instance: ExtendedNetwork;
+export default instance;
+//# sourceMappingURL=network.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/network.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/network.d.ts.map
new file mode 100644
index 0000000..fd2b54f
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/network.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"network.d.ts","sourceRoot":"","sources":["../src/network.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;AAGH,OAAO,OAAO,MAAM,kBAAkB,CAAC;AAEvC;;GAEG;AACH,cAAM,eAAgB,SAAQ,OAAO;IAUnC,UAAU,CAAC,IAAI,KAAA,EAAE,UAAU,UAAQ;CAOpC;AAGD,QAAA,MAAM,QAAQ,iBAAiC,CAAC;AAEhD,eAAe,QAAQ,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/network.js b/node_modules/@hathor/wallet-lib/oldLib/network.js
new file mode 100644
index 0000000..bc2b842
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/network.js
@@ -0,0 +1,40 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+var _config = _interopRequireDefault(require("./config"));
+var _network = _interopRequireDefault(require("./models/network"));
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+/**
+ * Extend the network to be able to set config when setNetwork is called on the singleton
+ */
+class ExtendedNetwork extends _network.default {
+  /* Until we replace the network singleton with the new config singleton, we need to
+   * maintain reverse compatibility as there are multiple use cases using the lib with
+   * this network singleton
+   *
+   * Since config.setNetwork also calls networkInstance.setNetwork, we need the skipConfig
+   * parameter to avoid a cyclic call
+   *
+   * TODO: Remove this when the network singleton is completely deprecated
+   */
+  setNetwork(name, skipConfig = false) {
+    super.setNetwork(name);
+    if (!skipConfig) {
+      _config.default.setNetwork(name);
+    }
+  }
+}
+
+// Default network for the lib is testnet
+const instance = new ExtendedNetwork('testnet');
+var _default = exports.default = instance;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/new/connection.d.ts b/node_modules/@hathor/wallet-lib/oldLib/new/connection.d.ts
new file mode 100644
index 0000000..1f2ffd9
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/new/connection.d.ts
@@ -0,0 +1,79 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+import BaseConnection, { ConnectionParams } from '../connection';
+import { IStorage } from '../types';
+type FullnodeCapability = 'history-streaming';
+/**
+ * Stream abort controller that carries the streamId it is managing.
+ */
+declare class StreamController extends AbortController {
+    streamId: string;
+    constructor(streamId: string);
+}
+/**
+ * This is a Connection that may be shared by one or more wallets.
+ *
+ * It has the following states:
+ * - CLOSED: When it is disconnected from the server.
+ * - CONNECTING: When it is connecting to the server.
+ * - CONNECTED: When it is connected.
+ *
+ * You can subscribe for the following events:
+ * - state: Fired when the state of the Wallet changes.
+ * - wallet-update: Fired when a new wallet message arrive from the websocket.
+ * */
+declare class WalletConnection extends BaseConnection {
+    static CLOSED: number;
+    static CONNECTING: number;
+    static CONNECTED: number;
+    streamController: StreamController | null;
+    streamWindowSize: number | undefined;
+    capabilities?: FullnodeCapability[];
+    constructor(options: ConnectionParams & {
+        streamWindowSize?: number;
+    });
+    /**
+     * Connect to the server and start emitting events.
+     * */
+    start(): void;
+    /**
+     * Handle the capabilities event from the websocket.
+     */
+    handleCapabilities(data: {
+        type: string;
+        capabilities: FullnodeCapability[];
+    }): void;
+    /**
+     * If the fullnode has not sent the capabilities yet wait a while.
+     */
+    waitCapabilities(): Promise<void>;
+    /**
+     * Check if the connected fullnode has the desired capability.
+     * Will return false if the fullnode has not yet sent the capability list.
+     */
+    hasCapability(flag: FullnodeCapability): Promise<boolean>;
+    startControlHandlers(storage: IStorage): void;
+    subscribeAddresses(addresses: string[]): void;
+    unsubscribeAddress(address: string): void;
+    addMetricsHandlers(storage: IStorage): void;
+    streamEndHandler(): void;
+    lockStream(streamId: string): boolean;
+    sendStartXPubStreamingHistory(id: string, firstIndex: number, xpubkey: string, gapLimit?: number): void;
+    sendManualStreamingHistory(id: string, firstIndex: number, addresses: [number, string][], first: boolean, gapLimit?: number): void;
+    /**
+     * Send an ACK message to the fullnode to confirm we received all events up to
+     * the event of sequence number `ack`.
+     */
+    sendStreamHistoryAck(id: string, ack: number): void;
+    stopStream(): Promise<void>;
+    /**
+     * Handle cleanup in cases of wallet reloads.
+     */
+    onReload(): Promise<void>;
+}
+export default WalletConnection;
+//# sourceMappingURL=connection.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/new/connection.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/new/connection.d.ts.map
new file mode 100644
index 0000000..871854e
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/new/connection.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"connection.d.ts","sourceRoot":"","sources":["../../src/new/connection.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;AAKH,OAAO,cAAc,EAAE,EAAE,gBAAgB,EAAE,MAAM,eAAe,CAAC;AAGjE,OAAO,EAAE,QAAQ,EAA6B,MAAM,UAAU,CAAC;AAe/D,KAAK,kBAAkB,GAAG,mBAAmB,CAAC;AAE9C;;GAEG;AACH,cAAM,gBAAiB,SAAQ,eAAe;IAC5C,QAAQ,EAAE,MAAM,CAAC;gBAEL,QAAQ,EAAE,MAAM;CAI7B;AAED;;;;;;;;;;;KAWK;AACL,cAAM,gBAAiB,SAAQ,cAAc;IAC3C,MAAM,CAAC,MAAM,EAAE,MAAM,CAAK;IAE1B,MAAM,CAAC,UAAU,EAAE,MAAM,CAAK;IAE9B,MAAM,CAAC,SAAS,EAAE,MAAM,CAAK;IAE7B,gBAAgB,EAAE,gBAAgB,GAAG,IAAI,CAAQ;IAEjD,gBAAgB,EAAE,MAAM,GAAG,SAAS,CAAC;IAErC,YAAY,CAAC,EAAE,kBAAkB,EAAE,CAAC;gBAExB,OAAO,EAAE,gBAAgB,GAAG;QAAE,gBAAgB,CAAC,EAAE,MAAM,CAAA;KAAE;IAwBrE;;SAEK;IACL,KAAK;IAuBL;;OAEG;IACH,kBAAkB,CAAC,IAAI,EAAE;QAAE,IAAI,EAAE,MAAM,CAAC;QAAC,YAAY,EAAE,kBAAkB,EAAE,CAAA;KAAE;IAS7E;;OAEG;IACG,gBAAgB;IAStB;;;OAGG;IACG,aAAa,CAAC,IAAI,EAAE,kBAAkB;IAQ5C,oBAAoB,CAAC,OAAO,EAAE,QAAQ;IAKtC,kBAAkB,CAAC,SAAS,EAAE,MAAM,EAAE;IAStC,kBAAkB,CAAC,OAAO,EAAE,MAAM;IAOlC,kBAAkB,CAAC,OAAO,EAAE,QAAQ;IAOpC,gBAAgB;IAKhB,UAAU,CAAC,QAAQ,EAAE,MAAM,GAAG,OAAO;IAQrC,6BAA6B,CAC3B,EAAE,EAAE,MAAM,EACV,UAAU,EAAE,MAAM,EAClB,OAAO,EAAE,MAAM,EACf,QAAQ,GAAE,MAAW;IAsBvB,0BAA0B,CACxB,EAAE,EAAE,MAAM,EACV,UAAU,EAAE,MAAM,EAClB,SAAS,EAAE,CAAC,MAAM,EAAE,MAAM,CAAC,EAAE,EAC7B,KAAK,EAAE,OAAO,EACd,QAAQ,GAAE,MAAW;IAuBvB;;;OAGG;IACH,oBAAoB,CAAC,EAAE,EAAE,MAAM,EAAE,GAAG,EAAE,MAAM;IAYtC,UAAU;IAwBhB;;OAEG;IACG,QAAQ;CAGf;AAED,eAAe,gBAAgB,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/new/connection.js b/node_modules/@hathor/wallet-lib/oldLib/new/connection.js
new file mode 100644
index 0000000..c047c6f
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/new/connection.js
@@ -0,0 +1,268 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+var _websocket = _interopRequireDefault(require("../websocket"));
+var _helpers = _interopRequireDefault(require("../utils/helpers"));
+var _connection = _interopRequireDefault(require("../connection"));
+var _types = require("../wallet/types");
+var _connection2 = require("../utils/connection");
+var _types2 = require("../types");
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
+function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
+function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */ /* eslint max-classes-per-file: ["error", 2] */
+const STREAM_ABORT_TIMEOUT = 10000; // 10s
+const CAPABILITIES_WAIT_TIMEOUT = 2000; // 2s
+
+/**
+ * Event names for requesting stream from fullnode
+ */
+var StreamRequestEvent = /*#__PURE__*/function (StreamRequestEvent) {
+  StreamRequestEvent["REQUEST_HISTORY_XPUB"] = "request:history:xpub";
+  StreamRequestEvent["REQUEST_HISTORY_MANUAL"] = "request:history:manual";
+  return StreamRequestEvent;
+}(StreamRequestEvent || {});
+const STREAM_HISTORY_ACK_EVENT = 'request:history:ack';
+/**
+ * Stream abort controller that carries the streamId it is managing.
+ */
+class StreamController extends AbortController {
+  constructor(streamId) {
+    super();
+    _defineProperty(this, "streamId", void 0);
+    this.streamId = streamId;
+  }
+}
+
+/**
+ * This is a Connection that may be shared by one or more wallets.
+ *
+ * It has the following states:
+ * - CLOSED: When it is disconnected from the server.
+ * - CONNECTING: When it is connecting to the server.
+ * - CONNECTED: When it is connected.
+ *
+ * You can subscribe for the following events:
+ * - state: Fired when the state of the Wallet changes.
+ * - wallet-update: Fired when a new wallet message arrive from the websocket.
+ * */
+class WalletConnection extends _connection.default {
+  constructor(options) {
+    super(options);
+    _defineProperty(this, "streamController", null);
+    _defineProperty(this, "streamWindowSize", void 0);
+    _defineProperty(this, "capabilities", void 0);
+    this.handleWalletMessage = this.handleWalletMessage.bind(this);
+    this.on('stream-end', this.streamEndHandler.bind(this));
+    const wsOptions = {
+      wsURL: _helpers.default.getWSServerURL(this.currentServer),
+      logger: options.logger || (0, _types2.getDefaultLogger)()
+    };
+    if (options.connectionTimeout) {
+      wsOptions.connectionTimeout = options.connectionTimeout;
+    }
+    this.streamWindowSize = options.streamWindowSize;
+    this.websocket = new _websocket.default(wsOptions);
+  }
+
+  /**
+   * Connect to the server and start emitting events.
+   * */
+  start() {
+    // This should never happen as the websocket is initialized on the constructor
+    if (!this.websocket) {
+      throw new Error('Websocket is not initialized');
+    }
+    this.websocket.on('is_online', this.onConnectionChange);
+    this.websocket.on('wallet', this.handleWalletMessage.bind(this));
+    this.websocket.on('stream', this.handleStreamMessage.bind(this));
+    this.websocket.on('capabilities', this.handleCapabilities.bind(this));
+    this.websocket.on('height_updated', height => {
+      this.emit('best-block-update', height);
+    });
+    this.websocket.on('addresses_loaded', data => {
+      this.emit('wallet-load-partial-update', data);
+    });
+    this.setState(_types.ConnectionState.CONNECTING);
+    this.websocket.setup();
+  }
+
+  /**
+   * Handle the capabilities event from the websocket.
+   */
+  handleCapabilities(data) {
+    this.logger.debug(`Fullnode has capabilities: ${JSON.stringify(data.capabilities)}`);
+    const {
+      capabilities
+    } = data;
+    if (!capabilities) {
+      return;
+    }
+    this.capabilities = capabilities;
+  }
+
+  /**
+   * If the fullnode has not sent the capabilities yet wait a while.
+   */
+  async waitCapabilities() {
+    if (this.capabilities === undefined) {
+      // Wait 2s so the fullnode has some time to send the capabilities envent
+      await new Promise(resolve => {
+        setTimeout(resolve, CAPABILITIES_WAIT_TIMEOUT);
+      });
+    }
+  }
+
+  /**
+   * Check if the connected fullnode has the desired capability.
+   * Will return false if the fullnode has not yet sent the capability list.
+   */
+  async hasCapability(flag) {
+    await this.waitCapabilities();
+    if (!this.capabilities) {
+      return false;
+    }
+    return this.capabilities?.includes(flag) || false;
+  }
+  startControlHandlers(storage) {
+    this.removeMetricsHandlers();
+    this.addMetricsHandlers(storage);
+  }
+  subscribeAddresses(addresses) {
+    if (this.websocket) {
+      for (const address of addresses) {
+        const msg = JSON.stringify({
+          type: 'subscribe_address',
+          address
+        });
+        this.websocket.sendMessage(msg);
+      }
+    }
+  }
+  unsubscribeAddress(address) {
+    if (this.websocket) {
+      const msg = JSON.stringify({
+        type: 'unsubscribe_address',
+        address
+      });
+      this.websocket.sendMessage(msg);
+    }
+  }
+  addMetricsHandlers(storage) {
+    if (this.websocket) {
+      this.websocket.on('dashboard', (0, _connection2.handleWsDashboard)(storage));
+      this.websocket.on('subscribe_address', (0, _connection2.handleSubscribeAddress)());
+    }
+  }
+  streamEndHandler() {
+    this.streamController?.abort();
+    this.streamController = null;
+  }
+  lockStream(streamId) {
+    if (this.streamController === null) {
+      this.streamController = new StreamController(streamId);
+      return true;
+    }
+    return false;
+  }
+  sendStartXPubStreamingHistory(id, firstIndex, xpubkey, gapLimit = -1) {
+    if (this.streamController?.streamId !== id) {
+      throw new Error('There is an on-going stream, cannot start a second one');
+    }
+    if (!this.websocket) {
+      throw new Error('No websocket connection to send message.');
+    }
+    const data = {
+      id,
+      xpub: xpubkey,
+      type: StreamRequestEvent.REQUEST_HISTORY_XPUB,
+      'first-index': firstIndex,
+      'gap-limit': gapLimit
+    };
+    if (this.streamWindowSize) {
+      data['window-size'] = this.streamWindowSize;
+    }
+    this.websocket.sendMessage(JSON.stringify(data));
+  }
+  sendManualStreamingHistory(id, firstIndex, addresses, first, gapLimit = -1) {
+    if (this.streamController?.streamId !== id) {
+      throw new Error('There is an on-going stream, cannot start a second one');
+    }
+    if (!this.websocket) {
+      throw new Error('No websocket connection to send message.');
+    }
+    const data = {
+      id,
+      first,
+      addresses,
+      type: StreamRequestEvent.REQUEST_HISTORY_MANUAL,
+      'first-index': firstIndex,
+      'gap-limit': gapLimit
+    };
+    if (this.streamWindowSize) {
+      data['window-size'] = this.streamWindowSize;
+    }
+    this.websocket.sendMessage(JSON.stringify(data));
+  }
+
+  /**
+   * Send an ACK message to the fullnode to confirm we received all events up to
+   * the event of sequence number `ack`.
+   */
+  sendStreamHistoryAck(id, ack) {
+    if (this.streamController?.streamId !== id) {
+      throw new Error('There is an on-going stream, cannot start a second one');
+    }
+    if (!this.websocket) {
+      throw new Error('No websocket connection to send message.');
+    }
+    const data = JSON.stringify({
+      id,
+      ack,
+      type: STREAM_HISTORY_ACK_EVENT
+    });
+    this.websocket.sendMessage(data);
+  }
+  async stopStream() {
+    await new Promise((resolve, reject) => {
+      if (this.streamController === null) {
+        // There is no active stream.
+        resolve();
+        return;
+      }
+      // Create a timeout so we do not wait indefinetely
+      // If it reaches here we should reject since something went wrong.
+      const timer = setTimeout(() => {
+        reject();
+      }, STREAM_ABORT_TIMEOUT);
+
+      // We have an active stream.
+      // We will wait for the stream to end then resolve.
+      this.once('stream-end', () => {
+        clearTimeout(timer);
+        resolve();
+      });
+      // Send the abort signal
+      this.streamController.abort();
+    });
+  }
+
+  /**
+   * Handle cleanup in cases of wallet reloads.
+   */
+  async onReload() {
+    await this.stopStream();
+  }
+}
+_defineProperty(WalletConnection, "CLOSED", 0);
+_defineProperty(WalletConnection, "CONNECTING", 1);
+_defineProperty(WalletConnection, "CONNECTED", 2);
+var _default = exports.default = WalletConnection;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/new/sendTransaction.d.ts b/node_modules/@hathor/wallet-lib/oldLib/new/sendTransaction.d.ts
new file mode 100644
index 0000000..d52e931
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/new/sendTransaction.d.ts
@@ -0,0 +1,205 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/// <reference types="node" />
+/// <reference types="node" />
+import EventEmitter from 'events';
+import MineTransaction from '../wallet/mineTransaction';
+import { OutputType } from '../wallet/types';
+import { IStorage, IDataTx, IDataInput, IUtxoSelectionOptions, OutputValueType } from '../types';
+import Transaction from '../models/transaction';
+import HathorWallet from './wallet';
+export interface ISendInput {
+    txId: string;
+    index: number;
+}
+export interface ISendDataOutput {
+    type: OutputType.DATA;
+    data: Buffer;
+    value?: number;
+    token?: string;
+}
+export declare function isDataOutput(output: ISendOutput): output is ISendDataOutput;
+export interface ISendTokenOutput {
+    type: OutputType.P2PKH | OutputType.P2SH;
+    address: string;
+    value: OutputValueType;
+    token: string;
+    timelock?: number | null;
+}
+export type ISendOutput = ISendDataOutput | ISendTokenOutput;
+/**
+ * This is transaction mining class responsible for:
+ *
+ * - Submit a job to be mined;
+ * - Update mining time estimation from time to time;
+ * - Get back mining response;
+ * - Push tx to the network;
+ *
+ * It emits the following events:
+ * 'job-submitted': after job was submitted;
+ * 'estimation-updated': after getting the job status;
+ * 'job-done': after job is finished;
+ * 'send-success': after push tx succeeds;
+ * 'send-error': if an error happens;
+ * 'unexpected-error': if an unexpected error happens;
+ * */
+export default class SendTransaction extends EventEmitter {
+    wallet: HathorWallet;
+    storage: IStorage | null;
+    transaction: Transaction | null;
+    outputs: ISendOutput[];
+    inputs: ISendInput[];
+    changeAddress: string | null;
+    pin: string | null;
+    fullTxData: IDataTx | null;
+    mineTransaction: MineTransaction | null;
+    /**
+     *
+     * @param {HathorWallet} wallet Wallet instance
+     * @param {IStorage} storage Storage object, superseded by `wallet.storage` if wallet is present
+     * @param {Object} [options={}] Options to initialize the facade
+     * @param {Transaction|null} [options.transaction=null] Full tx data
+     * @param {ISendInput[]} [options.inputs=[]] tx inputs
+     * @param {ISendOutput[]} [options.outputs=[]] tx outputs
+     * @param {string|null} [options.changeAddress=null] Address to use if we need to create a change output
+     * @param {string|null} [options.pin=null] Wallet pin
+     * @param {IStorage|null} [options.network=null] Network object
+     */
+    constructor({ wallet, storage, transaction, outputs, inputs, changeAddress, pin, }?: {
+        wallet?: HathorWallet | null;
+        storage?: IStorage | null;
+        transaction?: Transaction | null;
+        inputs?: ISendInput[];
+        outputs?: ISendOutput[];
+        changeAddress?: string | null;
+        pin?: string | null;
+    });
+    /**
+     * Prepare transaction data from inputs and outputs
+     * Fill the inputs if needed, create output change if needed
+     *
+     * @throws SendTxError
+     *
+     * @return {Object} fullTxData with tokens array, inputs and outputs
+     *
+     * @memberof SendTransaction
+     * @inner
+     */
+    prepareTxData(): Promise<IDataTx>;
+    /**
+     * Prepare transaction data from inputs and outputs
+     * Fill the inputs if needed, create output change if needed and sign inputs
+     *
+     * @throws SendTxError
+     *
+     * @return {Transaction} Transaction object prepared to be mined
+     *
+     * @memberof SendTransaction
+     * @inner
+     */
+    prepareTx(): Promise<Transaction>;
+    /**
+     * Prepare transaction to be mined from signatures
+     *
+     * The full tx data should already be prepared
+     * since the signatures have already been made
+     *
+     * @params {Array<Buffer>} Array of Buffer, each being a signature of the tx data
+     * The order of the signatures must match the inputs (private key used to sign should solve the input)
+     *
+     * @throws SendTxError
+     *
+     * @return {Transaction} Transaction object prepared to be mined
+     *
+     * @memberof SendTransaction
+     * @inner
+     */
+    prepareTxFrom(signatures: Buffer[]): Promise<Transaction>;
+    /**
+     * Mine the transaction
+     * Expects this.transaction to be prepared and signed
+     * Emits MineTransaction events while the process is ongoing
+     *
+     * @params {Object} options Optional object with {'startMiningTx', 'maxTxMiningRetries'}
+     *
+     * @throws WalletError
+     *
+     * @memberof SendTransaction
+     * @inner
+     */
+    mineTx(options?: {}): Promise<import("../wallet/types").MineTxSuccessData>;
+    /**
+     * Push tx to the network
+     * If success, emits 'send-tx-success' event, otherwise emits 'send-error' event.
+     *
+     * @memberof SendTransaction
+     * @inner
+     */
+    handlePushTx(): Promise<Transaction>;
+    /**
+     * Run sendTransaction from mining, i.e. expects this.transaction to be prepared and signed
+     * then it will mine and push tx
+     *
+     * 'until' parameter can be 'mine-tx', in order to only mine the transaction without propagating
+     *
+     * @memberof SendTransaction
+     * @inner
+     */
+    runFromMining(until?: null): Promise<Transaction>;
+    /**
+     * Method created for compatibility reasons
+     * some people might be using the old facade and this start method just calls runFromMining
+     *
+     * @deprecated
+     *
+     * @memberof SendTransaction
+     * @inner
+     */
+    start(): void;
+    /**
+     * Run sendTransaction from preparing, i.e. prepare, sign, mine and push the tx
+     *
+     * 'until' parameter can be 'prepare-tx' (it will stop before signing the tx),
+     * or 'mine-tx' (it will stop before send tx proposal, i.e. propagating the tx)
+     *
+     * @memberof SendTransaction
+     * @inner
+     */
+    run(until?: null): Promise<Transaction | null>;
+    /**
+     * Update the outputs of the tx data in localStorage to set 'selected_as_input'
+     * This will prevent the input selection algorithm to select the same input before the
+     * tx arrives from the websocket and set the 'spent_by' key
+     *
+     * @param {boolean} selected If should set the selected parameter as true or false
+     *
+     * */
+    updateOutputSelected(selected: boolean): Promise<void>;
+}
+/**
+ * Check the tx data and propose inputs and outputs to complete the transaction.
+ * We will only check a single token
+ *
+ * @param {IStorage} storage
+ * @param {IDataTx} dataTx
+ * @param {IUtxoSelectionOptions} options
+ */
+export declare function prepareSendTokensData(storage: IStorage, dataTx: IDataTx, options?: IUtxoSelectionOptions): Promise<Pick<IDataTx, 'inputs' | 'outputs'>>;
+/**
+ * Check that the input is unspent, valid and available.
+ * Will return a user-friendly message if it is not.
+ *
+ * @param {IStorage} storage The storage instance
+ * @param {IDataInput} input The input we are checking
+ * @param {string} selectedToken The token uid we are checking
+ * @returns {Promise<{success: boolean, message: string}>}
+ */
+export declare function checkUnspentInput(storage: IStorage, input: IDataInput, selectedToken: string): Promise<{
+    success: boolean;
+    message: string;
+}>;
+//# sourceMappingURL=sendTransaction.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/new/sendTransaction.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/new/sendTransaction.d.ts.map
new file mode 100644
index 0000000..fc7dc22
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/new/sendTransaction.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"sendTransaction.d.ts","sourceRoot":"","sources":["../../src/new/sendTransaction.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;;;AAEH,OAAO,YAAY,MAAM,QAAQ,CAAC;AAQlC,OAAO,eAAe,MAAM,2BAA2B,CAAC;AAExD,OAAO,EAAE,UAAU,EAAE,MAAM,iBAAiB,CAAC;AAC7C,OAAO,EACL,QAAQ,EACR,OAAO,EAEP,UAAU,EACV,qBAAqB,EAGrB,eAAe,EAChB,MAAM,UAAU,CAAC;AAClB,OAAO,WAAW,MAAM,uBAAuB,CAAC;AAIhD,OAAO,YAAY,MAAM,UAAU,CAAC;AAEpC,MAAM,WAAW,UAAU;IACzB,IAAI,EAAE,MAAM,CAAC;IACb,KAAK,EAAE,MAAM,CAAC;CACf;AAED,MAAM,WAAW,eAAe;IAC9B,IAAI,EAAE,UAAU,CAAC,IAAI,CAAC;IACtB,IAAI,EAAE,MAAM,CAAC;IACb,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,KAAK,CAAC,EAAE,MAAM,CAAC;CAChB;AAED,wBAAgB,YAAY,CAAC,MAAM,EAAE,WAAW,GAAG,MAAM,IAAI,eAAe,CAE3E;AAED,MAAM,WAAW,gBAAgB;IAC/B,IAAI,EAAE,UAAU,CAAC,KAAK,GAAG,UAAU,CAAC,IAAI,CAAC;IACzC,OAAO,EAAE,MAAM,CAAC;IAChB,KAAK,EAAE,eAAe,CAAC;IACvB,KAAK,EAAE,MAAM,CAAC;IACd,QAAQ,CAAC,EAAE,MAAM,GAAG,IAAI,CAAC;CAC1B;AAED,MAAM,MAAM,WAAW,GAAG,eAAe,GAAG,gBAAgB,CAAC;AAE7D;;;;;;;;;;;;;;;KAeK;AACL,MAAM,CAAC,OAAO,OAAO,eAAgB,SAAQ,YAAY;IACvD,MAAM,EAAE,YAAY,CAAC;IAErB,OAAO,EAAE,QAAQ,GAAG,IAAI,CAAC;IAEzB,WAAW,EAAE,WAAW,GAAG,IAAI,CAAC;IAEhC,OAAO,EAAE,WAAW,EAAE,CAAC;IAEvB,MAAM,EAAE,UAAU,EAAE,CAAC;IAErB,aAAa,EAAE,MAAM,GAAG,IAAI,CAAC;IAE7B,GAAG,EAAE,MAAM,GAAG,IAAI,CAAC;IAEnB,UAAU,EAAE,OAAO,GAAG,IAAI,CAAC;IAE3B,eAAe,EAAE,eAAe,GAAG,IAAI,CAAQ;IAE/C;;;;;;;;;;;OAWG;gBACS,EACV,MAAa,EACb,OAAc,EACd,WAAkB,EAClB,OAAY,EACZ,MAAW,EACX,aAAoB,EACpB,GAAU,GACX,GAAE;QACD,MAAM,CAAC,EAAE,YAAY,GAAG,IAAI,CAAC;QAC7B,OAAO,CAAC,EAAE,QAAQ,GAAG,IAAI,CAAC;QAC1B,WAAW,CAAC,EAAE,WAAW,GAAG,IAAI,CAAC;QACjC,MAAM,CAAC,EAAE,UAAU,EAAE,CAAC;QACtB,OAAO,CAAC,EAAE,WAAW,EAAE,CAAC;QACxB,aAAa,CAAC,EAAE,MAAM,GAAG,IAAI,CAAC;QAC9B,GAAG,CAAC,EAAE,MAAM,GAAG,IAAI,CAAC;KAChB;IAiBN;;;;;;;;;;OAUG;IACG,aAAa,IAAI,OAAO,CAAC,OAAO,CAAC;IA6GvC;;;;;;;;;;OAUG;IACG,SAAS,IAAI,OAAO,CAAC,WAAW,CAAC;IAmBvC;;;;;;;;;;;;;;;OAeG;IACG,aAAa,CAAC,UAAU,EAAE,MAAM,EAAE,GAAG,OAAO,CAAC,WAAW,CAAC;IAwC/D;;;;;;;;;;;OAWG;IACG,MAAM,CAAC,OAAO,KAAK;IAsDzB;;;;;;OAMG;IACH,YAAY,IAAI,OAAO,CAAC,WAAW,CAAC;IAmDpC;;;;;;;;OAQG;IACG,aAAa,CAAC,KAAK,OAAO,GAAG,OAAO,CAAC,WAAW,CAAC;IA4BvD;;;;;;;;OAQG;IACH,KAAK;IAIL;;;;;;;;OAQG;IACG,GAAG,CAAC,KAAK,OAAO;IAiBtB;;;;;;;SAOK;IACC,oBAAoB,CAAC,QAAQ,EAAE,OAAO;CAmB7C;AAED;;;;;;;GAOG;AACH,wBAAsB,qBAAqB,CACzC,OAAO,EAAE,QAAQ,EACjB,MAAM,EAAE,OAAO,EACf,OAAO,GAAE,qBAA0B,GAClC,OAAO,CAAC,IAAI,CAAC,OAAO,EAAE,QAAQ,GAAG,SAAS,CAAC,CAAC,CA0G9C;AAED;;;;;;;;GAQG;AACH,wBAAsB,iBAAiB,CACrC,OAAO,EAAE,QAAQ,EACjB,KAAK,EAAE,UAAU,EACjB,aAAa,EAAE,MAAM,GACpB,OAAO,CAAC;IAAE,OAAO,EAAE,OAAO,CAAC;IAAC,OAAO,EAAE,MAAM,CAAA;CAAE,CAAC,CA8DhD"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/new/sendTransaction.js b/node_modules/@hathor/wallet-lib/oldLib/new/sendTransaction.js
new file mode 100644
index 0000000..775df47
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/new/sendTransaction.js
@@ -0,0 +1,697 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.checkUnspentInput = checkUnspentInput;
+exports.default = void 0;
+exports.isDataOutput = isDataOutput;
+exports.prepareSendTokensData = prepareSendTokensData;
+var _events = _interopRequireDefault(require("events"));
+var _lodash = require("lodash");
+var _constants = require("../constants");
+var _transaction = _interopRequireDefault(require("../utils/transaction"));
+var _txApi = _interopRequireDefault(require("../api/txApi"));
+var _errors = require("../errors");
+var _errorMessages = require("../errorMessages");
+var _helpers = _interopRequireDefault(require("../utils/helpers"));
+var _mineTransaction = _interopRequireDefault(require("../wallet/mineTransaction"));
+var _address = _interopRequireDefault(require("../models/address"));
+var _types = require("../wallet/types");
+var _types2 = require("../types");
+var _utxo = require("../utils/utxo");
+var _storage = require("../utils/storage");
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
+function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
+function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+function isDataOutput(output) {
+  return output.type === _types.OutputType.DATA;
+}
+/**
+ * This is transaction mining class responsible for:
+ *
+ * - Submit a job to be mined;
+ * - Update mining time estimation from time to time;
+ * - Get back mining response;
+ * - Push tx to the network;
+ *
+ * It emits the following events:
+ * 'job-submitted': after job was submitted;
+ * 'estimation-updated': after getting the job status;
+ * 'job-done': after job is finished;
+ * 'send-success': after push tx succeeds;
+ * 'send-error': if an error happens;
+ * 'unexpected-error': if an unexpected error happens;
+ * */
+class SendTransaction extends _events.default {
+  /**
+   *
+   * @param {HathorWallet} wallet Wallet instance
+   * @param {IStorage} storage Storage object, superseded by `wallet.storage` if wallet is present
+   * @param {Object} [options={}] Options to initialize the facade
+   * @param {Transaction|null} [options.transaction=null] Full tx data
+   * @param {ISendInput[]} [options.inputs=[]] tx inputs
+   * @param {ISendOutput[]} [options.outputs=[]] tx outputs
+   * @param {string|null} [options.changeAddress=null] Address to use if we need to create a change output
+   * @param {string|null} [options.pin=null] Wallet pin
+   * @param {IStorage|null} [options.network=null] Network object
+   */
+  constructor({
+    wallet = null,
+    storage = null,
+    transaction = null,
+    outputs = [],
+    inputs = [],
+    changeAddress = null,
+    pin = null
+  } = {}) {
+    super();
+    _defineProperty(this, "wallet", void 0);
+    _defineProperty(this, "storage", void 0);
+    _defineProperty(this, "transaction", void 0);
+    _defineProperty(this, "outputs", void 0);
+    _defineProperty(this, "inputs", void 0);
+    _defineProperty(this, "changeAddress", void 0);
+    _defineProperty(this, "pin", void 0);
+    _defineProperty(this, "fullTxData", void 0);
+    _defineProperty(this, "mineTransaction", null);
+    this.wallet = wallet;
+    if (wallet) {
+      this.storage = wallet.storage;
+    } else {
+      this.storage = storage;
+    }
+    this.transaction = transaction;
+    this.outputs = outputs;
+    this.inputs = inputs;
+    this.changeAddress = changeAddress;
+    this.pin = pin;
+    this.fullTxData = null;
+  }
+
+  /**
+   * Prepare transaction data from inputs and outputs
+   * Fill the inputs if needed, create output change if needed
+   *
+   * @throws SendTxError
+   *
+   * @return {Object} fullTxData with tokens array, inputs and outputs
+   *
+   * @memberof SendTransaction
+   * @inner
+   */
+  async prepareTxData() {
+    if (!this.storage) {
+      throw new _errors.SendTxError('Storage is not set.');
+    }
+    const HTR_UID = _constants.NATIVE_TOKEN_UID;
+    const network = this.storage.config.getNetwork();
+    const txData = {
+      inputs: [],
+      outputs: [],
+      tokens: []
+    };
+    // Map of token uid to the chooseInputs value of this token
+    const tokenMap = new Map();
+    for (const output of this.outputs) {
+      if (isDataOutput(output)) {
+        tokenMap.set(HTR_UID, true);
+        output.token = HTR_UID;
+
+        // Data output will always have value 1 (0.01) HTR
+        txData.outputs.push({
+          type: _types.OutputType.DATA,
+          data: output.data.toString('hex'),
+          value: 1n,
+          authorities: 0n,
+          token: output.token
+        });
+      } else {
+        const addressObj = new _address.default(output.address, {
+          network
+        });
+        // We set chooseInputs true as default and may be overwritten by the inputs.
+        // chooseInputs should be true if no inputs are given
+        tokenMap.set(output.token, true);
+        txData.outputs.push({
+          address: output.address,
+          value: output.value,
+          timelock: output.timelock ? output.timelock : null,
+          authorities: 0n,
+          token: output.token,
+          type: addressObj.getType()
+        });
+      }
+    }
+    for (const input of this.inputs) {
+      const inputTx = await this.storage.getTx(input.txId);
+      if (inputTx === null || !inputTx.outputs[input.index]) {
+        const err = new _errors.SendTxError(_errorMessages.ErrorMessages.INVALID_INPUT);
+        err.errorData = {
+          txId: input.txId,
+          index: input.index
+        };
+        throw err;
+      }
+      const spentOut = inputTx.outputs[input.index];
+      if (!tokenMap.has(spentOut.token)) {
+        // The input select is from a token that is not in the outputs
+        const err = new _errors.SendTxError(_errorMessages.ErrorMessages.INVALID_INPUT);
+        err.errorData = {
+          txId: input.txId,
+          index: input.index
+        };
+        throw err;
+      }
+      tokenMap.set(spentOut.token, false);
+      txData.inputs.push({
+        txId: input.txId,
+        index: input.index,
+        value: spentOut.value,
+        token: spentOut.token,
+        address: spentOut.decoded.address,
+        authorities: _transaction.default.authoritiesFromOutput(spentOut)
+      });
+    }
+    const partialTxData = {
+      inputs: [],
+      outputs: []
+    };
+    for (const [token, chooseInputs] of tokenMap) {
+      const options = {
+        token,
+        chooseInputs
+      };
+      if (this.changeAddress) {
+        options.changeAddress = this.changeAddress;
+      }
+      try {
+        const proposedData = await prepareSendTokensData(this.storage, txData, options);
+        partialTxData.inputs.push(...proposedData.inputs);
+        partialTxData.outputs.push(...proposedData.outputs);
+      } catch (e) {
+        if (e instanceof Error) {
+          throw new _errors.SendTxError(e.message);
+        }
+        throw e;
+      }
+    }
+    let outputs;
+    if (partialTxData.outputs.length === 0) {
+      outputs = txData.outputs;
+    } else {
+      // Shuffle outputs, so we don't have change output always in the same index
+      outputs = (0, _lodash.shuffle)([...txData.outputs, ...partialTxData.outputs]);
+    }
+    tokenMap.delete(HTR_UID);
+    // This new IDataTx should be complete with the requested funds
+    this.fullTxData = {
+      outputs,
+      inputs: [...txData.inputs, ...partialTxData.inputs],
+      tokens: Array.from(tokenMap.keys())
+    };
+    return this.fullTxData;
+  }
+
+  /**
+   * Prepare transaction data from inputs and outputs
+   * Fill the inputs if needed, create output change if needed and sign inputs
+   *
+   * @throws SendTxError
+   *
+   * @return {Transaction} Transaction object prepared to be mined
+   *
+   * @memberof SendTransaction
+   * @inner
+   */
+  async prepareTx() {
+    if (!this.storage) {
+      throw new _errors.SendTxError('Storage is not set.');
+    }
+    const txData = this.fullTxData || (await this.prepareTxData());
+    try {
+      if (!this.pin) {
+        throw new Error('Pin is not set.');
+      }
+      this.transaction = await _transaction.default.prepareTransaction(txData, this.pin, this.storage);
+      // This will validate if the transaction has more than the max number of inputs and outputs.
+      this.transaction.validate();
+      return this.transaction;
+    } catch (e) {
+      const message = _helpers.default.handlePrepareDataError(e);
+      throw new _errors.SendTxError(message);
+    }
+  }
+
+  /**
+   * Prepare transaction to be mined from signatures
+   *
+   * The full tx data should already be prepared
+   * since the signatures have already been made
+   *
+   * @params {Array<Buffer>} Array of Buffer, each being a signature of the tx data
+   * The order of the signatures must match the inputs (private key used to sign should solve the input)
+   *
+   * @throws SendTxError
+   *
+   * @return {Transaction} Transaction object prepared to be mined
+   *
+   * @memberof SendTransaction
+   * @inner
+   */
+  async prepareTxFrom(signatures) {
+    if (!this.storage) {
+      throw new _errors.SendTxError('Storage is not set.');
+    }
+    if (this.fullTxData === null) {
+      // This method can only be called with a prepared tx data
+      // because prepareTxData may modify the inputs and outputs
+      throw new _errors.SendTxError(_errorMessages.ErrorMessages.TRANSACTION_IS_NULL);
+    }
+
+    // add each input data from signature
+    for (const [index, input] of this.fullTxData.inputs.entries()) {
+      const signature = signatures[index];
+      const addressInfo = await this.storage.getAddressInfo(input.address);
+      if (addressInfo === null) {
+        throw new _errors.SendTxError(_errorMessages.ErrorMessages.INVALID_INPUT);
+      }
+      // Creates input data for P2PKH
+      if (!addressInfo.publicKey) {
+        throw new _errors.SendTxError('Missing public key for address');
+      }
+      input.data = _transaction.default.createInputData(signature, Buffer.from(addressInfo.publicKey, 'hex')).toString('hex');
+    }
+
+    // prepare and create transaction
+    try {
+      this.transaction = _transaction.default.createTransactionFromData(this.fullTxData, this.storage.config.getNetwork());
+      this.transaction.prepareToSend();
+      return this.transaction;
+    } catch (e) {
+      const message = _helpers.default.handlePrepareDataError(e);
+      throw new _errors.SendTxError(message);
+    }
+  }
+
+  /**
+   * Mine the transaction
+   * Expects this.transaction to be prepared and signed
+   * Emits MineTransaction events while the process is ongoing
+   *
+   * @params {Object} options Optional object with {'startMiningTx', 'maxTxMiningRetries'}
+   *
+   * @throws WalletError
+   *
+   * @memberof SendTransaction
+   * @inner
+   */
+  async mineTx(options = {}) {
+    if (this.transaction === null) {
+      throw new _errors.WalletError(_errorMessages.ErrorMessages.TRANSACTION_IS_NULL);
+    }
+    await this.updateOutputSelected(true);
+    const newOptions = {
+      startMiningTx: true,
+      maxTxMiningRetries: 3,
+      ...options
+    };
+    this.mineTransaction = new _mineTransaction.default(this.transaction, {
+      maxTxMiningRetries: newOptions.maxTxMiningRetries
+    });
+    this.mineTransaction.on('mining-started', () => {
+      this.emit('mine-tx-started');
+    });
+    this.mineTransaction.on('estimation-updated', data => {
+      this.emit('estimation-updated', data);
+    });
+    this.mineTransaction.on('job-submitted', data => {
+      this.emit('job-submitted', data);
+    });
+    this.mineTransaction.on('job-done', data => {
+      this.emit('job-done', data);
+    });
+    this.mineTransaction.on('error', message => {
+      this.updateOutputSelected(false);
+      this.emit('send-error', message);
+    });
+    this.mineTransaction.on('unexpected-error', message => {
+      this.updateOutputSelected(false);
+      this.emit('unexpected-error', message);
+    });
+    this.mineTransaction.on('success', data => {
+      this.emit('mine-tx-ended', data);
+    });
+    if (newOptions.startMiningTx) {
+      this.mineTransaction.start();
+    }
+    return this.mineTransaction.promise;
+  }
+
+  /**
+   * Push tx to the network
+   * If success, emits 'send-tx-success' event, otherwise emits 'send-error' event.
+   *
+   * @memberof SendTransaction
+   * @inner
+   */
+  handlePushTx() {
+    if (this.transaction === null) {
+      throw new _errors.WalletError(_errorMessages.ErrorMessages.TRANSACTION_IS_NULL);
+    }
+    const promise = new Promise((resolve, reject) => {
+      if (this.transaction === null) {
+        throw new _errors.WalletError(_errorMessages.ErrorMessages.TRANSACTION_IS_NULL);
+      }
+      this.emit('send-tx-start', this.transaction);
+      const txHex = this.transaction.toHex();
+      _txApi.default.pushTx(txHex, false, response => {
+        if (response.success) {
+          if (this.transaction === null) {
+            throw new _errors.WalletError(_errorMessages.ErrorMessages.TRANSACTION_IS_NULL);
+          }
+          this.transaction.updateHash();
+          if (this.wallet && this.storage) {
+            // Add transaction to storage and process storage
+            (async (wallet, storage, transaction) => {
+              // Get the transaction as a history object
+              const historyTx = await _transaction.default.convertTransactionToHistoryTx(transaction, storage);
+              // Add token from a create token transaction to the storage
+              // This just returns if the transaction is not a CREATE_TOKEN_TX
+              await (0, _storage.addCreatedTokenFromTx)(transaction, storage);
+              // Add new transaction to the wallet's storage.
+              wallet.enqueueOnNewTx({
+                history: historyTx
+              });
+            })(this.wallet, this.storage, this.transaction);
+          }
+          this.emit('send-tx-success', this.transaction);
+          resolve(this.transaction);
+        } else {
+          this.updateOutputSelected(false);
+          const err = new _errors.SendTxError(response.message);
+          reject(err);
+        }
+      }).catch(e => {
+        this.updateOutputSelected(false);
+        this.emit('send-error', e.message);
+        reject(e);
+      });
+    });
+    return promise;
+  }
+
+  /**
+   * Run sendTransaction from mining, i.e. expects this.transaction to be prepared and signed
+   * then it will mine and push tx
+   *
+   * 'until' parameter can be 'mine-tx', in order to only mine the transaction without propagating
+   *
+   * @memberof SendTransaction
+   * @inner
+   */
+  async runFromMining(until = null) {
+    try {
+      if (this.transaction === null) {
+        throw new _errors.WalletError(_errorMessages.ErrorMessages.TRANSACTION_IS_NULL);
+      }
+      // This will await until mine tx is fully completed
+      // mineTx method returns a promise that resolves when
+      // mining succeeds or rejects when there is an error
+      const mineData = await this.mineTx();
+      this.transaction.parents = mineData.parents;
+      this.transaction.timestamp = mineData.timestamp;
+      this.transaction.nonce = mineData.nonce;
+      this.transaction.weight = mineData.weight;
+      if (until === 'mine-tx') {
+        return this.transaction;
+      }
+      const tx = await this.handlePushTx();
+      return tx;
+    } catch (err) {
+      if (err instanceof _errors.WalletError) {
+        this.emit('send-error', err.message);
+      }
+      throw err;
+    }
+  }
+
+  /**
+   * Method created for compatibility reasons
+   * some people might be using the old facade and this start method just calls runFromMining
+   *
+   * @deprecated
+   *
+   * @memberof SendTransaction
+   * @inner
+   */
+  start() {
+    this.runFromMining();
+  }
+
+  /**
+   * Run sendTransaction from preparing, i.e. prepare, sign, mine and push the tx
+   *
+   * 'until' parameter can be 'prepare-tx' (it will stop before signing the tx),
+   * or 'mine-tx' (it will stop before send tx proposal, i.e. propagating the tx)
+   *
+   * @memberof SendTransaction
+   * @inner
+   */
+  async run(until = null) {
+    try {
+      await this.prepareTx();
+      if (until === 'prepare-tx') {
+        return this.transaction;
+      }
+      const tx = await this.runFromMining(until);
+      return tx;
+    } catch (err) {
+      if (err instanceof _errors.WalletError) {
+        this.emit('send-error', err.message);
+      }
+      throw err;
+    }
+  }
+
+  /**
+   * Update the outputs of the tx data in localStorage to set 'selected_as_input'
+   * This will prevent the input selection algorithm to select the same input before the
+   * tx arrives from the websocket and set the 'spent_by' key
+   *
+   * @param {boolean} selected If should set the selected parameter as true or false
+   *
+   * */
+  async updateOutputSelected(selected) {
+    if (this.transaction === null) {
+      throw new _errors.WalletError(_errorMessages.ErrorMessages.TRANSACTION_IS_NULL);
+    }
+    if (!this.storage) {
+      // No storage available, so we can't update the selected utxos
+      return;
+    }
+
+    // Mark all inputs as selected
+    for (const input of this.transaction.inputs) {
+      await this.storage.utxoSelectAsInput({
+        txId: input.hash,
+        index: input.index
+      }, selected, _constants.SELECT_OUTPUTS_TIMEOUT);
+    }
+  }
+}
+
+/**
+ * Check the tx data and propose inputs and outputs to complete the transaction.
+ * We will only check a single token
+ *
+ * @param {IStorage} storage
+ * @param {IDataTx} dataTx
+ * @param {IUtxoSelectionOptions} options
+ */
+exports.default = SendTransaction;
+async function prepareSendTokensData(storage, dataTx, options = {}) {
+  async function getOutputTypeFromWallet() {
+    const walletType = await storage.getWalletType();
+    if (walletType === _types2.WalletType.P2PKH) {
+      return 'p2pkh';
+    }
+    if (walletType === _types2.WalletType.MULTISIG) {
+      return 'p2sh';
+    }
+    throw new Error('Unsupported wallet type.');
+  }
+  const token = options.token || _constants.NATIVE_TOKEN_UID;
+  const utxoSelection = options.utxoSelectionMethod || _utxo.bestUtxoSelection;
+  const newtxData = {
+    inputs: [],
+    outputs: []
+  };
+  let outputAmount = 0n;
+
+  // Calculate balance for the token on the transaction
+  for (const output of dataTx.outputs) {
+    if ((0, _types2.isDataOutputCreateToken)(output)) {
+      // This is a mint output
+      // Since the current transaction is creating the token we can safely ignore it
+      continue;
+    }
+    const outputToken = output.token || _constants.NATIVE_TOKEN_UID;
+    if (outputToken !== token) {
+      // This output is not for the token we are looking for
+      continue;
+    }
+    outputAmount += output.value;
+  }
+  if (options.chooseInputs) {
+    if (outputAmount === 0n) {
+      // We cannot process a target amount of 0 tokens.
+      throw new Error('Invalid amount of tokens to send.');
+    }
+
+    // We will choose the inputs to fill outputAmount.funds
+    const newUtxos = await utxoSelection(storage, token, outputAmount);
+    if (newUtxos.amount < outputAmount) {
+      throw new Error(`Token: ${token}. Insufficient amount of tokens to fill the amount.`);
+    }
+    newtxData.inputs = newUtxos.utxos.map(_helpers.default.getDataInputFromUtxo);
+    if (newUtxos.amount > outputAmount) {
+      // We need to create a change output
+      const changeAddress = await storage.getChangeAddress({
+        changeAddress: options.changeAddress
+      });
+      const changeOutput = {
+        type: await getOutputTypeFromWallet(),
+        token,
+        value: newUtxos.amount - outputAmount,
+        address: changeAddress,
+        authorities: 0n,
+        timelock: null,
+        isChange: true
+      };
+      newtxData.outputs.push(changeOutput);
+    }
+  } else {
+    let inputAmount = 0n;
+    for (const input of dataTx.inputs) {
+      if (input.token !== token) {
+        // The input is not for the token we are checking
+        continue;
+      }
+
+      // We will check the validity and availability of the provided inputs
+      // and the amount (suggesting a change if needed)
+      // The inputs do not need to be added on newtxData.inputs since they are provided by the caller.
+      const checkSpent = await checkUnspentInput(storage, input, token);
+      if (!checkSpent.success) {
+        throw new Error(`Token: ${token}. ${checkSpent.message}`);
+      }
+      if (!(await _transaction.default.canUseUtxo(input, storage))) {
+        throw new Error(`Token: ${token}. Output [${input.txId}, ${input.index}] is locked or being used`);
+      }
+      inputAmount += input.value;
+    }
+    if (inputAmount < outputAmount) {
+      throw new Error(`Token: ${token}. Sum of outputs is greater than sum of inputs`);
+    }
+    if (inputAmount > outputAmount) {
+      // Need to create a change output
+      const changeAddress = await storage.getChangeAddress({
+        changeAddress: options.changeAddress
+      });
+      newtxData.outputs.push({
+        type: await getOutputTypeFromWallet(),
+        token,
+        value: inputAmount - outputAmount,
+        address: changeAddress,
+        authorities: 0n,
+        timelock: null,
+        isChange: true
+      });
+    }
+  }
+  return newtxData;
+}
+
+/**
+ * Check that the input is unspent, valid and available.
+ * Will return a user-friendly message if it is not.
+ *
+ * @param {IStorage} storage The storage instance
+ * @param {IDataInput} input The input we are checking
+ * @param {string} selectedToken The token uid we are checking
+ * @returns {Promise<{success: boolean, message: string}>}
+ */
+async function checkUnspentInput(storage, input, selectedToken) {
+  const tx = await storage.getTx(input.txId);
+  if (tx === null) {
+    return {
+      success: false,
+      message: `Transaction [${input.txId}] does not exist in the wallet`
+    };
+  }
+  if (tx.is_voided) {
+    return {
+      success: false,
+      message: `Transaction [${input.txId}] is voided`
+    };
+  }
+  if (tx.outputs.length - 1 < input.index) {
+    return {
+      success: false,
+      message: `Transaction [${input.txId}] does not have this output [index=${input.index}]`
+    };
+  }
+  const txout = tx.outputs[input.index];
+  if (_transaction.default.isAuthorityOutput(txout)) {
+    /**
+     * XXX: We are NOT enabling authority outputs for now.
+     */
+    return {
+      success: false,
+      message: `Output [${input.index}] of transaction [${input.txId}] is an authority output`
+    };
+  }
+  if (txout.decoded.address) {
+    if (txout.decoded.address !== input.address) {
+      return {
+        success: false,
+        message: `Output [${input.index}] of transaction [${input.txId}] does not have the same address as the provided input`
+      };
+    }
+    if (!(await storage.isAddressMine(txout.decoded.address))) {
+      return {
+        success: false,
+        message: `Output [${input.index}] of transaction [${input.txId}] is not from the wallet`
+      };
+    }
+  } else {
+    // This output does not have an address, so it cannot be spent by us
+    return {
+      success: false,
+      message: `Output [${input.index}] of transaction [${input.txId}] cannot be spent since it does not belong to an address`
+    };
+  }
+  if (txout.token !== input.token || input.token !== selectedToken) {
+    return {
+      success: false,
+      message: `Output [${input.index}] of transaction [${input.txId}] is not from selected token [${selectedToken}]`
+    };
+  }
+  if (txout.spent_by) {
+    return {
+      success: false,
+      message: `Output [${input.index}] of transaction [${input.txId}] is already spent`
+    };
+  }
+  return {
+    success: true,
+    message: ''
+  };
+}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/new/wallet.js b/node_modules/@hathor/wallet-lib/oldLib/new/wallet.js
new file mode 100644
index 0000000..adf5584
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/new/wallet.js
@@ -0,0 +1,3541 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+var _lodash = require("lodash");
+var _bitcoreLib = _interopRequireWildcard(require("bitcore-lib"));
+var _events = _interopRequireDefault(require("events"));
+var _constants = require("../constants");
+var _tokens = _interopRequireDefault(require("../utils/tokens"));
+var _wallet = _interopRequireDefault(require("../api/wallet"));
+var _version = _interopRequireDefault(require("../api/version"));
+var _buffer = require("../utils/buffer");
+var _crypto = require("../utils/crypto");
+var _helpers = _interopRequireDefault(require("../utils/helpers"));
+var _scripts = require("../utils/scripts");
+var _wallet2 = _interopRequireDefault(require("../utils/wallet"));
+var _sendTransaction = _interopRequireDefault(require("./sendTransaction"));
+var _network = _interopRequireDefault(require("../models/network"));
+var _errors = require("../errors");
+var _errorMessages = require("../errorMessages");
+var _p2sh_signature = _interopRequireDefault(require("../models/p2sh_signature"));
+var _types = require("../types");
+var _transaction = _interopRequireDefault(require("../utils/transaction"));
+var _queue = _interopRequireDefault(require("../models/queue"));
+var _storage = require("../utils/storage");
+var _txApi = _interopRequireDefault(require("../api/txApi"));
+var _storage2 = require("../storage");
+var _address = require("../utils/address");
+var _builder = _interopRequireDefault(require("../nano_contracts/builder"));
+var _utils = require("../nano_contracts/utils");
+var _on_chain_blueprint = _interopRequireWildcard(require("../nano_contracts/on_chain_blueprint"));
+var _types2 = require("../nano_contracts/types");
+var _schemas = require("../schemas");
+var _gll = _interopRequireDefault(require("../sync/gll"));
+var _transaction2 = require("../template/transaction");
+var _address2 = _interopRequireDefault(require("../models/address"));
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
+function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
+function _awaitAsyncGenerator(e) { return new _OverloadYield(e, 0); }
+function _wrapAsyncGenerator(e) { return function () { return new AsyncGenerator(e.apply(this, arguments)); }; }
+function AsyncGenerator(e) { var r, t; function resume(r, t) { try { var n = e[r](t), o = n.value, u = o instanceof _OverloadYield; Promise.resolve(u ? o.v : o).then(function (t) { if (u) { var i = "return" === r ? "return" : "next"; if (!o.k || t.done) return resume(i, t); t = e[i](t).value; } settle(n.done ? "return" : "normal", t); }, function (e) { resume("throw", e); }); } catch (e) { settle("throw", e); } } function settle(e, n) { switch (e) { case "return": r.resolve({ value: n, done: !0 }); break; case "throw": r.reject(n); break; default: r.resolve({ value: n, done: !1 }); } (r = r.next) ? resume(r.key, r.arg) : t = null; } this._invoke = function (e, n) { return new Promise(function (o, u) { var i = { key: e, arg: n, resolve: o, reject: u, next: null }; t ? t = t.next = i : (r = t = i, resume(e, n)); }); }, "function" != typeof e.return && (this.return = void 0); }
+AsyncGenerator.prototype["function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator"] = function () { return this; }, AsyncGenerator.prototype.next = function (e) { return this._invoke("next", e); }, AsyncGenerator.prototype.throw = function (e) { return this._invoke("throw", e); }, AsyncGenerator.prototype.return = function (e) { return this._invoke("return", e); };
+function _OverloadYield(e, d) { this.v = e, this.k = d; }
+function _asyncIterator(r) { var n, t, o, e = 2; for ("undefined" != typeof Symbol && (t = Symbol.asyncIterator, o = Symbol.iterator); e--;) { if (t && null != (n = r[t])) return n.call(r); if (o && null != (n = r[o])) return new AsyncFromSyncIterator(n.call(r)); t = "@@asyncIterator", o = "@@iterator"; } throw new TypeError("Object is not async iterable"); }
+function AsyncFromSyncIterator(r) { function AsyncFromSyncIteratorContinuation(r) { if (Object(r) !== r) return Promise.reject(new TypeError(r + " is not an object.")); var n = r.done; return Promise.resolve(r.value).then(function (r) { return { value: r, done: n }; }); } return AsyncFromSyncIterator = function (r) { this.s = r, this.n = r.next; }, AsyncFromSyncIterator.prototype = { s: null, n: null, next: function () { return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments)); }, return: function (r) { var n = this.s.return; return void 0 === n ? Promise.resolve({ value: r, done: !0 }) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments)); }, throw: function (r) { var n = this.s.return; return void 0 === n ? Promise.reject(r) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments)); } }, new AsyncFromSyncIterator(r); } /**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/**
+ * @typedef {import('../models/create_token_transaction').default} CreateTokenTransaction
+ * @typedef {import('../models/transaction').default} Transaction
+ */
+
+const ERROR_MESSAGE_PIN_REQUIRED = 'Pin is required.';
+
+/**
+ * TODO: This should be removed when this file is migrated to typescript
+ * we need this here because the typescript enum from the Connection file is
+ * not being correctly transpiled here, returning `undefined` for ConnectionState.CLOSED.
+ */
+const ConnectionState = {
+  CLOSED: 0,
+  CONNECTING: 1,
+  CONNECTED: 2
+};
+
+/**
+ * This is a Wallet that is supposed to be simple to be used by a third-party app.
+ *
+ * This class handles all the details of syncing, including receiving the same transaction
+ * multiple times from the server. It also keeps the balance of the tokens updated.
+ *
+ * It has the following states:
+ * - CLOSED: When it is disconnected from the server.
+ * - CONNECTING: When it is connecting to the server.
+ * - SYNCING: When it has connected and is syncing the transaction history.
+ * - READY: When it is ready to be used.
+ *
+ * You can subscribe for the following events:
+ * - state: Fired when the state of the Wallet changes.
+ * - new-tx: Fired when a new tx arrives.
+ * - update-tx: Fired when a known tx is updated. Usually, it happens when one of its outputs is spent.
+ * - more-addresses-loaded: Fired when loading the history of transactions. It is fired multiple times,
+ *                          one for each request sent to the server.
+ */
+class HathorWallet extends _events.default {
+  /**
+   * @param {Object} param
+   * @param {FullnodeConnection} param.connection A connection to the server
+   * @param {import('../types').IStorage} param.storage A storage
+   * @param {string} param.seed 24 words separated by space
+   * @param {string} [param.passphrase=''] Wallet passphrase
+   * @param {string} [param.xpriv]
+   * @param {string} [param.xpub]
+   * @param {string} [param.tokenUid] UID of the token to handle on this wallet
+   * @param {string} [param.password] Password to encrypt the seed
+   * @param {string} [param.pinCode] PIN to execute wallet actions
+   * @param {boolean} [param.debug] Activates debug mode
+   * @param {{pubkeys:string[],numSignatures:number}} [param.multisig]
+   * @param {string[]} [param.preCalculatedAddresses] An array of pre-calculated addresses
+   * @param {import('../types').AddressScanPolicyData} [param.scanPolicy] config specific to
+   * @param {import('../types').ILogger} [param.logger] The logger instance to use
+   * the address scan policy.
+   */
+  constructor({
+    connection,
+    storage,
+    seed,
+    passphrase = '',
+    xpriv,
+    xpub,
+    tokenUid = _constants.NATIVE_TOKEN_UID,
+    password = null,
+    pinCode = null,
+    // debug mode
+    debug = false,
+    // Callback to be executed before reload data
+    beforeReloadCallback = null,
+    multisig = null,
+    preCalculatedAddresses = null,
+    scanPolicy = null,
+    logger = null
+  } = {}) {
+    super();
+    if (!connection) {
+      throw Error('You must provide a connection.');
+    }
+    if (!seed && !xpriv && !xpub) {
+      throw Error('You must explicitly provide the seed, xpriv or the xpub.');
+    }
+    if (seed && xpriv) {
+      throw Error('You cannot provide both a seed and an xpriv.');
+    }
+    if (xpriv && passphrase !== '') {
+      throw Error("You can't use xpriv with passphrase.");
+    }
+    if (connection.state !== ConnectionState.CLOSED) {
+      throw Error("You can't share connections.");
+    }
+    if (multisig) {
+      if (!(multisig.pubkeys && multisig.numSignatures)) {
+        throw Error('Multisig configuration requires both pubkeys and numSignatures.');
+      } else if (multisig.pubkeys.length < multisig.numSignatures) {
+        throw Error('Multisig configuration invalid.');
+      }
+    }
+    this.logger = logger || (0, _types.getDefaultLogger)();
+    if (storage) {
+      /**
+       * @type {import('../types').IStorage}
+       */
+      this.storage = storage;
+    } else {
+      // Default to a memory store
+      const store = new _storage2.MemoryStore();
+      /**
+       * @type {import('../types').IStorage}
+       */
+      this.storage = new _storage2.Storage(store);
+    }
+    this.storage.setLogger(this.logger);
+    /**
+     * @type {import('./connection').default}
+     */
+    this.conn = connection;
+    this.conn.startControlHandlers(this.storage);
+    this.state = HathorWallet.CLOSED;
+    this.xpriv = xpriv;
+    this.seed = seed;
+    this.xpub = xpub;
+
+    // tokenUid is optional so we can get the token of the wallet
+    this.token = null;
+    this.tokenUid = tokenUid;
+    this.passphrase = passphrase;
+    this.pinCode = pinCode;
+    this.password = password;
+    this.preCalculatedAddresses = preCalculatedAddresses;
+    this.onConnectionChangedState = this.onConnectionChangedState.bind(this);
+    this.handleWebsocketMsg = this.handleWebsocketMsg.bind(this);
+
+    // Used to know if the wallet is loading data for the first time
+    // or if it's reloading it (e.g. after a ws reconnection).
+    // The reload must execute some cleanups, that's why it's important
+    // to differentiate both actions
+    this.firstConnection = true;
+
+    // Debug mode. It is used to include debugging information
+    // when a problem occurs.
+    this.debug = debug;
+
+    // The reload is called automatically in the lib when the ws reconnects
+    // this callback gives a chance to the apps to run a method before reloading data in the lib
+    this.beforeReloadCallback = beforeReloadCallback;
+
+    // Set to true when stop() method is called
+    this.walletStopped = false;
+    if (multisig) {
+      this.multisig = {
+        pubkeys: multisig.pubkeys,
+        numSignatures: multisig.numSignatures
+      };
+    }
+    this.wsTxQueue = new _queue.default();
+    this.newTxPromise = Promise.resolve();
+    this.scanPolicy = scanPolicy;
+    this.isSignedExternally = this.storage.hasTxSignatureMethod();
+    this.historySyncMode = _types.HistorySyncMode.POLLING_HTTP_API;
+    this.txTemplateInterpreter = new _transaction2.WalletTxTemplateInterpreter(this);
+  }
+
+  /**
+   * Gets the current server url from connection
+   * @return {string} The server url. Ex.: 'http://server.com:8083'
+   */
+  getServerUrl() {
+    return this.conn.getCurrentServer();
+  }
+
+  /**
+   * Gets the current network from connection
+   * @return {string} The network name. Ex.: 'mainnet', 'testnet'
+   */
+  getNetwork() {
+    return this.conn.getCurrentNetwork();
+  }
+
+  /**
+   * Gets the network model object
+   */
+  getNetworkObject() {
+    return new _network.default(this.getNetwork());
+  }
+
+  /**
+   * Gets version data from the fullnode
+   *
+   * @return {FullNodeVersionData} The data information from the fullnode
+   *
+   * @memberof HathorWallet
+   * @inner
+   * */
+  // eslint-disable-next-line class-methods-use-this -- The server address is fetched directly from the configs
+  async getVersionData() {
+    const versionData = await new Promise((resolve, reject) => {
+      _version.default.getVersion(resolve).catch(error => reject(error));
+    });
+    return {
+      // The new facade returns the timestamp of when this information was cached, since we don't
+      // cache this information on the fullnode, it is ok to just return the current timestamp.
+      // This is currently not being used on hathor official wallets
+      timestamp: Date.now(),
+      version: versionData.version,
+      network: versionData.network,
+      minWeight: versionData.min_weight,
+      minTxWeight: versionData.min_tx_weight,
+      minTxWeightCoefficient: versionData.min_tx_weight_coefficient,
+      minTxWeightK: versionData.min_tx_weight_k,
+      tokenDepositPercentage: versionData.token_deposit_percentage,
+      rewardSpendMinBlocks: versionData.reward_spend_min_blocks,
+      maxNumberInputs: versionData.max_number_inputs,
+      maxNumberOutputs: versionData.max_number_outputs
+    };
+  }
+
+  /**
+   * Set the server url to connect to
+   * @param {String} newServer The new server to change to
+   *
+   * @memberof HathorWallet
+   * @inner
+   * */
+  changeServer(newServer) {
+    this.storage.config.setServerUrl(newServer);
+  }
+
+  /**
+   * Set the value of the gap limit for this wallet instance.
+   * @param {number} value The new gap limit value
+   * @returns {Promise<void>}
+   */
+  async setGapLimit(value) {
+    return this.storage.setGapLimit(value);
+  }
+
+  /**
+   * Load more addresses if configured to index-limit scanning policy.
+   * @param {number} count Number of addresses to load
+   * @returns {Promise<number>} The index of the last address loaded
+   */
+  async indexLimitLoadMore(count) {
+    const scanPolicy = await this.storage.getScanningPolicy();
+    if (scanPolicy !== _types.SCANNING_POLICY.INDEX_LIMIT) {
+      throw new Error('Wallet is not configured for index-limit scanning policy');
+    }
+    const limits = await this.storage.getIndexLimit();
+    if (!limits) {
+      throw new Error('Index limit scanning policy config error');
+    }
+    const newEndIndex = limits.endIndex + count;
+    await this.indexLimitSetEndIndex(newEndIndex);
+    return newEndIndex;
+  }
+
+  /**
+   * Set the value of the index limit end for this wallet instance.
+   * @param {number} endIndex The new index limit value
+   * @returns {Promise<void>}
+   */
+  async indexLimitSetEndIndex(endIndex) {
+    const scanPolicy = await this.storage.getScanningPolicy();
+    if (scanPolicy !== _types.SCANNING_POLICY.INDEX_LIMIT) {
+      throw new Error('Wallet is not configured for index-limit scanning policy');
+    }
+    const limits = await this.storage.getIndexLimit();
+    if (!limits) {
+      throw new Error('Index limit scanning policy config error');
+    }
+    if (endIndex <= limits.endIndex) {
+      // Cannot unload addresses from storage.
+      return;
+    }
+    const newPolicyData = {
+      ...limits,
+      endIndex,
+      policy: _types.SCANNING_POLICY.INDEX_LIMIT
+    };
+    await this.storage.setScanningPolicyData(newPolicyData);
+    // Force loading more addresses and process history if any tx is found
+    await this.scanAddressesToLoad(true);
+  }
+
+  /**
+   * Get the value of the gap limit for this wallet instance.
+   * @returns {Promise<number>}
+   */
+  async getGapLimit() {
+    return this.storage.getGapLimit();
+  }
+
+  /**
+   * Get the access data object from storage.
+   * @returns {Promise<import('../types').IWalletAccessData>}
+   */
+  async getAccessData() {
+    const accessData = await this.storage.getAccessData();
+    if (!accessData) {
+      throw new _errors.WalletError('Wallet was not initialized.');
+    }
+    return accessData;
+  }
+
+  /**
+   * Get the configured wallet type.
+   * @returns {Promise<string>} The wallet type
+   */
+  async getWalletType() {
+    const accessData = await this.getAccessData();
+    return accessData.walletType;
+  }
+
+  /**
+   * Get the multisig data object from storage.
+   * Only works if the wallet is a multisig wallet.
+   *
+   * @returns {Promise<import('../types').IMultisigData>}
+   */
+  async getMultisigData() {
+    const accessData = await this.getAccessData();
+    if (accessData.walletType !== _types.WalletType.MULTISIG) {
+      throw new _errors.WalletError('Wallet is not a multisig wallet.');
+    }
+    if (!accessData.multisigData) {
+      throw new _errors.WalletError('Multisig data not found in storage');
+    }
+    return accessData.multisigData;
+  }
+
+  /**
+   * Enable debug mode.
+   * */
+  enableDebugMode() {
+    this.debug = true;
+  }
+
+  /**
+   * Disable debug mode.
+   */
+  disableDebugMode() {
+    this.debug = false;
+  }
+
+  /**
+   * Check that this wallet is readonly.
+   * This can be shortcircuted if the wallet is meant to be signed externally.
+   * @returns {Promise<boolean>}
+   */
+  async isReadonly() {
+    if (this.isSignedExternally) {
+      return false;
+    }
+    return this.storage.isReadonly();
+  }
+
+  /**
+   * Called when the connection to the websocket changes.
+   * It is also called if the network is down.
+   *
+   * @param {Number} newState Enum of new state after change
+   */
+  async onConnectionChangedState(newState) {
+    if (newState === ConnectionState.CONNECTED) {
+      this.setState(HathorWallet.SYNCING);
+      try {
+        // If it's the first connection we just load the history
+        // otherwise we are reloading data, so we must execute some cleans
+        // before loading the full data again
+        if (this.firstConnection) {
+          this.firstConnection = false;
+          const addressesToLoad = await (0, _storage.scanPolicyStartAddresses)(this.storage);
+          await this.syncHistory(addressesToLoad.nextIndex, addressesToLoad.count);
+        } else {
+          if (this.beforeReloadCallback) {
+            this.beforeReloadCallback();
+          }
+          await this.reloadStorage();
+        }
+        this.setState(HathorWallet.PROCESSING);
+      } catch (error) {
+        this.setState(HathorWallet.ERROR);
+        this.logger.error('Error loading wallet', {
+          error
+        });
+      }
+    } else if (this.walletStopped) {
+      this.setState(HathorWallet.CLOSED);
+    } else {
+      // Otherwise we just lost websocket connection
+      this.setState(HathorWallet.CONNECTING);
+    }
+  }
+
+  /**
+   * Sign and return all signatures of the inputs belonging to this wallet.
+   *
+   * @param {string} txHex hex representation of the transaction.
+   * @param {string} pin PIN to decrypt the private key
+   *
+   * @async
+   * @return {Promise<string>} serialized P2SHSignature data
+   *
+   * @memberof HathorWallet
+   * @inner
+   */
+  async getAllSignatures(txHex, pin) {
+    if (await this.isReadonly()) {
+      throw new _errors.WalletFromXPubGuard('getAllSignatures');
+    }
+    const tx = _helpers.default.createTxFromHex(txHex, this.getNetworkObject());
+    const accessData = await this.storage.getAccessData();
+    if (accessData === null) {
+      throw new Error('Wallet is not initialized');
+    }
+    const signatures = {};
+    for (const signatureInfo of await this.getSignatures(tx, {
+      pinCode: pin
+    })) {
+      const {
+        inputIndex,
+        signature
+      } = signatureInfo;
+      signatures[inputIndex] = signature;
+    }
+    const p2shSig = new _p2sh_signature.default(accessData.multisigData.pubkey, signatures);
+    return p2shSig.serialize();
+  }
+
+  /**
+   * Assemble transaction from hex and collected p2sh_signatures.
+   *
+   * @param {string} txHex hex representation of the transaction.
+   * @param {Array} signatures Array of serialized p2sh_signatures (string).
+   *
+   * @return {Promise<Transaction>} with input data created from the signatures.
+   *
+   * @throws {Error} if there are not enough signatures for an input
+   *
+   * @memberof HathorWallet
+   * @inner
+   */
+  async assemblePartialTransaction(txHex, signatures) {
+    const tx = _helpers.default.createTxFromHex(txHex, this.getNetworkObject());
+    const accessData = await this.storage.getAccessData();
+    if (accessData === null) {
+      throw new Error('Wallet was not started');
+    }
+    const {
+      multisigData
+    } = accessData;
+    if (!multisigData) {
+      throw new Error('Cannot call this method from a p2pkh wallet');
+    }
+
+    // Deserialize P2SHSignature for all signatures
+    // XXX: the .sort here is very important since the fullnode requires the signatures
+    // in the same order as the pubkeys in the redeemScript and the order chosen for the
+    // pubkeys is the order of the sorted account path pubkey (hex encoded). This sort
+    // only works because the serialized signature starts with the account path pubkey.
+    const p2shSignatures = signatures.sort().map(sig => _p2sh_signature.default.deserialize(sig));
+    var _iteratorAbruptCompletion = false;
+    var _didIteratorError = false;
+    var _iteratorError;
+    try {
+      for (var _iterator = _asyncIterator(this.storage.getSpentTxs(tx.inputs)), _step; _iteratorAbruptCompletion = !(_step = await _iterator.next()).done; _iteratorAbruptCompletion = false) {
+        const {
+          tx: spentTx,
+          input,
+          index
+        } = _step.value;
+        {
+          const spentUtxo = spentTx.outputs[input.index];
+          const storageAddress = await this.storage.getAddressInfo(spentUtxo.decoded.address);
+          if (storageAddress === null) {
+            // The transaction is on our history but this input is not ours
+            continue;
+          }
+          const redeemScript = (0, _scripts.createP2SHRedeemScript)(multisigData.pubkeys, multisigData.numSignatures, storageAddress.bip32AddressIndex);
+          const sigs = [];
+          for (const p2shSig of p2shSignatures) {
+            try {
+              sigs.push((0, _buffer.hexToBuffer)(p2shSig.signatures[index]));
+            } catch (e) {
+              // skip if there is no signature, or if it's not hex
+              continue;
+            }
+          }
+          const inputData = _wallet2.default.getP2SHInputData(sigs, redeemScript);
+          tx.inputs[index].setData(inputData);
+        }
+      }
+    } catch (err) {
+      _didIteratorError = true;
+      _iteratorError = err;
+    } finally {
+      try {
+        if (_iteratorAbruptCompletion && _iterator.return != null) {
+          await _iterator.return();
+        }
+      } finally {
+        if (_didIteratorError) {
+          throw _iteratorError;
+        }
+      }
+    }
+    return tx;
+  }
+
+  /**
+   * Return all addresses of the wallet with info of each of them
+   *
+   * @async
+   * @generator
+   * @returns {AsyncGenerator<{address: string, index: number, transactions: number}>} transactions is the count of txs for this address
+   * @memberof HathorWallet
+   * */
+  getAllAddresses() {
+    var _this = this;
+    return _wrapAsyncGenerator(function* () {
+      // We add the count of transactions
+      // in order to replicate the same return as the new
+      // wallet service facade
+      var _iteratorAbruptCompletion2 = false;
+      var _didIteratorError2 = false;
+      var _iteratorError2;
+      try {
+        for (var _iterator2 = _asyncIterator(_this.storage.getAllAddresses()), _step2; _iteratorAbruptCompletion2 = !(_step2 = yield _awaitAsyncGenerator(_iterator2.next())).done; _iteratorAbruptCompletion2 = false) {
+          const address = _step2.value;
+          {
+            yield {
+              address: address.base58,
+              index: address.bip32AddressIndex,
+              transactions: address.numTransactions
+            };
+          }
+        }
+      } catch (err) {
+        _didIteratorError2 = true;
+        _iteratorError2 = err;
+      } finally {
+        try {
+          if (_iteratorAbruptCompletion2 && _iterator2.return != null) {
+            yield _awaitAsyncGenerator(_iterator2.return());
+          }
+        } finally {
+          if (_didIteratorError2) {
+            throw _iteratorError2;
+          }
+        }
+      }
+    })();
+  }
+
+  /**
+   * Get address from specific derivation index
+   *
+   * @return {Promise<string>} Address
+   *
+   * @memberof HathorWallet
+   * @inner
+   */
+  async getAddressAtIndex(index) {
+    let address = await this.storage.getAddressAtIndex(index);
+    if (address === null) {
+      if ((await this.storage.getWalletType()) === 'p2pkh') {
+        address = await (0, _address.deriveAddressP2PKH)(index, this.storage);
+      } else {
+        address = await (0, _address.deriveAddressP2SH)(index, this.storage);
+      }
+      await this.storage.saveAddress(address);
+    }
+    return address.base58;
+  }
+
+  /**
+   * Get address path from specific derivation index
+   *
+   * @param {number} index Address path index
+   *
+   * @return {Promise<string>} Address path for the given index
+   *
+   * @memberof HathorWallet
+   * @inner
+   */
+  async getAddressPathForIndex(index) {
+    const walletType = await this.storage.getWalletType();
+    if (walletType === _types.WalletType.MULTISIG) {
+      // P2SH
+      return `${_constants.P2SH_ACCT_PATH}/0/${index}`;
+    }
+
+    // P2PKH
+    return `${_constants.P2PKH_ACCT_PATH}/0/${index}`;
+  }
+
+  /**
+   * Get address to be used in the wallet
+   *
+   * @param [options]
+   * @param {boolean} [options.markAsUsed=false] if true, we will locally mark this address as used
+   *                                             and won't return it again to be used
+   *
+   * @return {Promise<{ address:string, index:number, addressPath:string }>}
+   *
+   * @memberof HathorWallet
+   * @inner
+   */
+  async getCurrentAddress({
+    markAsUsed = false
+  } = {}) {
+    const address = await this.storage.getCurrentAddress(markAsUsed);
+    const index = await this.getAddressIndex(address);
+    const addressPath = await this.getAddressPathForIndex(index);
+    return {
+      address,
+      index,
+      addressPath
+    };
+  }
+
+  /**
+   * Get the next address after the current available
+   *
+   * @return {Promise<{ address:string, index:number, addressPath:string }>}
+   */
+  async getNextAddress() {
+    // First we mark the current address as used, then return the next
+    await this.getCurrentAddress({
+      markAsUsed: true
+    });
+    return this.getCurrentAddress();
+  }
+
+  /**
+   * Called when a new message arrives from websocket.
+   */
+  handleWebsocketMsg(wsData) {
+    if (wsData.type === 'wallet:address_history') {
+      if (this.state !== HathorWallet.READY) {
+        // Cannot process new transactions from ws when the wallet is not ready.
+        // So we will enqueue this message to be processed later
+        this.wsTxQueue.enqueue(wsData);
+      } else {
+        this.enqueueOnNewTx(wsData);
+      }
+    }
+  }
+
+  /**
+   * Get balance for a token
+   *
+   * @param {string|null|undefined} token
+   *
+   * @return {Promise<{
+   *   token: {id:string, name:string, symbol:string},
+   *   balance: {unlocked:bigint, locked:bigint},
+   *   transactions:number,
+   *   lockExpires:number|null,
+   *   tokenAuthorities: {unlocked: {mint:bigint,melt:bigint}, locked: {mint:bigint,melt:bigint}}
+   * }[]>} Array of balance for each token
+   *
+   * @memberof HathorWallet
+   * @inner
+   * */
+  async getBalance(token = null) {
+    // TODO if token is null we should get the balance for each token I have
+    // but we don't use it in the wallets, so I won't implement it
+    if (token === null) {
+      throw new _errors.WalletError('Not implemented.');
+    }
+    const uid = token || this.token.uid;
+    // Using clone deep so the balance returned will not be updated in case
+    // we change the storage
+    let tokenData = (0, _lodash.cloneDeep)(await this.storage.getToken(uid));
+    if (tokenData === null) {
+      // We don't have the token on storage, so we need to return an empty default response
+      tokenData = {
+        uid,
+        numTransactions: 0,
+        balance: {
+          tokens: {
+            unlocked: 0n,
+            locked: 0n
+          },
+          authorities: {
+            mint: {
+              unlocked: 0n,
+              locked: 0n
+            },
+            melt: {
+              unlocked: 0n,
+              locked: 0n
+            }
+          }
+        }
+      };
+    }
+    return [{
+      token: {
+        id: tokenData.uid,
+        name: tokenData.name,
+        symbol: tokenData.symbol
+      },
+      balance: tokenData.balance.tokens,
+      transactions: tokenData.numTransactions,
+      lockExpires: null,
+      tokenAuthorities: {
+        unlocked: {
+          mint: tokenData.balance.authorities.mint.unlocked,
+          melt: tokenData.balance.authorities.melt.unlocked
+        },
+        locked: {
+          mint: tokenData.balance.authorities.mint.locked,
+          melt: tokenData.balance.authorities.melt.locked
+        }
+      }
+    }];
+  }
+
+  /**
+   * Summarizes the IHistoryTx that comes from wallet token's history.
+   *
+   * @typedef {Object} SummaryHistoryTx
+   * @property {string} txId - Transaction hash
+   * @property {number} balance
+   * @property {number} timestamp
+   * @property {boolean} voided
+   * @property {number} version
+   * @property {string} [ncId] - Nano Contract transaction hash
+   * @property {string} [ncMethod] - Nano Contract method called
+   * @property {Address} [ncCaller] - Nano Contract transaction's signing address
+   * @property {string} [firstBlock] - Hash of the first block that validates the transaction
+   */
+
+  /**
+   * Get transaction history
+   *
+   * @param options
+   * @param {string} [options.token_id]
+   * @param {number} [options.count]
+   * @param {number} [options.skip]
+   *
+   * @return {Promise<SummaryHistoryTx[]>} Array of transactions
+   *
+   * @memberof HathorWallet
+   * @inner
+   */
+  async getTxHistory(options = {}) {
+    const newOptions = {
+      token_id: _constants.NATIVE_TOKEN_UID,
+      count: 15,
+      skip: 0,
+      ...options
+    };
+    const {
+      skip
+    } = newOptions;
+    let {
+      count
+    } = newOptions;
+    const uid = newOptions.token_id || this.token.uid;
+    const txs = [];
+    let it = 0;
+    var _iteratorAbruptCompletion3 = false;
+    var _didIteratorError3 = false;
+    var _iteratorError3;
+    try {
+      for (var _iterator3 = _asyncIterator(this.storage.tokenHistory(uid)), _step3; _iteratorAbruptCompletion3 = !(_step3 = await _iterator3.next()).done; _iteratorAbruptCompletion3 = false) {
+        const tx = _step3.value;
+        {
+          if (it < skip) {
+            it++;
+            continue;
+          }
+          if (count <= 0) {
+            break;
+          }
+          const txbalance = await this.getTxBalance(tx);
+          const txHistory = {
+            txId: tx.tx_id,
+            timestamp: tx.timestamp,
+            voided: tx.is_voided,
+            balance: txbalance[uid] || 0n,
+            version: tx.version,
+            ncId: tx.nc_id,
+            ncMethod: tx.nc_method,
+            ncCaller: tx.nc_address && new _address2.default(tx.nc_address, {
+              network: this.getNetworkObject()
+            }),
+            firstBlock: tx.first_block
+          };
+          if (tx.version === _constants.ON_CHAIN_BLUEPRINTS_VERSION) {
+            txHistory.ncCaller = tx.nc_pubkey && (0, _address.getAddressFromPubkey)(tx.nc_pubkey, this.getNetworkObject());
+          }
+          txs.push(txHistory);
+          count--;
+        }
+      }
+    } catch (err) {
+      _didIteratorError3 = true;
+      _iteratorError3 = err;
+    } finally {
+      try {
+        if (_iteratorAbruptCompletion3 && _iterator3.return != null) {
+          await _iterator3.return();
+        }
+      } finally {
+        if (_didIteratorError3) {
+          throw _iteratorError3;
+        }
+      }
+    }
+    return txs;
+  }
+
+  /**
+   * Get tokens that this wallet has transactions
+   *
+   * @return {Promise<string[]>} Array of strings (token uid)
+   *
+   * @memberof HathorWallet
+   * @inner
+   * */
+  async getTokens() {
+    const tokens = [];
+    var _iteratorAbruptCompletion4 = false;
+    var _didIteratorError4 = false;
+    var _iteratorError4;
+    try {
+      for (var _iterator4 = _asyncIterator(this.storage.getAllTokens()), _step4; _iteratorAbruptCompletion4 = !(_step4 = await _iterator4.next()).done; _iteratorAbruptCompletion4 = false) {
+        const token = _step4.value;
+        {
+          tokens.push(token.uid);
+        }
+      }
+    } catch (err) {
+      _didIteratorError4 = true;
+      _iteratorError4 = err;
+    } finally {
+      try {
+        if (_iteratorAbruptCompletion4 && _iterator4.return != null) {
+          await _iterator4.return();
+        }
+      } finally {
+        if (_didIteratorError4) {
+          throw _iteratorError4;
+        }
+      }
+    }
+    return tokens;
+  }
+
+  /**
+   * Get a transaction data from the wallet
+   *
+   * @param {string} id Hash of the transaction to get data from
+   *
+   * @return {Promise<DecodedTx|null>} Data from the transaction to get.
+   *                          Can be null if the wallet does not contain the tx.
+   */
+  async getTx(id) {
+    return this.storage.getTx(id);
+  }
+
+  /**
+   * @typedef AddressInfoOptions
+   * @property {string} token Optionally filter transactions by this token uid (Default: HTR)
+   */
+
+  /**
+   * @typedef AddressInfo
+   * @property {bigint} total_amount_received Sum of the amounts received
+   * @property {bigint} total_amount_sent Sum of the amounts sent
+   * @property {bigint} total_amount_available Amount available to transfer
+   * @property {bigint} total_amount_locked Amount locked and thus no available to transfer
+   * @property {number} token Token used to calculate the amounts received, sent, available and locked
+   * @property {number} index Derivation path for the given address
+   */
+
+  /**
+   * Get information of a given address
+   *
+   * @param {string} address Address to get information of
+   * @param {AddressInfoOptions} options Optional parameters to filter the results
+   *
+   * @returns {Promise<AddressInfo>} Aggregated information about the given address
+   *
+   */
+  async getAddressInfo(address, options = {}) {
+    const {
+      token = _constants.NATIVE_TOKEN_UID
+    } = options;
+
+    // Throws an error if the address does not belong to this wallet
+    if (!(await this.storage.isAddressMine(address))) {
+      throw new _errors.AddressError('Address does not belong to this wallet.');
+    }
+
+    // Derivation path index
+    const addressData = await this.storage.getAddressInfo(address);
+    const index = addressData.bip32AddressIndex;
+
+    // Address information that will be calculated below
+    const addressInfo = {
+      total_amount_received: 0n,
+      total_amount_sent: 0n,
+      total_amount_available: 0n,
+      total_amount_locked: 0n,
+      token,
+      index
+    };
+
+    // Iterate through transactions
+    var _iteratorAbruptCompletion5 = false;
+    var _didIteratorError5 = false;
+    var _iteratorError5;
+    try {
+      for (var _iterator5 = _asyncIterator(this.storage.txHistory()), _step5; _iteratorAbruptCompletion5 = !(_step5 = await _iterator5.next()).done; _iteratorAbruptCompletion5 = false) {
+        const tx = _step5.value;
+        {
+          // Voided transactions should be ignored
+          if (tx.is_voided) {
+            continue;
+          }
+
+          // Iterate through outputs
+          for (const output of tx.outputs) {
+            const is_address_valid = output.decoded && output.decoded.address === address;
+            const is_token_valid = token === output.token;
+            const is_authority = _transaction.default.isAuthorityOutput(output);
+            if (!is_address_valid || !is_token_valid || is_authority) {
+              continue;
+            }
+            const is_spent = output.spent_by !== null;
+            const is_time_locked = _transaction.default.isOutputLocked(output);
+            // XXX: we currently do not check heightlock on the helper, checking here for compatibility
+            const nowHeight = await this.storage.getCurrentHeight();
+            const rewardLock = this.storage.version?.reward_spend_min_blocks;
+            const is_height_locked = _transaction.default.isHeightLocked(tx.height, nowHeight, rewardLock);
+            const is_locked = is_time_locked || is_height_locked;
+            addressInfo.total_amount_received += output.value;
+            if (is_spent) {
+              addressInfo.total_amount_sent += output.value;
+              continue;
+            }
+            if (is_locked) {
+              addressInfo.total_amount_locked += output.value;
+            } else {
+              addressInfo.total_amount_available += output.value;
+            }
+          }
+        }
+      }
+    } catch (err) {
+      _didIteratorError5 = true;
+      _iteratorError5 = err;
+    } finally {
+      try {
+        if (_iteratorAbruptCompletion5 && _iterator5.return != null) {
+          await _iterator5.return();
+        }
+      } finally {
+        if (_didIteratorError5) {
+          throw _iteratorError5;
+        }
+      }
+    }
+    return addressInfo;
+  }
+
+  /**
+   *
+   * @typedef UtxoOptions
+   * @property {number} [max_utxos] - Maximum number of utxos to aggregate. Default to MAX_INPUTS (255).
+   * @property {string} [token] - Token to filter the utxos. If not sent, we select only HTR utxos.
+   * @property {number} [authorities] - Authorities to filter the utxos. If not sent, we select only non authority utxos.
+   * @property {string} [filter_address] - Address to filter the utxos.
+   * @property {bigint} [amount_smaller_than] - Maximum limit of utxo amount to filter the utxos list. We will consolidate only utxos that have an amount lower than or equal to this value. Integer representation of decimals, i.e. 100 = 1.00.
+   * @property {bigint} [amount_bigger_than] - Minimum limit of utxo amount to filter the utxos list. We will consolidate only utxos that have an amount bigger than or equal to this value. Integer representation of decimals, i.e. 100 = 1.00.
+   * @property {bigint} [max_amount] - Limit the maximum total amount to consolidate summing all utxos. Integer representation of decimals, i.e. 100 = 1.00.
+   * @property {boolean} [only_available_utxos] - Use only available utxos (not locked)
+   */
+
+  /**
+   * @typedef UtxoInfo
+   * @property {string} address - Address that owns the UTXO.
+   * @property {bigint} amount - Amount of tokens.
+   * @property {string} tx_id - Original transaction id.
+   * @property {boolean} locked - If the output is currently locked.
+   * @property {number} index - Index on the output array of the original tx.
+   */
+
+  /**
+   * @typedef UtxoDetails
+   * @property {bigint} total_amount_available - Maximum number of utxos to aggregate. Default to MAX_INPUTS (255).
+   * @property {bigint} total_utxos_available - Token to filter the utxos. If not sent, we select only HTR utxos.
+   * @property {bigint} total_amount_locked - Address to filter the utxos.
+   * @property {bigint} total_utxos_locked - Maximum limit of utxo amount to filter the utxos list. We will consolidate only utxos that have an amount lower than this value. Integer representation of decimals, i.e. 100 = 1.00.
+   * @property {UtxoInfo[]} utxos - Array of utxos
+   */
+
+  /**
+   * Get utxos of the wallet addresses
+   *
+   * @param {UtxoOptions} options Utxo filtering options
+   *
+   * @return {Promise<UtxoDetails>} Utxos and meta information about it
+   *
+   */
+  async getUtxos(options = {}) {
+    const newOptions = {
+      token: options.token,
+      authorities: 0,
+      max_utxos: options.max_utxos,
+      filter_address: options.filter_address,
+      amount_smaller_than: options.amount_smaller_than,
+      amount_bigger_than: options.amount_bigger_than,
+      max_amount: options.max_amount,
+      only_available_utxos: options.only_available_utxos
+    };
+    /** @type {UtxoDetails} */
+    const utxoDetails = {
+      total_amount_available: 0n,
+      total_utxos_available: 0n,
+      total_amount_locked: 0n,
+      total_utxos_locked: 0n,
+      utxos: []
+    };
+    const nowTs = Math.floor(Date.now() / 1000);
+    const isTimeLocked = timestamp => timestamp && nowTs && nowTs < timestamp;
+    const nowHeight = await this.storage.getCurrentHeight();
+    const rewardLock = this.storage.version?.reward_spend_min_blocks;
+    var _iteratorAbruptCompletion6 = false;
+    var _didIteratorError6 = false;
+    var _iteratorError6;
+    try {
+      for (var _iterator6 = _asyncIterator(this.storage.selectUtxos(newOptions)), _step6; _iteratorAbruptCompletion6 = !(_step6 = await _iterator6.next()).done; _iteratorAbruptCompletion6 = false) {
+        const utxo = _step6.value;
+        {
+          const isLocked = isTimeLocked(utxo.timelock) || _transaction.default.isHeightLocked(utxo.height, nowHeight, rewardLock);
+          const utxoInfo = {
+            address: utxo.address,
+            amount: utxo.value,
+            tx_id: utxo.txId,
+            locked: !!isLocked,
+            index: utxo.index
+          };
+          utxoDetails.utxos.push(utxoInfo);
+          if (isLocked) {
+            utxoDetails.total_amount_locked += utxo.value;
+            utxoDetails.total_utxos_locked += 1n;
+          } else {
+            utxoDetails.total_amount_available += utxo.value;
+            utxoDetails.total_utxos_available += 1n;
+          }
+        }
+      }
+    } catch (err) {
+      _didIteratorError6 = true;
+      _iteratorError6 = err;
+    } finally {
+      try {
+        if (_iteratorAbruptCompletion6 && _iterator6.return != null) {
+          await _iterator6.return();
+        }
+      } finally {
+        if (_didIteratorError6) {
+          throw _iteratorError6;
+        }
+      }
+    }
+    return utxoDetails;
+  }
+
+  /**
+   * @typedef Utxo
+   * @property {string} txId
+   * @property {number} index
+   * @property {string} tokenId
+   * @property {string} address
+   * @property {string} value
+   * @property {OutputValueType} authorities
+   * @property {number|null} timelock
+   * @property {number|null} heightlock
+   * @property {boolean} locked
+   * @property {string} addressPath
+   */
+
+  /**
+   * Generates all available utxos
+   *
+   * @param [options] Utxo filtering options
+   * @param {string} [options.token='00'] - Search for UTXOs of this token UID.
+   * @param {string|null} [options.filter_address=null] - Address to filter the utxos.
+   *
+   * @async
+   * @generator
+   * @yields {Utxo} all available utxos
+   */
+  getAvailableUtxos(options = {}) {
+    var _this2 = this;
+    return _wrapAsyncGenerator(function* () {
+      // This method only returns available utxos
+      var _iteratorAbruptCompletion7 = false;
+      var _didIteratorError7 = false;
+      var _iteratorError7;
+      try {
+        for (var _iterator7 = _asyncIterator(_this2.storage.selectUtxos({
+            ...options,
+            only_available_utxos: true
+          })), _step7; _iteratorAbruptCompletion7 = !(_step7 = yield _awaitAsyncGenerator(_iterator7.next())).done; _iteratorAbruptCompletion7 = false) {
+          const utxo = _step7.value;
+          {
+            const addressIndex = yield _awaitAsyncGenerator(_this2.getAddressIndex(utxo.address));
+            const addressPath = yield _awaitAsyncGenerator(_this2.getAddressPathForIndex(addressIndex));
+            yield {
+              txId: utxo.txId,
+              index: utxo.index,
+              tokenId: utxo.token,
+              address: utxo.address,
+              value: utxo.value,
+              authorities: utxo.authorities,
+              timelock: utxo.timelock,
+              heightlock: null,
+              locked: false,
+              addressPath
+            };
+          }
+        }
+      } catch (err) {
+        _didIteratorError7 = true;
+        _iteratorError7 = err;
+      } finally {
+        try {
+          if (_iteratorAbruptCompletion7 && _iterator7.return != null) {
+            yield _awaitAsyncGenerator(_iterator7.return());
+          }
+        } finally {
+          if (_didIteratorError7) {
+            throw _iteratorError7;
+          }
+        }
+      }
+    })();
+  }
+
+  /**
+   * Get utxos of the wallet addresses to fill the amount specified.
+   *
+   * @param {Object} [options] Utxo filtering options
+   * @param {string} [options.token='00'] - Search for UTXOs of this token UID.
+   * @param {string|null} [options.filter_address=null] - Address to filter the utxos.
+   *
+   * @return {Promise<{utxos: Utxo[], changeAmount: OutputValueType}>} Utxos and change information.
+   */
+  async getUtxosForAmount(amount, options = {}) {
+    const newOptions = {
+      token: _constants.NATIVE_TOKEN_UID,
+      filter_address: null,
+      ...options,
+      order_by_value: 'desc'
+    };
+    const utxos = [];
+    var _iteratorAbruptCompletion8 = false;
+    var _didIteratorError8 = false;
+    var _iteratorError8;
+    try {
+      for (var _iterator8 = _asyncIterator(this.getAvailableUtxos(newOptions)), _step8; _iteratorAbruptCompletion8 = !(_step8 = await _iterator8.next()).done; _iteratorAbruptCompletion8 = false) {
+        const utxo = _step8.value;
+        {
+          utxos.push(utxo);
+        }
+      }
+    } catch (err) {
+      _didIteratorError8 = true;
+      _iteratorError8 = err;
+    } finally {
+      try {
+        if (_iteratorAbruptCompletion8 && _iterator8.return != null) {
+          await _iterator8.return();
+        }
+      } finally {
+        if (_didIteratorError8) {
+          throw _iteratorError8;
+        }
+      }
+    }
+    return _transaction.default.selectUtxos(utxos.filter(utxo => utxo.authorities === 0n), amount);
+  }
+
+  /**
+   * Mark UTXO selected_as_input.
+   *
+   * @param {string} txId Transaction id of the UTXO
+   * @param {number} index Output index of the UTXO
+   * @param {boolean} [value=true] The value to set the utxos.
+   * @param {number?} [ttl=null]
+   */
+  async markUtxoSelected(txId, index, value = true, ttl = null) {
+    await this.storage.utxoSelectAsInput({
+      txId,
+      index
+    }, value, ttl);
+  }
+
+  /**
+   * Prepare all required data to consolidate utxos.
+   *
+   * @typedef {Object} PrepareConsolidateUtxosDataResult
+   * @property {{ address: string, value: OutputValueType }[]} outputs - Destiny of the consolidated utxos
+   * @property {{ hash: string, index: number }[]} inputs - Inputs for the consolidation transaction
+   * @property {{ uid: string, name: string, symbol: string }} token - HTR or custom token
+   * @property {UtxoInfo[]} utxos - Array of utxos that will be consolidated
+   * @property {bigint} total_amount - Amount to be consolidated
+   *
+   * @param {string} destinationAddress Address of the consolidated utxos
+   * @param {UtxoOptions} options Utxo filtering options
+   *
+   * @return {Promise<PrepareConsolidateUtxosDataResult>} Required data to consolidate utxos
+   *
+   */
+  async prepareConsolidateUtxosData(destinationAddress, options = {}) {
+    const utxoDetails = await this.getUtxos({
+      ...options,
+      only_available_utxos: true
+    });
+    const inputs = [];
+    const utxos = [];
+    let total_amount = 0n;
+    for (let i = 0; i < utxoDetails.utxos.length; i++) {
+      if (inputs.length === this.storage.version.max_number_inputs) {
+        // Max number of inputs reached
+        break;
+      }
+      const utxo = utxoDetails.utxos[i];
+      inputs.push({
+        txId: utxo.tx_id,
+        index: utxo.index
+      });
+      utxos.push(utxo);
+      total_amount += utxo.amount;
+    }
+    const outputs = [{
+      address: destinationAddress,
+      value: total_amount,
+      token: options.token || _constants.NATIVE_TOKEN_UID
+    }];
+    return {
+      outputs,
+      inputs,
+      utxos,
+      total_amount
+    };
+  }
+
+  /**
+   * @typedef ConsolidationResultSendTx
+   * @property {number} total_utxos_consolidated - Number of utxos consolidated
+   * @property {bigint} total_amount - Consolidated amount
+   * @property {SendTransaction} sendTx - instance that will send the transaction.
+   * @property {UtxoInfo[]} utxos - Array of consolidated utxos
+   */
+
+  /**
+   * Consolidates many utxos into a single one for either HTR or exactly one custom token.
+   *
+   * @param {string} destinationAddress Address of the consolidated utxos
+   * @param {UtxoOptions} options Utxo filtering options
+   *
+   * @return {Promise<ConsolidationResultSendTx>}
+   *
+   */
+  async consolidateUtxosSendTransaction(destinationAddress, options = {}) {
+    if (await this.isReadonly()) {
+      throw new _errors.WalletFromXPubGuard('consolidateUtxos');
+    }
+    const {
+      outputs,
+      inputs,
+      utxos,
+      total_amount
+    } = await this.prepareConsolidateUtxosData(destinationAddress, options);
+    if (!(await this.isAddressMine(destinationAddress))) {
+      throw new Error("Utxo consolidation to an address not owned by this wallet isn't allowed.");
+    }
+    if (inputs.length === 0) {
+      throw new Error('No available utxo to consolidate.');
+    }
+    const sendTx = await this.sendManyOutputsSendTransaction(outputs, {
+      inputs
+    });
+    return {
+      total_utxos_consolidated: utxos.length,
+      total_amount,
+      utxos,
+      sendTx
+    };
+  }
+
+  /**
+   * @typedef ConsolidationResult
+   * @property {number} total_utxos_consolidated - Number of utxos consolidated
+   * @property {bigint} total_amount - Consolidated amount
+   * @property {string} txId - Consolidated transaction id
+   * @property {UtxoInfo[]} utxos - Array of consolidated utxos
+   */
+
+  /**
+   * Consolidates many utxos into a single one for either HTR or exactly one custom token.
+   *
+   * @param {string} destinationAddress Address of the consolidated utxos
+   * @param {UtxoOptions} options Utxo filtering options
+   *
+   * @return {Promise<ConsolidationResult>} Indicates that the transaction is sent or not
+   *
+   */
+  async consolidateUtxos(destinationAddress, options = {}) {
+    const {
+      total_utxos_consolidated,
+      total_amount,
+      sendTx,
+      utxos
+    } = await this.consolidateUtxosSendTransaction(destinationAddress, options);
+    const tx = await sendTx.run();
+    return {
+      total_utxos_consolidated,
+      total_amount,
+      txId: tx.hash,
+      utxos
+    };
+  }
+
+  /**
+   * @typedef DecodedTx
+   * @property {string} tx_id
+   * @property {number} version
+   * @property {number} weight
+   * @property {number} timestamp
+   * @property {boolean} is_voided
+   * @property {{
+   *   value: OutputValueType,
+   *   token_data: number,
+   *   script: string,
+   *   decoded: { type: string, address: string, timelock: number|null },
+   *   token: string,
+   *   tx_id: string,
+   *   index: number
+   * }[]} inputs
+   * @property {{
+   *   value: OutputValueType,
+   *   token_data: number,
+   *   script: string,
+   *   decoded: { type: string, address: string, timelock: number|null },
+   *   token: string,
+   *   spent_by: string|null,
+   *   selected_as_input?: boolean
+   * }[]} outputs
+   * @property {string[]} parents
+   */
+
+  /**
+   * Get full wallet history (same as old method to be used for compatibility)
+   *
+   * @return {Promise<Record<string,DecodedTx>>} Object with transaction data { tx_id: { full_transaction_data }}
+   *
+   * @memberof HathorWallet
+   * @inner
+   * */
+  async getFullHistory() {
+    const history = {};
+    var _iteratorAbruptCompletion9 = false;
+    var _didIteratorError9 = false;
+    var _iteratorError9;
+    try {
+      for (var _iterator9 = _asyncIterator(this.storage.txHistory()), _step9; _iteratorAbruptCompletion9 = !(_step9 = await _iterator9.next()).done; _iteratorAbruptCompletion9 = false) {
+        const tx = _step9.value;
+        {
+          history[tx.tx_id] = tx;
+        }
+      }
+    } catch (err) {
+      _didIteratorError9 = true;
+      _iteratorError9 = err;
+    } finally {
+      try {
+        if (_iteratorAbruptCompletion9 && _iterator9.return != null) {
+          await _iterator9.return();
+        }
+      } finally {
+        if (_didIteratorError9) {
+          throw _iteratorError9;
+        }
+      }
+    }
+    return history;
+  }
+
+  /**
+   * Process the transactions on the websocket transaction queue as if they just arrived.
+   *
+   * @memberof HathorWallet
+   * @inner
+   */
+  async processTxQueue() {
+    let wsData = this.wsTxQueue.dequeue();
+    while (wsData !== undefined) {
+      // save new txdata
+      await this.onNewTx(wsData);
+      wsData = this.wsTxQueue.dequeue();
+      // We should release the event loop for other threads
+      // This effectively awaits 0 seconds
+      // but it schedule the next iteration to run after other threads.
+      await new Promise(resolve => {
+        setTimeout(resolve, 0);
+      });
+    }
+    await this.storage.processHistory();
+  }
+
+  /**
+   * Check if we need to load more addresses and load them if needed.
+   * The configured scanning policy will be used to determine the loaded addresses.
+   * @param {boolean} processHistory If we should process the txs found on the loaded addresses.
+   *
+   * @returns {Promise<void>}
+   */
+  async scanAddressesToLoad(processHistory = false) {
+    // check address scanning policy and load more addresses if needed
+    const loadMoreAddresses = await (0, _storage.checkScanningPolicy)(this.storage);
+    if (loadMoreAddresses !== null) {
+      await this.syncHistory(loadMoreAddresses.nextIndex, loadMoreAddresses.count, processHistory);
+    }
+  }
+
+  /**
+   * Call the method to process data and resume with the correct state after processing.
+   *
+   * @returns {Promise} A promise that resolves when the wallet is done processing the tx queue.
+   */
+  async onEnterStateProcessing() {
+    // Started processing state now, so we prepare the local data to support using this facade interchangable with wallet service facade in both wallets
+    try {
+      await this.processTxQueue();
+      this.setState(HathorWallet.READY);
+    } catch (e) {
+      this.setState(HathorWallet.ERROR);
+    }
+  }
+  setState(state) {
+    if (state === HathorWallet.PROCESSING && state !== this.state) {
+      // XXX: will not await this so we can process history on background.
+      this.onEnterStateProcessing().catch(e => {
+        this.logger.error(e);
+        this.setState(HathorWallet.ERROR);
+      });
+    }
+    this.state = state;
+    this.emit('state', state);
+  }
+
+  /**
+   * Enqueue the call for onNewTx with the given data.
+   * @param {{ history: import('../types').IHistoryTx }} wsData
+   */
+  enqueueOnNewTx(wsData) {
+    this.newTxPromise = this.newTxPromise.then(() => this.onNewTx(wsData));
+  }
+
+  /**
+   * @param {{ history: import('../types').IHistoryTx }} wsData
+   */
+  async onNewTx(wsData) {
+    const parseResult = _schemas.IHistoryTxSchema.safeParse(wsData.history);
+    if (!parseResult.success) {
+      this.logger.error(parseResult.error);
+      return;
+    }
+    const newTx = parseResult.data;
+    // Later we will compare the storageTx and the received tx.
+    // To avoid reference issues we clone the current storageTx.
+    const storageTx = (0, _lodash.cloneDeep)(await this.storage.getTx(newTx.tx_id));
+    const isNewTx = storageTx === null;
+    newTx.processingStatus = _types.TxHistoryProcessingStatus.PROCESSING;
+    await this.storage.addTx(newTx);
+    await this.scanAddressesToLoad();
+
+    // set state to processing and save current state.
+    const previousState = this.state;
+    this.state = HathorWallet.PROCESSING;
+    if (isNewTx) {
+      // Process this single transaction.
+      // Handling new metadatas and deleting utxos that are not available anymore
+      await this.storage.processNewTx(newTx);
+    } else if (storageTx.is_voided !== newTx.is_voided) {
+      // This is a voided transaction update event.
+      // voided transactions require a full history reprocess.
+      await this.storage.processHistory();
+    } else {
+      // Process other types of metadata updates.
+      await (0, _storage.processMetadataChanged)(this.storage, newTx);
+    }
+    // restore previous state
+    this.state = previousState;
+    newTx.processingStatus = _types.TxHistoryProcessingStatus.FINISHED;
+    // Save the transaction in the storage
+    await this.storage.addTx(newTx);
+    if (isNewTx) {
+      this.emit('new-tx', newTx);
+    } else {
+      this.emit('update-tx', newTx);
+    }
+  }
+
+  /**
+   * Send a transaction with a single output
+   *
+   * @param {string} address Output address
+   * @param {bigint} value Output value
+   * @param [options] Options parameters
+   * @param {string} [options.changeAddress] address of the change output
+   * @param {string} [options.token] token uid
+   * @param {string} [options.pinCode] pin to decrypt the private key
+   *
+   * @return {Promise<SendTransaction>} Promise that resolves when transaction is sent
+   */
+  async sendTransactionInstance(address, value, options = {}) {
+    if (await this.isReadonly()) {
+      throw new _errors.WalletFromXPubGuard('sendTransaction');
+    }
+    const newOptions = {
+      token: '00',
+      changeAddress: null,
+      ...options
+    };
+    const {
+      token,
+      changeAddress,
+      pinCode
+    } = newOptions;
+    const outputs = [{
+      address,
+      value,
+      token
+    }];
+    return this.sendManyOutputsSendTransaction(outputs, {
+      inputs: [],
+      changeAddress,
+      pinCode
+    });
+  }
+
+  /**
+   * Send a transaction with a single output
+   *
+   * @param {string} address Output address
+   * @param {bigint} value Output value
+   * @param [options] Options parameters
+   * @param {string} [options.changeAddress] address of the change output
+   * @param {string} [options.token] token uid
+   * @param {string} [options.pinCode] pin to decrypt the private key
+   *
+   * @return {Promise<Transaction>} Promise that resolves when transaction is sent
+   */
+  async sendTransaction(address, value, options = {}) {
+    const sendTx = await this.sendTransactionInstance(address, value, options);
+    return sendTx.run();
+  }
+
+  /**
+   * @typedef {Object} ProposedOutput
+   * @property {string} address
+   * @property {import('../types').OutputValueType} value
+   * @property {number?} timelock
+   * @property {string} token
+   */
+
+  /**
+   * @typedef {Object} ProposedInput
+   * @property {string} txId
+   * @property {number} index
+   * @property {string} token
+   */
+
+  /**
+   * @typedef {Object} SendManyOutputsOptions
+   * @property {ProposedInput[]?} inputs Array of proposed inputs
+   * @property  {string?} [changeAddress] address of the change output
+   * @property  {boolean?} [startMiningTx=true] to trigger start mining
+   * @property  {string?} [pinCode] pin to decrypt xpriv information.
+   */
+
+  /**
+   * Create a SendTransaction instance to send a transaction with possibly multiple outputs.
+   *
+   * @param {ProposedOutput[]} outputs Array of proposed outputs
+   * @param {SendManyOutputsOptions?} [options={}]
+   *
+   * @return {Promise<SendTransaction>}
+   */
+  async sendManyOutputsSendTransaction(outputs, options = {}) {
+    if (await this.isReadonly()) {
+      throw new _errors.WalletFromXPubGuard('sendManyOutputsTransaction');
+    }
+    const newOptions = {
+      inputs: [],
+      changeAddress: null,
+      startMiningTx: true,
+      pinCode: null,
+      ...options
+    };
+    const pin = newOptions.pinCode || this.pinCode;
+    if (!pin) {
+      throw new Error(ERROR_MESSAGE_PIN_REQUIRED);
+    }
+    const {
+      inputs,
+      changeAddress
+    } = newOptions;
+    return new _sendTransaction.default({
+      wallet: this,
+      outputs,
+      inputs,
+      changeAddress,
+      pin
+    });
+  }
+
+  /**
+   * Send a transaction from its outputs
+   *
+   * @param {ProposedOutput[]} outputs Array of proposed outputs
+   * @param {SendManyOutputsOptions?} [options={}]
+   *
+   * @return {Promise<Transaction>} Promise that resolves when transaction is sent
+   */
+  async sendManyOutputsTransaction(outputs, options = {}) {
+    const sendTransaction = await this.sendManyOutputsSendTransaction(outputs, options);
+    return sendTransaction.run();
+  }
+
+  /**
+   * Connect to the server and start emitting events.
+   *
+   * @param {Object} optionsParams Options parameters
+   *  {
+   *   'pinCode': pin to decrypt xpriv information. Required if not set in object.
+   *   'password': password to decrypt xpriv information. Required if not set in object.
+   *  }
+   */
+  async start(optionsParams = {}) {
+    const options = {
+      pinCode: null,
+      password: null,
+      ...optionsParams
+    };
+    const pinCode = options.pinCode || this.pinCode;
+    const password = options.password || this.password;
+    if (!this.xpub && !pinCode) {
+      throw new Error(ERROR_MESSAGE_PIN_REQUIRED);
+    }
+    if (this.seed && !password) {
+      throw new Error('Password is required.');
+    }
+
+    // Check database consistency
+    await this.storage.store.validate();
+    await this.storage.setScanningPolicyData(this.scanPolicy || null);
+    this.storage.config.setNetwork(this.conn.network);
+    this.storage.config.setServerUrl(this.conn.getCurrentServer());
+    this.conn.on('state', this.onConnectionChangedState);
+    this.conn.on('wallet-update', this.handleWebsocketMsg);
+    if (this.preCalculatedAddresses) {
+      for (const [index, addr] of this.preCalculatedAddresses.entries()) {
+        await this.storage.saveAddress({
+          base58: addr,
+          bip32AddressIndex: index
+        });
+      }
+    }
+    let accessData = await this.storage.getAccessData();
+    if (!accessData) {
+      if (this.seed) {
+        accessData = _wallet2.default.generateAccessDataFromSeed(this.seed, {
+          multisig: this.multisig,
+          passphrase: this.passphrase,
+          pin: pinCode,
+          password,
+          networkName: this.conn.network
+        });
+      } else if (this.xpriv) {
+        accessData = _wallet2.default.generateAccessDataFromXpriv(this.xpriv, {
+          multisig: this.multisig,
+          pin: pinCode
+        });
+      } else if (this.xpub) {
+        accessData = _wallet2.default.generateAccessDataFromXpub(this.xpub, {
+          multisig: this.multisig
+        });
+      } else {
+        throw new Error('This should never happen');
+      }
+      await this.storage.saveAccessData(accessData);
+    }
+    this.clearSensitiveData();
+    this.getTokenData();
+    this.walletStopped = false;
+    this.setState(HathorWallet.CONNECTING);
+    const info = await new Promise((resolve, reject) => {
+      _version.default.getVersion(resolve).catch(error => reject(error));
+    });
+    if (info.network.indexOf(this.conn.network) >= 0) {
+      this.storage.setApiVersion(info);
+      await this.storage.saveNativeToken();
+      this.conn.start();
+    } else {
+      this.setState(HathorWallet.CLOSED);
+      throw new Error(`Wrong network. server=${info.network} expected=${this.conn.network}`);
+    }
+    return info;
+  }
+
+  /**
+   * Close the connections and stop emitting events.
+   */
+  async stop({
+    cleanStorage = true,
+    cleanAddresses = false,
+    cleanTokens = false
+  } = {}) {
+    this.setState(HathorWallet.CLOSED);
+    this.removeAllListeners();
+    await this.storage.handleStop({
+      connection: this.conn,
+      cleanStorage,
+      cleanAddresses,
+      cleanTokens
+    });
+    this.firstConnection = true;
+    this.walletStopped = true;
+    this.conn.stop();
+  }
+
+  /**
+   * Returns an address' HDPrivateKey given an index and the encryption password
+   *
+   * @param {string} pinCode - The PIN used to encrypt data in accessData
+   * @param {number} addressIndex - The address' index to fetch
+   *
+   * @returns {Promise<HDPrivateKey>} Promise that resolves with the HDPrivateKey
+   *
+   * @memberof HathorWallet
+   * @inner
+   */
+  async getAddressPrivKey(pinCode, addressIndex) {
+    const mainXPrivKey = await this.storage.getMainXPrivKey(pinCode);
+    const addressHDPrivKey = new _bitcoreLib.default.HDPrivateKey(mainXPrivKey).derive(addressIndex);
+    return addressHDPrivKey;
+  }
+
+  /**
+   * Returns a base64 encoded signed message with an address' private key given an
+   * andress index
+   *
+   * @param {string} message - The message to sign
+   * @param {number} index - The address index to sign with
+   * @param {string} pinCode - The PIN used to encrypt data in accessData
+   *
+   * @return {Promise} Promise that resolves with the signed message
+   *
+   * @memberof HathorWallet
+   * @inner
+   */
+  async signMessageWithAddress(message, index, pinCode) {
+    const addressHDPrivKey = await this.getAddressPrivKey(pinCode, index);
+    const signedMessage = (0, _crypto.signMessage)(message, addressHDPrivKey.privateKey);
+    return signedMessage;
+  }
+
+  /**
+   * Create SendTransaction object and run from mining
+   * Returns a promise that resolves when the send succeeds
+   *
+   * @param {Transaction} transaction Transaction object to be mined and pushed to the network
+   *
+   * @return {Promise<Transaction|CreateTokenTransaction>} Promise that resolves with transaction object if succeeds
+   * or with error message if it fails
+   *
+   * @memberof HathorWallet
+   * @inner
+   * @deprecated
+   */
+  async handleSendPreparedTransaction(transaction) {
+    const sendTransaction = new _sendTransaction.default({
+      wallet: this,
+      transaction
+    });
+    return sendTransaction.runFromMining();
+  }
+
+  /**
+   * @typedef {Object} CreateTokenOptions
+   *
+   * @property {string?} [address] address of the minted token
+   * @property {string?} [changeAddress] address of the change output
+   * @property {boolean?} [startMiningTx=true] trigger start mining
+   * @property {string?} [pinCode] pin to decrypt xpriv information.
+   * @property {boolean?} [createMint=true] should create mint authority
+   * @property {string?} [mintAuthorityAddress] the address to send the mint authority created
+   * @property {boolean?} [allowExternalMintAuthorityAddress=false] allow the mint authority address to be from another wallet
+   * @property {boolean?} [createMelt=true] should create melt authority
+   * @property {string?} [meltAuthorityAddress] the address to send the melt authority created
+   * @property {boolean?} [allowExternalMeltAuthorityAddress=false] allow the melt authority address
+   *                                                                    to be from another wallet
+   * @property {string[]?} [data=null] list of data strings using utf8 encoding to add each as a data script output
+   * @property {boolean?} [signTx=true] sign transaction instance
+   * @property {boolean?} [isCreateNFT=false] if the create token is an NFT creation call
+   */
+
+  /**
+   * Prepare create token transaction data before mining
+   *
+   * @param {string} name Name of the token
+   * @param {string} symbol Symbol of the token
+   * @param {OutputValueType} amount Quantity of the token to be minted
+   * @param {CreateTokenOptions} [options] Options parameters
+   *
+   * @return {Promise<CreateTokenTransaction>} Promise that resolves with transaction object if succeeds
+   * or with error message if it fails
+   *
+   * @memberof HathorWallet
+   * @inner
+   */
+  async prepareCreateNewToken(name, symbol, amount, options = {}) {
+    if (await this.isReadonly()) {
+      throw new _errors.WalletFromXPubGuard('createNewToken');
+    }
+    const newOptions = {
+      address: null,
+      changeAddress: null,
+      startMiningTx: true,
+      pinCode: null,
+      createMint: true,
+      mintAuthorityAddress: null,
+      allowExternalMintAuthorityAddress: false,
+      createMelt: true,
+      meltAuthorityAddress: null,
+      allowExternalMeltAuthorityAddress: false,
+      data: null,
+      isCreateNFT: false,
+      signTx: true,
+      ...options
+    };
+    const pin = newOptions.pinCode || this.pinCode;
+    if (!pin) {
+      throw new Error(ERROR_MESSAGE_PIN_REQUIRED);
+    }
+    if (newOptions.mintAuthorityAddress && !newOptions.allowExternalMintAuthorityAddress) {
+      // Validate that the mint authority address belongs to the wallet
+      const isAddressMine = await this.isAddressMine(newOptions.mintAuthorityAddress);
+      if (!isAddressMine) {
+        throw new Error('The mint authority address must belong to your wallet.');
+      }
+    }
+    if (newOptions.meltAuthorityAddress && !newOptions.allowExternalMeltAuthorityAddress) {
+      // Validate that the melt authority address belongs to the wallet
+      const isAddressMine = await this.isAddressMine(newOptions.meltAuthorityAddress);
+      if (!isAddressMine) {
+        throw new Error('The melt authority address must belong to your wallet.');
+      }
+    }
+    const mintAddress = newOptions.address || (await this.getCurrentAddress()).address;
+    const txData = await _tokens.default.prepareCreateTokenData(mintAddress, name, symbol, amount, this.storage, {
+      changeAddress: newOptions.changeAddress,
+      createMint: newOptions.createMint,
+      mintAuthorityAddress: newOptions.mintAuthorityAddress,
+      createMelt: newOptions.createMelt,
+      meltAuthorityAddress: newOptions.meltAuthorityAddress,
+      data: newOptions.data,
+      isCreateNFT: newOptions.isCreateNFT
+    });
+    return _transaction.default.prepareTransaction(txData, pin, this.storage, {
+      signTx: newOptions.signTx
+    });
+  }
+
+  /**
+   * Builds a SendTransaction instance that will create a new token for this wallet
+   *
+   * @param {string} name Name of the token
+   * @param {string} symbol Symbol of the token
+   * @param {OutputValueType} amount Quantity of the token to be minted
+   * @param {CreateTokenOptions} [options] Options parameters
+   *
+   * @return {Promise<SendTransaction>}
+   * @memberof HathorWallet
+   * @inner
+   * */
+  async createNewTokenSendTransaction(name, symbol, amount, options = {}) {
+    const transaction = await this.prepareCreateNewToken(name, symbol, amount, options);
+    return new _sendTransaction.default({
+      wallet: this,
+      transaction
+    });
+  }
+
+  /**
+   * Create a new token for this wallet
+   *
+   * @param {string} name Name of the token
+   * @param {string} symbol Symbol of the token
+   * @param {OutputValueType} amount Quantity of the token to be minted
+   * @param {CreateTokenOptions} [options] Options parameters
+   *
+   * @return {Promise<CreateTokenTransaction>}
+   * @memberof HathorWallet
+   * @inner
+   * */
+  async createNewToken(name, symbol, amount, options = {}) {
+    const sendTx = await this.createNewTokenSendTransaction(name, symbol, amount, options);
+    return sendTx.runFromMining();
+  }
+
+  /**
+   * Get mint authorities
+   *
+   * @param {string} tokenUid UID of the token to select the authority utxo
+   * @param {Object} [options] Object with custom options.
+   * @param {boolean} [options.many=false] if should return many utxos or just one (default false)
+   * @param {boolean} [options.only_available_utxos=false] If we should filter for available utxos.
+   * @param {string} [options.filter_address=null] Address to filter the utxo to get.
+   *
+   * @return {Promise<{
+   *   txId: string,
+   *   index: number,
+   *   address: string,
+   *   authorities: OutputValueType
+   * }[]>} Promise that resolves with an Array of objects with properties of the authority output.
+   *       The "authorities" field actually contains the output value with the authority masks.
+   *       Returns an empty array in case there are no tx_outupts for this type.
+   * */
+  async getMintAuthority(tokenUid, options = {}) {
+    return this.getAuthorityUtxo(tokenUid, 'mint', options);
+  }
+
+  /**
+   * Get melt authorities
+   *
+   * @param {string} tokenUid UID of the token to select the authority utxo
+   * @param {Object} [options] Object with custom options.
+   * @param {boolean} [options.many=false] if should return many utxos or just one (default false)
+   * @param {boolean} [options.only_available_utxos=false] If we should filter for available utxos.
+   * @param {string} [options.filter_address=null] Address to filter the utxo to get.
+   *
+   * @return {Promise<{
+   *   txId: string,
+   *   index: number,
+   *   address: string,
+   *   authorities: OutputValueType
+   * }[]>} Promise that resolves with an Array of objects with properties of the authority output.
+   *       The "authorities" field actually contains the output value with the authority masks.
+   *       Returns an empty array in case there are no tx_outupts for this type.
+   * */
+  async getMeltAuthority(tokenUid, options = {}) {
+    return this.getAuthorityUtxo(tokenUid, 'melt', options);
+  }
+
+  /**
+   * Get authority utxo
+   *
+   * @param {string} tokenUid UID of the token to select the authority utxo
+   * @param {string} authority The authority to filter ('mint' or 'melt')
+   * @param {Object} [options] Object with custom options.
+   * @param {boolean} [options.many=false] if should return many utxos or just one (default false)
+   * @param {boolean} [options.only_available_utxos=false] If we should filter for available utxos.
+   * @param {string} [options.filter_address=null] Address to filter the utxo to get.
+   *
+   * @return {Promise<{
+   *   txId: string,
+   *   index: number,
+   *   address: string,
+   *   authorities: OutputValueType
+   * }[]>} Promise that resolves with an Array of objects with properties of the authority output.
+   *       The "authorities" field actually contains the output value with the authority masks.
+   *       Returns an empty array in case there are no tx_outupts for this type.
+   * */
+  async getAuthorityUtxo(tokenUid, authority, options = {}) {
+    let authorityValue;
+    if (authority === 'mint') {
+      authorityValue = 1n;
+    } else if (authority === 'melt') {
+      authorityValue = 2n;
+    } else {
+      throw new Error('Invalid authority value.');
+    }
+    const newOptions = {
+      token: tokenUid,
+      authorities: authorityValue,
+      only_available_utxos: options.only_available_utxos ?? false,
+      filter_address: options.filter_address ?? null
+    };
+    if (!options.many) {
+      // limit number of utxos to select if many is false
+      newOptions.max_utxos = 1;
+    }
+    const utxos = [];
+    var _iteratorAbruptCompletion10 = false;
+    var _didIteratorError10 = false;
+    var _iteratorError10;
+    try {
+      for (var _iterator10 = _asyncIterator(this.storage.selectUtxos(newOptions)), _step10; _iteratorAbruptCompletion10 = !(_step10 = await _iterator10.next()).done; _iteratorAbruptCompletion10 = false) {
+        const utxo = _step10.value;
+        {
+          utxos.push(utxo);
+        }
+      }
+    } catch (err) {
+      _didIteratorError10 = true;
+      _iteratorError10 = err;
+    } finally {
+      try {
+        if (_iteratorAbruptCompletion10 && _iterator10.return != null) {
+          await _iterator10.return();
+        }
+      } finally {
+        if (_didIteratorError10) {
+          throw _iteratorError10;
+        }
+      }
+    }
+    return utxos;
+  }
+
+  /**
+   * @typedef {Object} MintTokensOptions
+   * @property {string?} [address] destination address of the minted token
+   *                                   (if not sent we choose the next available address to use)
+   * @property {string?} [changeAddress] address of the change output
+   *                                   (if not sent we choose the next available address to use)
+   * @property {boolean?} [startMiningTx=true] boolean to trigger start mining (default true)
+   * @property {boolean?} [createAnotherMint] boolean to create another mint authority or not for the wallet
+   * @property {string?} [mintAuthorityAddress] address to send the new mint authority created
+   * @property {boolean?} [allowExternalMintAuthorityAddress=false] allow the mint authority address to be from another wallet
+   * @property {boolean?} [unshiftData] whether to unshift the data script output
+   * @property {string[]|null?} [data=null] list of data strings using utf8 encoding to add each as a data script output
+   * @property {boolean?} [signTx=true] sign transaction instance
+   * @property {string?} [pinCode] pin to decrypt xpriv information.
+   */
+
+  /**
+   * Prepare mint transaction before mining
+   *
+   * @param {string} tokenUid UID of the token to mint
+   * @param {OutputValueType} amount Quantity to mint
+   * @param {MintTokensOptions} [options] Options parameters
+   *
+   * @return {Promise<Transaction>}
+   *
+   * @memberof HathorWallet
+   * @inner
+   * */
+  async prepareMintTokensData(tokenUid, amount, options = {}) {
+    if (await this.isReadonly()) {
+      throw new _errors.WalletFromXPubGuard('mintTokens');
+    }
+    const newOptions = {
+      address: null,
+      changeAddress: null,
+      createAnotherMint: true,
+      mintAuthorityAddress: null,
+      allowExternalMintAuthorityAddress: false,
+      unshiftData: false,
+      data: null,
+      pinCode: null,
+      signTx: true,
+      ...options
+    };
+    const pin = newOptions.pinCode || this.pinCode;
+    if (!pin) {
+      throw new Error(ERROR_MESSAGE_PIN_REQUIRED);
+    }
+    if (newOptions.mintAuthorityAddress && !newOptions.allowExternalMintAuthorityAddress) {
+      // Validate that the mint authority address belongs to the wallet
+      const isAddressMine = await this.isAddressMine(newOptions.mintAuthorityAddress);
+      if (!isAddressMine) {
+        throw new Error('The mint authority address must belong to your wallet.');
+      }
+    }
+    const mintAddress = newOptions.address || (await this.getCurrentAddress()).address;
+    const mintInput = await this.getMintAuthority(tokenUid, {
+      many: false,
+      only_available_utxos: true
+    });
+    if (!mintInput || mintInput.length === 0) {
+      throw new Error("Don't have mint authority output available.");
+    }
+    const mintOptions = {
+      token: tokenUid,
+      mintInput: mintInput[0],
+      createAnotherMint: newOptions.createAnotherMint,
+      changeAddress: newOptions.changeAddress,
+      mintAuthorityAddress: newOptions.mintAuthorityAddress,
+      unshiftData: newOptions.unshiftData,
+      data: newOptions.data
+    };
+    const txData = await _tokens.default.prepareMintTxData(mintAddress, amount, this.storage, mintOptions);
+    return _transaction.default.prepareTransaction(txData, pin, this.storage, {
+      signTx: newOptions.signTx
+    });
+  }
+
+  /**
+   * Mint tokens - SendTransaction
+   * Create a SendTransaction instance with a prepared mint tokens transaction.
+   *
+   * @param {string} tokenUid UID of the token to mint
+   * @param {OutputValueType} amount Quantity to mint
+   * @param {MintTokensOptions?} [options={}] Options parameters
+   *
+   * @return {Promise<SendTransaction>}
+   *
+   * @memberof HathorWallet
+   * @inner
+   * */
+  async mintTokensSendTransaction(tokenUid, amount, options = {}) {
+    const transaction = await this.prepareMintTokensData(tokenUid, amount, options);
+    return new _sendTransaction.default({
+      wallet: this,
+      transaction
+    });
+  }
+
+  /**
+   * Mint tokens
+   *
+   * @param {string} tokenUid UID of the token to mint
+   * @param {OutputValueType} amount Quantity to mint
+   * @param {MintTokensOptions?} [options={}] Options parameters
+   *
+   * @return {Promise<Transaction>} Promise that resolves with transaction object
+   *
+   * @memberof HathorWallet
+   * @inner
+   * */
+  async mintTokens(tokenUid, amount, options = {}) {
+    const sendTx = await this.mintTokensSendTransaction(tokenUid, amount, options);
+    return sendTx.runFromMining();
+  }
+
+  /**
+   * @typedef {Object} MeltTokensOptions
+   * @property {string?} [address] address of the HTR deposit back.
+   * @property {string?} [changeAddress] address of the change output.
+   * @property {boolean?} [createAnotherMelt=true] create another melt authority or not.
+   * @property {string?} [meltAuthorityAddress=null] where to send the new melt authority created.
+   * @property {boolean?} [allowExternalMeltAuthorityAddress=false] allow the melt authority address to be from another wallet.
+   * @property {boolean?} [unshiftData=false] Add the data outputs in the start of the output list.
+   * @property {string[]?} [data=null] list of data script output to add, UTF-8 encoded.
+   * @property {string?} [pinCode=null] pin to decrypt xpriv information. Optional but required if not set in this.
+   * @property {boolean?} [signTx=true] Sign transaction instance.
+   * @property {boolean?} [startMiningTx=true] boolean to trigger start mining
+   */
+
+  /**
+   * Prepare melt transaction before mining
+   *
+   * @param {string} tokenUid UID of the token to melt
+   * @param {OutputValueType} amount Quantity to melt
+   * @param {MeltTokensOptions} [options={}] Options parameters
+   *
+   * @return {Promise<Transaction>}
+   *
+   * @memberof HathorWallet
+   * @inner
+   * */
+  async prepareMeltTokensData(tokenUid, amount, options = {}) {
+    if (await this.isReadonly()) {
+      throw new _errors.WalletFromXPubGuard('meltTokens');
+    }
+    const newOptions = {
+      address: null,
+      changeAddress: null,
+      createAnotherMelt: true,
+      meltAuthorityAddress: null,
+      allowExternalMeltAuthorityAddress: false,
+      unshiftData: false,
+      data: null,
+      pinCode: null,
+      signTx: true,
+      ...options
+    };
+    const pin = newOptions.pinCode || this.pinCode;
+    if (!pin) {
+      throw new Error(ERROR_MESSAGE_PIN_REQUIRED);
+    }
+    if (newOptions.meltAuthorityAddress && !newOptions.allowExternalMeltAuthorityAddress) {
+      // Validate that the melt authority address belongs to the wallet
+      const isAddressMine = await this.isAddressMine(newOptions.meltAuthorityAddress);
+      if (!isAddressMine) {
+        throw new Error('The melt authority address must belong to your wallet.');
+      }
+    }
+    const meltInput = await this.getMeltAuthority(tokenUid, {
+      many: false,
+      only_available_utxos: true
+    });
+    if (!meltInput || meltInput.length === 0) {
+      throw new Error("Don't have melt authority output available.");
+    }
+    const meltOptions = {
+      createAnotherMelt: newOptions.createAnotherMelt,
+      meltAuthorityAddress: newOptions.meltAuthorityAddress,
+      changeAddress: newOptions.changeAddress,
+      unshiftData: newOptions.unshiftData,
+      data: newOptions.data
+    };
+    const txData = await _tokens.default.prepareMeltTxData(tokenUid, meltInput[0], newOptions.address || (await this.getCurrentAddress()).address, amount, this.storage, meltOptions);
+    return _transaction.default.prepareTransaction(txData, pin, this.storage, {
+      signTx: newOptions.signTx
+    });
+  }
+
+  /**
+   * Melt tokens - SendTransaction
+   * Create a SendTransaction instance with a prepared melt tokens transaction.
+   *
+   * @param {string} tokenUid UID of the token to melt
+   * @param {OutputValueType} amount Quantity to melt
+   * @param {MeltTokensOptions} [options] Options parameters
+   *
+   * @return {Promise<SendTransaction>}
+   *
+   * @memberof HathorWallet
+   * @inner
+   * */
+  async meltTokensSendTransaction(tokenUid, amount, options = {}) {
+    const transaction = await this.prepareMeltTokensData(tokenUid, amount, options);
+    return new _sendTransaction.default({
+      wallet: this,
+      transaction
+    });
+  }
+
+  /**
+   * Melt tokens
+   *
+   * @param {string} tokenUid UID of the token to melt
+   * @param {OutputValueType} amount Quantity to melt
+   * @param {MeltTokensOptions} [options] Options parameters
+   *
+   * @return {Promise<Transaction>}
+   *
+   * @memberof HathorWallet
+   * @inner
+   * */
+  async meltTokens(tokenUid, amount, options = {}) {
+    const sendTx = await this.meltTokensSendTransaction(tokenUid, amount, options);
+    return sendTx.runFromMining();
+  }
+
+  /**
+   * @typedef {Object} DelegateAuthorityOptions
+   * @property {boolean?} [options.createAnother=true] Should create another authority for the wallet.
+   * @property {boolean?} [options.startMiningTx=true] boolean to trigger start mining.
+   * @property {string?} [options.pinCode] pin to decrypt xpriv information.
+   */
+
+  /**
+   * Prepare delegate authority transaction before mining
+   *
+   * @param {string} tokenUid UID of the token to delegate the authority
+   * @param {string} type Type of the authority to delegate 'mint' or 'melt'
+   * @param {string} destinationAddress Destination address of the delegated authority
+   * @param {DelegateAuthorityOptions} [options] Options parameters
+   *
+   * @return {Promise<Transaction>}
+   *
+   * @memberof HathorWallet
+   * @inner
+   * */
+  async prepareDelegateAuthorityData(tokenUid, type, destinationAddress, options = {}) {
+    if (await this.isReadonly()) {
+      throw new _errors.WalletFromXPubGuard('delegateAuthority');
+    }
+    const newOptions = {
+      createAnother: true,
+      pinCode: null,
+      ...options
+    };
+    const pin = newOptions.pinCode || this.pinCode;
+    if (!pin) {
+      throw new Error(ERROR_MESSAGE_PIN_REQUIRED);
+    }
+    const {
+      createAnother
+    } = newOptions;
+    let delegateInput;
+    if (type === 'mint') {
+      delegateInput = await this.getMintAuthority(tokenUid, {
+        many: false,
+        only_available_utxos: true
+      });
+    } else if (type === 'melt') {
+      delegateInput = await this.getMeltAuthority(tokenUid, {
+        many: false,
+        only_available_utxos: true
+      });
+    } else {
+      throw new Error('This should never happen.');
+    }
+    if (delegateInput.length === 0) {
+      throw new Error({
+        success: false,
+        message: _errorMessages.ErrorMessages.NO_UTXOS_AVAILABLE
+      });
+    }
+    const txData = await _tokens.default.prepareDelegateAuthorityTxData(tokenUid, delegateInput[0], destinationAddress, this.storage, createAnother);
+    return _transaction.default.prepareTransaction(txData, pin, this.storage);
+  }
+
+  /**
+   * Delegate authority - Send Transaction
+   * Create a SendTransaction instance ready to mine a delegate authority transaction.
+   *
+   * @param {string} tokenUid UID of the token to delegate the authority
+   * @param {'mint'|'melt'} type Type of the authority to delegate 'mint' or 'melt'
+   * @param {string} destinationAddress Destination address of the delegated authority
+   * @param {DelegateAuthorityOptions} [options] Options parameters
+   *
+   * @return {Promise<SendTransaction>}
+   *
+   * @memberof HathorWallet
+   * @inner
+   * */
+  async delegateAuthoritySendTransaction(tokenUid, type, destinationAddress, options = {}) {
+    const transaction = await this.prepareDelegateAuthorityData(tokenUid, type, destinationAddress, options);
+    return new _sendTransaction.default({
+      wallet: this,
+      transaction
+    });
+  }
+
+  /**
+   * Delegate authority
+   *
+   * @param {string} tokenUid UID of the token to delegate the authority
+   * @param {'mint'|'melt'} type Type of the authority to delegate 'mint' or 'melt'
+   * @param {string} destinationAddress Destination address of the delegated authority
+   * @param {DelegateAuthorityOptions} [options] Options parameters
+   *
+   * @return {Promise<Transaction>}
+   *
+   * @memberof HathorWallet
+   * @inner
+   * */
+  async delegateAuthority(tokenUid, type, destinationAddress, options = {}) {
+    const sendTx = await this.delegateAuthoritySendTransaction(tokenUid, type, destinationAddress, options);
+    return sendTx.runFromMining();
+  }
+
+  /**
+   * @typedef {Object} DestroyAuthorityOptions
+   * @param {boolean?} [startMiningTx=true] trigger start mining
+   * @param {string?} [pinCode] pin to decrypt xpriv information.
+   */
+
+  /**
+   * Prepare destroy authority transaction before mining
+   *
+   * @param {string} tokenUid UID of the token to delegate the authority
+   * @param {string} type Type of the authority to delegate 'mint' or 'melt'
+   * @param {number} count How many authority outputs to destroy
+   * @param {DestroyAuthorityOptions} [options] Options parameters
+   *
+   * @return {Promise<Transaction>}
+   *
+   * @memberof HathorWallet
+   * @inner
+   * */
+  async prepareDestroyAuthorityData(tokenUid, type, count, options = {}) {
+    if (await this.isReadonly()) {
+      throw new _errors.WalletFromXPubGuard('destroyAuthority');
+    }
+    const newOptions = {
+      pinCode: null,
+      ...options
+    };
+    const pin = newOptions.pinCode || this.pinCode;
+    if (!pin) {
+      throw new Error(ERROR_MESSAGE_PIN_REQUIRED);
+    }
+    let destroyInputs;
+    if (type === 'mint') {
+      destroyInputs = await this.getMintAuthority(tokenUid, {
+        many: true,
+        only_available_utxos: true
+      });
+    } else if (type === 'melt') {
+      destroyInputs = await this.getMeltAuthority(tokenUid, {
+        many: true,
+        only_available_utxos: true
+      });
+    } else {
+      throw new Error('This should never happen.');
+    }
+    if (destroyInputs.length < count) {
+      throw new Error(_errorMessages.ErrorMessages.NO_UTXOS_AVAILABLE);
+    }
+    const data = [];
+    for (const utxo of destroyInputs) {
+      // FIXME: select utxos passing count to the method
+      data.push(utxo);
+      // Even though count is expected as a number, I am using ==
+      // in case someone sends a string in the future
+      if (data.length >= count) {
+        break;
+      }
+    }
+    const txData = _tokens.default.prepareDestroyAuthorityTxData(data);
+    return _transaction.default.prepareTransaction(txData, pin, this.storage);
+  }
+
+  /**
+   * Destroy authority - SendTransaction
+   * Creates a SendTransaction instance with a prepared destroy transaction.
+   *
+   * @param {string} tokenUid UID of the token to destroy the authority
+   * @param {'mint'|'melt'} type Type of the authority to destroy: 'mint' or 'melt'
+   * @param {number} count How many authority outputs to destroy
+   * @param {DestroyAuthorityOptions} [options] Options parameters
+   *
+   * @return {Promise<SendTransaction>}
+   *
+   * @memberof HathorWallet
+   * @inner
+   * */
+  async destroyAuthoritySendTransaction(tokenUid, type, count, options = {}) {
+    const transaction = await this.prepareDestroyAuthorityData(tokenUid, type, count, options);
+    return new _sendTransaction.default({
+      wallet: this,
+      transaction
+    });
+  }
+
+  /**
+   * Destroy authority
+   *
+   * @param {string} tokenUid UID of the token to destroy the authority
+   * @param {'mint'|'melt'} type Type of the authority to destroy: 'mint' or 'melt'
+   * @param {number} count How many authority outputs to destroy
+   * @param {DestroyAuthorityOptions} [options] Options parameters
+   *
+   * @return {Promise<Transaction>}
+   *
+   * @memberof HathorWallet
+   * @inner
+   * */
+  async destroyAuthority(tokenUid, type, count, options = {}) {
+    const sendTx = await this.destroyAuthoritySendTransaction(tokenUid, type, count, options);
+    return sendTx.runFromMining();
+  }
+
+  /**
+   * Remove sensitive data from memory
+   *
+   * NOTICE: This won't remove data from memory immediately, we have to wait until javascript
+   * garbage collect it. JavaScript currently does not provide a standard way to trigger
+   * garbage collection
+   * */
+  clearSensitiveData() {
+    this.xpriv = undefined;
+    this.seed = undefined;
+  }
+
+  /**
+   * Get all authorities utxos for specific token
+   *
+   * @param {string} tokenUid UID of the token to delegate the authority
+   * @param {"mint"|"melt"} type Type of the authority to search for: 'mint' or 'melt'
+   *
+   * @return {{tx_id: string, index: number, address: string, authorities: OutputValueType}[]}
+   *    Array of the authority outputs.
+   * */
+  async getAuthorityUtxos(tokenUid, type) {
+    if (type === 'mint') {
+      return this.getMintAuthority(tokenUid, {
+        many: true
+      });
+    }
+    if (type === 'melt') {
+      return this.getMeltAuthority(tokenUid, {
+        many: true
+      });
+    }
+    throw new Error('This should never happen.');
+  }
+  getTokenData() {
+    if (this.tokenUid === _constants.NATIVE_TOKEN_UID) {
+      // Hathor token we don't get from the full node
+      this.token = this.storage.getNativeTokenData();
+    } else {
+      // XXX: This request is not awaited
+      // Get token info from full node
+      // XXX This request might take longer than the ws connection to start
+      // so it's possible (but hard to happen) that the wallet will change to
+      // READY state with token still null.
+      // I will keep it like that for now but to protect from this
+      // we should change to READY only after both things finish
+      _wallet.default.getGeneralTokenInfo(this.tokenUid, response => {
+        if (response.success) {
+          this.token = {
+            uid: this.tokenUid,
+            name: response.name,
+            symbol: response.symbol
+          };
+        } else {
+          throw Error(response.message);
+        }
+      });
+    }
+  }
+
+  /**
+   * Call get token details API
+   *
+   * @param tokenId Token uid to get the token details
+   *
+   * @return {Promise<{
+   *   totalSupply: bigint,
+   *   totalTransactions: number,
+   *   tokenInfo: {
+   *     name: string,
+   *     symbol: string,
+   *   },
+   *   authorities: {
+   *     mint: boolean,
+   *     melt: boolean,
+   *   },
+   * }>} token details
+   */
+  // eslint-disable-next-line class-methods-use-this -- The server address is fetched directly from the configs
+  async getTokenDetails(tokenId) {
+    const result = await new Promise((resolve, reject) => {
+      _wallet.default.getGeneralTokenInfo(tokenId, resolve).catch(error => reject(error));
+    });
+    if (!result.success) {
+      throw new Error(result.message);
+    }
+    const {
+      name,
+      symbol,
+      mint,
+      melt,
+      total,
+      transactions_count
+    } = result;
+
+    // Transform to the same format the wallet service facade responds
+    return {
+      totalSupply: total,
+      totalTransactions: transactions_count,
+      tokenInfo: {
+        name,
+        symbol
+      },
+      authorities: {
+        mint: mint.length > 0,
+        melt: melt.length > 0
+      }
+    };
+  }
+  isReady() {
+    return this.state === HathorWallet.READY;
+  }
+
+  /**
+   * Check if address is from the loaded wallet
+   *
+   * @param {string} address Address to check
+   *
+   * @return {Promise<boolean>}
+   * */
+  async isAddressMine(address) {
+    return this.storage.isAddressMine(address);
+  }
+
+  /**
+   * Check if a list of addresses are from the loaded wallet
+   *
+   * @param {string[]} addresses Addresses to check
+   *
+   * @return {Object} Object with the addresses and whether it belongs or not { address: boolean }
+   * */
+  async checkAddressesMine(addresses) {
+    const promises = [];
+    for (const address of addresses) {
+      promises.push(this.storage.isAddressMine(address).then(mine => ({
+        address,
+        mine
+      })));
+    }
+    const results = await Promise.all(promises);
+    return results.reduce((acc, result) => {
+      acc[result.address] = result.mine;
+      return acc;
+    }, {});
+  }
+
+  /**
+   * Get index of address
+   * Returns null if address does not belong to the wallet
+   *
+   * @param {string} address Address to get the index
+   *
+   * @return {Promise<number | null>}
+   * */
+  async getAddressIndex(address) {
+    const addressInfo = await this.storage.getAddressInfo(address);
+    return (0, _lodash.get)(addressInfo, 'bip32AddressIndex', null);
+  }
+
+  /**
+   * FIXME: does not differentiate between locked and unlocked, also ignores authorities
+   * Returns the balance for each token in tx, if the input/output belongs to this wallet
+   *
+   * @param {DecodedTx} tx Decoded transaction with populated data from local wallet history
+   * @param [optionsParam]
+   * @param {boolean} [optionsParam.includeAuthorities=false] Retrieve authority balances if true
+   *
+   * @return {Promise<Record<string,bigint>>} Promise that resolves with an object with each token
+   *                                          and it's balance in this tx for this wallet
+   *
+   * @example
+   * const decodedTx = hathorWalletInstance.getTx(txHash);
+   * const txBalance = await hathorWalletInstance.getTxBalance(decodedTx);
+   * */
+  async getTxBalance(tx, optionsParam = {}) {
+    const balance = {};
+    const fullBalance = await _transaction.default.getTxBalance(tx, this.storage);
+
+    // We need to map balance for backwards compatibility
+    for (const [token, tokenBalance] of Object.entries(fullBalance)) {
+      balance[token] = tokenBalance.tokens.locked + tokenBalance.tokens.unlocked;
+    }
+    return balance;
+  }
+
+  /**
+   * Return the addresses of the tx that belongs to this wallet
+   * The address might be in the input or output
+   * Removes duplicates
+   *
+   * @param {DecodedTx} tx Transaction data with array of inputs and outputs
+   *
+   * @return {Set<string>} Set of strings with addresses
+   * */
+  async getTxAddresses(tx) {
+    const addresses = new Set();
+    for (const io of [...tx.outputs, ...tx.inputs]) {
+      if (io.decoded && io.decoded.address && (await this.isAddressMine(io.decoded.address))) {
+        addresses.add(io.decoded.address);
+      }
+    }
+    return addresses;
+  }
+
+  /**
+   * @typedef {Omit<CreateTokenOptions, 'data'|'isCreateNFT'>} CreateNFTOptions
+   */
+
+  /**
+   * Create a SendTransaction instance with a create NFT transaction prepared.
+   *
+   * @param {string} name Name of the token
+   * @param {string} symbol Symbol of the token
+   * @param {OutputValueType} amount Quantity of the token to be minted
+   * @param {string} data NFT data string using utf8 encoding
+   * @param {CreateNFTOptions?} [options={}] Options parameters
+   *
+   * @return {Promise<SendTransaction>}
+   *
+   * @memberof HathorWallet
+   * @inner
+   * */
+  async createNFTSendTransaction(name, symbol, amount, data, options = {}) {
+    /** @type {CreateTokenOptions} */
+    const newOptions = {
+      address: null,
+      changeAddress: null,
+      startMiningTx: true,
+      pinCode: null,
+      createMint: false,
+      mintAuthorityAddress: null,
+      allowExternalMintAuthorityAddress: false,
+      createMelt: false,
+      meltAuthorityAddress: null,
+      allowExternalMeltAuthorityAddress: false,
+      ...options
+    };
+    newOptions.data = [data];
+    newOptions.isCreateNFT = true;
+    const transaction = await this.prepareCreateNewToken(name, symbol, amount, newOptions);
+    return new _sendTransaction.default({
+      wallet: this,
+      transaction
+    });
+  }
+
+  /**
+   * Create an NFT for this wallet
+   *
+   * @param {string} name Name of the token
+   * @param {string} symbol Symbol of the token
+   * @param {OutputValueType} amount Quantity of the token to be minted
+   * @param {string} data NFT data string using utf8 encoding
+   * @param {CreateNFTOptions?} [options={}] Options parameters
+   *
+   * @return {Promise<CreateTokenTransaction>}
+   *
+   * @memberof HathorWallet
+   * @inner
+   * */
+  async createNFT(name, symbol, amount, data, options = {}) {
+    const sendTx = await this.createNFTSendTransaction(name, symbol, amount, data, options);
+    return sendTx.runFromMining();
+  }
+
+  /**
+   * Identify all inputs from the loaded wallet
+   *
+   * @param {Transaction} tx The transaction
+   *
+   * @returns {Promise<{
+   * inputIndex: number,
+   * addressIndex: number,
+   * addressPath: string,
+   * }[]>} List of indexes and their associated address index
+   */
+  async getWalletInputInfo(tx) {
+    const walletInputs = [];
+    var _iteratorAbruptCompletion11 = false;
+    var _didIteratorError11 = false;
+    var _iteratorError11;
+    try {
+      for (var _iterator11 = _asyncIterator(this.storage.getSpentTxs(tx.inputs)), _step11; _iteratorAbruptCompletion11 = !(_step11 = await _iterator11.next()).done; _iteratorAbruptCompletion11 = false) {
+        const {
+          tx: spentTx,
+          input,
+          index
+        } = _step11.value;
+        {
+          const addressInfo = await this.storage.getAddressInfo(spentTx.outputs[input.index].decoded.address);
+          if (addressInfo === null) {
+            continue;
+          }
+          const addressPath = await this.getAddressPathForIndex(addressInfo.bip32AddressIndex);
+          walletInputs.push({
+            inputIndex: index,
+            addressIndex: addressInfo.bip32AddressIndex,
+            addressPath
+          });
+        }
+      }
+    } catch (err) {
+      _didIteratorError11 = true;
+      _iteratorError11 = err;
+    } finally {
+      try {
+        if (_iteratorAbruptCompletion11 && _iterator11.return != null) {
+          await _iterator11.return();
+        }
+      } finally {
+        if (_didIteratorError11) {
+          throw _iteratorError11;
+        }
+      }
+    }
+    return walletInputs;
+  }
+
+  /**
+   * Get signatures for all inputs of the loaded wallet.
+   *
+   * @param {Transaction} tx The transaction to be signed
+   * @param [options]
+   * @param {string} [options.pinCode] PIN to decrypt the private key.
+   *                                   Optional but required if not set in this
+   *
+   * @async
+   * @returns {Promise<{
+   * inputIndex: number,
+   * addressIndex: number,
+   * addressPath: string,
+   * signature: string,
+   * pubkey: string,
+   * }>} Input and signature information
+   */
+  async getSignatures(tx, {
+    pinCode = null
+  } = {}) {
+    if (await this.isReadonly()) {
+      throw new _errors.WalletFromXPubGuard('getSignatures');
+    }
+    const pin = pinCode || this.pinCode;
+    if (!pin) {
+      throw new Error(ERROR_MESSAGE_PIN_REQUIRED);
+    }
+    const signatures = await this.storage.getTxSignatures(tx, pin);
+    const sigInfoArray = [];
+    for (const sigData of signatures.inputSignatures) {
+      sigInfoArray.push({
+        ...sigData,
+        pubkey: sigData.pubkey.toString('hex'),
+        signature: sigData.signature.toString('hex'),
+        addressPath: await this.getAddressPathForIndex(sigData.addressIndex)
+      });
+    }
+    return sigInfoArray;
+  }
+
+  /**
+   * Sign all inputs of the given transaction.
+   *   OBS: only for P2PKH wallets.
+   *
+   * @param {Transaction} tx The transaction to be signed
+   * @param [options]
+   * @param {string} [options.pinCode] PIN to decrypt the private key.
+   *                                   Optional but required if not set in this
+   *
+   * @returns {Promise<Transaction>} The signed transaction
+   */
+  async signTx(tx, options = {}) {
+    for (const sigInfo of await this.getSignatures(tx, options)) {
+      const {
+        signature,
+        pubkey,
+        inputIndex
+      } = sigInfo;
+      const inputData = _transaction.default.createInputData(Buffer.from(signature, 'hex'), Buffer.from(pubkey, 'hex'));
+      tx.inputs[inputIndex].setData(inputData);
+    }
+    return tx;
+  }
+
+  /**
+   * Guard to check if the response is a transaction not found response
+   *
+   * @param {Object} data The request response data
+   *
+   * @throws {TxNotFoundError} If the returned error was a transaction not found
+   */
+  static _txNotFoundGuard(data) {
+    if ((0, _lodash.get)(data, 'message', '') === 'Transaction not found') {
+      throw new _errors.TxNotFoundError();
+    }
+  }
+
+  /**
+   * Queries the fullnode for a transaction
+   *
+   * @param {string} txId The transaction to query
+   *
+   * @returns {FullNodeTxResponse} Transaction data in the fullnode
+   */
+  // eslint-disable-next-line class-methods-use-this -- The server address is fetched directly from the configs
+  async getFullTxById(txId) {
+    const tx = await new Promise((resolve, reject) => {
+      _txApi.default.getTransaction(txId, resolve)
+      // txApi will call the `resolve` callback and end the promise chain,
+      // so if it falls here, we should throw
+      .then(() => reject(new Error('API client did not use the callback'))).catch(err => reject(err));
+    });
+    if (!tx.success) {
+      HathorWallet._txNotFoundGuard(tx);
+      throw new Error(`Invalid transaction ${txId}`);
+    }
+    return tx;
+  }
+
+  /**
+   * Queries the fullnode for a transaction confirmation data
+   *
+   * @param {string} txId The transaction to query
+   *
+   * @returns {FullNodeTxConfirmationDataResponse} Transaction confirmation data
+   */
+  // eslint-disable-next-line class-methods-use-this -- The server address is fetched directly from the configs
+  async getTxConfirmationData(txId) {
+    const confirmationData = await new Promise((resolve, reject) => {
+      _txApi.default.getConfirmationData(txId, resolve).then(() => reject(new Error('API client did not use the callback'))).catch(err => reject(err));
+    });
+    if (!confirmationData.success) {
+      HathorWallet._txNotFoundGuard(confirmationData);
+      throw new Error(`Invalid transaction ${txId}`);
+    }
+    return confirmationData;
+  }
+
+  /**
+   * Queries the fullnode for a graphviz graph, given a graph type and txId
+   *
+   * @param {string} txId The transaction to query
+   * @param {string} graphType The graph type to query
+   * @param {string} maxLevel Max level to render
+   *
+   * @returns {Promise<string>} The graphviz digraph
+   */
+  async graphvizNeighborsQuery(txId, graphType, maxLevel) {
+    const url = `${this.storage.config.getServerUrl()}graphviz/neighbours.dot?tx=${txId}&graph_type=${graphType}&max_level=${maxLevel}`;
+    const graphvizData = await new Promise((resolve, reject) => {
+      _txApi.default.getGraphviz(url, resolve).then(() => reject(new Error('API client did not use the callback'))).catch(err => reject(err));
+    });
+
+    // The response will either be a string with the graphviz data or an object
+    // { success: boolean, message: string } so we need to check if the response has
+    // the `success` key
+    if (Object.hasOwnProperty.call(graphvizData, 'success') && !graphvizData.success) {
+      HathorWallet._txNotFoundGuard(graphvizData);
+      throw new Error(`Invalid transaction ${txId}`);
+    }
+    return graphvizData;
+  }
+
+  /**
+   * This function is responsible for getting the details of each token in the transaction.
+   * @param {string} txId - Transaction id
+   * @returns {Promise<{
+   *   success: boolean
+   *   txTokens: Array<{
+   *     txId: string,
+   *     timestamp: number,
+   *     version: number,
+   *     voided: boolean,
+   *     weight: number,
+   *     tokenName: string,
+   *     tokenSymbol: string,
+   *     balance: bigint
+   *   }>
+   * }>} Array of token details
+   * @example
+   * {
+   *   success: true,
+   *   txTokens: [
+   *     {
+   *      txId: '000021e7addbb94a8e43d7f1237d556d47efc4d34800c5923ed3a75bf5a2886e';
+   *      timestamp: 123456789;
+   *      version: 1;
+   *      voided: false;
+   *      weight: 18.5;
+   *      tokenId: '00',
+   *      tokenName: 'Hathor',
+   *      tokenSymbol: 'HTR',
+   *      balance: 100,
+   *     },
+   *   ],
+   * }
+   * @throws {Error} (propagation) Invalid transaction
+   * @throws {Error} (propagation) Client did not use the callback
+   * @throws {Error} (propagation) Transaction not found
+   * @throws {Error} Transaction does not have any balance for this wallet
+   * @throws {Error} Token uid not found in tokens list
+   * @throws {Error} Token uid not found in tx
+   */
+  async getTxById(txId) {
+    /**
+     * Hydrate input and output with token uid
+     * @param {Transaction.input|Transaction.output} io - Input or output
+     * @param {Array} tokens - Array of token configs
+     * @example
+     * {
+     *   ...output,
+     *   token: '00',
+     * }
+     * @throws {Error} Token uid not found in tokens list
+     */
+    const hydrateWithTokenUid = (io, tokens) => {
+      const {
+        token_data
+      } = io;
+      if (token_data === 0) {
+        return {
+          ...io,
+          token: _constants.NATIVE_TOKEN_UID
+        };
+      }
+      const tokenIdx = _tokens.default.getTokenIndexFromData(token_data);
+      const tokenUid = tokens[tokenIdx - 1]?.uid;
+      if (!tokenUid) {
+        throw new Error(`Invalid token_data ${token_data}, token not found in tokens list`);
+      }
+      return {
+        ...io,
+        token: tokenUid
+      };
+    };
+
+    /**
+     * @throws {Error} Invalid transaction
+     * @throws {Error} Client did not use the callback
+     * @throws {Error} Transaction not found
+     */
+    const fullTx = await this.getFullTxById(txId);
+    fullTx.tx.outputs = fullTx.tx.outputs.map(output => hydrateWithTokenUid(output, fullTx.tx.tokens));
+    fullTx.tx.inputs = fullTx.tx.inputs.map(input => hydrateWithTokenUid(input, fullTx.tx.tokens));
+
+    // Get the balance of each token in the transaction that belongs to this wallet
+    // sample output: { 'A': 100, 'B': 10 }, where 'A' and 'B' are token UIDs
+    const tokenBalances = await this.getTxBalance(fullTx.tx);
+    const {
+      length: hasBalance
+    } = Object.keys(tokenBalances);
+    if (!hasBalance) {
+      throw new Error(`Transaction ${txId} does not have any balance for this wallet`);
+    }
+    const listTokenUid = Object.keys(tokenBalances);
+    const txTokens = listTokenUid.map(uid => {
+      /**
+       * Retrieves the token config from the transaction.
+       * @param {string} tokenUid
+       * @returns {TokenInfo} Token config
+       */
+      const getToken = tokenUid => {
+        if (tokenUid === _constants.NATIVE_TOKEN_UID) {
+          return this.storage.getNativeTokenData();
+        }
+        const token = fullTx.tx.tokens.find(tokenElem => tokenElem.uid === tokenUid);
+        if (!token) {
+          throw new Error(`Token ${tokenUid} not found in tx`);
+        }
+        return token;
+      };
+      const isVoided = fullTx.meta.voided_by.length > 0;
+      const token = getToken(uid);
+      const tokenBalance = tokenBalances[uid];
+      const tokenDetails = {
+        txId,
+        timestamp: fullTx.tx.timestamp,
+        version: fullTx.tx.version,
+        voided: isVoided,
+        weight: fullTx.tx.weight,
+        tokenId: token.uid,
+        tokenName: token.name,
+        tokenSymbol: token.symbol,
+        balance: tokenBalance
+      };
+      return tokenDetails;
+    });
+    return {
+      success: true,
+      txTokens
+    };
+  }
+
+  /**
+   * Check if the pin used to encrypt the main key is valid.
+   * @param {string} pin
+   * @returns {Promise<boolean>}
+   */
+  async checkPin(pin) {
+    return this.storage.checkPin(pin);
+  }
+
+  /**
+   * Check if the password used to encrypt the seed is valid.
+   * @param {string} password
+   * @returns {Promise<boolean>}
+   */
+  async checkPassword(password) {
+    return this.storage.checkPassword(password);
+  }
+
+  /**
+   * @param {string} pin
+   * @param {string} password
+   * @returns {Promise<boolean>}
+   */
+  async checkPinAndPassword(pin, password) {
+    return (await this.checkPin(pin)) && this.checkPassword(password); // The promise from checkPassword will be returned here
+  }
+
+  /**
+   * Check if the wallet is a hardware wallet.
+   * @returns {Promise<boolean>}
+   */
+  async isHardwareWallet() {
+    return this.storage.isHardwareWallet();
+  }
+
+  /**
+   * @typedef {Object} CreateNanoTxOptions
+   * @property {string?} [pinCode] PIN to decrypt the private key.
+   */
+
+  /**
+   * @typedef {Object} CreateNanoTxData
+   * @property {string?} [blueprintId=null] ID of the blueprint to create the nano contract. Required if method is initialize.
+   * @property {string?} [ncId=null] ID of the nano contract to execute method. Required if method is not initialize
+   * @property {NanoContractAction[]?} [actions] List of actions to execute in the nano contract transaction
+   * @property {any[]} [args] List of arguments for the method to be executed in the transaction
+   *
+   */
+
+  /**
+   * Create and send a Transaction with nano header
+   *
+   * @param {string} method Method of nano contract to have the transaction created
+   * @param {string} address Address that will be used to sign the nano contract transaction
+   * @param {CreateNanoTxData} [data]
+   * @param {CreateNanoTxOptions} [options]
+   *
+   * @returns {Promise<Transaction>}
+   */
+  async createAndSendNanoContractTransaction(method, address, data, options = {}) {
+    const sendTransaction = await this.createNanoContractTransaction(method, address, data, options);
+    return sendTransaction.runFromMining();
+  }
+
+  /**
+   * Create a Transaction with nano header and return the SendTransaction object
+   *
+   * @param {string} method Method of nano contract to have the transaction created
+   * @param {string} address Address that will be used to sign the nano contract transaction
+   * @param {CreateNanoTxData} [data]
+   * @param {CreateNanoTxOptions} [options]
+   *
+   * @returns {Promise<SendTransaction>}
+   */
+  async createNanoContractTransaction(method, address, data, options = {}) {
+    if (await this.storage.isReadonly()) {
+      throw new _errors.WalletFromXPubGuard('createNanoContractTransaction');
+    }
+    const newOptions = {
+      pinCode: null,
+      ...options
+    };
+    const pin = newOptions.pinCode || this.pinCode;
+    if (!pin) {
+      throw new _errors.PinRequiredError(ERROR_MESSAGE_PIN_REQUIRED);
+    }
+
+    // Get caller pubkey
+    const addressInfo = await this.storage.getAddressInfo(address);
+    if (!addressInfo) {
+      throw new _errors.NanoContractTransactionError(`Address used to sign the transaction (${address}) does not belong to the wallet.`);
+    }
+
+    // Build and send transaction
+    const builder = new _builder.default().setMethod(method).setWallet(this).setBlueprintId(data.blueprintId).setNcId(data.ncId).setCaller(new _address2.default(address, {
+      network: this.getNetworkObject()
+    })).setActions(data.actions).setArgs(data.args).setVertexType(_types2.NanoContractVertexType.TRANSACTION);
+    const nc = await builder.build();
+    return (0, _utils.prepareNanoSendTransaction)(nc, pin, this.storage);
+  }
+
+  /**
+   * @typedef {Object} CreateTokenTxOptions
+   * @property {string} [name] Token name
+   * @property {string} [symbol] Token symbol
+   * @property {OutputValueType} [amount] Token mint amount
+   * @property {boolean} [contractPaysTokenDeposit] If the contract will pay for the token deposit fee
+   * @property {string?} [mintAddress] Address to send the minted tokens
+   * @property {string?} [changeAddress] Change address to send change values
+   * @property {boolean?} [createMint] If should create a mint authority output
+   * @property {string?} [mintAuthorityAddress] The address to send the mint authority output to
+   * @property {boolean?} [allowExternalMintAuthorityAddress] If should accept an external mint authority address
+   * @property {boolean?} [createMelt] If should create a melt authority output
+   * @property {string?} [meltAuthorityAddress] The address to send the melt authority output to
+   * @property {boolean?} [allowExternalMeltAuthorityAddress] If should accept an external melt authority address
+   * @property {string[]?} [data] List of data strings to create data outputs
+   * @property {boolean?} [isCreateNFT] If this token is an NFT
+   */
+
+  /**
+   * Create and send a Create Token Transaction with nano header
+   *
+   * @param {string} method Method of nano contract to have the transaction created
+   * @param {string} address Address that will be used to sign the nano contract transaction
+   * @param {CreateNanoTxData} [data]
+   * @param {CreateNanoTxData} [data]
+   * @param {CreateTokenTxOptions} [createTokenOptions]
+   * @param {CreateNanoTxOptions} [options]
+   *
+   * @returns {Promise<Transaction>}
+   */
+  async createAndSendNanoContractCreateTokenTransaction(method, address, data, createTokenOptions, options = {}) {
+    const sendTransaction = await this.createNanoContractCreateTokenTransaction(method, address, data, createTokenOptions, options);
+    return sendTransaction.runFromMining();
+  }
+
+  /**
+   * Create a Create Token Transaction with nano header and return the SendTransaction object
+   *
+   * @param {string} method Method of nano contract to have the transaction created
+   * @param {string} address Address that will be used to sign the nano contract transaction
+   * @param {CreateNanoTxData} [data]
+   * @param {CreateTokenTxOptions} [createTokenOptions]
+   * @param {CreateNanoTxOptions} [options]
+   *
+   * @returns {Promise<SendTransaction>}
+   */
+  async createNanoContractCreateTokenTransaction(method, address, data, createTokenOptions, options = {}) {
+    if (await this.storage.isReadonly()) {
+      throw new _errors.WalletFromXPubGuard('createNanoContractCreateTokenTransaction');
+    }
+    const newOptions = {
+      pinCode: null,
+      ...options
+    };
+    const pin = newOptions.pinCode || this.pinCode;
+    if (!pin) {
+      throw new _errors.PinRequiredError(ERROR_MESSAGE_PIN_REQUIRED);
+    }
+    const newCreateTokenOptions = {
+      mintAddress: null,
+      changeAddress: null,
+      createMint: true,
+      mintAuthorityAddress: null,
+      allowExternalMintAuthorityAddress: false,
+      createMelt: true,
+      meltAuthorityAddress: null,
+      allowExternalMeltAuthorityAddress: false,
+      data: null,
+      isCreateNFT: false,
+      ...createTokenOptions
+    };
+    if (newCreateTokenOptions.mintAuthorityAddress && !newCreateTokenOptions.allowExternalMintAuthorityAddress) {
+      // Validate that the mint authority address belongs to the wallet
+      const isAddressMine = await this.isAddressMine(newCreateTokenOptions.mintAuthorityAddress);
+      if (!isAddressMine) {
+        throw new _errors.NanoContractTransactionError('The mint authority address must belong to your wallet.');
+      }
+    }
+    if (newCreateTokenOptions.meltAuthorityAddress && !newCreateTokenOptions.allowExternalMeltAuthorityAddress) {
+      // Validate that the melt authority address belongs to the wallet
+      const isAddressMine = await this.isAddressMine(newCreateTokenOptions.meltAuthorityAddress);
+      if (!isAddressMine) {
+        throw new _errors.NanoContractTransactionError('The melt authority address must belong to your wallet.');
+      }
+    }
+    newCreateTokenOptions.mintAddress = newCreateTokenOptions.mintAddress || (await this.getCurrentAddress()).address;
+
+    // Get caller pubkey
+    const addressInfo = await this.storage.getAddressInfo(address);
+    if (!addressInfo) {
+      throw new _errors.NanoContractTransactionError(`Address used to sign the transaction (${address}) does not belong to the wallet.`);
+    }
+    // Build and send transaction
+    const builder = new _builder.default().setMethod(method).setWallet(this).setBlueprintId(data.blueprintId).setNcId(data.ncId).setCaller(new _address2.default(address, {
+      network: this.getNetworkObject()
+    })).setActions(data.actions).setArgs(data.args).setVertexType(_types2.NanoContractVertexType.CREATE_TOKEN_TRANSACTION, newCreateTokenOptions);
+    const nc = await builder.build();
+    return (0, _utils.prepareNanoSendTransaction)(nc, pin, this.storage);
+  }
+
+  /**
+   * Generate and return the PrivateKey for an address
+   *
+   * @param {string} address Address to get the PrivateKey from
+   * @param [options]
+   * @param {string} [options.pinCode] PIN to decrypt the private key.
+   *                                   Optional but required if not set in this
+   *
+   * @returns {Promise<HDPrivateKey>}
+   */
+  async getPrivateKeyFromAddress(address, options = {}) {
+    if (await this.storage.isReadonly()) {
+      throw new _errors.WalletFromXPubGuard('getPrivateKeyFromAddress');
+    }
+    const newOptions = {
+      pinCode: null,
+      ...options
+    };
+    const pin = newOptions.pinCode || this.pinCode;
+    if (!pin) {
+      throw new _errors.PinRequiredError(ERROR_MESSAGE_PIN_REQUIRED);
+    }
+    const addressIndex = await this.getAddressIndex(address);
+    if (addressIndex === null) {
+      throw new _errors.AddressError('Address does not belong to the wallet.');
+    }
+    const xprivkey = await this.storage.getMainXPrivKey(pin);
+    const key = (0, _bitcoreLib.HDPrivateKey)(xprivkey);
+    // Derive key to addressIndex
+    const derivedKey = key.deriveNonCompliantChild(addressIndex);
+    return derivedKey.privateKey;
+  }
+
+  /**
+   * Set the external tx signing method.
+   * @param {EcdsaTxSign|null} method
+   */
+  setExternalTxSigningMethod(method) {
+    this.isSignedExternally = !!method;
+    this.storage.setTxSignatureMethod(method);
+  }
+
+  /**
+   * Set the history sync mode.
+   * @param {HistorySyncMode} mode
+   */
+  setHistorySyncMode(mode) {
+    this.historySyncMode = mode;
+  }
+
+  /**
+   * @param {number} startIndex
+   * @param {number} count
+   * @param {boolean} [shouldProcessHistory=false]
+   * @returns {Promise<void>}
+   */
+  async syncHistory(startIndex, count, shouldProcessHistory = false) {
+    if (!(await (0, _storage.getSupportedSyncMode)(this.storage)).includes(this.historySyncMode)) {
+      throw new Error('Trying to use an unsupported sync method for this wallet.');
+    }
+    let syncMode = this.historySyncMode;
+    if ([_types.HistorySyncMode.MANUAL_STREAM_WS, _types.HistorySyncMode.XPUB_STREAM_WS].includes(this.historySyncMode) && !(await this.conn.hasCapability('history-streaming'))) {
+      // History sync mode is streaming but fullnode is not streaming capable.
+      // We revert to the http polling default.
+      this.logger.debug('Either fullnode does not support history-streaming or has not sent a capabilities event');
+      this.logger.debug('Falling back to http polling API');
+      syncMode = _types.HistorySyncMode.POLLING_HTTP_API;
+    }
+    const syncMethod = (0, _storage.getHistorySyncMethod)(syncMode);
+    // This will add the task to the GLL queue and return a promise that
+    // resolves when the task finishes executing
+    await _gll.default.add(async () => {
+      await syncMethod(startIndex, count, this.storage, this.conn, shouldProcessHistory);
+    });
+  }
+
+  /**
+   * Reload all addresses and transactions from the full node
+   */
+  async reloadStorage() {
+    await this.conn.onReload();
+
+    // unsub all addresses
+    var _iteratorAbruptCompletion12 = false;
+    var _didIteratorError12 = false;
+    var _iteratorError12;
+    try {
+      for (var _iterator12 = _asyncIterator(this.storage.getAllAddresses()), _step12; _iteratorAbruptCompletion12 = !(_step12 = await _iterator12.next()).done; _iteratorAbruptCompletion12 = false) {
+        const address = _step12.value;
+        {
+          this.conn.unsubscribeAddress(address.base58);
+        }
+      }
+    } catch (err) {
+      _didIteratorError12 = true;
+      _iteratorError12 = err;
+    } finally {
+      try {
+        if (_iteratorAbruptCompletion12 && _iterator12.return != null) {
+          await _iterator12.return();
+        }
+      } finally {
+        if (_didIteratorError12) {
+          throw _iteratorError12;
+        }
+      }
+    }
+    const accessData = await this.storage.getAccessData();
+    if (accessData != null) {
+      // Clean entire storage
+      await this.storage.cleanStorage(true, true);
+      // Reset access data
+      await this.storage.saveAccessData(accessData);
+    }
+    const addressesToLoad = await (0, _storage.scanPolicyStartAddresses)(this.storage);
+    await this.syncHistory(addressesToLoad.nextIndex, addressesToLoad.count);
+  }
+
+  /**
+   * Build a transaction from a template.
+   *
+   * @param {z.input<typeof TransactionTemplate>} template
+   * @param [options]
+   * @param {boolean} [options.signTx] If the transaction should be signed.
+   * @param {string} [options.pinCode] PIN to decrypt the private key.
+   * @returns {Promise<Transaction|CreateTokenTransaction>}
+   */
+  async buildTxTemplate(template, options) {
+    const newOptions = {
+      signTx: false,
+      pinCode: null,
+      ...options
+    };
+    const instructions = _transaction2.TransactionTemplate.parse(template);
+    const tx = await this.txTemplateInterpreter.build(instructions, this.debug);
+    if (newOptions.signTx) {
+      await _transaction.default.signTransaction(tx, this.storage, newOptions.pinCode || this.pinCode);
+      tx.prepareToSend();
+    }
+    return tx;
+  }
+
+  /**
+   * Run a transaction template and send the transaction.
+   *
+   * @param {z.input<typeof TransactionTemplate>} template
+   * @param {string|undefined} pinCode
+   * @returns {Promise<Transaction|CreateTokenTransaction>}
+   */
+  async runTxTemplate(template, pinCode) {
+    const transaction = await this.buildTxTemplate(template, {
+      signTx: true,
+      pinCode
+    });
+    return this.handleSendPreparedTransaction(transaction);
+  }
+
+  /**
+   * @typedef {Object} CreateOnChainBlueprintTxOptions
+   * @property {string?} [pinCode] PIN to decrypt the private key.
+   */
+
+  /**
+   * Create and send an on chain blueprint transaction
+   *
+   * @param {string} code Blueprint code in utf-8
+   * @param {string} address Address that will be used to sign the on chain blueprint transaction
+   * @param {CreateOnChainBlueprintTxOptions} [options]
+   *
+   * @returns {Promise<OnChainBlueprint>}
+   */
+  async createAndSendOnChainBlueprintTransaction(code, address, options = {}) {
+    const sendTransaction = await this.createOnChainBlueprintTransaction(code, address, options);
+    return sendTransaction.runFromMining();
+  }
+
+  /**
+   * Create an on chain blueprint transaction and return the SendTransaction object
+   *
+   * @param {string} code Blueprint code in utf-8
+   * @param {string} address Address that will be used to sign the on chain blueprint transaction
+   * @param {CreateOnChainBlueprintTxOptions} [options]
+   *
+   * @returns {Promise<SendTransaction>}
+   */
+  async createOnChainBlueprintTransaction(code, address, options) {
+    if (await this.storage.isReadonly()) {
+      throw new _errors.WalletFromXPubGuard('createOnChainBlueprintTransaction');
+    }
+    const newOptions = {
+      pinCode: null,
+      ...options
+    };
+    const pin = newOptions.pinCode || this.pinCode;
+    if (!pin) {
+      throw new _errors.PinRequiredError(ERROR_MESSAGE_PIN_REQUIRED);
+    }
+
+    // Get caller pubkey
+    const addressInfo = await this.storage.getAddressInfo(address);
+    if (!addressInfo) {
+      throw new _errors.NanoContractTransactionError(`Address used to sign the transaction (${address}) does not belong to the wallet.`);
+    }
+    const pubkeyStr = await this.storage.getAddressPubkey(addressInfo.bip32AddressIndex);
+    const pubkey = Buffer.from(pubkeyStr, 'hex');
+
+    // Create code object from code data
+    const codeContent = Buffer.from(code, 'utf8');
+    const codeObj = new _on_chain_blueprint.Code(_on_chain_blueprint.CodeKind.PYTHON_ZLIB, codeContent);
+    const tx = new _on_chain_blueprint.default(codeObj, pubkey);
+    return (0, _utils.prepareNanoSendTransaction)(tx, pin, this.storage);
+  }
+
+  /**
+   * Get the seqnum to be used in a nano header for the address
+   *
+   * @param {string} address Address that will be the nano header caller
+   *
+   * @returns {Promise<number>}
+   */
+  async getNanoHeaderSeqnum(address) {
+    const addressInfo = await this.storage.getAddressInfo(address.base58);
+    return addressInfo.seqnum + 1;
+  }
+}
+
+// State constants.
+HathorWallet.CLOSED = 0;
+HathorWallet.CONNECTING = 1;
+HathorWallet.SYNCING = 2;
+HathorWallet.READY = 3;
+HathorWallet.ERROR = 4;
+HathorWallet.PROCESSING = 5;
+var _default = exports.default = HathorWallet;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/opcodes.d.ts b/node_modules/@hathor/wallet-lib/oldLib/opcodes.d.ts
new file mode 100644
index 0000000..5d29196
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/opcodes.d.ts
@@ -0,0 +1,48 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/// <reference types="node" />
+/**
+ * Opcodes used to generate output script
+ * @module Opcodes
+ */
+/**
+ * Checks if timestamp is greater than a value
+ */
+export declare const OP_GREATERTHAN_TIMESTAMP: Buffer;
+/**
+ * Duplicates value
+ */
+export declare const OP_DUP: Buffer;
+/**
+ * Calculates hash160 of value
+ */
+export declare const OP_HASH160: Buffer;
+/**
+ * Check if values are equal and push 1 to the stack
+ * in case it is and 0 if not
+ */
+export declare const OP_EQUAL: Buffer;
+/**
+ * Verifies if values are equal
+ */
+export declare const OP_EQUALVERIFY: Buffer;
+/**
+ * Verifies signature
+ */
+export declare const OP_CHECKSIG: Buffer;
+/**
+ * Shows that pushdata will need length value
+ */
+export declare const OP_PUSHDATA1: Buffer;
+/**
+ * Verifies a list of signatures
+ * Syntax: <sig1><sig2>...<m> <pub1><pub2>...<n><op_checkmultisig>
+ * it will check the m signatures of the current transaction against the n pubkeys
+ */
+export declare const OP_CHECKMULTISIG: Buffer;
+export declare const OP_0: Buffer;
+//# sourceMappingURL=opcodes.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/opcodes.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/opcodes.d.ts.map
new file mode 100644
index 0000000..d37326a
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/opcodes.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"opcodes.d.ts","sourceRoot":"","sources":["../src/opcodes.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;;AAIH;;;GAGG;AAEH;;GAEG;AACH,eAAO,MAAM,wBAAwB,QAAoB,CAAC;AAE1D;;GAEG;AACH,eAAO,MAAM,MAAM,QAAoB,CAAC;AAExC;;GAEG;AACH,eAAO,MAAM,UAAU,QAAoB,CAAC;AAE5C;;;GAGG;AACH,eAAO,MAAM,QAAQ,QAAoB,CAAC;AAE1C;;GAEG;AACH,eAAO,MAAM,cAAc,QAAoB,CAAC;AAEhD;;GAEG;AACH,eAAO,MAAM,WAAW,QAAoB,CAAC;AAE7C;;GAEG;AACH,eAAO,MAAM,YAAY,QAAoB,CAAC;AAE9C;;;;GAIG;AACH,eAAO,MAAM,gBAAgB,QAAoB,CAAC;AAElD,eAAO,MAAM,IAAI,QAAoB,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/opcodes.js b/node_modules/@hathor/wallet-lib/oldLib/opcodes.js
new file mode 100644
index 0000000..10b9127
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/opcodes.js
@@ -0,0 +1,62 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.OP_PUSHDATA1 = exports.OP_HASH160 = exports.OP_GREATERTHAN_TIMESTAMP = exports.OP_EQUALVERIFY = exports.OP_EQUAL = exports.OP_DUP = exports.OP_CHECKSIG = exports.OP_CHECKMULTISIG = exports.OP_0 = void 0;
+var _buffer = require("./utils/buffer");
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+/**
+ * Opcodes used to generate output script
+ * @module Opcodes
+ */
+
+/**
+ * Checks if timestamp is greater than a value
+ */
+const OP_GREATERTHAN_TIMESTAMP = exports.OP_GREATERTHAN_TIMESTAMP = (0, _buffer.hexToBuffer)('6f');
+
+/**
+ * Duplicates value
+ */
+const OP_DUP = exports.OP_DUP = (0, _buffer.hexToBuffer)('76');
+
+/**
+ * Calculates hash160 of value
+ */
+const OP_HASH160 = exports.OP_HASH160 = (0, _buffer.hexToBuffer)('a9');
+
+/**
+ * Check if values are equal and push 1 to the stack
+ * in case it is and 0 if not
+ */
+const OP_EQUAL = exports.OP_EQUAL = (0, _buffer.hexToBuffer)('87');
+
+/**
+ * Verifies if values are equal
+ */
+const OP_EQUALVERIFY = exports.OP_EQUALVERIFY = (0, _buffer.hexToBuffer)('88');
+
+/**
+ * Verifies signature
+ */
+const OP_CHECKSIG = exports.OP_CHECKSIG = (0, _buffer.hexToBuffer)('ac');
+
+/**
+ * Shows that pushdata will need length value
+ */
+const OP_PUSHDATA1 = exports.OP_PUSHDATA1 = (0, _buffer.hexToBuffer)('4c');
+
+/**
+ * Verifies a list of signatures
+ * Syntax: <sig1><sig2>...<m> <pub1><pub2>...<n><op_checkmultisig>
+ * it will check the m signatures of the current transaction against the n pubkeys
+ */
+const OP_CHECKMULTISIG = exports.OP_CHECKMULTISIG = (0, _buffer.hexToBuffer)('ae');
+const OP_0 = exports.OP_0 = (0, _buffer.hexToBuffer)('50');
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/pushNotification.d.ts b/node_modules/@hathor/wallet-lib/oldLib/pushNotification.d.ts
new file mode 100644
index 0000000..afd78fd
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/pushNotification.d.ts
@@ -0,0 +1,58 @@
+import HathorWalletServiceWallet from './wallet/wallet';
+export declare class PushNotification {
+    /**
+     * Register the device to receive push notifications
+     *
+     * @memberof PushNotification
+     * @inner
+     */
+    static registerDevice(wallet: HathorWalletServiceWallet, payload: PushRegisterRequestData): Promise<PushNotificationResult>;
+    /**
+     * Update the device settings to receive push notifications
+     *
+     * @memberof PushNotification
+     * @inner
+     */
+    static updateDevice(wallet: HathorWalletServiceWallet, payload: PushUpdateRequestData): Promise<PushNotificationResult>;
+    /**
+     * Delete the device from the push notification service
+     *
+     * @memberof PushNotification
+     * @inner
+     */
+    static unregisterDevice(wallet: HathorWalletServiceWallet, deviceId: string): Promise<PushNotificationResult>;
+}
+export interface PushNotificationResult {
+    success: boolean;
+}
+export declare enum PushNotificationProvider {
+    IOS = "ios",
+    ANDROID = "android"
+}
+export interface PushNotificationResponseData {
+    success: boolean;
+    error?: string;
+    /** This property shows up in case of validation error. */
+    details?: {
+        message: string;
+        path: string;
+    }[];
+}
+export interface PushRegisterRequestData {
+    pushProvider: PushNotificationProvider;
+    deviceId: string;
+    enablePush?: boolean;
+    enableShowAmounts?: boolean;
+}
+export interface PushRegisterResponseData extends PushNotificationResponseData {
+}
+export interface PushUpdateRequestData {
+    deviceId: string;
+    enablePush: boolean;
+    enableShowAmounts: boolean;
+}
+export interface PushUpdateResponseData extends PushNotificationResponseData {
+}
+export interface PushUnregisterResponseData extends PushNotificationResponseData {
+}
+//# sourceMappingURL=pushNotification.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/pushNotification.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/pushNotification.d.ts.map
new file mode 100644
index 0000000..700fc5f
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/pushNotification.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"pushNotification.d.ts","sourceRoot":"","sources":["../src/pushNotification.ts"],"names":[],"mappings":"AAAA,OAAO,yBAAyB,MAAM,iBAAiB,CAAC;AAIxD,qBAAa,gBAAgB;IAC3B;;;;;OAKG;WACU,cAAc,CACzB,MAAM,EAAE,yBAAyB,EACjC,OAAO,EAAE,uBAAuB,GAC/B,OAAO,CAAC,sBAAsB,CAAC;IAMlC;;;;;OAKG;WACU,YAAY,CACvB,MAAM,EAAE,yBAAyB,EACjC,OAAO,EAAE,qBAAqB,GAC7B,OAAO,CAAC,sBAAsB,CAAC;IAMlC;;;;;OAKG;WACU,gBAAgB,CAC3B,MAAM,EAAE,yBAAyB,EACjC,QAAQ,EAAE,MAAM,GACf,OAAO,CAAC,sBAAsB,CAAC;CAKnC;AA+CD,MAAM,WAAW,sBAAsB;IACrC,OAAO,EAAE,OAAO,CAAC;CAClB;AAED,oBAAY,wBAAwB;IAClC,GAAG,QAAQ;IACX,OAAO,YAAY;CACpB;AAED,MAAM,WAAW,4BAA4B;IAC3C,OAAO,EAAE,OAAO,CAAC;IACjB,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,0DAA0D;IAC1D,OAAO,CAAC,EAAE;QAAE,OAAO,EAAE,MAAM,CAAC;QAAC,IAAI,EAAE,MAAM,CAAA;KAAE,EAAE,CAAC;CAC/C;AAED,MAAM,WAAW,uBAAuB;IACtC,YAAY,EAAE,wBAAwB,CAAC;IACvC,QAAQ,EAAE,MAAM,CAAC;IACjB,UAAU,CAAC,EAAE,OAAO,CAAC;IACrB,iBAAiB,CAAC,EAAE,OAAO,CAAC;CAC7B;AAED,MAAM,WAAW,wBAAyB,SAAQ,4BAA4B;CAAG;AAEjF,MAAM,WAAW,qBAAqB;IACpC,QAAQ,EAAE,MAAM,CAAC;IACjB,UAAU,EAAE,OAAO,CAAC;IACpB,iBAAiB,EAAE,OAAO,CAAC;CAC5B;AAED,MAAM,WAAW,sBAAuB,SAAQ,4BAA4B;CAAG;AAE/E,MAAM,WAAW,0BAA2B,SAAQ,4BAA4B;CAAG"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/pushNotification.js b/node_modules/@hathor/wallet-lib/oldLib/pushNotification.js
new file mode 100644
index 0000000..24791e6
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/pushNotification.js
@@ -0,0 +1,83 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.PushNotificationProvider = exports.PushNotification = void 0;
+var _walletServiceAxios = require("./wallet/api/walletServiceAxios");
+var _errors = require("./errors");
+class PushNotification {
+  /**
+   * Register the device to receive push notifications
+   *
+   * @memberof PushNotification
+   * @inner
+   */
+  static async registerDevice(wallet, payload) {
+    wallet.failIfWalletNotReady();
+    const data = await walletServiceClient.pushRegister(wallet, payload);
+    return data;
+  }
+
+  /**
+   * Update the device settings to receive push notifications
+   *
+   * @memberof PushNotification
+   * @inner
+   */
+  static async updateDevice(wallet, payload) {
+    wallet.failIfWalletNotReady();
+    const data = await walletServiceClient.pushUpdate(wallet, payload);
+    return data;
+  }
+
+  /**
+   * Delete the device from the push notification service
+   *
+   * @memberof PushNotification
+   * @inner
+   */
+  static async unregisterDevice(wallet, deviceId) {
+    wallet.failIfWalletNotReady();
+    const data = await walletServiceClient.pushUnregister(wallet, deviceId);
+    return data;
+  }
+}
+exports.PushNotification = PushNotification;
+const walletServiceClient = {
+  async pushRegister(wallet, payload) {
+    const axios = await (0, _walletServiceAxios.axiosInstance)(wallet, true);
+    const response = await axios.post('wallet/push/register', payload);
+    if (response.status === 200 && response.data.success) {
+      return response.data;
+    }
+    throw new _errors.WalletRequestError('Error registering device for push notification.', {
+      cause: response.data
+    });
+  },
+  async pushUpdate(wallet, payload) {
+    const axios = await (0, _walletServiceAxios.axiosInstance)(wallet, true);
+    const response = await axios.put('wallet/push/update', payload);
+    if (response.status === 200 && response.data.success) {
+      return response.data;
+    }
+    throw new _errors.WalletRequestError('Error updating push notification settings for device.', {
+      cause: response.data
+    });
+  },
+  async pushUnregister(wallet, deviceId) {
+    const axios = await (0, _walletServiceAxios.axiosInstance)(wallet, true);
+    const response = await axios.delete(`wallet/push/unregister/${deviceId}`);
+    if (response.status === 200 && response.data.success) {
+      return response.data;
+    }
+    throw new _errors.WalletRequestError('Error unregistering wallet from push notifications.', {
+      cause: response.data
+    });
+  }
+};
+let PushNotificationProvider = exports.PushNotificationProvider = /*#__PURE__*/function (PushNotificationProvider) {
+  PushNotificationProvider["IOS"] = "ios";
+  PushNotificationProvider["ANDROID"] = "android";
+  return PushNotificationProvider;
+}({});
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/schemas.d.ts b/node_modules/@hathor/wallet-lib/oldLib/schemas.d.ts
new file mode 100644
index 0000000..deafcda
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/schemas.d.ts
@@ -0,0 +1,465 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+import { z } from 'zod';
+import { IAddressMetadataAsRecord, IAuthoritiesBalance, IBalance, IHistoryInput, IHistoryOutput, IHistoryOutputDecoded, IHistoryTx, ILockedUtxo, ITokenBalance, ITokenMetadata, IUtxo } from './types';
+import { ZodSchema } from './utils/bigint';
+/**
+ * TxId schema
+ */
+export declare const txIdSchema: z.ZodString;
+export declare const ITokenBalanceSchema: ZodSchema<ITokenBalance>;
+export declare const IAuthoritiesBalanceSchema: ZodSchema<IAuthoritiesBalance>;
+export declare const IBalanceSchema: ZodSchema<IBalance>;
+export declare const IAddressMetadataAsRecordSchema: ZodSchema<IAddressMetadataAsRecord>;
+export declare const ITokenMetadataSchema: ZodSchema<ITokenMetadata>;
+export declare const IHistoryOutputDecodedSchema: ZodSchema<IHistoryOutputDecoded>;
+export declare const IHistoryInputSchema: ZodSchema<IHistoryInput>;
+export declare const IHistoryOutputSchema: ZodSchema<IHistoryOutput>;
+export declare const IHistoryNanoContractBaseAction: z.ZodObject<{
+    token_uid: z.ZodString;
+}, "strip", z.ZodTypeAny, {
+    token_uid: string;
+}, {
+    token_uid: string;
+}>;
+export declare const IHistoryNanoContractBaseTokenAction: z.ZodObject<z.objectUtil.extendShape<{
+    token_uid: z.ZodString;
+}, {
+    amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+}>, "strip", z.ZodTypeAny, {
+    token_uid: string;
+    amount: bigint;
+}, {
+    token_uid: string;
+    amount: string | number | bigint;
+}>;
+export declare const IHistoryNanoContractBaseAuthorityAction: z.ZodObject<z.objectUtil.extendShape<{
+    token_uid: z.ZodString;
+}, {
+    mint: z.ZodBoolean;
+    melt: z.ZodBoolean;
+}>, "strip", z.ZodTypeAny, {
+    mint: boolean;
+    melt: boolean;
+    token_uid: string;
+}, {
+    mint: boolean;
+    melt: boolean;
+    token_uid: string;
+}>;
+export declare const IHistoryNanoContractActionWithdrawalSchema: z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+    token_uid: z.ZodString;
+}, {
+    amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+}>, {
+    type: z.ZodLiteral<"withdrawal">;
+}>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+    token_uid: z.ZodString;
+}, {
+    amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+}>, {
+    type: z.ZodLiteral<"withdrawal">;
+}>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+    token_uid: z.ZodString;
+}, {
+    amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+}>, {
+    type: z.ZodLiteral<"withdrawal">;
+}>, z.ZodTypeAny, "passthrough">>;
+export declare const IHistoryNanoContractActionDepositSchema: z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+    token_uid: z.ZodString;
+}, {
+    amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+}>, {
+    type: z.ZodLiteral<"deposit">;
+}>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+    token_uid: z.ZodString;
+}, {
+    amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+}>, {
+    type: z.ZodLiteral<"deposit">;
+}>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+    token_uid: z.ZodString;
+}, {
+    amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+}>, {
+    type: z.ZodLiteral<"deposit">;
+}>, z.ZodTypeAny, "passthrough">>;
+export declare const IHistoryNanoContractActionGrantAuthoritySchema: z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+    token_uid: z.ZodString;
+}, {
+    mint: z.ZodBoolean;
+    melt: z.ZodBoolean;
+}>, {
+    type: z.ZodLiteral<"grant_authority">;
+}>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+    token_uid: z.ZodString;
+}, {
+    mint: z.ZodBoolean;
+    melt: z.ZodBoolean;
+}>, {
+    type: z.ZodLiteral<"grant_authority">;
+}>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+    token_uid: z.ZodString;
+}, {
+    mint: z.ZodBoolean;
+    melt: z.ZodBoolean;
+}>, {
+    type: z.ZodLiteral<"grant_authority">;
+}>, z.ZodTypeAny, "passthrough">>;
+export declare const IHistoryNanoContractActionAcquireAuthoritySchema: z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+    token_uid: z.ZodString;
+}, {
+    mint: z.ZodBoolean;
+    melt: z.ZodBoolean;
+}>, {
+    type: z.ZodLiteral<"acquire_authority">;
+}>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+    token_uid: z.ZodString;
+}, {
+    mint: z.ZodBoolean;
+    melt: z.ZodBoolean;
+}>, {
+    type: z.ZodLiteral<"acquire_authority">;
+}>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+    token_uid: z.ZodString;
+}, {
+    mint: z.ZodBoolean;
+    melt: z.ZodBoolean;
+}>, {
+    type: z.ZodLiteral<"acquire_authority">;
+}>, z.ZodTypeAny, "passthrough">>;
+export declare const IHistoryNanoContractActionSchema: z.ZodDiscriminatedUnion<"type", [z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+    token_uid: z.ZodString;
+}, {
+    amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+}>, {
+    type: z.ZodLiteral<"deposit">;
+}>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+    token_uid: z.ZodString;
+}, {
+    amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+}>, {
+    type: z.ZodLiteral<"deposit">;
+}>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+    token_uid: z.ZodString;
+}, {
+    amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+}>, {
+    type: z.ZodLiteral<"deposit">;
+}>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+    token_uid: z.ZodString;
+}, {
+    amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+}>, {
+    type: z.ZodLiteral<"withdrawal">;
+}>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+    token_uid: z.ZodString;
+}, {
+    amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+}>, {
+    type: z.ZodLiteral<"withdrawal">;
+}>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+    token_uid: z.ZodString;
+}, {
+    amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+}>, {
+    type: z.ZodLiteral<"withdrawal">;
+}>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+    token_uid: z.ZodString;
+}, {
+    mint: z.ZodBoolean;
+    melt: z.ZodBoolean;
+}>, {
+    type: z.ZodLiteral<"grant_authority">;
+}>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+    token_uid: z.ZodString;
+}, {
+    mint: z.ZodBoolean;
+    melt: z.ZodBoolean;
+}>, {
+    type: z.ZodLiteral<"grant_authority">;
+}>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+    token_uid: z.ZodString;
+}, {
+    mint: z.ZodBoolean;
+    melt: z.ZodBoolean;
+}>, {
+    type: z.ZodLiteral<"grant_authority">;
+}>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+    token_uid: z.ZodString;
+}, {
+    mint: z.ZodBoolean;
+    melt: z.ZodBoolean;
+}>, {
+    type: z.ZodLiteral<"acquire_authority">;
+}>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+    token_uid: z.ZodString;
+}, {
+    mint: z.ZodBoolean;
+    melt: z.ZodBoolean;
+}>, {
+    type: z.ZodLiteral<"acquire_authority">;
+}>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+    token_uid: z.ZodString;
+}, {
+    mint: z.ZodBoolean;
+    melt: z.ZodBoolean;
+}>, {
+    type: z.ZodLiteral<"acquire_authority">;
+}>, z.ZodTypeAny, "passthrough">>]>;
+export declare const IHistoryNanoContractContextSchema: z.ZodObject<{
+    actions: z.ZodArray<z.ZodDiscriminatedUnion<"type", [z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+        token_uid: z.ZodString;
+    }, {
+        amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+    }>, {
+        type: z.ZodLiteral<"deposit">;
+    }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+        token_uid: z.ZodString;
+    }, {
+        amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+    }>, {
+        type: z.ZodLiteral<"deposit">;
+    }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+        token_uid: z.ZodString;
+    }, {
+        amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+    }>, {
+        type: z.ZodLiteral<"deposit">;
+    }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+        token_uid: z.ZodString;
+    }, {
+        amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+    }>, {
+        type: z.ZodLiteral<"withdrawal">;
+    }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+        token_uid: z.ZodString;
+    }, {
+        amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+    }>, {
+        type: z.ZodLiteral<"withdrawal">;
+    }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+        token_uid: z.ZodString;
+    }, {
+        amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+    }>, {
+        type: z.ZodLiteral<"withdrawal">;
+    }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+        token_uid: z.ZodString;
+    }, {
+        mint: z.ZodBoolean;
+        melt: z.ZodBoolean;
+    }>, {
+        type: z.ZodLiteral<"grant_authority">;
+    }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+        token_uid: z.ZodString;
+    }, {
+        mint: z.ZodBoolean;
+        melt: z.ZodBoolean;
+    }>, {
+        type: z.ZodLiteral<"grant_authority">;
+    }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+        token_uid: z.ZodString;
+    }, {
+        mint: z.ZodBoolean;
+        melt: z.ZodBoolean;
+    }>, {
+        type: z.ZodLiteral<"grant_authority">;
+    }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+        token_uid: z.ZodString;
+    }, {
+        mint: z.ZodBoolean;
+        melt: z.ZodBoolean;
+    }>, {
+        type: z.ZodLiteral<"acquire_authority">;
+    }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+        token_uid: z.ZodString;
+    }, {
+        mint: z.ZodBoolean;
+        melt: z.ZodBoolean;
+    }>, {
+        type: z.ZodLiteral<"acquire_authority">;
+    }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+        token_uid: z.ZodString;
+    }, {
+        mint: z.ZodBoolean;
+        melt: z.ZodBoolean;
+    }>, {
+        type: z.ZodLiteral<"acquire_authority">;
+    }>, z.ZodTypeAny, "passthrough">>]>, "many">;
+    address: z.ZodString;
+    timestamp: z.ZodNumber;
+}, "passthrough", z.ZodTypeAny, z.objectOutputType<{
+    actions: z.ZodArray<z.ZodDiscriminatedUnion<"type", [z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+        token_uid: z.ZodString;
+    }, {
+        amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+    }>, {
+        type: z.ZodLiteral<"deposit">;
+    }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+        token_uid: z.ZodString;
+    }, {
+        amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+    }>, {
+        type: z.ZodLiteral<"deposit">;
+    }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+        token_uid: z.ZodString;
+    }, {
+        amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+    }>, {
+        type: z.ZodLiteral<"deposit">;
+    }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+        token_uid: z.ZodString;
+    }, {
+        amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+    }>, {
+        type: z.ZodLiteral<"withdrawal">;
+    }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+        token_uid: z.ZodString;
+    }, {
+        amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+    }>, {
+        type: z.ZodLiteral<"withdrawal">;
+    }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+        token_uid: z.ZodString;
+    }, {
+        amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+    }>, {
+        type: z.ZodLiteral<"withdrawal">;
+    }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+        token_uid: z.ZodString;
+    }, {
+        mint: z.ZodBoolean;
+        melt: z.ZodBoolean;
+    }>, {
+        type: z.ZodLiteral<"grant_authority">;
+    }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+        token_uid: z.ZodString;
+    }, {
+        mint: z.ZodBoolean;
+        melt: z.ZodBoolean;
+    }>, {
+        type: z.ZodLiteral<"grant_authority">;
+    }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+        token_uid: z.ZodString;
+    }, {
+        mint: z.ZodBoolean;
+        melt: z.ZodBoolean;
+    }>, {
+        type: z.ZodLiteral<"grant_authority">;
+    }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+        token_uid: z.ZodString;
+    }, {
+        mint: z.ZodBoolean;
+        melt: z.ZodBoolean;
+    }>, {
+        type: z.ZodLiteral<"acquire_authority">;
+    }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+        token_uid: z.ZodString;
+    }, {
+        mint: z.ZodBoolean;
+        melt: z.ZodBoolean;
+    }>, {
+        type: z.ZodLiteral<"acquire_authority">;
+    }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+        token_uid: z.ZodString;
+    }, {
+        mint: z.ZodBoolean;
+        melt: z.ZodBoolean;
+    }>, {
+        type: z.ZodLiteral<"acquire_authority">;
+    }>, z.ZodTypeAny, "passthrough">>]>, "many">;
+    address: z.ZodString;
+    timestamp: z.ZodNumber;
+}, z.ZodTypeAny, "passthrough">, z.objectInputType<{
+    actions: z.ZodArray<z.ZodDiscriminatedUnion<"type", [z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+        token_uid: z.ZodString;
+    }, {
+        amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+    }>, {
+        type: z.ZodLiteral<"deposit">;
+    }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+        token_uid: z.ZodString;
+    }, {
+        amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+    }>, {
+        type: z.ZodLiteral<"deposit">;
+    }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+        token_uid: z.ZodString;
+    }, {
+        amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+    }>, {
+        type: z.ZodLiteral<"deposit">;
+    }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+        token_uid: z.ZodString;
+    }, {
+        amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+    }>, {
+        type: z.ZodLiteral<"withdrawal">;
+    }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+        token_uid: z.ZodString;
+    }, {
+        amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+    }>, {
+        type: z.ZodLiteral<"withdrawal">;
+    }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+        token_uid: z.ZodString;
+    }, {
+        amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+    }>, {
+        type: z.ZodLiteral<"withdrawal">;
+    }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+        token_uid: z.ZodString;
+    }, {
+        mint: z.ZodBoolean;
+        melt: z.ZodBoolean;
+    }>, {
+        type: z.ZodLiteral<"grant_authority">;
+    }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+        token_uid: z.ZodString;
+    }, {
+        mint: z.ZodBoolean;
+        melt: z.ZodBoolean;
+    }>, {
+        type: z.ZodLiteral<"grant_authority">;
+    }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+        token_uid: z.ZodString;
+    }, {
+        mint: z.ZodBoolean;
+        melt: z.ZodBoolean;
+    }>, {
+        type: z.ZodLiteral<"grant_authority">;
+    }>, z.ZodTypeAny, "passthrough">>, z.ZodObject<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+        token_uid: z.ZodString;
+    }, {
+        mint: z.ZodBoolean;
+        melt: z.ZodBoolean;
+    }>, {
+        type: z.ZodLiteral<"acquire_authority">;
+    }>, "passthrough", z.ZodTypeAny, z.objectOutputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+        token_uid: z.ZodString;
+    }, {
+        mint: z.ZodBoolean;
+        melt: z.ZodBoolean;
+    }>, {
+        type: z.ZodLiteral<"acquire_authority">;
+    }>, z.ZodTypeAny, "passthrough">, z.objectInputType<z.objectUtil.extendShape<z.objectUtil.extendShape<{
+        token_uid: z.ZodString;
+    }, {
+        mint: z.ZodBoolean;
+        melt: z.ZodBoolean;
+    }>, {
+        type: z.ZodLiteral<"acquire_authority">;
+    }>, z.ZodTypeAny, "passthrough">>]>, "many">;
+    address: z.ZodString;
+    timestamp: z.ZodNumber;
+}, z.ZodTypeAny, "passthrough">>;
+export declare const IHistoryTxSchema: ZodSchema<IHistoryTx>;
+export declare const IUtxoSchema: ZodSchema<IUtxo>;
+export declare const ILockedUtxoSchema: ZodSchema<ILockedUtxo>;
+//# sourceMappingURL=schemas.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/schemas.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/schemas.d.ts.map
new file mode 100644
index 0000000..60f574c
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/schemas.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"schemas.d.ts","sourceRoot":"","sources":["../src/schemas.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;AAEH,OAAO,EAAE,CAAC,EAAE,MAAM,KAAK,CAAC;AACxB,OAAO,EACL,wBAAwB,EACxB,mBAAmB,EACnB,QAAQ,EACR,aAAa,EACb,cAAc,EACd,qBAAqB,EACrB,UAAU,EACV,WAAW,EACX,aAAa,EACb,cAAc,EACd,KAAK,EAEN,MAAM,SAAS,CAAC;AACjB,OAAO,EAAyB,SAAS,EAAE,MAAM,gBAAgB,CAAC;AAElE;;GAEG;AACH,eAAO,MAAM,UAAU,aAAwC,CAAC;AAEhE,eAAO,MAAM,mBAAmB,EAAE,SAAS,CAAC,aAAa,CAKzC,CAAC;AAEjB,eAAO,MAAM,yBAAyB,EAAE,SAAS,CAAC,mBAAmB,CAKrD,CAAC;AAEjB,eAAO,MAAM,cAAc,EAAE,SAAS,CAAC,QAAQ,CAK/B,CAAC;AAEjB,eAAO,MAAM,8BAA8B,EAAE,SAAS,CAAC,wBAAwB,CAM/D,CAAC;AAEjB,eAAO,MAAM,oBAAoB,EAAE,SAAS,CAAC,cAAc,CAK3C,CAAC;AAEjB,eAAO,MAAM,2BAA2B,EAAE,SAAS,CAAC,qBAAqB,CAOzD,CAAC;AAEjB,eAAO,MAAM,mBAAmB,EAAE,SAAS,CAAC,aAAa,CAUzC,CAAC;AAEjB,eAAO,MAAM,oBAAoB,EAAE,SAAS,CAAC,cAAc,CAU3C,CAAC;AAEjB,eAAO,MAAM,8BAA8B;;;;;;EAEzC,CAAC;AAEH,eAAO,MAAM,mCAAmC;;;;;;;;;;EAE9C,CAAC;AAEH,eAAO,MAAM,uCAAuC;;;;;;;;;;;;;EAGlD,CAAC;AACH,eAAO,MAAM,0CAA0C;;;;;;;;;;;;;;;;;;iCAGrC,CAAC;AAEnB,eAAO,MAAM,uCAAuC;;;;;;;;;;;;;;;;;;iCAEpC,CAAC;AAEjB,eAAO,MAAM,8CAA8C;;;;;;;;;;;;;;;;;;;;;iCAGzC,CAAC;AAEnB,eAAO,MAAM,gDAAgD;;;;;;;;;;;;;;;;;;;;;iCAG3C,CAAC;AAEnB,eAAO,MAAM,gCAAgC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mCAK3C,CAAC;AAEH,eAAO,MAAM,iCAAiC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gCAM9B,CAAC;AAEjB,eAAO,MAAM,gBAAgB,EAAE,SAAS,CAAC,UAAU,CA6BnC,CAAC;AAEjB,eAAO,MAAM,WAAW,EAAE,SAAS,CAAC,KAAK,CAYzB,CAAC;AAEjB,eAAO,MAAM,iBAAiB,EAAE,SAAS,CAAC,WAAW,CAKrC,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/schemas.js b/node_modules/@hathor/wallet-lib/oldLib/schemas.js
new file mode 100644
index 0000000..6918a21
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/schemas.js
@@ -0,0 +1,134 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.txIdSchema = exports.IUtxoSchema = exports.ITokenMetadataSchema = exports.ITokenBalanceSchema = exports.ILockedUtxoSchema = exports.IHistoryTxSchema = exports.IHistoryOutputSchema = exports.IHistoryOutputDecodedSchema = exports.IHistoryNanoContractContextSchema = exports.IHistoryNanoContractBaseTokenAction = exports.IHistoryNanoContractBaseAuthorityAction = exports.IHistoryNanoContractBaseAction = exports.IHistoryNanoContractActionWithdrawalSchema = exports.IHistoryNanoContractActionSchema = exports.IHistoryNanoContractActionGrantAuthoritySchema = exports.IHistoryNanoContractActionDepositSchema = exports.IHistoryNanoContractActionAcquireAuthoritySchema = exports.IHistoryInputSchema = exports.IBalanceSchema = exports.IAuthoritiesBalanceSchema = exports.IAddressMetadataAsRecordSchema = void 0;
+var _zod = require("zod");
+var _types = require("./types");
+var _bigint = require("./utils/bigint");
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+/**
+ * TxId schema
+ */
+const txIdSchema = exports.txIdSchema = _zod.z.string().regex(/^[a-fA-F0-9]{64}$/);
+const ITokenBalanceSchema = exports.ITokenBalanceSchema = _zod.z.object({
+  locked: _bigint.bigIntCoercibleSchema,
+  unlocked: _bigint.bigIntCoercibleSchema
+}).passthrough();
+const IAuthoritiesBalanceSchema = exports.IAuthoritiesBalanceSchema = _zod.z.object({
+  mint: ITokenBalanceSchema,
+  melt: ITokenBalanceSchema
+}).passthrough();
+const IBalanceSchema = exports.IBalanceSchema = _zod.z.object({
+  tokens: ITokenBalanceSchema,
+  authorities: IAuthoritiesBalanceSchema
+}).passthrough();
+const IAddressMetadataAsRecordSchema = exports.IAddressMetadataAsRecordSchema = _zod.z.object({
+  numTransactions: _zod.z.number(),
+  balance: _zod.z.record(IBalanceSchema),
+  seqnum: _zod.z.number()
+}).passthrough();
+const ITokenMetadataSchema = exports.ITokenMetadataSchema = _zod.z.object({
+  numTransactions: _zod.z.number(),
+  balance: IBalanceSchema
+}).passthrough();
+const IHistoryOutputDecodedSchema = exports.IHistoryOutputDecodedSchema = _zod.z.object({
+  type: _zod.z.string().optional(),
+  address: _zod.z.string().optional(),
+  timelock: _zod.z.number().nullish(),
+  data: _zod.z.string().optional()
+}).passthrough();
+const IHistoryInputSchema = exports.IHistoryInputSchema = _zod.z.object({
+  value: _bigint.bigIntCoercibleSchema,
+  token_data: _zod.z.number(),
+  script: _zod.z.string(),
+  decoded: IHistoryOutputDecodedSchema,
+  token: _zod.z.string(),
+  tx_id: txIdSchema,
+  index: _zod.z.number()
+}).passthrough();
+const IHistoryOutputSchema = exports.IHistoryOutputSchema = _zod.z.object({
+  value: _bigint.bigIntCoercibleSchema,
+  token_data: _zod.z.number(),
+  script: _zod.z.string(),
+  decoded: IHistoryOutputDecodedSchema,
+  token: _zod.z.string(),
+  spent_by: _zod.z.string().nullable(),
+  selected_as_input: _zod.z.boolean().optional()
+}).passthrough();
+const IHistoryNanoContractBaseAction = exports.IHistoryNanoContractBaseAction = _zod.z.object({
+  token_uid: _zod.z.string()
+});
+const IHistoryNanoContractBaseTokenAction = exports.IHistoryNanoContractBaseTokenAction = IHistoryNanoContractBaseAction.extend({
+  amount: _bigint.bigIntCoercibleSchema
+});
+const IHistoryNanoContractBaseAuthorityAction = exports.IHistoryNanoContractBaseAuthorityAction = IHistoryNanoContractBaseAction.extend({
+  mint: _zod.z.boolean(),
+  melt: _zod.z.boolean()
+});
+const IHistoryNanoContractActionWithdrawalSchema = exports.IHistoryNanoContractActionWithdrawalSchema = IHistoryNanoContractBaseTokenAction.extend({
+  type: _zod.z.literal('withdrawal')
+}).passthrough();
+const IHistoryNanoContractActionDepositSchema = exports.IHistoryNanoContractActionDepositSchema = IHistoryNanoContractBaseTokenAction.extend({
+  type: _zod.z.literal('deposit')
+}).passthrough();
+const IHistoryNanoContractActionGrantAuthoritySchema = exports.IHistoryNanoContractActionGrantAuthoritySchema = IHistoryNanoContractBaseAuthorityAction.extend({
+  type: _zod.z.literal('grant_authority')
+}).passthrough();
+const IHistoryNanoContractActionAcquireAuthoritySchema = exports.IHistoryNanoContractActionAcquireAuthoritySchema = IHistoryNanoContractBaseAuthorityAction.extend({
+  type: _zod.z.literal('acquire_authority')
+}).passthrough();
+const IHistoryNanoContractActionSchema = exports.IHistoryNanoContractActionSchema = _zod.z.discriminatedUnion('type', [IHistoryNanoContractActionDepositSchema, IHistoryNanoContractActionWithdrawalSchema, IHistoryNanoContractActionGrantAuthoritySchema, IHistoryNanoContractActionAcquireAuthoritySchema]);
+const IHistoryNanoContractContextSchema = exports.IHistoryNanoContractContextSchema = _zod.z.object({
+  actions: IHistoryNanoContractActionSchema.array(),
+  address: _zod.z.string(),
+  timestamp: _zod.z.number()
+}).passthrough();
+const IHistoryTxSchema = exports.IHistoryTxSchema = _zod.z.object({
+  tx_id: txIdSchema,
+  signalBits: _zod.z.number().optional(),
+  version: _zod.z.number(),
+  weight: _zod.z.number(),
+  timestamp: _zod.z.number(),
+  is_voided: _zod.z.boolean(),
+  nonce: _zod.z.number().optional(),
+  inputs: IHistoryInputSchema.array(),
+  outputs: IHistoryOutputSchema.array(),
+  parents: _zod.z.string().array(),
+  token_name: _zod.z.string().optional(),
+  token_symbol: _zod.z.string().optional(),
+  tokens: _zod.z.string().array().optional(),
+  height: _zod.z.number().optional(),
+  processingStatus: _zod.z.nativeEnum(_types.TxHistoryProcessingStatus).optional(),
+  nc_id: _zod.z.string().optional(),
+  nc_blueprint_id: _zod.z.string().optional(),
+  nc_method: _zod.z.string().optional(),
+  nc_args: _zod.z.string().optional(),
+  nc_pubkey: _zod.z.string().regex(/^[a-fA-F0-9]*$/).optional(),
+  // for on-chain-blueprints
+  nc_address: _zod.z.string().optional(),
+  nc_context: IHistoryNanoContractContextSchema.optional(),
+  first_block: _zod.z.string().nullish()
+}).passthrough();
+const IUtxoSchema = exports.IUtxoSchema = _zod.z.object({
+  txId: txIdSchema,
+  index: _zod.z.number(),
+  token: _zod.z.string(),
+  address: _zod.z.string(),
+  value: _bigint.bigIntCoercibleSchema,
+  authorities: _bigint.bigIntCoercibleSchema,
+  timelock: _zod.z.number().nullable(),
+  type: _zod.z.number(),
+  height: _zod.z.number().nullable()
+}).passthrough();
+const ILockedUtxoSchema = exports.ILockedUtxoSchema = _zod.z.object({
+  tx: IHistoryTxSchema,
+  index: _zod.z.number()
+}).passthrough();
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/storage/index.d.ts b/node_modules/@hathor/wallet-lib/oldLib/storage/index.d.ts
new file mode 100644
index 0000000..ba6490c
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/storage/index.d.ts
@@ -0,0 +1,13 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+import { Storage } from './storage';
+import { MemoryStore } from './memory_store';
+declare const storage: Storage;
+export { Storage };
+export { MemoryStore };
+export default storage;
+//# sourceMappingURL=index.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/storage/index.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/storage/index.d.ts.map
new file mode 100644
index 0000000..ae8f31a
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/storage/index.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../src/storage/index.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;AAEH,OAAO,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;AACpC,OAAO,EAAE,WAAW,EAAE,MAAM,gBAAgB,CAAC;AAG7C,QAAA,MAAM,OAAO,SAAqB,CAAC;AAEnC,OAAO,EAAE,OAAO,EAAE,CAAC;AACnB,OAAO,EAAE,WAAW,EAAE,CAAC;AAEvB,eAAe,OAAO,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/storage/index.js b/node_modules/@hathor/wallet-lib/oldLib/storage/index.js
new file mode 100644
index 0000000..d4c5f1c
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/storage/index.js
@@ -0,0 +1,30 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+Object.defineProperty(exports, "MemoryStore", {
+  enumerable: true,
+  get: function () {
+    return _memory_store.MemoryStore;
+  }
+});
+Object.defineProperty(exports, "Storage", {
+  enumerable: true,
+  get: function () {
+    return _storage.Storage;
+  }
+});
+exports.default = void 0;
+var _storage = require("./storage");
+var _memory_store = require("./memory_store");
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+const store = new _memory_store.MemoryStore();
+const storage = new _storage.Storage(store);
+var _default = exports.default = storage;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/storage/memory_store.d.ts b/node_modules/@hathor/wallet-lib/oldLib/storage/memory_store.d.ts
new file mode 100644
index 0000000..0d9ecca
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/storage/memory_store.d.ts
@@ -0,0 +1,441 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+import { IStore, IAddressInfo, ITokenData, ITokenMetadata, IHistoryTx, IUtxo, IWalletAccessData, IUtxoFilterOptions, IAddressMetadata, IWalletData, ILockedUtxo, AddressScanPolicy, AddressScanPolicyData, IIndexLimitAddressScanPolicy, INcData } from '../types';
+export declare class MemoryStore implements IStore {
+    /**
+     * Map<base58, IAddressInfo>
+     * where base58 is the address in base58
+     */
+    addresses: Map<string, IAddressInfo>;
+    /**
+     * Map<index, base58>
+     * where index is the address index and base58 is the address in base58
+     */
+    addressIndexes: Map<number, string>;
+    /**
+     * Map<base58, IAddressMetadata>
+     * where base58 is the address in base58
+     */
+    addressesMetadata: Map<string, IAddressMetadata>;
+    /**
+     * Map<uid, ITokenData>
+     * where uid is the token uid in hex
+     */
+    tokens: Map<string, ITokenData>;
+    /**
+     * Map<uid, ITokenMetadata>
+     * where uid is the token uid in hex
+     */
+    tokensMetadata: Map<string, ITokenMetadata>;
+    /**
+     * Map<uid, ITokenData>
+     * where uid is the token uid in hex
+     */
+    registeredTokens: Map<string, ITokenData>;
+    /**
+     * Map<ncId, INcData>
+     * where ncId is the nano contract id in hex
+     */
+    registeredNanoContracts: Map<string, INcData>;
+    /**
+     * Map<txId, IHistoryTx>
+     * where txId is the transaction id in hex
+     */
+    history: Map<string, IHistoryTx>;
+    /**
+     * Array of `<timestamp>:<txId>` strings, which should be always sorted.
+     * `timestamp` should be in uint32 representation
+     * This will force the items to be ordered by timestamp.
+     */
+    historyTs: string[];
+    /**
+     * Map<utxoid, IUtxo>
+     * where utxoid is the txId + index, a string representation of IUtxoId
+     */
+    utxos: Map<string, IUtxo>;
+    /**
+     * Wallet access data
+     */
+    accessData: IWalletAccessData | null;
+    /**
+     * Wallet metadata
+     */
+    walletData: IWalletData;
+    /**
+     * Generic storage for any other data
+     */
+    genericStorage: Record<string, unknown>;
+    lockedUtxos: Map<string, ILockedUtxo>;
+    constructor();
+    validate(): Promise<void>;
+    /**
+     * Prepare the store for history processing.
+     */
+    preProcessHistory(): Promise<void>;
+    /** ADDRESSES */
+    /**
+     * Iterate on all addresses
+     *
+     * @async
+     * @returns {AsyncGenerator<IAddressInfo>}
+     */
+    addressIter(): AsyncGenerator<IAddressInfo, void, void>;
+    /**
+     * Get the address info if it exists.
+     *
+     * @param {string} base58 Address in base58 to search
+     * @async
+     * @returns {Promise<IAddressInfo | null>} A promise with the address info or null if not in storage
+     */
+    getAddress(base58: string): Promise<IAddressInfo | null>;
+    /**
+     * Get the metadata for an address if it exists.
+     *
+     * @param {string} base58 Address in base58 to search the metadata
+     * @async
+     * @returns {Promise<IAddressMetadata | null>} A promise with the address metadata or null if not in storage
+     */
+    getAddressMeta(base58: string): Promise<IAddressMetadata | null>;
+    /**
+     * Count the number of addresses in storage.
+     * @async
+     * @returns {Promise<number>} A promise with the number of addresses
+     */
+    addressCount(): Promise<number>;
+    /**
+     * Get the address info from its bip32 index.
+     * @param index bip32 address index to search for
+     * @async
+     * @returns {Promise<IAddressInfo | null>} The address info or null if not in storage
+     */
+    getAddressAtIndex(index: number): Promise<IAddressInfo | null>;
+    /**
+     * Save the address in storage
+     * @param {IAddressInfo} info Info on address to save
+     * @async
+     * @returns {Promise<void>}
+     */
+    saveAddress(info: IAddressInfo): Promise<void>;
+    /**
+     * Check that an address is in our storage.
+     * @param {string} base58 Address to check.
+     * @async
+     * @returns A promise that resolves to wheather the address is saved in storage or no.
+     */
+    addressExists(base58: string): Promise<boolean>;
+    /**
+     * Get the current address.
+     *
+     * @param {boolean | undefined} markAsUsed If we should set the next address as current
+     * @async
+     * @returns {Promise<string>} The address in base58 format
+     */
+    getCurrentAddress(markAsUsed?: boolean): Promise<string>;
+    /**
+     * Set the value of the current address index.
+     * @param {number} index The index to set
+     */
+    setCurrentAddressIndex(index: number): Promise<void>;
+    /**
+     * Edit address metadata.
+     *
+     * @param {string} base58 The address in base58 format
+     * @param {IAddressMetadata} meta The metadata to save
+     */
+    editAddressMeta(base58: string, meta: IAddressMetadata): Promise<void>;
+    /**
+     * Iterate on the transaction history ordered by timestamp.
+     *
+     * @param {string|undefined} tokenUid Only yield txs with this token.
+     *
+     * @async
+     * @returns {AsyncGenerator<IHistoryTx>}
+     */
+    historyIter(tokenUid?: string | undefined): AsyncGenerator<IHistoryTx>;
+    /**
+     * Get the size of the transaction history.
+     *
+     * @returns {Promise<number>} The size of the transaction history
+     */
+    historyCount(): Promise<number>;
+    /**
+     * Save a transaction on storage.
+     * @param {IHistoryTx} tx The transaction to store
+     * @async
+     * @returns {Promise<void>}
+     */
+    saveTx(tx: IHistoryTx): Promise<void>;
+    /**
+     * Fetch a transaction in the storage by its id.
+     * @param txId The transaction id
+     * @async
+     * @returns {Promise<IHistoryTx | null>} A promise with the transaction or null
+     */
+    getTx(txId: string): Promise<IHistoryTx | null>;
+    /** TOKENS */
+    /**
+     * Iterate on tokens with the available metadata
+     *
+     * @async
+     * @returns {AsyncGenerator<ITokenData & Partial<ITokenMetadata>>}
+     */
+    tokenIter(): AsyncGenerator<ITokenData & Partial<ITokenMetadata>>;
+    /**
+     * Get a token on storage from the uid
+     * @param tokenUid The token id to fetch
+     * @returns {Promise<(ITokenData & Partial<ITokenMetadata>) | null>} The token data if present
+     */
+    getToken(tokenUid: string): Promise<(ITokenData & Partial<ITokenMetadata>) | null>;
+    /**
+     * Fetch the token metadata from the storage.
+     *
+     * @param {string} tokenUid The token id to fetch metadata.
+     * @returns {Promise<ITokenMetadata | null>} The token metadata if present
+     */
+    getTokenMeta(tokenUid: string): Promise<ITokenMetadata | null>;
+    /**
+     * Save a token on storage
+     * @param {ITokenData} tokenConfig Token config
+     * @param {ITokenMetadata|undefined} [meta] The token metadata
+     * @async
+     * @returns {Promise<void>}
+     */
+    saveToken(tokenConfig: ITokenData, meta?: ITokenMetadata | undefined): Promise<void>;
+    /**
+     * Iterate on registered tokens.
+     *
+     * @async
+     * @returns {AsyncGenerator<ITokenData & Partial<ITokenMetadata>>}
+     */
+    registeredTokenIter(): AsyncGenerator<ITokenData & Partial<ITokenMetadata>>;
+    /**
+     * Register a token.
+     *
+     * Obs: we require the token data because the token being registered may not be on our storage yet.
+     *
+     * @param token Token config to register
+     * @async
+     * @returns {Promise<void>}
+     */
+    registerToken(token: ITokenData): Promise<void>;
+    /**
+     * Unregister a token.
+     *
+     * @param {string} tokenUid Token id
+     * @async
+     * @returns {Promise<void>}
+     */
+    unregisterToken(tokenUid: string): Promise<void>;
+    /**
+     * Return if a token uid is registered or not.
+     *
+     * @param {string} tokenUid - Token id
+     * @returns {Promise<boolean>}
+     */
+    isTokenRegistered(tokenUid: string): Promise<boolean>;
+    /**
+     * Edit token metadata on storage.
+     * @param {string} tokenUid Token id to edit
+     * @param {Partial<ITokenMetadata>} meta Metadata to save
+     * @returns {Promise<void>}
+     */
+    editTokenMeta(tokenUid: string, meta: ITokenMetadata): Promise<void>;
+    /** UTXOS */
+    /**
+     * Iterate on all available utxos.
+     * @async
+     * @returns {AsyncGenerator<IUtxo>}
+     */
+    utxoIter(): AsyncGenerator<IUtxo, void, void>;
+    deleteUtxo(utxo: IUtxo): Promise<void>;
+    /**
+     * Fetch utxos based on a selection criteria
+     * @param {IUtxoFilterOptions} options Options to filter utxos
+     * @async
+     * @returns {AsyncGenerator<IUtxo>}
+     */
+    selectUtxos(options: IUtxoFilterOptions): AsyncGenerator<IUtxo>;
+    /**
+     * Save an utxo on storage.
+     * @param {IUtxo} utxo Utxo to save
+     * @async
+     * @returns {Promise<void>}
+     */
+    saveUtxo(utxo: IUtxo): Promise<void>;
+    /**
+     * Save a locked utxo.
+     * Used when a new utxo is received but it is either time locked or height locked.
+     * The locked utxo index will be used to manage the locked utxos.
+     *
+     * @param {ILockedUtxo} lockedUtxo The locked utxo to be saved
+     * @returns {Promise<void>}
+     */
+    saveLockedUtxo(lockedUtxo: ILockedUtxo): Promise<void>;
+    /**
+     * Iterate over all locked utxos
+     * @returns {AsyncGenerator<ILockedUtxo>}
+     */
+    iterateLockedUtxos(): AsyncGenerator<ILockedUtxo>;
+    /**
+     * Remove an utxo from the locked utxos if it became unlocked.
+     *
+     * @param lockedUtxo utxo that became unlocked
+     * @returns {Promise<void>}
+     */
+    unlockUtxo(lockedUtxo: ILockedUtxo): Promise<void>;
+    /** ACCESS DATA */
+    /**
+     * Save access data on storage.
+     * @param {IWalletAccessData} data Access data to save
+     * @async
+     * @returns {Promise<void>}
+     */
+    saveAccessData(data: IWalletAccessData): Promise<void>;
+    /**
+     * Fetch wallet access data on storage if present.
+     * @async
+     * @returns {Promise<IWalletAccessData | null>} A promise with the wallet access data.
+     */
+    getAccessData(): Promise<IWalletAccessData | null>;
+    /**
+     * Get the last bip32 address index loaded on storage.
+     * @async
+     * @returns {Promise<number>}
+     */
+    getLastLoadedAddressIndex(): Promise<number>;
+    /**
+     * Get the last bip32 address index used, i.e. with any transaction.
+     * @async
+     * @returns {Promise<number>}
+     */
+    getLastUsedAddressIndex(): Promise<number>;
+    /**
+     * Set the current best chain height.
+     * @async
+     * @param {number} height Height to set.
+     */
+    setCurrentHeight(height: number): Promise<void>;
+    /**
+     * Set the last bip32 address index used on storage.
+     * @param {number} index The index to set as last used address.
+     */
+    setLastUsedAddressIndex(index: number): Promise<void>;
+    /**
+     * Get the current best chain height.
+     * @async
+     * @returns {Promise<number>}
+     */
+    getCurrentHeight(): Promise<number>;
+    /**
+     * Set the gap limit for this wallet.
+     * @async
+     * @param {number} value Gat limit to set.
+     */
+    setGapLimit(value: number): Promise<void>;
+    /**
+     * Get the current wallet gap limit.
+     * @async
+     * @returns {Promise<number>}
+     */
+    getGapLimit(): Promise<number>;
+    getIndexLimit(): Promise<Omit<IIndexLimitAddressScanPolicy, 'policy'> | null>;
+    /**
+     * Get the configured address scanning policy.
+     * @async
+     * @returns {Promise<AddressScanPolicy>}
+     */
+    getScanningPolicy(): Promise<AddressScanPolicy>;
+    setScanningPolicyData(data: AddressScanPolicyData): Promise<void>;
+    getScanningPolicyData(): Promise<AddressScanPolicyData>;
+    /**
+     * Get the wallet data.
+     * @async
+     * @returns {Promise<IWalletData>}
+     */
+    getWalletData(): Promise<IWalletData>;
+    /**
+     * Get an entry on the generic storage.
+     * @param {string} key Key to fetch
+     * @async
+     * @returns {Promise<any>}
+     */
+    getItem(key: string): Promise<unknown>;
+    /**
+     * Set an item on the generic storage.
+     *
+     * @param {string} key Key to store
+     * @param {any} value Value to store
+     * @async
+     * @returns {Promise<void>}
+     */
+    setItem(key: string, value: unknown): Promise<void>;
+    /**
+     * Clean the storage.
+     * @param {boolean} cleanHistory if we should clean the transaction history.
+     * @param {boolean} cleanAddresses if we should clean the addresses.
+     * @param {boolean} cleanTokens if we should clean the registered tokens.
+     * @async
+     * @returns {Promise<void>}
+     */
+    cleanStorage(cleanHistory?: boolean, cleanAddresses?: boolean, cleanTokens?: boolean): Promise<void>;
+    /**
+     * Clean the store metadata.
+     *
+     * This is used when processing the history to avoid keeping metadata from a voided tx.
+     * `processHistory` is additive, so if we don't clean the metadata we are passive to keep stale metadata.
+     * This is also true for utxos since processing txs that spent utxos will not remove the utxo from the store.
+     *
+     * @returns {Promise<void>}
+     */
+    cleanMetadata(): Promise<void>;
+    /**
+     * Return if the nano contract is registered for the given address based on ncId.
+     *
+     * @param ncId Nano Contract ID.
+     * @returns `true` if registered and `false` otherwise.
+     * @async
+     */
+    isNanoContractRegistered(ncId: string): Promise<boolean>;
+    /**
+     * Iterate on registered nano contracts.
+     *
+     * @async
+     * @generator
+     * @returns {AsyncGenerator<INcData>}
+     */
+    registeredNanoContractsIter(): AsyncGenerator<INcData>;
+    /**
+     * Get a nano contract data on storage from the ncId.
+     *
+     * @param ncId Nano Contract ID.
+     * @returns Nano contract data instance.
+     * @async
+     */
+    getNanoContract(ncId: string): Promise<INcData | null>;
+    /**
+     * Register a nano contract data.
+     *
+     * @param ncId Nano Contract ID.
+     * @param ncValue Nano contract basic information.
+     * @async
+     */
+    registerNanoContract(ncId: string, ncValue: INcData): Promise<void>;
+    /**
+     * Unregister nano contract.
+     *
+     * @param ncId Nano Contract ID.
+     */
+    unregisterNanoContract(ncId: string): Promise<void>;
+    /**
+     * Update nano contract registered address.
+     *
+     * @param ncId Nano Contract ID.
+     * @param address Nano Contract registered address.
+     */
+    updateNanoContractRegisteredAddress(ncId: string, address: string): Promise<void>;
+}
+//# sourceMappingURL=memory_store.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/storage/memory_store.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/storage/memory_store.d.ts.map
new file mode 100644
index 0000000..aa607b1
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/storage/memory_store.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"memory_store.d.ts","sourceRoot":"","sources":["../../src/storage/memory_store.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/storage/memory_store.js b/node_modules/@hathor/wallet-lib/oldLib/storage/memory_store.js
new file mode 100644
index 0000000..32a9d50
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/storage/memory_store.js
@@ -0,0 +1,990 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.MemoryStore = void 0;
+var _lodash = require("lodash");
+var _types = require("../types");
+var _constants = require("../constants");
+var _transaction = _interopRequireDefault(require("../utils/transaction"));
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
+function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
+function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
+function _awaitAsyncGenerator(e) { return new _OverloadYield(e, 0); }
+function _wrapAsyncGenerator(e) { return function () { return new AsyncGenerator(e.apply(this, arguments)); }; }
+function AsyncGenerator(e) { var r, t; function resume(r, t) { try { var n = e[r](t), o = n.value, u = o instanceof _OverloadYield; Promise.resolve(u ? o.v : o).then(function (t) { if (u) { var i = "return" === r ? "return" : "next"; if (!o.k || t.done) return resume(i, t); t = e[i](t).value; } settle(n.done ? "return" : "normal", t); }, function (e) { resume("throw", e); }); } catch (e) { settle("throw", e); } } function settle(e, n) { switch (e) { case "return": r.resolve({ value: n, done: !0 }); break; case "throw": r.reject(n); break; default: r.resolve({ value: n, done: !1 }); } (r = r.next) ? resume(r.key, r.arg) : t = null; } this._invoke = function (e, n) { return new Promise(function (o, u) { var i = { key: e, arg: n, resolve: o, reject: u, next: null }; t ? t = t.next = i : (r = t = i, resume(e, n)); }); }, "function" != typeof e.return && (this.return = void 0); }
+AsyncGenerator.prototype["function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator"] = function () { return this; }, AsyncGenerator.prototype.next = function (e) { return this._invoke("next", e); }, AsyncGenerator.prototype.throw = function (e) { return this._invoke("throw", e); }, AsyncGenerator.prototype.return = function (e) { return this._invoke("return", e); };
+function _OverloadYield(e, d) { this.v = e, this.k = d; } /**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+const DEFAULT_ADDRESSES_WALLET_DATA = {
+  lastLoadedAddressIndex: 0,
+  lastUsedAddressIndex: -1,
+  currentAddressIndex: -1
+};
+const DEFAULT_SCAN_POLICY_DATA = {
+  policy: _types.SCANNING_POLICY.GAP_LIMIT,
+  gapLimit: _constants.GAP_LIMIT
+};
+const DEFAULT_WALLET_DATA = {
+  bestBlockHeight: 0,
+  scanPolicyData: DEFAULT_SCAN_POLICY_DATA
+};
+
+/**
+ * Get the ordering key for a transaction.
+ * This will be used to sort the transactions by timestamp.
+ *
+ * @param {Pick<IHistoryTx, 'timestamp'|'tx_id'>} tx The transaction, at least with timestamp and tx_id
+ * @returns {string} The ordering key for the transaction
+ * @example
+ * // returns '0000000f:cafe'
+ * getOrderingKey({ tx_id: 'cafe', timestamp: 15 });
+ * @example
+ * // returns '5fbec5d0:abcdef'
+ * getOrderingKey({ tx_id: 'abcdef', timestamp: 1606338000 });
+ */
+function getOrderingKey(tx) {
+  const buf = Buffer.alloc(4);
+  buf.writeUInt32BE(tx.timestamp, 0);
+  return `${buf.toString('hex')}:${tx.tx_id}`;
+}
+
+/**
+ * Get the parts of the ordering key.
+ * This is meant to be used to decode the ordering key
+ * so we can fetch the transaction from the storage.
+ *
+ * @param {string} key The ordering key of a transaction
+ * @returns {{ timestamp: number, txId: string }}
+ * @example
+ * // returns { timestamp: 15, txId: 'cafe' }
+ * getPartsFromOrderingKey('0000000f:cafe');
+ * @example
+ * // returns { timestamp: 1606338000, txId: 'abcdef' }
+ * getPartsFromOrderingKey('5fbec5d0:abcdef');
+ */
+function getPartsFromOrderingKey(key) {
+  const parts = key.split(':');
+  const buf = Buffer.from(parts[0], 'hex');
+  return {
+    timestamp: buf.readUInt32BE(0),
+    txId: parts[1]
+  };
+}
+class MemoryStore {
+  constructor() {
+    /**
+     * Map<base58, IAddressInfo>
+     * where base58 is the address in base58
+     */
+    _defineProperty(this, "addresses", void 0);
+    /**
+     * Map<index, base58>
+     * where index is the address index and base58 is the address in base58
+     */
+    _defineProperty(this, "addressIndexes", void 0);
+    /**
+     * Map<base58, IAddressMetadata>
+     * where base58 is the address in base58
+     */
+    _defineProperty(this, "addressesMetadata", void 0);
+    /**
+     * Map<uid, ITokenData>
+     * where uid is the token uid in hex
+     */
+    _defineProperty(this, "tokens", void 0);
+    /**
+     * Map<uid, ITokenMetadata>
+     * where uid is the token uid in hex
+     */
+    _defineProperty(this, "tokensMetadata", void 0);
+    /**
+     * Map<uid, ITokenData>
+     * where uid is the token uid in hex
+     */
+    _defineProperty(this, "registeredTokens", void 0);
+    /**
+     * Map<ncId, INcData>
+     * where ncId is the nano contract id in hex
+     */
+    _defineProperty(this, "registeredNanoContracts", void 0);
+    /**
+     * Map<txId, IHistoryTx>
+     * where txId is the transaction id in hex
+     */
+    _defineProperty(this, "history", void 0);
+    /**
+     * Array of `<timestamp>:<txId>` strings, which should be always sorted.
+     * `timestamp` should be in uint32 representation
+     * This will force the items to be ordered by timestamp.
+     */
+    _defineProperty(this, "historyTs", void 0);
+    /**
+     * Map<utxoid, IUtxo>
+     * where utxoid is the txId + index, a string representation of IUtxoId
+     */
+    _defineProperty(this, "utxos", void 0);
+    /**
+     * Wallet access data
+     */
+    _defineProperty(this, "accessData", void 0);
+    /**
+     * Wallet metadata
+     */
+    _defineProperty(this, "walletData", void 0);
+    /**
+     * Generic storage for any other data
+     */
+    _defineProperty(this, "genericStorage", void 0);
+    _defineProperty(this, "lockedUtxos", void 0);
+    this.addresses = new Map();
+    this.addressIndexes = new Map();
+    this.addressesMetadata = new Map();
+    this.tokens = new Map();
+    this.tokensMetadata = new Map();
+    this.registeredTokens = new Map();
+    this.history = new Map();
+    this.historyTs = [];
+    this.utxos = new Map();
+    this.accessData = null;
+    this.genericStorage = {};
+    this.lockedUtxos = new Map();
+    this.registeredNanoContracts = new Map();
+    this.walletData = (0, _lodash.cloneDeep)({
+      ...DEFAULT_WALLET_DATA,
+      ...DEFAULT_ADDRESSES_WALLET_DATA
+    });
+  }
+
+  // eslint-disable-next-line class-methods-use-this
+  async validate() {
+    // This is a noop since the memory store always starts clean.
+  }
+
+  /**
+   * Prepare the store for history processing.
+   */
+  async preProcessHistory() {
+    this.historyTs.sort();
+  }
+
+  /** ADDRESSES */
+
+  /**
+   * Iterate on all addresses
+   *
+   * @async
+   * @returns {AsyncGenerator<IAddressInfo>}
+   */
+  addressIter() {
+    var _this = this;
+    return _wrapAsyncGenerator(function* () {
+      for (const addrInfo of _this.addresses.values()) {
+        yield addrInfo;
+      }
+    })();
+  }
+
+  /**
+   * Get the address info if it exists.
+   *
+   * @param {string} base58 Address in base58 to search
+   * @async
+   * @returns {Promise<IAddressInfo | null>} A promise with the address info or null if not in storage
+   */
+  async getAddress(base58) {
+    return this.addresses.get(base58) || null;
+  }
+
+  /**
+   * Get the metadata for an address if it exists.
+   *
+   * @param {string} base58 Address in base58 to search the metadata
+   * @async
+   * @returns {Promise<IAddressMetadata | null>} A promise with the address metadata or null if not in storage
+   */
+  async getAddressMeta(base58) {
+    return this.addressesMetadata.get(base58) || null;
+  }
+
+  /**
+   * Count the number of addresses in storage.
+   * @async
+   * @returns {Promise<number>} A promise with the number of addresses
+   */
+  async addressCount() {
+    return this.addresses.size;
+  }
+
+  /**
+   * Get the address info from its bip32 index.
+   * @param index bip32 address index to search for
+   * @async
+   * @returns {Promise<IAddressInfo | null>} The address info or null if not in storage
+   */
+  async getAddressAtIndex(index) {
+    const addr = this.addressIndexes.get(index);
+    if (addr === undefined) {
+      // We do not have this index loaded on storage, it should be generated instead
+      return null;
+    }
+    return this.addresses.get(addr);
+  }
+
+  /**
+   * Save the address in storage
+   * @param {IAddressInfo} info Info on address to save
+   * @async
+   * @returns {Promise<void>}
+   */
+  async saveAddress(info) {
+    if (!info.base58) {
+      throw new Error('Invalid address');
+    }
+    if (this.addresses.has(info.base58)) {
+      throw new Error('Already have this address');
+    }
+
+    // Saving address info
+    this.addresses.set(info.base58, info);
+    this.addressIndexes.set(info.bip32AddressIndex, info.base58);
+    if (this.walletData.currentAddressIndex === -1) {
+      this.walletData.currentAddressIndex = info.bip32AddressIndex;
+    }
+    if (info.bip32AddressIndex > this.walletData.lastLoadedAddressIndex) {
+      this.walletData.lastLoadedAddressIndex = info.bip32AddressIndex;
+    }
+  }
+
+  /**
+   * Check that an address is in our storage.
+   * @param {string} base58 Address to check.
+   * @async
+   * @returns A promise that resolves to wheather the address is saved in storage or no.
+   */
+  async addressExists(base58) {
+    return this.addresses.has(base58);
+  }
+
+  /**
+   * Get the current address.
+   *
+   * @param {boolean | undefined} markAsUsed If we should set the next address as current
+   * @async
+   * @returns {Promise<string>} The address in base58 format
+   */
+  async getCurrentAddress(markAsUsed) {
+    const addressInfo = await this.getAddressAtIndex(this.walletData.currentAddressIndex);
+    if (!addressInfo) {
+      throw new Error('Current address is not loaded');
+    }
+    if (markAsUsed) {
+      // Will move the address index only if we have not reached the gap limit
+      this.walletData.currentAddressIndex = Math.min(this.walletData.lastLoadedAddressIndex, this.walletData.currentAddressIndex + 1);
+    }
+    return addressInfo.base58;
+  }
+
+  /**
+   * Set the value of the current address index.
+   * @param {number} index The index to set
+   */
+  async setCurrentAddressIndex(index) {
+    this.walletData.currentAddressIndex = index;
+  }
+
+  /**
+   * Edit address metadata.
+   *
+   * @param {string} base58 The address in base58 format
+   * @param {IAddressMetadata} meta The metadata to save
+   */
+  async editAddressMeta(base58, meta) {
+    this.addressesMetadata.set(base58, meta);
+  }
+
+  /* TRANSACTIONS */
+
+  /**
+   * Iterate on the transaction history ordered by timestamp.
+   *
+   * @param {string|undefined} tokenUid Only yield txs with this token.
+   *
+   * @async
+   * @returns {AsyncGenerator<IHistoryTx>}
+   */
+  historyIter(tokenUid) {
+    var _this2 = this;
+    return _wrapAsyncGenerator(function* () {
+      /**
+       * We iterate in reverse order so the most recent transactions are yielded first.
+       * This is to maintain the behavior in the wallets and allow the user to see the most recent transactions first.
+       */
+      for (let i = _this2.historyTs.length - 1; i >= 0; i -= 1) {
+        const orderKey = _this2.historyTs[i];
+        const {
+          txId
+        } = getPartsFromOrderingKey(orderKey);
+        const tx = _this2.history.get(txId);
+        if (!tx) {
+          // This should never happen since any transactions in historyTs should also be in history
+          throw new Error('Transaction not found');
+        }
+        if (tokenUid === undefined) {
+          yield tx;
+          continue;
+        }
+
+        // If a tokenUid is passed, we only yield the transaction if it has the token in one of our addresses
+        let found = false;
+        for (const input of tx.inputs) {
+          if (input.decoded.address && _this2.addresses.has(input.decoded.address) && input.token === tokenUid) {
+            found = true;
+            break;
+          }
+        }
+        if (found) {
+          yield tx;
+          continue;
+        }
+        for (const output of tx.outputs) {
+          if (output.decoded.address && _this2.addresses.has(output.decoded.address) && output.token === tokenUid) {
+            found = true;
+            break;
+          }
+        }
+        if (found) {
+          yield tx;
+          continue;
+        }
+      }
+    })();
+  }
+
+  /**
+   * Get the size of the transaction history.
+   *
+   * @returns {Promise<number>} The size of the transaction history
+   */
+  async historyCount() {
+    return this.history.size;
+  }
+
+  /**
+   * Save a transaction on storage.
+   * @param {IHistoryTx} tx The transaction to store
+   * @async
+   * @returns {Promise<void>}
+   */
+  async saveTx(tx) {
+    // Protect ordering list from updates on the same transaction
+    // We can check the historyTs but it's O(n) and this check is O(1).
+    if (!this.history.has(tx.tx_id)) {
+      // Add transaction to the ordering list
+      // Wallets expect to show users the transactions in order of descending timestamp
+      // This is so wallets can show the most recent transactions to users
+      // The historyTs should be sorted to ensure the history order but this is not
+      // done here due to the performance bottleneck it creates on big wallets.
+      this.historyTs.push(getOrderingKey(tx));
+    }
+    this.history.set(tx.tx_id, tx);
+    let maxIndex = this.walletData.lastUsedAddressIndex;
+    for (const el of [...tx.inputs, ...tx.outputs]) {
+      if (el.decoded.address && (await this.addressExists(el.decoded.address))) {
+        const index = this.addresses.get(el.decoded.address).bip32AddressIndex;
+        if (index > maxIndex) {
+          maxIndex = index;
+        }
+      }
+    }
+    if (this.walletData.currentAddressIndex < maxIndex) {
+      this.walletData.currentAddressIndex = Math.min(maxIndex + 1, this.walletData.lastLoadedAddressIndex);
+    }
+    this.walletData.lastUsedAddressIndex = maxIndex;
+  }
+
+  /**
+   * Fetch a transaction in the storage by its id.
+   * @param txId The transaction id
+   * @async
+   * @returns {Promise<IHistoryTx | null>} A promise with the transaction or null
+   */
+  async getTx(txId) {
+    return this.history.get(txId) || null;
+  }
+
+  /** TOKENS */
+
+  /**
+   * Iterate on tokens with the available metadata
+   *
+   * @async
+   * @returns {AsyncGenerator<ITokenData & Partial<ITokenMetadata>>}
+   */
+  tokenIter() {
+    var _this3 = this;
+    return _wrapAsyncGenerator(function* () {
+      for (const tokenInfo of _this3.tokens.values()) {
+        const tokenMeta = _this3.tokensMetadata.get(tokenInfo.uid);
+        yield {
+          ...tokenInfo,
+          ...tokenMeta
+        };
+      }
+    })();
+  }
+
+  /**
+   * Get a token on storage from the uid
+   * @param tokenUid The token id to fetch
+   * @returns {Promise<(ITokenData & Partial<ITokenMetadata>) | null>} The token data if present
+   */
+  async getToken(tokenUid) {
+    const tokenConfig = this.tokens.get(tokenUid);
+    if (tokenConfig === undefined) {
+      return null;
+    }
+    const DEFAULT_TOKEN_META = {
+      numTransactions: 0,
+      balance: {
+        tokens: {
+          unlocked: 0n,
+          locked: 0n
+        },
+        authorities: {
+          mint: {
+            unlocked: 0n,
+            locked: 0n
+          },
+          melt: {
+            unlocked: 0n,
+            locked: 0n
+          }
+        }
+      }
+    };
+    const tokenMeta = this.tokensMetadata.get(tokenUid);
+    return {
+      ...tokenConfig,
+      ...DEFAULT_TOKEN_META,
+      ...tokenMeta
+    };
+  }
+
+  /**
+   * Fetch the token metadata from the storage.
+   *
+   * @param {string} tokenUid The token id to fetch metadata.
+   * @returns {Promise<ITokenMetadata | null>} The token metadata if present
+   */
+  async getTokenMeta(tokenUid) {
+    const tokenMeta = this.tokensMetadata.get(tokenUid);
+    if (tokenMeta === undefined) {
+      return null;
+    }
+    return tokenMeta;
+  }
+
+  /**
+   * Save a token on storage
+   * @param {ITokenData} tokenConfig Token config
+   * @param {ITokenMetadata|undefined} [meta] The token metadata
+   * @async
+   * @returns {Promise<void>}
+   */
+  async saveToken(tokenConfig, meta) {
+    if (this.tokens.has(tokenConfig.uid)) {
+      throw new Error('Already have this token');
+    }
+    this.tokens.set(tokenConfig.uid, tokenConfig);
+    if (meta !== undefined) {
+      this.tokensMetadata.set(tokenConfig.uid, meta);
+    }
+  }
+
+  /**
+   * Iterate on registered tokens.
+   *
+   * @async
+   * @returns {AsyncGenerator<ITokenData & Partial<ITokenMetadata>>}
+   */
+  registeredTokenIter() {
+    var _this4 = this;
+    return _wrapAsyncGenerator(function* () {
+      for (const tokenConfig of _this4.registeredTokens.values()) {
+        const tokenMeta = _this4.tokensMetadata.get(tokenConfig.uid);
+        yield {
+          ...tokenConfig,
+          ...tokenMeta
+        };
+      }
+    })();
+  }
+
+  /**
+   * Register a token.
+   *
+   * Obs: we require the token data because the token being registered may not be on our storage yet.
+   *
+   * @param token Token config to register
+   * @async
+   * @returns {Promise<void>}
+   */
+  async registerToken(token) {
+    this.registeredTokens.set(token.uid, token);
+  }
+
+  /**
+   * Unregister a token.
+   *
+   * @param {string} tokenUid Token id
+   * @async
+   * @returns {Promise<void>}
+   */
+  async unregisterToken(tokenUid) {
+    this.registeredTokens.delete(tokenUid);
+  }
+
+  /**
+   * Return if a token uid is registered or not.
+   *
+   * @param {string} tokenUid - Token id
+   * @returns {Promise<boolean>}
+   */
+  async isTokenRegistered(tokenUid) {
+    return this.registeredTokens.has(tokenUid);
+  }
+
+  /**
+   * Edit token metadata on storage.
+   * @param {string} tokenUid Token id to edit
+   * @param {Partial<ITokenMetadata>} meta Metadata to save
+   * @returns {Promise<void>}
+   */
+  async editTokenMeta(tokenUid, meta) {
+    this.tokensMetadata.set(tokenUid, meta);
+  }
+
+  /** UTXOS */
+
+  /**
+   * Iterate on all available utxos.
+   * @async
+   * @returns {AsyncGenerator<IUtxo>}
+   */
+  utxoIter() {
+    var _this5 = this;
+    return _wrapAsyncGenerator(function* () {
+      for (const utxo of _this5.utxos.values()) {
+        yield utxo;
+      }
+    })();
+  }
+  async deleteUtxo(utxo) {
+    this.utxos.delete(`${utxo.txId}:${utxo.index}`);
+  }
+
+  /**
+   * Fetch utxos based on a selection criteria
+   * @param {IUtxoFilterOptions} options Options to filter utxos
+   * @async
+   * @returns {AsyncGenerator<IUtxo>}
+   */
+  selectUtxos(options) {
+    var _this6 = this;
+    return _wrapAsyncGenerator(function* () {
+      const networkHeight = yield _awaitAsyncGenerator(_this6.getCurrentHeight());
+      const nowTs = Math.floor(Date.now() / 1000);
+      const isTimeLocked = timestamp => !!timestamp && nowTs < timestamp;
+      const isHeightLocked = utxo => {
+        if (!_transaction.default.isBlock({
+          version: utxo.type
+        })) {
+          // Only blocks can be reward locked
+          return false;
+        }
+        return _transaction.default.isHeightLocked(utxo.height, networkHeight, options.reward_lock);
+      };
+      const isLocked = utxo => isTimeLocked(utxo.timelock || 0) || isHeightLocked(utxo);
+      const token = options.token || _constants.NATIVE_TOKEN_UID;
+      const authorities = options.authorities || 0;
+      if (options.max_amount && options.target_amount) {
+        throw new Error('invalid options');
+      }
+      let sumAmount = 0n;
+      let utxoNum = 0;
+
+      // Map.prototype.values() is an iterable but orderBy returns an array
+      // Both work with for...of so we can use them interchangeably
+      let iter;
+      if (options.order_by_value) {
+        // Sort by value as requested in options.order_by_value
+        iter = (0, _lodash.orderBy)(Array.from(_this6.utxos.values()), ['value'], [options.order_by_value]);
+      } else {
+        iter = _this6.utxos.values();
+      }
+      for (const utxo of iter) {
+        if (options.only_available_utxos && isLocked(utxo)) {
+          // Skip locked utxos if we only want available utxos
+          continue;
+        }
+        let authority_match;
+        if (authorities === 0) {
+          authority_match = utxo.authorities === 0n;
+        } else {
+          authority_match = (utxo.authorities & authorities) > 0;
+        }
+        if (options.filter_method && !options.filter_method(utxo) || options.amount_bigger_than && utxo.value <= options.amount_bigger_than || options.amount_smaller_than && utxo.value >= options.amount_smaller_than || options.filter_address && utxo.address !== options.filter_address || !authority_match || utxo.token !== token) {
+          // This utxo has failed a filter constraint
+          continue;
+        }
+        if (options.max_amount && sumAmount + utxo.value > options.max_amount) {
+          // If this utxo is returned we would pass the max_amount
+          // We continue to ensure we have the closest to max_amount
+          continue;
+        }
+        yield utxo;
+        utxoNum += 1;
+        if (!isLocked(utxo)) {
+          // sumAmount is used to filter for a target_amount and max_amount
+          // both only count unlocked utxos.
+          sumAmount += utxo.value;
+        }
+        if (options.target_amount && sumAmount >= options.target_amount || options.max_utxos && utxoNum >= options.max_utxos) {
+          // We have reached either the target amount or the max number of utxos requested
+          return;
+        }
+      }
+    })();
+  }
+
+  /**
+   * Save an utxo on storage.
+   * @param {IUtxo} utxo Utxo to save
+   * @async
+   * @returns {Promise<void>}
+   */
+  async saveUtxo(utxo) {
+    this.utxos.set(`${utxo.txId}:${utxo.index}`, utxo);
+  }
+
+  /**
+   * Save a locked utxo.
+   * Used when a new utxo is received but it is either time locked or height locked.
+   * The locked utxo index will be used to manage the locked utxos.
+   *
+   * @param {ILockedUtxo} lockedUtxo The locked utxo to be saved
+   * @returns {Promise<void>}
+   */
+  async saveLockedUtxo(lockedUtxo) {
+    this.lockedUtxos.set(`${lockedUtxo.tx.tx_id}:${lockedUtxo.index}`, lockedUtxo);
+  }
+
+  /**
+   * Iterate over all locked utxos
+   * @returns {AsyncGenerator<ILockedUtxo>}
+   */
+  iterateLockedUtxos() {
+    var _this7 = this;
+    return _wrapAsyncGenerator(function* () {
+      for (const lockedUtxo of _this7.lockedUtxos.values()) {
+        yield lockedUtxo;
+      }
+    })();
+  }
+
+  /**
+   * Remove an utxo from the locked utxos if it became unlocked.
+   *
+   * @param lockedUtxo utxo that became unlocked
+   * @returns {Promise<void>}
+   */
+  async unlockUtxo(lockedUtxo) {
+    this.lockedUtxos.delete(`${lockedUtxo.tx.tx_id}:${lockedUtxo.index}`);
+  }
+
+  /** ACCESS DATA */
+
+  /**
+   * Save access data on storage.
+   * @param {IWalletAccessData} data Access data to save
+   * @async
+   * @returns {Promise<void>}
+   */
+  async saveAccessData(data) {
+    this.accessData = data;
+  }
+
+  /**
+   * Fetch wallet access data on storage if present.
+   * @async
+   * @returns {Promise<IWalletAccessData | null>} A promise with the wallet access data.
+   */
+  async getAccessData() {
+    return this.accessData;
+  }
+
+  /**
+   * Get the last bip32 address index loaded on storage.
+   * @async
+   * @returns {Promise<number>}
+   */
+  async getLastLoadedAddressIndex() {
+    return this.walletData.lastLoadedAddressIndex;
+  }
+
+  /**
+   * Get the last bip32 address index used, i.e. with any transaction.
+   * @async
+   * @returns {Promise<number>}
+   */
+  async getLastUsedAddressIndex() {
+    return this.walletData.lastUsedAddressIndex;
+  }
+
+  /**
+   * Set the current best chain height.
+   * @async
+   * @param {number} height Height to set.
+   */
+  async setCurrentHeight(height) {
+    this.walletData.bestBlockHeight = height;
+  }
+
+  /**
+   * Set the last bip32 address index used on storage.
+   * @param {number} index The index to set as last used address.
+   */
+  async setLastUsedAddressIndex(index) {
+    this.walletData.lastUsedAddressIndex = index;
+  }
+
+  /**
+   * Get the current best chain height.
+   * @async
+   * @returns {Promise<number>}
+   */
+  async getCurrentHeight() {
+    return this.walletData.bestBlockHeight;
+  }
+
+  /**
+   * Set the gap limit for this wallet.
+   * @async
+   * @param {number} value Gat limit to set.
+   */
+  async setGapLimit(value) {
+    if (!this.walletData.scanPolicyData) {
+      this.walletData.scanPolicyData = {
+        policy: _types.SCANNING_POLICY.GAP_LIMIT,
+        gapLimit: value
+      };
+      return;
+    }
+    if ((0, _types.isGapLimitScanPolicy)(this.walletData.scanPolicyData)) {
+      this.walletData.scanPolicyData.gapLimit = value;
+    }
+  }
+
+  /**
+   * Get the current wallet gap limit.
+   * @async
+   * @returns {Promise<number>}
+   */
+  async getGapLimit() {
+    if ((0, _types.isGapLimitScanPolicy)(this.walletData.scanPolicyData)) {
+      if (!this.walletData.scanPolicyData.gapLimit) {
+        this.walletData.scanPolicyData = {
+          policy: _types.SCANNING_POLICY.GAP_LIMIT,
+          gapLimit: _constants.GAP_LIMIT
+        };
+      }
+      return this.walletData.scanPolicyData.gapLimit;
+    }
+    // Return default gap limit
+    return _constants.GAP_LIMIT;
+  }
+  async getIndexLimit() {
+    if (this.walletData.scanPolicyData?.policy === _types.SCANNING_POLICY.INDEX_LIMIT) {
+      return {
+        startIndex: this.walletData?.scanPolicyData?.startIndex || 0,
+        endIndex: this.walletData?.scanPolicyData?.endIndex || 0
+      };
+    }
+    return null;
+  }
+
+  /**
+   * Get the configured address scanning policy.
+   * @async
+   * @returns {Promise<AddressScanPolicy>}
+   */
+  async getScanningPolicy() {
+    return this.walletData.scanPolicyData?.policy || _types.SCANNING_POLICY.GAP_LIMIT;
+  }
+  async setScanningPolicyData(data) {
+    this.walletData.scanPolicyData = data;
+  }
+  async getScanningPolicyData() {
+    return this.walletData.scanPolicyData || DEFAULT_SCAN_POLICY_DATA;
+  }
+
+  /**
+   * Get the wallet data.
+   * @async
+   * @returns {Promise<IWalletData>}
+   */
+  async getWalletData() {
+    return this.walletData;
+  }
+
+  /**
+   * Get an entry on the generic storage.
+   * @param {string} key Key to fetch
+   * @async
+   * @returns {Promise<any>}
+   */
+  async getItem(key) {
+    return this.genericStorage[key];
+  }
+
+  /**
+   * Set an item on the generic storage.
+   *
+   * @param {string} key Key to store
+   * @param {any} value Value to store
+   * @async
+   * @returns {Promise<void>}
+   */
+  async setItem(key, value) {
+    this.genericStorage[key] = value;
+  }
+
+  /**
+   * Clean the storage.
+   * @param {boolean} cleanHistory if we should clean the transaction history.
+   * @param {boolean} cleanAddresses if we should clean the addresses.
+   * @param {boolean} cleanTokens if we should clean the registered tokens.
+   * @async
+   * @returns {Promise<void>}
+   */
+  async cleanStorage(cleanHistory = false, cleanAddresses = false, cleanTokens = false) {
+    if (cleanHistory) {
+      this.tokens = new Map();
+      this.tokensMetadata = new Map();
+      this.history = new Map();
+      this.historyTs = [];
+      this.utxos = new Map();
+      this.lockedUtxos = new Map();
+    }
+    if (cleanAddresses) {
+      this.addresses = new Map();
+      this.addressIndexes = new Map();
+      this.addressesMetadata = new Map();
+      this.walletData = {
+        ...this.walletData,
+        ...DEFAULT_ADDRESSES_WALLET_DATA
+      };
+    }
+    if (cleanTokens) {
+      this.registeredTokens = new Map();
+      this.registeredNanoContracts = new Map();
+    }
+  }
+
+  /**
+   * Clean the store metadata.
+   *
+   * This is used when processing the history to avoid keeping metadata from a voided tx.
+   * `processHistory` is additive, so if we don't clean the metadata we are passive to keep stale metadata.
+   * This is also true for utxos since processing txs that spent utxos will not remove the utxo from the store.
+   *
+   * @returns {Promise<void>}
+   */
+  async cleanMetadata() {
+    this.tokensMetadata = new Map();
+    this.addressesMetadata = new Map();
+    this.utxos = new Map();
+    this.lockedUtxos = new Map();
+  }
+
+  /**
+   * Return if the nano contract is registered for the given address based on ncId.
+   *
+   * @param ncId Nano Contract ID.
+   * @returns `true` if registered and `false` otherwise.
+   * @async
+   */
+  async isNanoContractRegistered(ncId) {
+    return this.registeredNanoContracts.has(ncId);
+  }
+
+  /**
+   * Iterate on registered nano contracts.
+   *
+   * @async
+   * @generator
+   * @returns {AsyncGenerator<INcData>}
+   */
+  registeredNanoContractsIter() {
+    var _this8 = this;
+    return _wrapAsyncGenerator(function* () {
+      for (const ncData of _this8.registeredNanoContracts.values()) {
+        yield ncData;
+      }
+    })();
+  }
+
+  /**
+   * Get a nano contract data on storage from the ncId.
+   *
+   * @param ncId Nano Contract ID.
+   * @returns Nano contract data instance.
+   * @async
+   */
+  async getNanoContract(ncId) {
+    return this.registeredNanoContracts.get(ncId) || null;
+  }
+
+  /**
+   * Register a nano contract data.
+   *
+   * @param ncId Nano Contract ID.
+   * @param ncValue Nano contract basic information.
+   * @async
+   */
+  async registerNanoContract(ncId, ncValue) {
+    this.registeredNanoContracts.set(ncId, ncValue);
+  }
+
+  /**
+   * Unregister nano contract.
+   *
+   * @param ncId Nano Contract ID.
+   */
+  async unregisterNanoContract(ncId) {
+    this.registeredNanoContracts.delete(ncId);
+  }
+
+  /**
+   * Update nano contract registered address.
+   *
+   * @param ncId Nano Contract ID.
+   * @param address Nano Contract registered address.
+   */
+  async updateNanoContractRegisteredAddress(ncId, address) {
+    const currentNanoContractData = await this.getNanoContract(ncId);
+    if (currentNanoContractData !== null) {
+      this.registeredNanoContracts.set(ncId, Object.assign(currentNanoContractData, {
+        address
+      }));
+    }
+  }
+}
+exports.MemoryStore = MemoryStore;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/storage/storage.d.ts b/node_modules/@hathor/wallet-lib/oldLib/storage/storage.d.ts
new file mode 100644
index 0000000..fce72c2
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/storage/storage.d.ts
@@ -0,0 +1,532 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+import Input from '../models/input';
+import { ApiVersion, IStorage, IAddressInfo, IAddressMetadata, ITokenData, ITokenMetadata, IHistoryTx, IUtxo, IWalletAccessData, IStore, IUtxoFilterOptions, IWalletData, WalletType, IUtxoId, IDataTx, IDataInput, IDataOutput, IFillTxOptions, AddressScanPolicy, AddressScanPolicyData, IIndexLimitAddressScanPolicy, INcData, EcdsaTxSign, ITxSignatureData, OutputValueType, ILogger } from '../types';
+import { Config } from '../config';
+import FullNodeConnection from '../new/connection';
+import Transaction from '../models/transaction';
+export declare const DEFAULT_ADDRESS_META: IAddressMetadata;
+export declare class Storage implements IStorage {
+    store: IStore;
+    utxosSelectedAsInput: Map<string, boolean>;
+    config: Config;
+    version: ApiVersion | null;
+    txSignFunc: EcdsaTxSign | null;
+    /**
+     * This promise is used to chain the calls to process unlocked utxos.
+     * This way we can avoid concurrent calls.
+     * The best way to do this would be an async queue or a mutex, but to avoid adding
+     * more dependencies we are using this simpler method.
+     *
+     * We can change this implementation to use a mutex or async queue in the future.
+     */
+    utxoUnlockWait: Promise<void>;
+    logger: ILogger;
+    constructor(store: IStore);
+    /**
+     * Set the fullnode api version data.
+     * @param {ApiVersion} version Fullnode api version data
+     */
+    setApiVersion(version: ApiVersion): void;
+    /**
+     * Get the decimal places.
+     * If not configured, will return the default DECIMAL_PLACES (2)
+     * @returns {number}
+     */
+    getDecimalPlaces(): number;
+    /**
+     * Set the native token config on the store
+     */
+    saveNativeToken(): Promise<void>;
+    /**
+     * Adds a new token to the storage.
+     */
+    addToken(data: ITokenData): Promise<void>;
+    /**
+     * Gets the native token config
+     *
+     * @return {ITokenData} The native token config
+     */
+    getNativeTokenData(): ITokenData;
+    /**
+     * Set the logger instance to use.
+     */
+    setLogger(logger: ILogger): void;
+    /**
+     * Check if the tx signing method is set
+     * @returns {boolean}
+     */
+    hasTxSignatureMethod(): boolean;
+    /**
+     * Set the tx signing function
+     * @param {EcdsaTxSign} txSign The signing function
+     */
+    setTxSignatureMethod(txSign: EcdsaTxSign): void;
+    /**
+     * Sign the transaction
+     * @param {Transaction} tx The transaction to sign
+     * @param {string} pinCode The pin code
+     * @returns {Promise<ITxSignatureData>} The signatures
+     */
+    getTxSignatures(tx: Transaction, pinCode: string): Promise<ITxSignatureData>;
+    /**
+     * Return the deposit percentage for creating tokens.
+     * @returns {number}
+     */
+    getTokenDepositPercentage(): number;
+    /**
+     * Fetch all addresses from storage
+     *
+     * @async
+     * @generator
+     * @yields {Promise<IAddressInfo & Partial<IAddressMetadata>>} The addresses in store.
+     */
+    getAllAddresses(): AsyncGenerator<IAddressInfo & IAddressMetadata>;
+    /**
+     * Get the address info from store
+     *
+     * @param {string} base58 The base58 address to fetch
+     * @async
+     * @returns {Promise<(IAddressInfo & Partial<IAddressMetadata>)|null>} The address info or null if not found
+     */
+    getAddressInfo(base58: string): Promise<(IAddressInfo & IAddressMetadata) | null>;
+    /**
+     * Get the address at the given index
+     *
+     * @param {number} index
+     * @async
+     * @returns {Promise<IAddressInfo|null>} The address info or null if not found
+     */
+    getAddressAtIndex(index: number): Promise<IAddressInfo | null>;
+    /**
+     * Get the address public key, if not available derive from xpub
+     * @param {number} index
+     * @async
+     * @returns {Promise<string>} The public key DER encoded in hex
+     */
+    getAddressPubkey(index: number): Promise<string>;
+    /**
+     * Check if the address is from our wallet.
+     * @param {string} base58 The address encoded as base58
+     * @returns {Promise<boolean>} If the address is known by the storage
+     */
+    isAddressMine(base58: string): Promise<boolean>;
+    /**
+     * Save address info on storage
+     * @param {IAddressInfo} info Address info to save on storage
+     * @returns {Promise<void>}
+     */
+    saveAddress(info: IAddressInfo): Promise<void>;
+    /**
+     * Get the current address.
+     *
+     * @param {boolean|undefined} markAsUsed If we should set the next address as current
+     * @returns {Promise<string>} The address in base58 encoding
+     */
+    getCurrentAddress(markAsUsed?: boolean): Promise<string>;
+    /**
+     * Get a change address to use, if one is provided we need to check if we own it
+     * If not provided, the current address will be used instead.
+     *
+     * @param {Object} [options={}]
+     * @param {string|null|undefined} [options.changeAddress=undefined] User provided change address to use
+     * @returns {Promise<string>} The change address to use
+     */
+    getChangeAddress({ changeAddress, }?: {
+        changeAddress?: string | null | undefined;
+    }): Promise<string>;
+    /**
+     * Iterate on the history of transactions.
+     * @returns {AsyncGenerator<IHistoryTx>}
+     */
+    txHistory(): AsyncGenerator<IHistoryTx>;
+    /**
+     * Iterate on the history of transactions that include the given token.
+     *
+     * @param {string|undefined} [tokenUid='00'] Token to fetch, defaults to HTR
+     * @returns {AsyncGenerator<IHistoryTx>}
+     */
+    tokenHistory(tokenUid?: string): AsyncGenerator<IHistoryTx>;
+    /**
+     * Fetch a transaction on the storage by it's id.
+     *
+     * @param {string} txId The transaction id to fetch
+     * @returns {Promise<IHistoryTx | null>} The transaction or null if not on storage
+     */
+    getTx(txId: string): Promise<IHistoryTx | null>;
+    /**
+     * Get the transactions being spent by the given inputs if they belong in our wallet.
+     *
+     * @param {Input[]} inputs A list of inputs
+     * @returns {AsyncGenerator<{tx: IHistoryTx, input: Input, index: number}>}
+     */
+    getSpentTxs(inputs: Input[]): AsyncGenerator<{
+        tx: IHistoryTx;
+        input: Input;
+        index: number;
+    }>;
+    /**
+     * Add a transaction on storage.
+     *
+     * @param {IHistoryTx} tx The transaction
+     * @returns {Promise<void>}
+     */
+    addTx(tx: IHistoryTx): Promise<void>;
+    /**
+     * Process the transaction history to calculate the metadata.
+     * @returns {Promise<void>}
+     */
+    processHistory(): Promise<void>;
+    /**
+     * Process the transaction history to calculate the metadata.
+     * @returns {Promise<void>}
+     */
+    processNewTx(tx: IHistoryTx): Promise<void>;
+    /**
+     * Iterate on all tokens on the storage.
+     *
+     * @returns {AsyncGenerator<ITokenData & Partial<ITokenMetadata>>}
+     */
+    getAllTokens(): AsyncGenerator<ITokenData & Partial<ITokenMetadata>>;
+    /**
+     * Iterate on all registered tokens of the wallet.
+     *
+     * @returns {AsyncGenerator<ITokenData & Partial<ITokenMetadata>>}
+     */
+    getRegisteredTokens(): AsyncGenerator<ITokenData & Partial<ITokenMetadata>>;
+    /**
+     * Get a token from storage along with the metadata of the wallet transactions.
+     *
+     * @param {string} token Token uid to fetch
+     * @returns {Promise<(ITokenData & Partial<ITokenMetadata>)|null>}
+     */
+    getToken(token: string): Promise<(ITokenData & Partial<ITokenMetadata>) | null>;
+    /**
+     * Regsiter a token.
+     * @param {ITokenData} token Token data to register
+     * @returns {Promise<void>}
+     */
+    registerToken(token: ITokenData): Promise<void>;
+    /**
+     * Unregister a token from the wallet.
+     * @param {Promise<void>} tokenUid Token uid to unregister.
+     * @returns {Promise<void>}
+     */
+    unregisterToken(tokenUid: string): Promise<void>;
+    /**
+     * Return if a token is registered.
+     * @param tokenUid - Token id.
+     * @returns {Promise<boolean>}
+     */
+    isTokenRegistered(tokenUid: string): Promise<boolean>;
+    /**
+     * Process the locked utxos to unlock them if the lock has expired.
+     * Will process both timelocked and heightlocked utxos.
+     *
+     * We will wait for any previous execution to finish before starting the next one.
+     *
+     * @param {number} height The network height to use as reference to unlock utxos
+     * @returns {Promise<void>}
+     */
+    unlockUtxos(height: number): Promise<void>;
+    /**
+     * Iterate on all utxos of the wallet.
+     * @returns {AsyncGenerator<IUtxo, any, unknown>}
+     */
+    getAllUtxos(): AsyncGenerator<IUtxo, void, void>;
+    /**
+     * Select utxos matching the request and do not select any utxos marked for inputs.
+     *
+     * @param {Omit<IUtxoFilterOptions, 'reward_lock'>} [options={}] Options to filter utxos and stop when the target is found.
+     * @returns {AsyncGenerator<IUtxo, any, unknown>}
+     */
+    selectUtxos(options?: Omit<IUtxoFilterOptions, 'reward_lock'>): AsyncGenerator<IUtxo, void, void>;
+    /**
+     * Match the selected balance for the given authority and token.
+     *
+     * @param {OutputValueType} singleBalance The balance we want to match
+     * @param {string} token The token uid
+     * @param {OutputValueType} authorities The authorities we want to match
+     * @param {string} changeAddress change address to use
+     * @param {boolean} chooseInputs If we can add new inputs to the transaction
+     * @returns {Promise<{inputs: IDataInput[], outputs: IDataOutput[]}>} The inputs and outputs that match the balance
+     * @internal
+     */
+    matchBalanceSelection(singleBalance: OutputValueType, token: string, authorities: OutputValueType, changeAddress: string, chooseInputs: boolean): Promise<{
+        inputs: IDataInput[];
+        outputs: IDataOutput[];
+    }>;
+    /**
+     * Generate inputs and outputs so that the transaction balance is filled.
+     *
+     * @param {string} token Token uid
+     * @param {Record<'funds'|'mint'|'melt', number>} balance Balance of funds and authorities for a token on the transaction
+     * @param {IFillTxOptions} [options={}]
+     * @param {string} options.changeAddress Address to send change to
+     * @param {boolean} [options.skipAuthorities=false] If we should fill authorities or only funds
+     * @param {boolean} [options.chooseInputs=true] If we can choose inputs when needed or not
+     * @returns {Promise<{inputs: IDataInput[], outputs: IDataOutput[]}>} The inputs and outputs to fill the transaction
+     * @internal
+     */
+    matchTokenBalance(token: string, balance: Record<'funds' | 'mint' | 'melt', OutputValueType>, { changeAddress, skipAuthorities, chooseInputs }?: IFillTxOptions): Promise<{
+        inputs: IDataInput[];
+        outputs: IDataOutput[];
+    }>;
+    /**
+     * Check the balance of the transaction and add inputs and outputs to match the funds and authorities.
+     * It will fail if we do not have enough funds or authorities and it will fail if we try to add too many inputs or outputs.
+     *
+     * @param tx The incomplete transaction we need to fill
+     * @param {IFillTxOptions} [options={}] options to use a change address.
+     *
+     * @async
+     * @returns {Promise<void>}
+     */
+    fillTx(token: string, tx: IDataTx, options?: IFillTxOptions): Promise<{
+        inputs: IDataInput[];
+        outputs: IDataOutput[];
+    }>;
+    /**
+     * Mark an utxo as selected as input
+     *
+     * @param {IUtxoId} utxo The Data to identify the utxo
+     * @param {boolean} markAs Mark the utxo as this value
+     * @param {number|undefined} ttl Unmark the utxo after this amount os ms passed
+     *
+     * @async
+     * @returns {Promise<void>}
+     */
+    utxoSelectAsInput(utxo: IUtxoId, markAs: boolean, ttl?: number): Promise<void>;
+    /**
+     * Iterate over all locked utxos and unlock them if needed
+     * When a utxo is unlocked, the balances and metadatas are updated
+     * and the utxo is removed from the locked utxos.
+     *
+     * @param {number} height The new height of the best chain
+     */
+    processLockedUtxos(height: number): Promise<void>;
+    /**
+     * Check if an utxo is selected as input.
+     *
+     * @param {IUtxoId} utxo The utxo we want to check if it is selected as input
+     * @returns {Promise<boolean>}
+     * @example
+     * const isSelected = await isUtxoSelectedAsInput({ txId: 'tx1', index: 0 });
+     */
+    isUtxoSelectedAsInput(utxo: IUtxoId): Promise<boolean>;
+    /**
+     * Iterate on all locked utxos.
+     * Used to check if the utxos are still locked.
+     *
+     * @returns {AsyncGenerator<IUtxoId>}
+     */
+    utxoSelectedAsInputIter(): AsyncGenerator<IUtxoId>;
+    /**
+     * Helper to check if the access data exists before returning it.
+     * Having the accessData as null means the wallet is not initialized so we should throw an error.
+     *
+     * @returns {Promise<IWalletAccessData>} The access data.
+     * @internal
+     */
+    _getValidAccessData(): Promise<IWalletAccessData>;
+    /**
+     * Get the wallet's access data if the wallet is initialized.
+     *
+     * @returns {Promise<IWalletAccessData | null>}
+     */
+    getAccessData(): Promise<IWalletAccessData | null>;
+    /**
+     * Save the access data, initializing the wallet.
+     *
+     * @param {IWalletAccessData} data The wallet access data
+     * @returns {Promise<void>}
+     */
+    saveAccessData(data: IWalletAccessData): Promise<void>;
+    /**
+     * Get the wallet's metadata.
+     *
+     * @returns {Promise<IWalletData>}
+     */
+    getWalletData(): Promise<IWalletData>;
+    /**
+     * Get the wallet type, i.e. P2PKH or MultiSig.
+     *
+     * @returns {Promise<WalletType>}
+     */
+    getWalletType(): Promise<WalletType>;
+    /**
+     * Set the current height
+     * @param {number} height The current height
+     * @returns {Promise<void>} The current height of the network
+     */
+    setCurrentHeight(height: number): Promise<void>;
+    /**
+     * Get the current height
+     * @returns {Promise<number>} The current height
+     */
+    getCurrentHeight(): Promise<number>;
+    /**
+     * Return wheather the wallet is readonly, i.e. was started without the private key.
+     * @returns {Promise<boolean>}
+     */
+    isReadonly(): Promise<boolean>;
+    /**
+     * Decrypt and return the main private key of the wallet.
+     *
+     * @param {string} pinCode Pin to unlock the private key
+     * @returns {Promise<string>} The HDPrivateKey in string format.
+     */
+    getMainXPrivKey(pinCode: string): Promise<string>;
+    /**
+     * Get account path xprivkey if available.
+     *
+     * @param {string} pinCode
+     * @returns {Promise<string>}
+     */
+    getAcctPathXPrivKey(pinCode: string): Promise<string>;
+    /**
+     * Decrypt and return the auth private key of the wallet.
+     *
+     * @param {string} pinCode Pin to unlock the private key
+     * @returns {Promise<string>} The Auth HDPrivateKey in string format.
+     */
+    getAuthPrivKey(pinCode: string): Promise<string>;
+    /**
+     * Handle storage operations for a wallet being stopped.
+     * @param {{
+     *   connection?: FullNodeConnection;
+     *   cleanStorage?: boolean;
+     *   cleanAddresses?: boolean;
+     *   cleanTokens?: boolean;
+     * }} Options to handle stop
+     * @returns {Promise<void>}
+     */
+    handleStop({ connection, cleanStorage, cleanAddresses, cleanTokens, }?: {
+        connection?: FullNodeConnection;
+        cleanStorage?: boolean;
+        cleanAddresses?: boolean;
+        cleanTokens?: boolean;
+    }): Promise<void>;
+    /**
+     * Clean the storage data.
+     *
+     * @param {boolean} [cleanHistory=false] If we should clean the history data
+     * @param {boolean} [cleanAddresses=false] If we should clean the address data
+     * @param {boolean} [cleanTokens=false] If we should clean the registered tokens
+     * @returns {Promise<void>}
+     */
+    cleanStorage(cleanHistory?: boolean, cleanAddresses?: boolean, cleanTokens?: boolean): Promise<void>;
+    /**
+     * Check if the pin is correct
+     *
+     * @param {string} pinCode - Pin to check
+     * @returns {Promise<boolean>}
+     * @throws {Error} if the wallet is not initialized
+     * @throws {Error} if the wallet does not have the private key
+     */
+    checkPin(pinCode: string): Promise<boolean>;
+    /**
+     * Check if the password is correct
+     *
+     * @param {string} password - Password to check
+     * @returns {Promise<boolean>}
+     * @throws {Error} if the wallet is not initialized
+     * @throws {Error} if the wallet does not have the private key
+     */
+    checkPassword(password: string): Promise<boolean>;
+    /**
+     * Change the wallet pin.
+     * @param {string} oldPin Old pin to unlock data.
+     * @param {string} newPin New pin to lock data.
+     * @returns {Promise<void>}
+     */
+    changePin(oldPin: string, newPin: string): Promise<void>;
+    /**
+     * Change the wallet password.
+     *
+     * @param {string} oldPassword Old password
+     * @param {string} newPassword New password
+     * @returns {Promise<void>}
+     */
+    changePassword(oldPassword: string, newPassword: string): Promise<void>;
+    /**
+     * Set the wallet gap limit.
+     * @param {number} value New gap limit to use.
+     * @returns {Promise<void>}
+     */
+    setGapLimit(value: number): Promise<void>;
+    /**
+     * Get the wallet gap limit.
+     * @returns {Promise<number>}
+     */
+    getGapLimit(): Promise<number>;
+    /**
+     * Get the index limit.
+     * @returns {Promise<Omit<IIndexLimitAddressScanPolicy, 'policy'>>}
+     */
+    getIndexLimit(): Promise<Omit<IIndexLimitAddressScanPolicy, 'policy'> | null>;
+    /**
+     * Get the scanning policy.
+     * @returns {Promise<AddressScanPolicy>}
+     */
+    getScanningPolicy(): Promise<AddressScanPolicy>;
+    /**
+     * Set the scanning policy data.
+     * @param {AddressScanPolicyData | null} data
+     * @returns {Promise<void>}
+     */
+    setScanningPolicyData(data: AddressScanPolicyData | null): Promise<void>;
+    /**
+     * Get the scanning policy data.
+     * @returns {Promise<AddressScanPolicyData>}
+     */
+    getScanningPolicyData(): Promise<AddressScanPolicyData>;
+    /**
+     * Return if the loaded wallet was started from a hardware wallet.
+     * @returns {Promise<boolean>}
+     */
+    isHardwareWallet(): Promise<boolean>;
+    /**
+     * Return if the nano contract is registered for the given address based on ncId.
+     * @param ncId Nano Contract ID.
+     * @returns `true` if registered and `false` otherwise.
+     * @async
+     */
+    isNanoContractRegistered(ncId: string): Promise<boolean>;
+    /**
+     * Iterate on all registered nano contracts of the wallet.
+     *
+     * @async
+     * @generator
+     * @returns {AsyncGenerator<INcData>}
+     */
+    getRegisteredNanoContracts(): AsyncGenerator<INcData>;
+    /**
+     * Get nano contract data.
+     * @param ncId Nano Contract ID.
+     * @returns An instance of Nano Contract data.
+     */
+    getNanoContract(ncId: string): Promise<INcData | null>;
+    /**
+     * Register nano contract data instance.
+     * @param ncId Nano Contract ID.
+     * @param ncValue Nano Contract basic information.
+     */
+    registerNanoContract(ncId: string, ncValue: INcData): Promise<void>;
+    /**
+     * Unregister nano contract.
+     * @param ncId Nano Contract ID.
+     */
+    unregisterNanoContract(ncId: string): Promise<void>;
+    /**
+     * Update nano contract registered address
+     * @param ncId Nano Contract ID.
+     * @param address New registered address
+     */
+    updateNanoContractRegisteredAddress(ncId: string, address: string): Promise<void>;
+}
+//# sourceMappingURL=storage.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/storage/storage.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/storage/storage.d.ts.map
new file mode 100644
index 0000000..82602f7
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/storage/storage.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"storage.d.ts","sourceRoot":"","sources":["../../src/storage/storage.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/storage/storage.js b/node_modules/@hathor/wallet-lib/oldLib/storage/storage.js
new file mode 100644
index 0000000..3bcbc6b
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/storage/storage.js
@@ -0,0 +1,1371 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.Storage = exports.DEFAULT_ADDRESS_META = void 0;
+var _bitcoreLib = require("bitcore-lib");
+var _types = require("../types");
+var _transaction = _interopRequireDefault(require("../utils/transaction"));
+var _storage = require("../utils/storage");
+var _config = _interopRequireDefault(require("../config"));
+var _crypto = require("../utils/crypto");
+var _address = require("../utils/address");
+var _wallet = _interopRequireDefault(require("../utils/wallet"));
+var _constants = require("../constants");
+var _errors = require("../errors");
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
+function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
+function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
+function _awaitAsyncGenerator(e) { return new _OverloadYield(e, 0); }
+function _wrapAsyncGenerator(e) { return function () { return new AsyncGenerator(e.apply(this, arguments)); }; }
+function AsyncGenerator(e) { var r, t; function resume(r, t) { try { var n = e[r](t), o = n.value, u = o instanceof _OverloadYield; Promise.resolve(u ? o.v : o).then(function (t) { if (u) { var i = "return" === r ? "return" : "next"; if (!o.k || t.done) return resume(i, t); t = e[i](t).value; } settle(n.done ? "return" : "normal", t); }, function (e) { resume("throw", e); }); } catch (e) { settle("throw", e); } } function settle(e, n) { switch (e) { case "return": r.resolve({ value: n, done: !0 }); break; case "throw": r.reject(n); break; default: r.resolve({ value: n, done: !1 }); } (r = r.next) ? resume(r.key, r.arg) : t = null; } this._invoke = function (e, n) { return new Promise(function (o, u) { var i = { key: e, arg: n, resolve: o, reject: u, next: null }; t ? t = t.next = i : (r = t = i, resume(e, n)); }); }, "function" != typeof e.return && (this.return = void 0); }
+AsyncGenerator.prototype["function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator"] = function () { return this; }, AsyncGenerator.prototype.next = function (e) { return this._invoke("next", e); }, AsyncGenerator.prototype.throw = function (e) { return this._invoke("throw", e); }, AsyncGenerator.prototype.return = function (e) { return this._invoke("return", e); };
+function _OverloadYield(e, d) { this.v = e, this.k = d; }
+function _asyncIterator(r) { var n, t, o, e = 2; for ("undefined" != typeof Symbol && (t = Symbol.asyncIterator, o = Symbol.iterator); e--;) { if (t && null != (n = r[t])) return n.call(r); if (o && null != (n = r[o])) return new AsyncFromSyncIterator(n.call(r)); t = "@@asyncIterator", o = "@@iterator"; } throw new TypeError("Object is not async iterable"); }
+function AsyncFromSyncIterator(r) { function AsyncFromSyncIteratorContinuation(r) { if (Object(r) !== r) return Promise.reject(new TypeError(r + " is not an object.")); var n = r.done; return Promise.resolve(r.value).then(function (r) { return { value: r, done: n }; }); } return AsyncFromSyncIterator = function (r) { this.s = r, this.n = r.next; }, AsyncFromSyncIterator.prototype = { s: null, n: null, next: function () { return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments)); }, return: function (r) { var n = this.s.return; return void 0 === n ? Promise.resolve({ value: r, done: !0 }) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments)); }, throw: function (r) { var n = this.s.return; return void 0 === n ? Promise.reject(r) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments)); } }, new AsyncFromSyncIterator(r); } /**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+const DEFAULT_ADDRESS_META = exports.DEFAULT_ADDRESS_META = {
+  numTransactions: 0,
+  balance: new Map(),
+  seqnum: -1
+};
+class Storage {
+  constructor(store) {
+    _defineProperty(this, "store", void 0);
+    _defineProperty(this, "utxosSelectedAsInput", void 0);
+    _defineProperty(this, "config", void 0);
+    _defineProperty(this, "version", void 0);
+    _defineProperty(this, "txSignFunc", void 0);
+    /**
+     * This promise is used to chain the calls to process unlocked utxos.
+     * This way we can avoid concurrent calls.
+     * The best way to do this would be an async queue or a mutex, but to avoid adding
+     * more dependencies we are using this simpler method.
+     *
+     * We can change this implementation to use a mutex or async queue in the future.
+     */
+    _defineProperty(this, "utxoUnlockWait", void 0);
+    _defineProperty(this, "logger", void 0);
+    this.store = store;
+    this.utxosSelectedAsInput = new Map();
+    this.config = _config.default;
+    this.version = null;
+    this.utxoUnlockWait = Promise.resolve();
+    this.txSignFunc = null;
+    this.logger = (0, _types.getDefaultLogger)();
+  }
+
+  /**
+   * Set the fullnode api version data.
+   * @param {ApiVersion} version Fullnode api version data
+   */
+  setApiVersion(version) {
+    this.version = version;
+  }
+
+  /**
+   * Get the decimal places.
+   * If not configured, will return the default DECIMAL_PLACES (2)
+   * @returns {number}
+   */
+  getDecimalPlaces() {
+    return this.version?.decimal_places ?? _constants.DECIMAL_PLACES;
+  }
+
+  /**
+   * Set the native token config on the store
+   */
+  async saveNativeToken() {
+    await this.addToken(this.getNativeTokenData());
+  }
+
+  /**
+   * Adds a new token to the storage.
+   */
+  async addToken(data) {
+    if ((await this.store.getToken(data.uid)) === null) {
+      await this.store.saveToken(data);
+    }
+  }
+
+  /**
+   * Gets the native token config
+   *
+   * @return {ITokenData} The native token config
+   */
+  getNativeTokenData() {
+    const nativeToken = this.version?.native_token ?? _constants.DEFAULT_NATIVE_TOKEN_CONFIG;
+    return {
+      ...nativeToken,
+      uid: _constants.NATIVE_TOKEN_UID
+    };
+  }
+
+  /**
+   * Set the logger instance to use.
+   */
+  setLogger(logger) {
+    this.logger = logger;
+  }
+
+  /**
+   * Check if the tx signing method is set
+   * @returns {boolean}
+   */
+  hasTxSignatureMethod() {
+    return !!this.txSignFunc;
+  }
+
+  /**
+   * Set the tx signing function
+   * @param {EcdsaTxSign} txSign The signing function
+   */
+  setTxSignatureMethod(txSign) {
+    this.txSignFunc = txSign;
+  }
+
+  /**
+   * Sign the transaction
+   * @param {Transaction} tx The transaction to sign
+   * @param {string} pinCode The pin code
+   * @returns {Promise<ITxSignatureData>} The signatures
+   */
+  async getTxSignatures(tx, pinCode) {
+    if (this.txSignFunc) {
+      return this.txSignFunc(tx, this, pinCode);
+    }
+    return _transaction.default.getSignatureForTx(tx, this, pinCode);
+  }
+
+  /**
+   * Return the deposit percentage for creating tokens.
+   * @returns {number}
+   */
+  getTokenDepositPercentage() {
+    /**
+     *  When using wallet-service facade we do not update the version constants
+     *  Since this data is important for the wallets UI we will return the default value here.
+     */
+    return this.version?.token_deposit_percentage ?? _constants.TOKEN_DEPOSIT_PERCENTAGE;
+  }
+
+  /**
+   * Fetch all addresses from storage
+   *
+   * @async
+   * @generator
+   * @yields {Promise<IAddressInfo & Partial<IAddressMetadata>>} The addresses in store.
+   */
+  getAllAddresses() {
+    var _this = this;
+    return _wrapAsyncGenerator(function* () {
+      var _iteratorAbruptCompletion = false;
+      var _didIteratorError = false;
+      var _iteratorError;
+      try {
+        for (var _iterator = _asyncIterator(_this.store.addressIter()), _step; _iteratorAbruptCompletion = !(_step = yield _awaitAsyncGenerator(_iterator.next())).done; _iteratorAbruptCompletion = false) {
+          const address = _step.value;
+          {
+            const meta = yield _awaitAsyncGenerator(_this.store.getAddressMeta(address.base58));
+            yield {
+              ...address,
+              ...DEFAULT_ADDRESS_META,
+              ...meta
+            };
+          }
+        }
+      } catch (err) {
+        _didIteratorError = true;
+        _iteratorError = err;
+      } finally {
+        try {
+          if (_iteratorAbruptCompletion && _iterator.return != null) {
+            yield _awaitAsyncGenerator(_iterator.return());
+          }
+        } finally {
+          if (_didIteratorError) {
+            throw _iteratorError;
+          }
+        }
+      }
+    })();
+  }
+
+  /**
+   * Get the address info from store
+   *
+   * @param {string} base58 The base58 address to fetch
+   * @async
+   * @returns {Promise<(IAddressInfo & Partial<IAddressMetadata>)|null>} The address info or null if not found
+   */
+  async getAddressInfo(base58) {
+    const address = await this.store.getAddress(base58);
+    if (address === null) {
+      return null;
+    }
+    const meta = await this.store.getAddressMeta(base58);
+    return {
+      ...address,
+      ...DEFAULT_ADDRESS_META,
+      ...meta
+    };
+  }
+
+  /**
+   * Get the address at the given index
+   *
+   * @param {number} index
+   * @async
+   * @returns {Promise<IAddressInfo|null>} The address info or null if not found
+   */
+  async getAddressAtIndex(index) {
+    return this.store.getAddressAtIndex(index);
+  }
+
+  /**
+   * Get the address public key, if not available derive from xpub
+   * @param {number} index
+   * @async
+   * @returns {Promise<string>} The public key DER encoded in hex
+   */
+  async getAddressPubkey(index) {
+    const addressInfo = await this.store.getAddressAtIndex(index);
+    if (addressInfo?.publicKey) {
+      // public key already cached on address info
+      return addressInfo.publicKey;
+    }
+
+    // derive public key from xpub
+    const accessData = await this._getValidAccessData();
+    const hdpubkey = new _bitcoreLib.HDPublicKey(accessData.xpubkey);
+    const key = hdpubkey.deriveChild(index);
+    return key.publicKey.toString('hex');
+  }
+
+  /**
+   * Check if the address is from our wallet.
+   * @param {string} base58 The address encoded as base58
+   * @returns {Promise<boolean>} If the address is known by the storage
+   */
+  async isAddressMine(base58) {
+    return this.store.addressExists(base58);
+  }
+
+  /**
+   * Save address info on storage
+   * @param {IAddressInfo} info Address info to save on storage
+   * @returns {Promise<void>}
+   */
+  async saveAddress(info) {
+    await this.store.saveAddress(info);
+  }
+
+  /**
+   * Get the current address.
+   *
+   * @param {boolean|undefined} markAsUsed If we should set the next address as current
+   * @returns {Promise<string>} The address in base58 encoding
+   */
+  async getCurrentAddress(markAsUsed) {
+    return this.store.getCurrentAddress(markAsUsed);
+  }
+
+  /**
+   * Get a change address to use, if one is provided we need to check if we own it
+   * If not provided, the current address will be used instead.
+   *
+   * @param {Object} [options={}]
+   * @param {string|null|undefined} [options.changeAddress=undefined] User provided change address to use
+   * @returns {Promise<string>} The change address to use
+   */
+  async getChangeAddress({
+    changeAddress
+  } = {}) {
+    if (changeAddress) {
+      if (!(await this.isAddressMine(changeAddress))) {
+        throw new Error('Change address is not from the wallet');
+      }
+      return changeAddress;
+    }
+    return this.getCurrentAddress();
+  }
+
+  /**
+   * Iterate on the history of transactions.
+   * @returns {AsyncGenerator<IHistoryTx>}
+   */
+  txHistory() {
+    var _this2 = this;
+    return _wrapAsyncGenerator(function* () {
+      var _iteratorAbruptCompletion2 = false;
+      var _didIteratorError2 = false;
+      var _iteratorError2;
+      try {
+        for (var _iterator2 = _asyncIterator(_this2.store.historyIter()), _step2; _iteratorAbruptCompletion2 = !(_step2 = yield _awaitAsyncGenerator(_iterator2.next())).done; _iteratorAbruptCompletion2 = false) {
+          const tx = _step2.value;
+          {
+            yield tx;
+          }
+        }
+      } catch (err) {
+        _didIteratorError2 = true;
+        _iteratorError2 = err;
+      } finally {
+        try {
+          if (_iteratorAbruptCompletion2 && _iterator2.return != null) {
+            yield _awaitAsyncGenerator(_iterator2.return());
+          }
+        } finally {
+          if (_didIteratorError2) {
+            throw _iteratorError2;
+          }
+        }
+      }
+    })();
+  }
+
+  /**
+   * Iterate on the history of transactions that include the given token.
+   *
+   * @param {string|undefined} [tokenUid='00'] Token to fetch, defaults to HTR
+   * @returns {AsyncGenerator<IHistoryTx>}
+   */
+  tokenHistory(tokenUid) {
+    var _this3 = this;
+    return _wrapAsyncGenerator(function* () {
+      var _iteratorAbruptCompletion3 = false;
+      var _didIteratorError3 = false;
+      var _iteratorError3;
+      try {
+        for (var _iterator3 = _asyncIterator(_this3.store.historyIter(tokenUid || _constants.NATIVE_TOKEN_UID)), _step3; _iteratorAbruptCompletion3 = !(_step3 = yield _awaitAsyncGenerator(_iterator3.next())).done; _iteratorAbruptCompletion3 = false) {
+          const tx = _step3.value;
+          {
+            yield tx;
+          }
+        }
+      } catch (err) {
+        _didIteratorError3 = true;
+        _iteratorError3 = err;
+      } finally {
+        try {
+          if (_iteratorAbruptCompletion3 && _iterator3.return != null) {
+            yield _awaitAsyncGenerator(_iterator3.return());
+          }
+        } finally {
+          if (_didIteratorError3) {
+            throw _iteratorError3;
+          }
+        }
+      }
+    })();
+  }
+
+  /**
+   * Fetch a transaction on the storage by it's id.
+   *
+   * @param {string} txId The transaction id to fetch
+   * @returns {Promise<IHistoryTx | null>} The transaction or null if not on storage
+   */
+  async getTx(txId) {
+    return this.store.getTx(txId);
+  }
+
+  /**
+   * Get the transactions being spent by the given inputs if they belong in our wallet.
+   *
+   * @param {Input[]} inputs A list of inputs
+   * @returns {AsyncGenerator<{tx: IHistoryTx, input: Input, index: number}>}
+   */
+  getSpentTxs(inputs) {
+    var _this4 = this;
+    return _wrapAsyncGenerator(function* () {
+      var _iteratorAbruptCompletion4 = false;
+      var _didIteratorError4 = false;
+      var _iteratorError4;
+      try {
+        for (var _iterator4 = _asyncIterator(inputs.entries()), _step4; _iteratorAbruptCompletion4 = !(_step4 = yield _awaitAsyncGenerator(_iterator4.next())).done; _iteratorAbruptCompletion4 = false) {
+          const [index, input] = _step4.value;
+          {
+            const tx = yield _awaitAsyncGenerator(_this4.getTx(input.hash));
+            // Ignore unknown transactions
+            if (tx === null) continue;
+            yield {
+              tx,
+              input,
+              index
+            };
+          }
+        }
+      } catch (err) {
+        _didIteratorError4 = true;
+        _iteratorError4 = err;
+      } finally {
+        try {
+          if (_iteratorAbruptCompletion4 && _iterator4.return != null) {
+            yield _awaitAsyncGenerator(_iterator4.return());
+          }
+        } finally {
+          if (_didIteratorError4) {
+            throw _iteratorError4;
+          }
+        }
+      }
+    })();
+  }
+
+  /**
+   * Add a transaction on storage.
+   *
+   * @param {IHistoryTx} tx The transaction
+   * @returns {Promise<void>}
+   */
+  async addTx(tx) {
+    await this.store.saveTx(tx);
+  }
+
+  /**
+   * Process the transaction history to calculate the metadata.
+   * @returns {Promise<void>}
+   */
+  async processHistory() {
+    await this.store.preProcessHistory();
+    await (0, _storage.processHistory)(this, {
+      rewardLock: this.version?.reward_spend_min_blocks
+    });
+  }
+
+  /**
+   * Process the transaction history to calculate the metadata.
+   * @returns {Promise<void>}
+   */
+  async processNewTx(tx) {
+    // Keep tx-timestamp index sorted
+    await this.store.preProcessHistory();
+    // Process the single tx we received
+    await (0, _storage.processSingleTx)(this, tx, {
+      rewardLock: this.version?.reward_spend_min_blocks
+    });
+  }
+
+  /**
+   * Iterate on all tokens on the storage.
+   *
+   * @returns {AsyncGenerator<ITokenData & Partial<ITokenMetadata>>}
+   */
+  getAllTokens() {
+    var _this5 = this;
+    return _wrapAsyncGenerator(function* () {
+      var _iteratorAbruptCompletion5 = false;
+      var _didIteratorError5 = false;
+      var _iteratorError5;
+      try {
+        for (var _iterator5 = _asyncIterator(_this5.store.tokenIter()), _step5; _iteratorAbruptCompletion5 = !(_step5 = yield _awaitAsyncGenerator(_iterator5.next())).done; _iteratorAbruptCompletion5 = false) {
+          const token = _step5.value;
+          {
+            yield token;
+          }
+        }
+      } catch (err) {
+        _didIteratorError5 = true;
+        _iteratorError5 = err;
+      } finally {
+        try {
+          if (_iteratorAbruptCompletion5 && _iterator5.return != null) {
+            yield _awaitAsyncGenerator(_iterator5.return());
+          }
+        } finally {
+          if (_didIteratorError5) {
+            throw _iteratorError5;
+          }
+        }
+      }
+    })();
+  }
+
+  /**
+   * Iterate on all registered tokens of the wallet.
+   *
+   * @returns {AsyncGenerator<ITokenData & Partial<ITokenMetadata>>}
+   */
+  getRegisteredTokens() {
+    var _this6 = this;
+    return _wrapAsyncGenerator(function* () {
+      var _iteratorAbruptCompletion6 = false;
+      var _didIteratorError6 = false;
+      var _iteratorError6;
+      try {
+        for (var _iterator6 = _asyncIterator(_this6.store.registeredTokenIter()), _step6; _iteratorAbruptCompletion6 = !(_step6 = yield _awaitAsyncGenerator(_iterator6.next())).done; _iteratorAbruptCompletion6 = false) {
+          const token = _step6.value;
+          {
+            yield token;
+          }
+        }
+      } catch (err) {
+        _didIteratorError6 = true;
+        _iteratorError6 = err;
+      } finally {
+        try {
+          if (_iteratorAbruptCompletion6 && _iterator6.return != null) {
+            yield _awaitAsyncGenerator(_iterator6.return());
+          }
+        } finally {
+          if (_didIteratorError6) {
+            throw _iteratorError6;
+          }
+        }
+      }
+    })();
+  }
+
+  /**
+   * Get a token from storage along with the metadata of the wallet transactions.
+   *
+   * @param {string} token Token uid to fetch
+   * @returns {Promise<(ITokenData & Partial<ITokenMetadata>)|null>}
+   */
+  async getToken(token) {
+    return this.store.getToken(token);
+  }
+
+  /**
+   * Regsiter a token.
+   * @param {ITokenData} token Token data to register
+   * @returns {Promise<void>}
+   */
+  async registerToken(token) {
+    await this.store.registerToken(token);
+  }
+
+  /**
+   * Unregister a token from the wallet.
+   * @param {Promise<void>} tokenUid Token uid to unregister.
+   * @returns {Promise<void>}
+   */
+  async unregisterToken(tokenUid) {
+    await this.store.unregisterToken(tokenUid);
+  }
+
+  /**
+   * Return if a token is registered.
+   * @param tokenUid - Token id.
+   * @returns {Promise<boolean>}
+   */
+  async isTokenRegistered(tokenUid) {
+    return this.store.isTokenRegistered(tokenUid);
+  }
+
+  /**
+   * Process the locked utxos to unlock them if the lock has expired.
+   * Will process both timelocked and heightlocked utxos.
+   *
+   * We will wait for any previous execution to finish before starting the next one.
+   *
+   * @param {number} height The network height to use as reference to unlock utxos
+   * @returns {Promise<void>}
+   */
+  async unlockUtxos(height) {
+    // Will wait for the previous execution to finish before starting the next one
+    // This is to prevent multiple calls to this method to run in parallel and "double unlock" utxos
+    this.utxoUnlockWait = this.utxoUnlockWait.then(() => this.processLockedUtxos(height));
+  }
+
+  /**
+   * Iterate on all utxos of the wallet.
+   * @returns {AsyncGenerator<IUtxo, any, unknown>}
+   */
+  getAllUtxos() {
+    var _this7 = this;
+    return _wrapAsyncGenerator(function* () {
+      var _iteratorAbruptCompletion7 = false;
+      var _didIteratorError7 = false;
+      var _iteratorError7;
+      try {
+        for (var _iterator7 = _asyncIterator(_this7.store.utxoIter()), _step7; _iteratorAbruptCompletion7 = !(_step7 = yield _awaitAsyncGenerator(_iterator7.next())).done; _iteratorAbruptCompletion7 = false) {
+          const utxo = _step7.value;
+          {
+            yield utxo;
+          }
+        }
+      } catch (err) {
+        _didIteratorError7 = true;
+        _iteratorError7 = err;
+      } finally {
+        try {
+          if (_iteratorAbruptCompletion7 && _iterator7.return != null) {
+            yield _awaitAsyncGenerator(_iterator7.return());
+          }
+        } finally {
+          if (_didIteratorError7) {
+            throw _iteratorError7;
+          }
+        }
+      }
+    })();
+  }
+
+  /**
+   * Select utxos matching the request and do not select any utxos marked for inputs.
+   *
+   * @param {Omit<IUtxoFilterOptions, 'reward_lock'>} [options={}] Options to filter utxos and stop when the target is found.
+   * @returns {AsyncGenerator<IUtxo, any, unknown>}
+   */
+  selectUtxos(options = {}) {
+    var _this8 = this;
+    return _wrapAsyncGenerator(function* () {
+      const filterSelected = utxo => {
+        const utxoId = `${utxo.txId}:${utxo.index}`;
+        return !_this8.utxosSelectedAsInput.has(utxoId);
+      };
+      const newFilter = utxo => {
+        const optionsFilter = options.filter_method ? options.filter_method(utxo) : true;
+        const selectedFilter = filterSelected(utxo);
+        if (options.only_available_utxos) {
+          // We need to check if the utxo is selected as an input since we only want available utxos.
+          return selectedFilter && optionsFilter;
+        }
+        // Only check the filter method if we don't care about available utxos.
+        return optionsFilter;
+      };
+      const newOptions = {
+        ...options,
+        filter_method: newFilter
+      };
+      if (_this8.version?.reward_spend_min_blocks) {
+        newOptions.reward_lock = _this8.version.reward_spend_min_blocks;
+      }
+      var _iteratorAbruptCompletion8 = false;
+      var _didIteratorError8 = false;
+      var _iteratorError8;
+      try {
+        for (var _iterator8 = _asyncIterator(_this8.store.selectUtxos(newOptions)), _step8; _iteratorAbruptCompletion8 = !(_step8 = yield _awaitAsyncGenerator(_iterator8.next())).done; _iteratorAbruptCompletion8 = false) {
+          const utxo = _step8.value;
+          {
+            yield utxo;
+          }
+        }
+      } catch (err) {
+        _didIteratorError8 = true;
+        _iteratorError8 = err;
+      } finally {
+        try {
+          if (_iteratorAbruptCompletion8 && _iterator8.return != null) {
+            yield _awaitAsyncGenerator(_iterator8.return());
+          }
+        } finally {
+          if (_didIteratorError8) {
+            throw _iteratorError8;
+          }
+        }
+      }
+    })();
+  }
+
+  /**
+   * Match the selected balance for the given authority and token.
+   *
+   * @param {OutputValueType} singleBalance The balance we want to match
+   * @param {string} token The token uid
+   * @param {OutputValueType} authorities The authorities we want to match
+   * @param {string} changeAddress change address to use
+   * @param {boolean} chooseInputs If we can add new inputs to the transaction
+   * @returns {Promise<{inputs: IDataInput[], outputs: IDataOutput[]}>} The inputs and outputs that match the balance
+   * @internal
+   */
+  async matchBalanceSelection(singleBalance, token, authorities, changeAddress, chooseInputs) {
+    const newInputs = [];
+    const newOutputs = [];
+    const options = {
+      authorities,
+      token,
+      only_available_utxos: true
+    };
+    const isAuthority = authorities > 0;
+    if (isAuthority) {
+      options.max_utxos = Number(singleBalance);
+    } else {
+      options.target_amount = singleBalance;
+    }
+    if (singleBalance > 0) {
+      if (!chooseInputs) {
+        // We cannot choose inputs, so we fail
+        throw new Error(`Insufficient funds in the given inputs for ${token}, missing ${singleBalance} more tokens.`);
+      }
+      // We have a surplus of this token on the outputs, so we need to find utxos to match
+      let foundAmount = 0n;
+      var _iteratorAbruptCompletion9 = false;
+      var _didIteratorError9 = false;
+      var _iteratorError9;
+      try {
+        for (var _iterator9 = _asyncIterator(this.selectUtxos(options)), _step9; _iteratorAbruptCompletion9 = !(_step9 = await _iterator9.next()).done; _iteratorAbruptCompletion9 = false) {
+          const utxo = _step9.value;
+          {
+            if (isAuthority) {
+              foundAmount += 1n;
+            } else {
+              foundAmount += utxo.value;
+            }
+            newInputs.push({
+              txId: utxo.txId,
+              index: utxo.index,
+              token: utxo.token,
+              address: utxo.address,
+              value: utxo.value,
+              authorities: utxo.authorities
+            });
+          }
+        }
+      } catch (err) {
+        _didIteratorError9 = true;
+        _iteratorError9 = err;
+      } finally {
+        try {
+          if (_iteratorAbruptCompletion9 && _iterator9.return != null) {
+            await _iterator9.return();
+          }
+        } finally {
+          if (_didIteratorError9) {
+            throw _iteratorError9;
+          }
+        }
+      }
+      if (foundAmount < singleBalance) {
+        // XXX: Insufficient funds
+        throw new Error(`Insufficient funds, found ${foundAmount} but requested ${singleBalance}`);
+      } else if (foundAmount > singleBalance) {
+        if (isAuthority) {
+          // Since we use max_utxos for authorities we should stop before we select more utxos than
+          // required, so there should be no need to add an authority change
+          throw new Error('This should never happen, authorities should be exact');
+        } else {
+          // Add change output
+          newOutputs.push({
+            type: (0, _address.getAddressType)(changeAddress, this.config.getNetwork()),
+            token,
+            authorities: 0n,
+            value: foundAmount - singleBalance,
+            address: changeAddress,
+            timelock: null
+          });
+        }
+      }
+    } else if (singleBalance < 0) {
+      // We have a surplus of this token on the inputs, so we need to add a change output
+      if (isAuthority) {
+        for (let i = 0; i < -singleBalance; i++) {
+          newOutputs.push({
+            type: (0, _address.getAddressType)(changeAddress, this.config.getNetwork()),
+            token,
+            authorities,
+            value: authorities,
+            address: changeAddress,
+            timelock: null
+          });
+        }
+      } else {
+        newOutputs.push({
+          type: (0, _address.getAddressType)(changeAddress, this.config.getNetwork()),
+          token,
+          authorities: 0n,
+          value: -singleBalance,
+          address: changeAddress,
+          timelock: null
+        });
+      }
+    }
+    return {
+      inputs: newInputs,
+      outputs: newOutputs
+    };
+  }
+
+  /**
+   * Generate inputs and outputs so that the transaction balance is filled.
+   *
+   * @param {string} token Token uid
+   * @param {Record<'funds'|'mint'|'melt', number>} balance Balance of funds and authorities for a token on the transaction
+   * @param {IFillTxOptions} [options={}]
+   * @param {string} options.changeAddress Address to send change to
+   * @param {boolean} [options.skipAuthorities=false] If we should fill authorities or only funds
+   * @param {boolean} [options.chooseInputs=true] If we can choose inputs when needed or not
+   * @returns {Promise<{inputs: IDataInput[], outputs: IDataOutput[]}>} The inputs and outputs to fill the transaction
+   * @internal
+   */
+  async matchTokenBalance(token, balance, {
+    changeAddress,
+    skipAuthorities = true,
+    chooseInputs = true
+  } = {}) {
+    const addressForChange = changeAddress || (await this.getCurrentAddress());
+    // balance holds the balance of all tokens on the transaction
+    const newInputs = [];
+    const newOutputs = [];
+    // match funds
+    const {
+      inputs: fundsInputs,
+      outputs: fundsOutputs
+    } = await this.matchBalanceSelection(balance.funds, token, 0n, addressForChange, chooseInputs);
+    newInputs.push(...fundsInputs);
+    newOutputs.push(...fundsOutputs);
+    if (!(skipAuthorities || token === _constants.NATIVE_TOKEN_UID)) {
+      // Match authority balance (only possible for custom tokens)
+      // match mint
+      const {
+        inputs: mintInputs,
+        outputs: mintOutputs
+      } = await this.matchBalanceSelection(balance.mint, token, 1n, addressForChange, chooseInputs);
+      // match melt
+      const {
+        inputs: meltInputs,
+        outputs: meltOutputs
+      } = await this.matchBalanceSelection(balance.melt, token, 2n, addressForChange, chooseInputs);
+      newInputs.push(...mintInputs, ...meltInputs);
+      newOutputs.push(...mintOutputs, ...meltOutputs);
+    }
+    return {
+      inputs: newInputs,
+      outputs: newOutputs
+    };
+  }
+
+  /**
+   * Check the balance of the transaction and add inputs and outputs to match the funds and authorities.
+   * It will fail if we do not have enough funds or authorities and it will fail if we try to add too many inputs or outputs.
+   *
+   * @param tx The incomplete transaction we need to fill
+   * @param {IFillTxOptions} [options={}] options to use a change address.
+   *
+   * @async
+   * @returns {Promise<void>}
+   */
+  async fillTx(token, tx, options = {}) {
+    const tokenBalance = await _transaction.default.calculateTxBalanceToFillTx(token, tx);
+    const {
+      inputs: newInputs,
+      outputs: newOutputs
+    } = await this.matchTokenBalance(token, tokenBalance, options);
+
+    // Validate if we will add too many inputs/outputs
+    const max_inputs = this.version?.max_number_inputs || _constants.MAX_INPUTS;
+    const max_outputs = this.version?.max_number_outputs || _constants.MAX_OUTPUTS;
+    if (tx.inputs.length + newInputs.length > max_inputs || tx.outputs.length + newOutputs.length > max_outputs) {
+      // we have more inputs/outputs than what can be sent on the transaction
+      throw new Error('When over the maximum amount of inputs/outputs');
+    }
+    return {
+      inputs: newInputs,
+      outputs: newOutputs
+    };
+  }
+
+  /**
+   * Mark an utxo as selected as input
+   *
+   * @param {IUtxoId} utxo The Data to identify the utxo
+   * @param {boolean} markAs Mark the utxo as this value
+   * @param {number|undefined} ttl Unmark the utxo after this amount os ms passed
+   *
+   * @async
+   * @returns {Promise<void>}
+   */
+  async utxoSelectAsInput(utxo, markAs, ttl) {
+    const tx = await this.getTx(utxo.txId);
+    if (!tx || !tx.outputs[utxo.index]) {
+      return;
+    }
+    if (markAs && tx.outputs[utxo.index].spent_by !== null) {
+      // Already spent, no need to mark as selected_as_input
+      return;
+    }
+    const utxoId = `${utxo.txId}:${utxo.index}`;
+    if (markAs) {
+      this.utxosSelectedAsInput.set(utxoId, markAs);
+      // if a ttl is given, we should reverse
+      if (ttl) {
+        setTimeout(() => {
+          if (this.utxosSelectedAsInput.has(utxoId)) {
+            this.utxosSelectedAsInput.delete(utxoId);
+          }
+        }, ttl);
+      }
+    } else {
+      this.utxosSelectedAsInput.delete(utxoId);
+    }
+  }
+
+  /**
+   * Iterate over all locked utxos and unlock them if needed
+   * When a utxo is unlocked, the balances and metadatas are updated
+   * and the utxo is removed from the locked utxos.
+   *
+   * @param {number} height The new height of the best chain
+   */
+  async processLockedUtxos(height) {
+    const nowTs = Math.floor(Date.now() / 1000);
+    var _iteratorAbruptCompletion10 = false;
+    var _didIteratorError10 = false;
+    var _iteratorError10;
+    try {
+      for (var _iterator10 = _asyncIterator(this.store.iterateLockedUtxos()), _step10; _iteratorAbruptCompletion10 = !(_step10 = await _iterator10.next()).done; _iteratorAbruptCompletion10 = false) {
+        const lockedUtxo = _step10.value;
+        {
+          await (0, _storage.processUtxoUnlock)(this, lockedUtxo, {
+            nowTs,
+            rewardLock: this.version?.reward_spend_min_blocks || 0,
+            currentHeight: height
+          });
+        }
+      }
+    } catch (err) {
+      _didIteratorError10 = true;
+      _iteratorError10 = err;
+    } finally {
+      try {
+        if (_iteratorAbruptCompletion10 && _iterator10.return != null) {
+          await _iterator10.return();
+        }
+      } finally {
+        if (_didIteratorError10) {
+          throw _iteratorError10;
+        }
+      }
+    }
+  }
+
+  /**
+   * Check if an utxo is selected as input.
+   *
+   * @param {IUtxoId} utxo The utxo we want to check if it is selected as input
+   * @returns {Promise<boolean>}
+   * @example
+   * const isSelected = await isUtxoSelectedAsInput({ txId: 'tx1', index: 0 });
+   */
+  async isUtxoSelectedAsInput(utxo) {
+    const utxoId = `${utxo.txId}:${utxo.index}`;
+    return this.utxosSelectedAsInput.has(utxoId);
+  }
+
+  /**
+   * Iterate on all locked utxos.
+   * Used to check if the utxos are still locked.
+   *
+   * @returns {AsyncGenerator<IUtxoId>}
+   */
+  utxoSelectedAsInputIter() {
+    var _this9 = this;
+    return _wrapAsyncGenerator(function* () {
+      for (const [utxoStr, isSelected] of _this9.utxosSelectedAsInput.entries()) {
+        if (isSelected) {
+          const [txId, index] = utxoStr.split(':');
+          yield {
+            txId,
+            index: parseInt(index, 10)
+          };
+        }
+      }
+    })();
+  }
+
+  /**
+   * Helper to check if the access data exists before returning it.
+   * Having the accessData as null means the wallet is not initialized so we should throw an error.
+   *
+   * @returns {Promise<IWalletAccessData>} The access data.
+   * @internal
+   */
+  async _getValidAccessData() {
+    const accessData = await this.getAccessData();
+    if (!accessData) {
+      throw new _errors.UninitializedWalletError();
+    }
+    return accessData;
+  }
+
+  /**
+   * Get the wallet's access data if the wallet is initialized.
+   *
+   * @returns {Promise<IWalletAccessData | null>}
+   */
+  async getAccessData() {
+    return this.store.getAccessData();
+  }
+
+  /**
+   * Save the access data, initializing the wallet.
+   *
+   * @param {IWalletAccessData} data The wallet access data
+   * @returns {Promise<void>}
+   */
+  async saveAccessData(data) {
+    return this.store.saveAccessData(data);
+  }
+
+  /**
+   * Get the wallet's metadata.
+   *
+   * @returns {Promise<IWalletData>}
+   */
+  async getWalletData() {
+    return this.store.getWalletData();
+  }
+
+  /**
+   * Get the wallet type, i.e. P2PKH or MultiSig.
+   *
+   * @returns {Promise<WalletType>}
+   */
+  async getWalletType() {
+    const accessData = await this._getValidAccessData();
+    return accessData.walletType;
+  }
+
+  /**
+   * Set the current height
+   * @param {number} height The current height
+   * @returns {Promise<void>} The current height of the network
+   */
+  async setCurrentHeight(height) {
+    await this.store.setCurrentHeight(height);
+  }
+
+  /**
+   * Get the current height
+   * @returns {Promise<number>} The current height
+   */
+  async getCurrentHeight() {
+    return this.store.getCurrentHeight();
+  }
+
+  /**
+   * Return wheather the wallet is readonly, i.e. was started without the private key.
+   * @returns {Promise<boolean>}
+   */
+  async isReadonly() {
+    const accessData = await this._getValidAccessData();
+    return (accessData.walletFlags & _types.WALLET_FLAGS.READONLY) > 0;
+  }
+
+  /**
+   * Decrypt and return the main private key of the wallet.
+   *
+   * @param {string} pinCode Pin to unlock the private key
+   * @returns {Promise<string>} The HDPrivateKey in string format.
+   */
+  async getMainXPrivKey(pinCode) {
+    const accessData = await this._getValidAccessData();
+    if (accessData.mainKey === undefined) {
+      throw new Error('Private key is not present on this wallet.');
+    }
+
+    // decryptData handles pin validation
+    return (0, _crypto.decryptData)(accessData.mainKey, pinCode);
+  }
+
+  /**
+   * Get account path xprivkey if available.
+   *
+   * @param {string} pinCode
+   * @returns {Promise<string>}
+   */
+  async getAcctPathXPrivKey(pinCode) {
+    const accessData = await this._getValidAccessData();
+    if (!accessData.acctPathKey) {
+      throw new Error('Private key is not present on this wallet.');
+    }
+
+    // decryptData handles pin validation
+    return (0, _crypto.decryptData)(accessData.acctPathKey, pinCode);
+  }
+
+  /**
+   * Decrypt and return the auth private key of the wallet.
+   *
+   * @param {string} pinCode Pin to unlock the private key
+   * @returns {Promise<string>} The Auth HDPrivateKey in string format.
+   */
+  async getAuthPrivKey(pinCode) {
+    const accessData = await this._getValidAccessData();
+    if (accessData.authKey === undefined) {
+      throw new Error('Private key is not present on this wallet.');
+    }
+
+    // decryptData handles pin validation
+    return (0, _crypto.decryptData)(accessData.authKey, pinCode);
+  }
+
+  /**
+   * Handle storage operations for a wallet being stopped.
+   * @param {{
+   *   connection?: FullNodeConnection;
+   *   cleanStorage?: boolean;
+   *   cleanAddresses?: boolean;
+   *   cleanTokens?: boolean;
+   * }} Options to handle stop
+   * @returns {Promise<void>}
+   */
+  async handleStop({
+    connection,
+    cleanStorage = false,
+    cleanAddresses = false,
+    cleanTokens = false
+  } = {}) {
+    if (connection) {
+      var _iteratorAbruptCompletion11 = false;
+      var _didIteratorError11 = false;
+      var _iteratorError11;
+      try {
+        for (var _iterator11 = _asyncIterator(this.getAllAddresses()), _step11; _iteratorAbruptCompletion11 = !(_step11 = await _iterator11.next()).done; _iteratorAbruptCompletion11 = false) {
+          const addressInfo = _step11.value;
+          {
+            connection.unsubscribeAddress(addressInfo.base58);
+          }
+        }
+      } catch (err) {
+        _didIteratorError11 = true;
+        _iteratorError11 = err;
+      } finally {
+        try {
+          if (_iteratorAbruptCompletion11 && _iterator11.return != null) {
+            await _iterator11.return();
+          }
+        } finally {
+          if (_didIteratorError11) {
+            throw _iteratorError11;
+          }
+        }
+      }
+      connection.removeMetricsHandlers();
+    }
+    this.version = null;
+    if (cleanStorage || cleanAddresses || cleanTokens) {
+      await this.cleanStorage(cleanStorage, cleanAddresses, cleanTokens);
+    }
+  }
+
+  /**
+   * Clean the storage data.
+   *
+   * @param {boolean} [cleanHistory=false] If we should clean the history data
+   * @param {boolean} [cleanAddresses=false] If we should clean the address data
+   * @param {boolean} [cleanTokens=false] If we should clean the registered tokens
+   * @returns {Promise<void>}
+   */
+  async cleanStorage(cleanHistory = false, cleanAddresses = false, cleanTokens = false) {
+    return this.store.cleanStorage(cleanHistory, cleanAddresses, cleanTokens);
+  }
+
+  /**
+   * Check if the pin is correct
+   *
+   * @param {string} pinCode - Pin to check
+   * @returns {Promise<boolean>}
+   * @throws {Error} if the wallet is not initialized
+   * @throws {Error} if the wallet does not have the private key
+   */
+  async checkPin(pinCode) {
+    const accessData = await this._getValidAccessData();
+    if (!accessData.mainKey) {
+      throw new Error('Cannot check pin without the private key.');
+    }
+    return (0, _crypto.checkPassword)(accessData.mainKey, pinCode);
+  }
+
+  /**
+   * Check if the password is correct
+   *
+   * @param {string} password - Password to check
+   * @returns {Promise<boolean>}
+   * @throws {Error} if the wallet is not initialized
+   * @throws {Error} if the wallet does not have the private key
+   */
+  async checkPassword(password) {
+    const accessData = await this._getValidAccessData();
+    if (!accessData.words) {
+      throw new Error('Cannot check password without the words.');
+    }
+    return (0, _crypto.checkPassword)(accessData.words, password);
+  }
+
+  /**
+   * Change the wallet pin.
+   * @param {string} oldPin Old pin to unlock data.
+   * @param {string} newPin New pin to lock data.
+   * @returns {Promise<void>}
+   */
+  async changePin(oldPin, newPin) {
+    const accessData = await this._getValidAccessData();
+    const newAccessData = _wallet.default.changeEncryptionPin(accessData, oldPin, newPin);
+
+    // Save the changes made
+    await this.saveAccessData(newAccessData);
+  }
+
+  /**
+   * Change the wallet password.
+   *
+   * @param {string} oldPassword Old password
+   * @param {string} newPassword New password
+   * @returns {Promise<void>}
+   */
+  async changePassword(oldPassword, newPassword) {
+    const accessData = await this._getValidAccessData();
+    const newAccessData = _wallet.default.changeEncryptionPassword(accessData, oldPassword, newPassword);
+
+    // Save the changes made
+    await this.saveAccessData(newAccessData);
+  }
+
+  /**
+   * Set the wallet gap limit.
+   * @param {number} value New gap limit to use.
+   * @returns {Promise<void>}
+   */
+  async setGapLimit(value) {
+    return this.store.setGapLimit(value);
+  }
+
+  /**
+   * Get the wallet gap limit.
+   * @returns {Promise<number>}
+   */
+  async getGapLimit() {
+    if ((await this.getScanningPolicy()) !== _types.SCANNING_POLICY.GAP_LIMIT) {
+      throw new Error('Wallet is not configured to use gap limit');
+    }
+    return this.store.getGapLimit();
+  }
+
+  /**
+   * Get the index limit.
+   * @returns {Promise<Omit<IIndexLimitAddressScanPolicy, 'policy'>>}
+   */
+  async getIndexLimit() {
+    return this.store.getIndexLimit();
+  }
+
+  /**
+   * Get the scanning policy.
+   * @returns {Promise<AddressScanPolicy>}
+   */
+  async getScanningPolicy() {
+    return this.store.getScanningPolicy();
+  }
+
+  /**
+   * Set the scanning policy data.
+   * @param {AddressScanPolicyData | null} data
+   * @returns {Promise<void>}
+   */
+  async setScanningPolicyData(data) {
+    if (!data) return;
+    await this.store.setScanningPolicyData(data);
+  }
+
+  /**
+   * Get the scanning policy data.
+   * @returns {Promise<AddressScanPolicyData>}
+   */
+  async getScanningPolicyData() {
+    return this.store.getScanningPolicyData();
+  }
+
+  /**
+   * Return if the loaded wallet was started from a hardware wallet.
+   * @returns {Promise<boolean>}
+   */
+  async isHardwareWallet() {
+    const accessData = await this._getValidAccessData();
+    return (accessData.walletFlags & _types.WALLET_FLAGS.HARDWARE) > 0;
+  }
+
+  /**
+   * Return if the nano contract is registered for the given address based on ncId.
+   * @param ncId Nano Contract ID.
+   * @returns `true` if registered and `false` otherwise.
+   * @async
+   */
+  async isNanoContractRegistered(ncId) {
+    return this.store.isNanoContractRegistered(ncId);
+  }
+
+  /**
+   * Iterate on all registered nano contracts of the wallet.
+   *
+   * @async
+   * @generator
+   * @returns {AsyncGenerator<INcData>}
+   */
+  getRegisteredNanoContracts() {
+    var _this10 = this;
+    return _wrapAsyncGenerator(function* () {
+      var _iteratorAbruptCompletion12 = false;
+      var _didIteratorError12 = false;
+      var _iteratorError12;
+      try {
+        for (var _iterator12 = _asyncIterator(_this10.store.registeredNanoContractsIter()), _step12; _iteratorAbruptCompletion12 = !(_step12 = yield _awaitAsyncGenerator(_iterator12.next())).done; _iteratorAbruptCompletion12 = false) {
+          const ncData = _step12.value;
+          {
+            yield ncData;
+          }
+        }
+      } catch (err) {
+        _didIteratorError12 = true;
+        _iteratorError12 = err;
+      } finally {
+        try {
+          if (_iteratorAbruptCompletion12 && _iterator12.return != null) {
+            yield _awaitAsyncGenerator(_iterator12.return());
+          }
+        } finally {
+          if (_didIteratorError12) {
+            throw _iteratorError12;
+          }
+        }
+      }
+    })();
+  }
+
+  /**
+   * Get nano contract data.
+   * @param ncId Nano Contract ID.
+   * @returns An instance of Nano Contract data.
+   */
+  async getNanoContract(ncId) {
+    return this.store.getNanoContract(ncId);
+  }
+
+  /**
+   * Register nano contract data instance.
+   * @param ncId Nano Contract ID.
+   * @param ncValue Nano Contract basic information.
+   */
+  async registerNanoContract(ncId, ncValue) {
+    return this.store.registerNanoContract(ncId, ncValue);
+  }
+
+  /**
+   * Unregister nano contract.
+   * @param ncId Nano Contract ID.
+   */
+  async unregisterNanoContract(ncId) {
+    return this.store.unregisterNanoContract(ncId);
+  }
+
+  /**
+   * Update nano contract registered address
+   * @param ncId Nano Contract ID.
+   * @param address New registered address
+   */
+  async updateNanoContractRegisteredAddress(ncId, address) {
+    if (!(await this.isAddressMine(address))) {
+      throw new Error('Registered address must belong to the wallet.');
+    }
+    return this.store.updateNanoContractRegisteredAddress(ncId, address);
+  }
+}
+exports.Storage = Storage;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/swapService/swapConnection.d.ts b/node_modules/@hathor/wallet-lib/oldLib/swapService/swapConnection.d.ts
new file mode 100644
index 0000000..4fa44da
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/swapService/swapConnection.d.ts
@@ -0,0 +1,53 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/// <reference types="node" />
+import { EventEmitter } from 'events';
+import { ConnectionState } from '../wallet/types';
+import GenericWebSocket from '../websocket';
+import { ILogger } from '../types';
+/**
+ * This is a Websocket Connection with the Atomic Swap Service
+ *
+ * It has the following states:
+ * - CLOSED: When it is disconnected from the server.
+ * - CONNECTING: When it is connecting to the server.
+ * - CONNECTED: When it is connected.
+ *
+ * You can subscribe for the following events:
+ * - update-atomic-swap-proposal: Fired when the state of a listened proposal changes
+ * - state: Fired when the websocket connection state changes
+ * - pong: Internal or debug use only. Fired when the health check is received from the backend
+ * */
+export declare class AtomicSwapServiceConnection extends EventEmitter {
+    websocket: GenericWebSocket;
+    protected state: ConnectionState;
+    protected logger: ILogger;
+    constructor(options: {
+        wsURL: string;
+        connectionTimeout?: number;
+        logger?: ILogger;
+    });
+    /**
+     * Connect to the server and start emitting events.
+     * */
+    start(): void;
+    /**
+     * Called when the connection to the websocket changes.
+     * It is also called if the network is down.
+     * */
+    onConnectionChange(value: boolean): void;
+    /**
+     * Update class state
+     *
+     * @param {Number} state New state
+     */
+    private setState;
+    getState(): ConnectionState;
+    subscribeProposal(proposalsIds: string[]): void;
+    unsubscribeProposal(proposalId: string): void;
+}
+//# sourceMappingURL=swapConnection.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/swapService/swapConnection.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/swapService/swapConnection.d.ts.map
new file mode 100644
index 0000000..894762d
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/swapService/swapConnection.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"swapConnection.d.ts","sourceRoot":"","sources":["../../src/swapService/swapConnection.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;;AAEH,OAAO,EAAE,YAAY,EAAE,MAAM,QAAQ,CAAC;AACtC,OAAO,EAAE,eAAe,EAAE,MAAM,iBAAiB,CAAC;AAClD,OAAO,gBAAgB,MAAM,cAAc,CAAC;AAC5C,OAAO,EAAE,OAAO,EAAoB,MAAM,UAAU,CAAC;AAErD;;;;;;;;;;;;KAYK;AACL,qBAAa,2BAA4B,SAAQ,YAAY;IAC3D,SAAS,EAAE,gBAAgB,CAAC;IAE5B,SAAS,CAAC,KAAK,EAAE,eAAe,CAAC;IAEjC,SAAS,CAAC,MAAM,EAAE,OAAO,CAAC;gBAEd,OAAO,EAAE;QAAE,KAAK,EAAE,MAAM,CAAC;QAAC,iBAAiB,CAAC,EAAE,MAAM,CAAC;QAAC,MAAM,CAAC,EAAE,OAAO,CAAA;KAAE;IAqBpF;;SAEK;IACL,KAAK;IA0BL;;;SAGK;IACL,kBAAkB,CAAC,KAAK,EAAE,OAAO;IAQjC;;;;OAIG;IACH,OAAO,CAAC,QAAQ;IAKhB,QAAQ;IAIR,iBAAiB,CAAC,YAAY,EAAE,MAAM,EAAE;IASxC,mBAAmB,CAAC,UAAU,EAAE,MAAM;CAMvC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/swapService/swapConnection.js b/node_modules/@hathor/wallet-lib/oldLib/swapService/swapConnection.js
new file mode 100644
index 0000000..34b50d0
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/swapService/swapConnection.js
@@ -0,0 +1,125 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.AtomicSwapServiceConnection = void 0;
+var _events = require("events");
+var _types = require("../wallet/types");
+var _websocket = _interopRequireDefault(require("../websocket"));
+var _types2 = require("../types");
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
+function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
+function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/**
+ * This is a Websocket Connection with the Atomic Swap Service
+ *
+ * It has the following states:
+ * - CLOSED: When it is disconnected from the server.
+ * - CONNECTING: When it is connecting to the server.
+ * - CONNECTED: When it is connected.
+ *
+ * You can subscribe for the following events:
+ * - update-atomic-swap-proposal: Fired when the state of a listened proposal changes
+ * - state: Fired when the websocket connection state changes
+ * - pong: Internal or debug use only. Fired when the health check is received from the backend
+ * */
+class AtomicSwapServiceConnection extends _events.EventEmitter {
+  constructor(options) {
+    super();
+    _defineProperty(this, "websocket", void 0);
+    _defineProperty(this, "state", void 0);
+    _defineProperty(this, "logger", void 0);
+    const logger = options.logger || (0, _types2.getDefaultLogger)();
+
+    // Initializing WebSocket
+    const wsOptions = {
+      logger,
+      wsURL: options.wsURL
+    };
+    if (options.connectionTimeout) {
+      wsOptions.connectionTimeout = options.connectionTimeout;
+    }
+    this.websocket = new _websocket.default(wsOptions);
+
+    // Remaining properties initialization
+    this.state = _types.ConnectionState.CLOSED;
+    this.logger = logger;
+  }
+
+  /**
+   * Connect to the server and start emitting events.
+   * */
+  start() {
+    // This should never happen as the websocket is initialized on the constructor
+    if (!this.websocket) {
+      throw new Error('Websocket is not initialized');
+    }
+    this.websocket.on('pong', value => {
+      this.emit('pong', value);
+    });
+    this.websocket.on('is_online', value => {
+      return this.onConnectionChange(value);
+    });
+    this.websocket.on('proposal_updated', data => {
+      this.emit('update-atomic-swap-proposal', data);
+    });
+    this.websocket.on('connection_error', err => {
+      this.logger.error(`Atomic Swap Service Websocket error: ${err.message}`);
+    });
+    this.setState(_types.ConnectionState.CONNECTING);
+    this.websocket.setup();
+  }
+
+  /**
+   * Called when the connection to the websocket changes.
+   * It is also called if the network is down.
+   * */
+  onConnectionChange(value) {
+    if (value) {
+      this.setState(_types.ConnectionState.CONNECTED);
+    } else {
+      this.setState(_types.ConnectionState.CONNECTING);
+    }
+  }
+
+  /**
+   * Update class state
+   *
+   * @param {Number} state New state
+   */
+  setState(state) {
+    this.state = state;
+    this.emit('state', state);
+  }
+  getState() {
+    return this.state;
+  }
+  subscribeProposal(proposalsIds) {
+    if (this.websocket) {
+      for (const proposalId of proposalsIds) {
+        const msg = JSON.stringify({
+          type: 'subscribe_proposal',
+          proposalId
+        });
+        this.websocket.sendMessage(msg);
+      }
+    }
+  }
+  unsubscribeProposal(proposalId) {
+    if (this.websocket) {
+      const msg = JSON.stringify({
+        type: 'unsubscribe_proposal',
+        proposalId
+      });
+      this.websocket.sendMessage(msg);
+    }
+  }
+}
+exports.AtomicSwapServiceConnection = AtomicSwapServiceConnection;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/sync/gll.d.ts b/node_modules/@hathor/wallet-lib/oldLib/sync/gll.d.ts
new file mode 100644
index 0000000..8c49b4a
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/sync/gll.d.ts
@@ -0,0 +1,4 @@
+import PromiseQueue from '../models/promise_queue';
+declare const GLL: PromiseQueue;
+export default GLL;
+//# sourceMappingURL=gll.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/sync/gll.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/sync/gll.d.ts.map
new file mode 100644
index 0000000..1629b17
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/sync/gll.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"gll.d.ts","sourceRoot":"","sources":["../../src/sync/gll.ts"],"names":[],"mappings":"AAAA,OAAO,YAAY,MAAM,yBAAyB,CAAC;AAInD,QAAA,MAAM,GAAG,cAAqB,CAAC;AAG/B,eAAe,GAAG,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/sync/gll.js b/node_modules/@hathor/wallet-lib/oldLib/sync/gll.js
new file mode 100644
index 0000000..fbe49f6
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/sync/gll.js
@@ -0,0 +1,12 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+var _promise_queue = _interopRequireDefault(require("../models/promise_queue"));
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+const MAX_CONCURRENT_LOAD_TASKS = 3;
+const GLL = new _promise_queue.default();
+GLL.concurrent = MAX_CONCURRENT_LOAD_TASKS;
+var _default = exports.default = GLL;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/sync/stream.d.ts b/node_modules/@hathor/wallet-lib/oldLib/sync/stream.d.ts
new file mode 100644
index 0000000..985fc6e
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/sync/stream.d.ts
@@ -0,0 +1,153 @@
+import FullNodeConnection from '../new/connection';
+import { IStorage, IHistoryTx, HistorySyncMode, IAddressInfo, ILogger } from '../types';
+import Queue from '../models/queue';
+interface IStreamItemVertex {
+    seq: number;
+    type: 'vertex';
+    vertex: IHistoryTx;
+}
+interface IStreamItemAddress {
+    seq: number;
+    type: 'address';
+    address: IAddressInfo;
+}
+type IStreamItem = IStreamItemAddress | IStreamItemVertex;
+/**
+ * Stream statistics manager.
+ * Will provide insight on the rates of the stream and how the client is performing.
+ */
+declare class StreamStatsManager {
+    recvCounter: number;
+    procCounter: number;
+    ackCounter: number;
+    emptyCounter: number;
+    inTimer?: ReturnType<typeof setTimeout>;
+    outTimer?: ReturnType<typeof setTimeout>;
+    qTimer?: ReturnType<typeof setTimeout>;
+    logger: ILogger;
+    q: Queue;
+    sampleInterval: number;
+    constructor(queue: Queue, logger: ILogger);
+    /**
+     * Perform any cleanup necessary when the queue is done processing.
+     * For instance, stop the timers processing the io rates.
+     */
+    clean(): void;
+    /**
+     * Mark an ACK message sent to the fullnode.
+     */
+    ack(seq: number): void;
+    /**
+     * Mark that an item has been received by the queue.
+     * This also manages the inTimer, which calculates the rate of received items.
+     */
+    recv(): void;
+    /**
+     * Mark that an item has been processed from the queue.
+     * This also manages the outTimer, which calculates the rate of processed items.
+     */
+    proc(): void;
+    /**
+     * Mark that the queue processed all items ready.
+     * This will onlt log once out of every 100 calls to avoid verbosity.
+     */
+    queueEmpty(): void;
+}
+/**
+ * Load addresses in a CPU intensive way
+ * This only contemplates P2PKH addresses for now.
+ */
+export declare function loadAddressesCPUIntensive(startIndex: number, count: number, xpubkey: string, networkName: string): [number, string][];
+export declare function generateStreamId(): string;
+export declare function xpubStreamSyncHistory(startIndex: number, _count: number, storage: IStorage, connection: FullNodeConnection, shouldProcessHistory?: boolean): Promise<void>;
+export declare function manualStreamSyncHistory(startIndex: number, _count: number, storage: IStorage, connection: FullNodeConnection, shouldProcessHistory?: boolean): Promise<void>;
+/**
+ * The StreamManager extends the AbortController because it will be used to stop the stream.
+ * The abort signal will be used to:
+ * - Stop generating more addresses since the fullnode will not receive them.
+ * - Stop updating the UI with events of new addresses and transactions.
+ * - Stop processing new events from the fullnode.
+ * - Once aborted the `stream` event listener will be removed from the connection.
+ * - Resolve the promise when aborted.
+ */
+export declare class StreamManager extends AbortController {
+    streamId: string;
+    MAX_WINDOW_SIZE: number;
+    ADDRESSES_PER_MESSAGE: number;
+    UI_UPDATE_INTERVAL: number;
+    storage: IStorage;
+    connection: FullNodeConnection;
+    xpubkey: string;
+    gapLimit: number;
+    network: string;
+    lastLoadedIndex: number;
+    lastReceivedIndex: number;
+    canUpdateUI: boolean;
+    foundAnyTx: boolean;
+    mode: HistorySyncMode;
+    batchQueue: Promise<void>;
+    itemQueue: Queue<IStreamItem>;
+    errorMessage: string | null;
+    logger: ILogger;
+    isProcessingQueue: boolean;
+    lastAcked: number;
+    lastSeenSeq: number;
+    lastProcSeq: number;
+    hasReceivedEndStream: boolean;
+    stats: StreamStatsManager;
+    /**
+     * @param {number} startIndex Index to start loading addresses
+     * @param {IStorage} storage The storage to load the addresses
+     * @param {FullNodeConnection} connection Connection to the full node
+     * @param {HistorySyncMode} mode The mode of the stream
+     */
+    constructor(startIndex: number, storage: IStorage, connection: FullNodeConnection, mode: HistorySyncMode);
+    /**
+     * Make initial preparations and lock the stream on the connection.
+     */
+    setupStream(): Promise<void>;
+    /**
+     * Abort the stream with an error.
+     */
+    abortWithError(error: string): void;
+    /**
+     * Generate the next batch of addresses to send to the fullnode.
+     * The batch will generate `ADDRESSES_PER_MESSAGE` addresses and send them to the fullnode.
+     * It will run again until the fullnode has `MAX_WINDOW_SIZE` addresses on its end.
+     * This is calculated by the distance between the highest index we sent to the fullnode minus the highest index we received from the fullnode.
+     * This is only used for manual streams.
+     */
+    generateNextBatch(): void;
+    /**
+     * This controls the ACK strategy.
+     * @returns {boolean} if we should send an ack message to the server.
+     */
+    shouldACK(): boolean;
+    /**
+     * Ack the stream messages.
+     */
+    ack(): void;
+    isQueueDone(): boolean;
+    processQueue(): Promise<void>;
+    addTx(seq: number, tx: IHistoryTx): void;
+    addAddress(seq: number, index: number, address: string): void;
+    /**
+     * Send event to update UI.
+     * This should be throttled to avoid flooding the UI with events.
+     * The UI will be updated in intervals of at least `UI_UPDATE_INTERVAL`.
+     */
+    updateUI(): void;
+    sendStartMessage(): void;
+    endStream(seq: number): void;
+    shutdown(): Promise<void>;
+}
+/**
+ * Start a stream to sync the history of the wallet on `storage`.
+ * Since there is a lot of overlap between xpub and manual modes this method was created to accomodate both.
+ * @param {StreamManager} manager stream manager instance.
+ * @param {boolean} shouldProcessHistory If we should process the history after loading it.
+ * @returns {Promise<void>}
+ */
+export declare function streamSyncHistory(manager: StreamManager, shouldProcessHistory: boolean): Promise<void>;
+export {};
+//# sourceMappingURL=stream.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/sync/stream.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/sync/stream.d.ts.map
new file mode 100644
index 0000000..3dc7326
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/sync/stream.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"stream.d.ts","sourceRoot":"","sources":["../../src/sync/stream.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/sync/stream.js b/node_modules/@hathor/wallet-lib/oldLib/sync/stream.js
new file mode 100644
index 0000000..1cdcf12
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/sync/stream.js
@@ -0,0 +1,613 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.StreamManager = void 0;
+exports.generateStreamId = generateStreamId;
+exports.loadAddressesCPUIntensive = loadAddressesCPUIntensive;
+exports.manualStreamSyncHistory = manualStreamSyncHistory;
+exports.streamSyncHistory = streamSyncHistory;
+exports.xpubStreamSyncHistory = xpubStreamSyncHistory;
+var _bitcoreLib = require("bitcore-lib");
+var _queueMicrotask = _interopRequireDefault(require("queue-microtask"));
+var _types = require("../types");
+var _network = _interopRequireDefault(require("../models/network"));
+var _queue = _interopRequireDefault(require("../models/queue"));
+var _schemas = require("../schemas");
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
+function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
+function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
+/* eslint max-classes-per-file: ["error", 2] */
+
+const QUEUE_GRACEFUL_SHUTDOWN_LIMIT = 10000;
+function isStreamSyncHistoryBegin(data) {
+  return data.type === 'stream:history:begin';
+}
+function isStreamSyncHistoryVertex(data) {
+  return data.type === 'stream:history:vertex';
+}
+function isStreamSyncHistoryAddress(data) {
+  return data.type === 'stream:history:address';
+}
+function isStreamSyncHistoryEnd(data) {
+  return data.type === 'stream:history:end';
+}
+function isStreamSyncHistoryError(data) {
+  return data.type === 'stream:history:error';
+}
+function isStreamItemVertex(item) {
+  return item.type === 'vertex';
+}
+function isStreamItemAddress(item) {
+  return item.type === 'address';
+}
+
+/**
+ * Stream statistics manager.
+ * Will provide insight on the rates of the stream and how the client is performing.
+ */
+class StreamStatsManager {
+  constructor(queue, logger) {
+    // Counter for received events
+    _defineProperty(this, "recvCounter", void 0);
+    // Counter for processed events
+    _defineProperty(this, "procCounter", void 0);
+    // Counter for ack messages sent
+    _defineProperty(this, "ackCounter", void 0);
+    // Counter for the number of times the queue has been empty.
+    _defineProperty(this, "emptyCounter", void 0);
+    // Timer to process in_rate, which is number of received events per second.
+    _defineProperty(this, "inTimer", void 0);
+    // Timer to process out_rate, which is the number of processed events per second.
+    _defineProperty(this, "outTimer", void 0);
+    // Simple timer to log the number of events on queue.
+    _defineProperty(this, "qTimer", void 0);
+    // Custom logger to log in the desired format.
+    _defineProperty(this, "logger", void 0);
+    // Reference to the item queue we are processing.
+    _defineProperty(this, "q", void 0);
+    // Interval to use when calculating rates.
+    _defineProperty(this, "sampleInterval", void 0);
+    this.recvCounter = 0;
+    this.procCounter = 0;
+    this.ackCounter = 0;
+    this.emptyCounter = 0;
+    this.logger = logger;
+    this.sampleInterval = 2000;
+    this.q = queue;
+    this.qTimer = setInterval(() => {
+      this.logger.debug(`[*] queue_size: ${queue.size()}`);
+    }, this.sampleInterval);
+  }
+
+  /**
+   * Perform any cleanup necessary when the queue is done processing.
+   * For instance, stop the timers processing the io rates.
+   */
+  clean() {
+    if (this.inTimer) {
+      clearTimeout(this.inTimer);
+    }
+    if (this.outTimer) {
+      clearTimeout(this.outTimer);
+    }
+    if (this.qTimer) {
+      clearInterval(this.qTimer);
+    }
+  }
+
+  /**
+   * Mark an ACK message sent to the fullnode.
+   */
+  ack(seq) {
+    this.ackCounter += 1;
+    this.logger.debug(`[*] ACKed ${seq} with queue at ${this.q.size()}. Sent ACK ${this.ackCounter} times`);
+  }
+
+  /**
+   * Mark that an item has been received by the queue.
+   * This also manages the inTimer, which calculates the rate of received items.
+   */
+  recv() {
+    if (!this.inTimer) {
+      this.inTimer = setTimeout(() => {
+        this.logger.debug(`[+] => in_rate: ${1000 * this.recvCounter / this.sampleInterval} items/s`);
+        this.inTimer = undefined;
+        this.recvCounter = -1;
+        this.recv();
+      }, this.sampleInterval);
+    }
+    this.recvCounter += 1;
+  }
+
+  /**
+   * Mark that an item has been processed from the queue.
+   * This also manages the outTimer, which calculates the rate of processed items.
+   */
+  proc() {
+    if (!this.outTimer) {
+      this.outTimer = setTimeout(() => {
+        this.logger.debug(`[+] <= out_rate: ${1000 * this.procCounter / this.sampleInterval} items/s`);
+        this.outTimer = undefined;
+        this.procCounter = -1;
+        this.proc();
+      }, this.sampleInterval);
+    }
+    this.procCounter += 1;
+  }
+
+  /**
+   * Mark that the queue processed all items ready.
+   * This will onlt log once out of every 100 calls to avoid verbosity.
+   */
+  queueEmpty() {
+    this.emptyCounter += 1;
+    if (this.emptyCounter % 100 === 0) {
+      this.logger.debug(`[-] queue has been empty ${this.emptyCounter} times`);
+    }
+  }
+}
+
+/**
+ * Load addresses in a CPU intensive way
+ * This only contemplates P2PKH addresses for now.
+ */
+function loadAddressesCPUIntensive(startIndex, count, xpubkey, networkName) {
+  const addresses = [];
+  const stopIndex = startIndex + count;
+  const network = new _network.default(networkName);
+  const hdpubkey = new _bitcoreLib.HDPublicKey(xpubkey);
+  for (let i = startIndex; i < stopIndex; i++) {
+    const key = hdpubkey.deriveChild(i);
+    addresses.push([i, new _bitcoreLib.Address(key.publicKey, network.bitcoreNetwork).toString()]);
+  }
+  return addresses;
+}
+function generateStreamId() {
+  return Math.random().toString(36).substring(2, 15);
+}
+async function xpubStreamSyncHistory(startIndex, _count, storage, connection, shouldProcessHistory = false) {
+  let firstIndex = startIndex;
+  const scanPolicyData = await storage.getScanningPolicyData();
+  if ((0, _types.isGapLimitScanPolicy)(scanPolicyData)) {
+    if (startIndex !== 0) {
+      const {
+        lastLoadedAddressIndex
+      } = await storage.getWalletData();
+      firstIndex = lastLoadedAddressIndex + 1;
+    }
+  }
+  const manager = new StreamManager(firstIndex, storage, connection, _types.HistorySyncMode.XPUB_STREAM_WS);
+  await streamSyncHistory(manager, shouldProcessHistory);
+}
+async function manualStreamSyncHistory(startIndex, _count, storage, connection, shouldProcessHistory = false) {
+  let firstIndex = startIndex;
+  const scanPolicyData = await storage.getScanningPolicyData();
+  if ((0, _types.isGapLimitScanPolicy)(scanPolicyData)) {
+    if (startIndex !== 0) {
+      const {
+        lastLoadedAddressIndex
+      } = await storage.getWalletData();
+      firstIndex = lastLoadedAddressIndex + 1;
+    }
+  }
+  const manager = new StreamManager(firstIndex, storage, connection, _types.HistorySyncMode.MANUAL_STREAM_WS);
+  await streamSyncHistory(manager, shouldProcessHistory);
+}
+
+/**
+ * The StreamManager extends the AbortController because it will be used to stop the stream.
+ * The abort signal will be used to:
+ * - Stop generating more addresses since the fullnode will not receive them.
+ * - Stop updating the UI with events of new addresses and transactions.
+ * - Stop processing new events from the fullnode.
+ * - Once aborted the `stream` event listener will be removed from the connection.
+ * - Resolve the promise when aborted.
+ */
+class StreamManager extends AbortController {
+  /**
+   * @param {number} startIndex Index to start loading addresses
+   * @param {IStorage} storage The storage to load the addresses
+   * @param {FullNodeConnection} connection Connection to the full node
+   * @param {HistorySyncMode} mode The mode of the stream
+   */
+  constructor(startIndex, storage, connection, mode) {
+    super();
+    _defineProperty(this, "streamId", void 0);
+    _defineProperty(this, "MAX_WINDOW_SIZE", 600);
+    _defineProperty(this, "ADDRESSES_PER_MESSAGE", 40);
+    _defineProperty(this, "UI_UPDATE_INTERVAL", 500);
+    _defineProperty(this, "storage", void 0);
+    _defineProperty(this, "connection", void 0);
+    _defineProperty(this, "xpubkey", void 0);
+    _defineProperty(this, "gapLimit", void 0);
+    _defineProperty(this, "network", void 0);
+    _defineProperty(this, "lastLoadedIndex", void 0);
+    _defineProperty(this, "lastReceivedIndex", void 0);
+    _defineProperty(this, "canUpdateUI", void 0);
+    _defineProperty(this, "foundAnyTx", void 0);
+    _defineProperty(this, "mode", void 0);
+    _defineProperty(this, "batchQueue", void 0);
+    _defineProperty(this, "itemQueue", void 0);
+    _defineProperty(this, "errorMessage", void 0);
+    _defineProperty(this, "logger", void 0);
+    _defineProperty(this, "isProcessingQueue", void 0);
+    _defineProperty(this, "lastAcked", void 0);
+    _defineProperty(this, "lastSeenSeq", void 0);
+    _defineProperty(this, "lastProcSeq", void 0);
+    _defineProperty(this, "hasReceivedEndStream", void 0);
+    _defineProperty(this, "stats", void 0);
+    this.streamId = generateStreamId();
+    this.storage = storage;
+    this.connection = connection;
+    this.xpubkey = '';
+    this.gapLimit = 0;
+    this.network = '';
+    this.lastLoadedIndex = startIndex - 1;
+    this.lastReceivedIndex = -1;
+    this.canUpdateUI = true;
+    this.mode = mode;
+    this.errorMessage = null;
+    this.foundAnyTx = false;
+    this.lastAcked = -1;
+    this.lastSeenSeq = -1;
+    this.lastProcSeq = -1;
+    this.hasReceivedEndStream = false;
+    this.batchQueue = Promise.resolve();
+    this.logger = storage.logger;
+    this.itemQueue = new _queue.default();
+    this.isProcessingQueue = false;
+    this.stats = new StreamStatsManager(this.itemQueue, this.logger);
+  }
+
+  /**
+   * Make initial preparations and lock the stream on the connection.
+   */
+  async setupStream() {
+    if (![_types.HistorySyncMode.MANUAL_STREAM_WS, _types.HistorySyncMode.XPUB_STREAM_WS].includes(this.mode)) {
+      throw new Error(`Unsupported stream mode ${this.mode}`);
+    }
+    const accessData = await this.storage.getAccessData();
+    if (accessData === null) {
+      throw new Error('No access data');
+    }
+    const {
+      xpubkey
+    } = accessData;
+    // Should not throw here since we only support gapLimit wallets
+    const gapLimit = await this.storage.getGapLimit();
+    this.xpubkey = xpubkey;
+    this.gapLimit = gapLimit;
+    this.network = this.storage.config.getNetwork().name;
+
+    // Make sure this is the only stream running on this connection
+    if (!this.connection.lockStream(this.streamId)) {
+      throw new Error('There is an on-going stream on this connection');
+    }
+
+    // If the abort controller of the connection aborts we need to abort the stream
+    const signal = this.connection.streamController?.signal;
+    if (!signal) {
+      // Should not happen, but will cleanup just in case.
+      this.connection.streamEndHandler();
+      throw new Error('No abort controller on connection');
+    }
+    signal.addEventListener('abort', () => {
+      this.abortWithError('Stream aborted');
+    }, {
+      once: true,
+      signal: this.signal
+    });
+  }
+
+  /**
+   * Abort the stream with an error.
+   */
+  abortWithError(error) {
+    this.errorMessage = error;
+    this.abort();
+  }
+
+  /**
+   * Generate the next batch of addresses to send to the fullnode.
+   * The batch will generate `ADDRESSES_PER_MESSAGE` addresses and send them to the fullnode.
+   * It will run again until the fullnode has `MAX_WINDOW_SIZE` addresses on its end.
+   * This is calculated by the distance between the highest index we sent to the fullnode minus the highest index we received from the fullnode.
+   * This is only used for manual streams.
+   */
+  generateNextBatch() {
+    this.batchQueue = this.batchQueue.then(async () => {
+      if (this.signal.aborted || this.hasReceivedEndStream || this.mode !== _types.HistorySyncMode.MANUAL_STREAM_WS) {
+        return;
+      }
+      const distance = this.lastLoadedIndex - this.lastReceivedIndex;
+      if (distance > this.MAX_WINDOW_SIZE - this.ADDRESSES_PER_MESSAGE) {
+        return;
+      }
+
+      // This part is sync so that we block the main loop during the generation of the batch
+      const batch = loadAddressesCPUIntensive(this.lastLoadedIndex + 1, this.ADDRESSES_PER_MESSAGE, this.xpubkey, this.network);
+      this.lastLoadedIndex += this.ADDRESSES_PER_MESSAGE;
+      this.connection.sendManualStreamingHistory(this.streamId, this.lastLoadedIndex + 1, batch, false, this.gapLimit);
+
+      // Free main loop to run other tasks and queue next batch
+      setTimeout(() => {
+        this.generateNextBatch();
+      }, 0);
+    });
+  }
+
+  /**
+   * This controls the ACK strategy.
+   * @returns {boolean} if we should send an ack message to the server.
+   */
+  shouldACK() {
+    if (!this.connection.streamWindowSize) {
+      // Window size is not configured so we should not ack.
+      return false;
+    }
+    const minSize = this.connection.streamWindowSize / 2;
+    return !this.hasReceivedEndStream && !this.signal.aborted && this.lastSeenSeq - this.lastAcked > minSize && this.lastProcSeq - this.lastAcked > minSize && this.itemQueue.size() <= minSize;
+  }
+
+  /**
+   * Ack the stream messages.
+   */
+  ack() {
+    if (!this.shouldACK()) {
+      return;
+    }
+
+    // Send the ACK for the end of the queue
+    this.lastAcked = this.lastSeenSeq;
+    this.stats.ack(this.lastSeenSeq);
+    this.connection.sendStreamHistoryAck(this.streamId, this.lastSeenSeq);
+  }
+  isQueueDone() {
+    // Must not be processing the queue and the queue must be empty
+    return !(this.isProcessingQueue && this.itemQueue.size() !== 0);
+  }
+  async processQueue() {
+    if (this.isProcessingQueue) {
+      return;
+    }
+    this.isProcessingQueue = true;
+    while (true) {
+      if (this.signal.aborted) {
+        // Abort processing the queue
+        break;
+      }
+      const item = this.itemQueue.dequeue();
+      this.ack();
+      if (!item) {
+        // Queue is empty
+        this.stats.queueEmpty();
+        break;
+      }
+      this.lastProcSeq = item.seq;
+      if (isStreamItemAddress(item)) {
+        const addr = item.address;
+        const alreadyExists = await this.storage.isAddressMine(addr.base58);
+        if (!alreadyExists) {
+          await this.storage.saveAddress(addr);
+        }
+      } else if (isStreamItemVertex(item)) {
+        await this.storage.addTx(item.vertex);
+      }
+      this.stats.proc();
+
+      /**
+       * This promise will resolve after the JS task queue current run.
+       * This means that we will free IO tasks like receiving events from the WS
+       * and other async code to run before we continue processing our event queue.
+       * @see https://www.npmjs.com/package/queue-microtask
+       */
+      await new Promise(resolve => {
+        (0, _queueMicrotask.default)(resolve);
+      });
+    }
+    this.isProcessingQueue = false;
+  }
+  addTx(seq, tx) {
+    this.stats.recv();
+    this.foundAnyTx = true;
+    this.lastSeenSeq = seq;
+    this.itemQueue.enqueue({
+      seq,
+      vertex: tx,
+      type: 'vertex'
+    });
+    this.processQueue();
+  }
+  addAddress(seq, index, address) {
+    this.stats.recv();
+    if (index > this.lastReceivedIndex) {
+      this.lastReceivedIndex = index;
+    }
+    this.lastSeenSeq = seq;
+    this.itemQueue.enqueue({
+      seq,
+      type: 'address',
+      address: {
+        base58: address,
+        bip32AddressIndex: index
+      }
+    });
+    this.processQueue();
+  }
+
+  /**
+   * Send event to update UI.
+   * This should be throttled to avoid flooding the UI with events.
+   * The UI will be updated in intervals of at least `UI_UPDATE_INTERVAL`.
+   */
+  updateUI() {
+    // Queue the UI update to run after we process the event that
+    // generated this update.
+    if (this.signal.aborted) {
+      return;
+    }
+    if (this.canUpdateUI) {
+      this.canUpdateUI = false;
+      (async () => {
+        this.connection.emit('wallet-load-partial-update', {
+          addressesFound: await this.storage.store.addressCount(),
+          historyLength: await this.storage.store.historyCount()
+        });
+      })();
+      setTimeout(() => {
+        this.canUpdateUI = true;
+      }, this.UI_UPDATE_INTERVAL);
+    }
+  }
+  sendStartMessage() {
+    switch (this.mode) {
+      case _types.HistorySyncMode.XPUB_STREAM_WS:
+        this.connection.sendStartXPubStreamingHistory(this.streamId, this.lastLoadedIndex + 1, this.xpubkey, this.gapLimit);
+        break;
+      case _types.HistorySyncMode.MANUAL_STREAM_WS:
+        this.connection.sendManualStreamingHistory(this.streamId, this.lastLoadedIndex + 1, loadAddressesCPUIntensive(this.lastLoadedIndex + 1, this.ADDRESSES_PER_MESSAGE, this.xpubkey, this.network), true, this.gapLimit);
+        this.lastLoadedIndex += this.ADDRESSES_PER_MESSAGE;
+        break;
+      default:
+        // Should never happen.
+        this.abortWithError('Unknown stream mode');
+        break;
+    }
+  }
+  endStream(seq) {
+    this.logger.debug('Received end-of-stream event.');
+    this.hasReceivedEndStream = true;
+    this.connection.sendStreamHistoryAck(this.streamId, seq);
+  }
+  async shutdown() {
+    await this.batchQueue;
+    await this.processQueue();
+    if (this.isProcessingQueue) {
+      let shutdownTimedout = false;
+      // Limit wait period as to not wait forever
+      const timer = setTimeout(() => {
+        this.logger.error(`Stream shutdown reached ${QUEUE_GRACEFUL_SHUTDOWN_LIMIT}ms limit`);
+        this.errorMessage = `Stream could not gracefully shutdown due to timeout.`;
+        shutdownTimedout = true;
+      }, QUEUE_GRACEFUL_SHUTDOWN_LIMIT);
+
+      // Check every 0.1s
+      while (this.isProcessingQueue) {
+        if (shutdownTimedout) {
+          break;
+        }
+        await new Promise(resolve => {
+          setTimeout(resolve, 100);
+        });
+      }
+      // Clear timer to avoid unnecessary error
+      if (!shutdownTimedout) {
+        clearTimeout(timer);
+      }
+    }
+    this.stats.clean();
+    if (this.errorMessage) {
+      throw new Error(this.errorMessage);
+    }
+  }
+}
+exports.StreamManager = StreamManager;
+function buildListener(manager, resolve) {
+  return wsData => {
+    // Early return if the stream is aborted
+    // This will prevent any tx or address from being added when we want to stop the stream.
+    if (manager.signal.aborted) {
+      return;
+    }
+    // Only process the message if it is from our stream, this error should not happen.
+    if (wsData.id !== manager.streamId) {
+      // Check that the stream id is the same we sent
+      manager.logger.error(`Received stream event for id ${wsData.id} while expecting ${manager.streamId}`);
+      return;
+    }
+    if (isStreamSyncHistoryBegin(wsData)) {
+      manager.logger.info('Begin stream event received.');
+    } else if (isStreamSyncHistoryVertex(wsData)) {
+      // Vertex is a transaction in the history of the last address received
+      // foundAnyTx = true;
+      // add to history
+      const vertex = _schemas.IHistoryTxSchema.parse(wsData.data);
+      manager.addTx(wsData.seq, vertex);
+      manager.updateUI();
+    } else if (isStreamSyncHistoryAddress(wsData)) {
+      manager.addAddress(wsData.seq, wsData.index, wsData.address);
+      manager.updateUI();
+      manager.generateNextBatch();
+    } else if (isStreamSyncHistoryEnd(wsData)) {
+      // cleanup and stop the method.
+      manager.endStream(wsData.seq);
+      resolve();
+    } else if (isStreamSyncHistoryError(wsData)) {
+      // An error happened on the fullnode, we should stop the stream
+      manager.logger.error(`Stream error: ${wsData.errmsg}`);
+      manager.abortWithError(wsData.errmsg);
+    } else {
+      manager.logger.error(`Unknown event type ${JSON.stringify(wsData)}`);
+    }
+  };
+}
+
+/**
+ * Start a stream to sync the history of the wallet on `storage`.
+ * Since there is a lot of overlap between xpub and manual modes this method was created to accomodate both.
+ * @param {StreamManager} manager stream manager instance.
+ * @param {boolean} shouldProcessHistory If we should process the history after loading it.
+ * @returns {Promise<void>}
+ */
+async function streamSyncHistory(manager, shouldProcessHistory) {
+  await manager.setupStream();
+
+  // This is a try..finally so that we can always call the signal abort function
+  // This is meant to prevent memory leaks
+  try {
+    /**
+     * The promise will resolve when either:
+     * - The stream is done.
+     * - The stream is aborted.
+     * - An error happens in the fullnode.
+     */
+    await new Promise(resolve => {
+      // If the manager aborts we need to resolve and exit the promise.
+      manager.signal.addEventListener('abort', () => {
+        resolve();
+      }, {
+        once: true
+      });
+      // If it is already aborted for some reason, just exit
+      if (manager.signal.aborted) {
+        resolve();
+      }
+
+      // Start listening for stream events
+      const listener = buildListener(manager, resolve);
+      manager.connection.on('stream', listener);
+      // Cleanup the listener when the manager aborts
+      manager.signal.addEventListener('abort', () => {
+        manager.connection.removeListener('stream', listener);
+      }, {
+        once: true
+      });
+
+      // Send the start message to the fullnode
+      manager.sendStartMessage();
+    });
+
+    // Graceful shutdown and cleanup.
+    await manager.shutdown();
+    if (manager.foundAnyTx && shouldProcessHistory) {
+      await manager.storage.processHistory();
+    }
+  } finally {
+    // Always abort on finally to avoid memory leaks
+    manager.abort();
+    manager.connection.emit('stream-end');
+  }
+}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/template/transaction/builder.d.ts b/node_modules/@hathor/wallet-lib/oldLib/template/transaction/builder.d.ts
new file mode 100644
index 0000000..c89ca63
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/template/transaction/builder.d.ts
@@ -0,0 +1,502 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+import { z } from 'zod';
+import { TxTemplateInstruction, TransactionTemplate } from './instructions';
+declare const RawInputInsArgs: z.ZodObject<Omit<{
+    type: z.ZodLiteral<"input/raw">;
+    position: z.ZodDefault<z.ZodNumber>;
+    index: z.ZodUnion<[z.ZodString, z.ZodPipeline<z.ZodUnion<[z.ZodNumber, z.ZodString]>, z.ZodNumber>]>;
+    txId: z.ZodUnion<[z.ZodString, z.ZodString]>;
+}, "type">, "strip", z.ZodTypeAny, {
+    index: string | number;
+    position: number;
+    txId: string;
+}, {
+    index: string | number;
+    txId: string;
+    position?: number | undefined;
+}>;
+declare const UtxoSelectInsArgs: z.ZodObject<Omit<{
+    type: z.ZodLiteral<"input/utxo">;
+    position: z.ZodDefault<z.ZodNumber>;
+    fill: z.ZodUnion<[z.ZodString, z.ZodEffects<z.ZodPipeline<z.ZodUnion<[z.ZodBigInt, z.ZodNumber, z.ZodString]>, z.ZodBigInt>, bigint, string | number | bigint>]>;
+    token: z.ZodUnion<[z.ZodString, z.ZodDefault<z.ZodString>]>;
+    address: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+    autoChange: z.ZodDefault<z.ZodBoolean>;
+    changeAddress: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+}, "type">, "strip", z.ZodTypeAny, {
+    fill: string | bigint;
+    position: number;
+    token: string;
+    autoChange: boolean;
+    address?: string | undefined;
+    changeAddress?: string | undefined;
+}, {
+    fill: string | number | bigint;
+    address?: string | undefined;
+    position?: number | undefined;
+    token?: string | undefined;
+    changeAddress?: string | undefined;
+    autoChange?: boolean | undefined;
+}>;
+declare const AuthoritySelectInsArgs: z.ZodObject<Omit<{
+    type: z.ZodLiteral<"input/authority">;
+    position: z.ZodDefault<z.ZodNumber>;
+    authority: z.ZodEnum<["mint", "melt"]>;
+    token: z.ZodUnion<[z.ZodString, z.ZodString]>;
+    count: z.ZodUnion<[z.ZodString, z.ZodDefault<z.ZodPipeline<z.ZodUnion<[z.ZodNumber, z.ZodString]>, z.ZodNumber>>]>;
+    address: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+}, "type">, "strip", z.ZodTypeAny, {
+    position: number;
+    token: string;
+    count: string | number;
+    authority: "mint" | "melt";
+    address?: string | undefined;
+}, {
+    token: string;
+    authority: "mint" | "melt";
+    address?: string | undefined;
+    position?: number | undefined;
+    count?: string | number | undefined;
+}>;
+declare const RawOutputInsArgs: z.ZodObject<Omit<{
+    type: z.ZodLiteral<"output/raw">;
+    position: z.ZodDefault<z.ZodNumber>;
+    amount: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodEffects<z.ZodPipeline<z.ZodUnion<[z.ZodBigInt, z.ZodNumber, z.ZodString]>, z.ZodBigInt>, bigint, string | number | bigint>>]>;
+    script: z.ZodUnion<[z.ZodString, z.ZodString]>;
+    token: z.ZodUnion<[z.ZodString, z.ZodDefault<z.ZodString>]>;
+    timelock: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodNumber>]>;
+    authority: z.ZodOptional<z.ZodEnum<["mint", "melt"]>>;
+    useCreatedToken: z.ZodDefault<z.ZodBoolean>;
+}, "type">, "strip", z.ZodTypeAny, {
+    position: number;
+    script: string;
+    token: string;
+    useCreatedToken: boolean;
+    timelock?: string | number | undefined;
+    amount?: string | bigint | undefined;
+    authority?: "mint" | "melt" | undefined;
+}, {
+    script: string;
+    position?: number | undefined;
+    timelock?: string | number | undefined;
+    token?: string | undefined;
+    amount?: string | number | bigint | undefined;
+    authority?: "mint" | "melt" | undefined;
+    useCreatedToken?: boolean | undefined;
+}>;
+declare const DataOutputInsArgs: z.ZodObject<Omit<{
+    type: z.ZodLiteral<"output/data">;
+    position: z.ZodDefault<z.ZodNumber>;
+    data: z.ZodUnion<[z.ZodString, z.ZodString]>;
+    token: z.ZodUnion<[z.ZodString, z.ZodDefault<z.ZodString>]>;
+    useCreatedToken: z.ZodDefault<z.ZodBoolean>;
+}, "type">, "strip", z.ZodTypeAny, {
+    data: string;
+    position: number;
+    token: string;
+    useCreatedToken: boolean;
+}, {
+    data: string;
+    position?: number | undefined;
+    token?: string | undefined;
+    useCreatedToken?: boolean | undefined;
+}>;
+declare const TokenOutputInsArgs: z.ZodObject<Omit<{
+    type: z.ZodLiteral<"output/token">;
+    position: z.ZodDefault<z.ZodNumber>;
+    amount: z.ZodUnion<[z.ZodString, z.ZodEffects<z.ZodPipeline<z.ZodUnion<[z.ZodBigInt, z.ZodNumber, z.ZodString]>, z.ZodBigInt>, bigint, string | number | bigint>]>;
+    token: z.ZodUnion<[z.ZodString, z.ZodDefault<z.ZodString>]>;
+    address: z.ZodUnion<[z.ZodString, z.ZodString]>;
+    timelock: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodNumber>]>;
+    checkAddress: z.ZodOptional<z.ZodBoolean>;
+    useCreatedToken: z.ZodDefault<z.ZodBoolean>;
+}, "type">, "strip", z.ZodTypeAny, {
+    address: string;
+    position: number;
+    token: string;
+    amount: string | bigint;
+    useCreatedToken: boolean;
+    timelock?: string | number | undefined;
+    checkAddress?: boolean | undefined;
+}, {
+    address: string;
+    amount: string | number | bigint;
+    position?: number | undefined;
+    timelock?: string | number | undefined;
+    token?: string | undefined;
+    useCreatedToken?: boolean | undefined;
+    checkAddress?: boolean | undefined;
+}>;
+declare const AuthorityOutputInsArgs: z.ZodObject<Omit<{
+    type: z.ZodLiteral<"output/authority">;
+    position: z.ZodDefault<z.ZodNumber>;
+    count: z.ZodUnion<[z.ZodString, z.ZodDefault<z.ZodPipeline<z.ZodUnion<[z.ZodNumber, z.ZodString]>, z.ZodNumber>>]>;
+    token: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+    authority: z.ZodEnum<["mint", "melt"]>;
+    address: z.ZodUnion<[z.ZodString, z.ZodString]>;
+    timelock: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodNumber>]>;
+    checkAddress: z.ZodOptional<z.ZodBoolean>;
+    useCreatedToken: z.ZodDefault<z.ZodBoolean>;
+}, "type">, "strip", z.ZodTypeAny, {
+    address: string;
+    position: number;
+    count: string | number;
+    authority: "mint" | "melt";
+    useCreatedToken: boolean;
+    timelock?: string | number | undefined;
+    token?: string | undefined;
+    checkAddress?: boolean | undefined;
+}, {
+    address: string;
+    authority: "mint" | "melt";
+    position?: number | undefined;
+    timelock?: string | number | undefined;
+    token?: string | undefined;
+    count?: string | number | undefined;
+    useCreatedToken?: boolean | undefined;
+    checkAddress?: boolean | undefined;
+}>;
+declare const ShuffleInsArgs: z.ZodObject<Omit<{
+    type: z.ZodLiteral<"action/shuffle">;
+    target: z.ZodEnum<["inputs", "outputs", "all"]>;
+}, "type">, "strip", z.ZodTypeAny, {
+    target: "all" | "inputs" | "outputs";
+}, {
+    target: "all" | "inputs" | "outputs";
+}>;
+declare const CompleteTxInsArgs: z.ZodObject<Omit<{
+    type: z.ZodLiteral<"action/complete">;
+    token: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+    address: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+    changeAddress: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+    timelock: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodNumber>]>;
+    skipSelection: z.ZodDefault<z.ZodBoolean>;
+    skipChange: z.ZodDefault<z.ZodBoolean>;
+    skipAuthorities: z.ZodDefault<z.ZodBoolean>;
+    calculateFee: z.ZodDefault<z.ZodBoolean>;
+}, "type">, "strip", z.ZodTypeAny, {
+    skipAuthorities: boolean;
+    skipSelection: boolean;
+    skipChange: boolean;
+    calculateFee: boolean;
+    address?: string | undefined;
+    timelock?: string | number | undefined;
+    token?: string | undefined;
+    changeAddress?: string | undefined;
+}, {
+    address?: string | undefined;
+    timelock?: string | number | undefined;
+    token?: string | undefined;
+    changeAddress?: string | undefined;
+    skipAuthorities?: boolean | undefined;
+    skipSelection?: boolean | undefined;
+    skipChange?: boolean | undefined;
+    calculateFee?: boolean | undefined;
+}>;
+declare const ConfigInsArgs: z.ZodObject<Omit<{
+    type: z.ZodLiteral<"action/config">;
+    version: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodNumber>]>;
+    signalBits: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodNumber>]>;
+    createToken: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodBoolean>]>;
+    tokenName: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+    tokenSymbol: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+}, "type">, "strip", z.ZodTypeAny, {
+    signalBits?: string | number | undefined;
+    version?: string | number | undefined;
+    tokenName?: string | undefined;
+    tokenSymbol?: string | undefined;
+    createToken?: string | boolean | undefined;
+}, {
+    signalBits?: string | number | undefined;
+    version?: string | number | undefined;
+    tokenName?: string | undefined;
+    tokenSymbol?: string | undefined;
+    createToken?: string | boolean | undefined;
+}>;
+declare const SetVarInsArgs: z.ZodObject<Omit<{
+    type: z.ZodLiteral<"action/setvar">;
+    name: z.ZodString;
+    value: z.ZodOptional<z.ZodUnknown>;
+    call: z.ZodOptional<z.ZodDiscriminatedUnion<"method", [z.ZodObject<{
+        method: z.ZodLiteral<"get_wallet_address">;
+        index: z.ZodOptional<z.ZodNumber>;
+    }, "strip", z.ZodTypeAny, {
+        method: "get_wallet_address";
+        index?: number | undefined;
+    }, {
+        method: "get_wallet_address";
+        index?: number | undefined;
+    }>, z.ZodObject<{
+        method: z.ZodLiteral<"get_wallet_balance">;
+        token: z.ZodUnion<[z.ZodString, z.ZodDefault<z.ZodString>]>;
+        authority: z.ZodOptional<z.ZodEnum<["mint", "melt"]>>;
+    }, "strip", z.ZodTypeAny, {
+        method: "get_wallet_balance";
+        token: string;
+        authority?: "mint" | "melt" | undefined;
+    }, {
+        method: "get_wallet_balance";
+        token?: string | undefined;
+        authority?: "mint" | "melt" | undefined;
+    }>, z.ZodObject<{
+        method: z.ZodLiteral<"get_oracle_script">;
+        index: z.ZodNumber;
+    }, "strip", z.ZodTypeAny, {
+        index: number;
+        method: "get_oracle_script";
+    }, {
+        index: number;
+        method: "get_oracle_script";
+    }>, z.ZodObject<{
+        method: z.ZodLiteral<"get_oracle_signed_data">;
+        index: z.ZodNumber;
+        type: z.ZodString;
+        data: z.ZodUnion<[z.ZodString, z.ZodUnknown]>;
+        ncId: z.ZodUnion<[z.ZodString, z.ZodString]>;
+    }, "strip", z.ZodTypeAny, {
+        index: number;
+        type: string;
+        method: "get_oracle_signed_data";
+        ncId: string;
+        data?: unknown;
+    }, {
+        index: number;
+        type: string;
+        method: "get_oracle_signed_data";
+        ncId: string;
+        data?: unknown;
+    }>]>>;
+}, "type">, "strip", z.ZodTypeAny, {
+    name: string;
+    value?: unknown;
+    call?: {
+        method: "get_wallet_address";
+        index?: number | undefined;
+    } | {
+        index: number;
+        method: "get_oracle_script";
+    } | {
+        index: number;
+        type: string;
+        method: "get_oracle_signed_data";
+        ncId: string;
+        data?: unknown;
+    } | {
+        method: "get_wallet_balance";
+        token: string;
+        authority?: "mint" | "melt" | undefined;
+    } | undefined;
+}, {
+    name: string;
+    value?: unknown;
+    call?: {
+        method: "get_wallet_address";
+        index?: number | undefined;
+    } | {
+        index: number;
+        method: "get_oracle_script";
+    } | {
+        index: number;
+        type: string;
+        method: "get_oracle_signed_data";
+        ncId: string;
+        data?: unknown;
+    } | {
+        method: "get_wallet_balance";
+        token?: string | undefined;
+        authority?: "mint" | "melt" | undefined;
+    } | undefined;
+}>;
+declare const NanoMethodInsArgs: z.ZodObject<Omit<{
+    type: z.ZodLiteral<"nano/execute">;
+    id: z.ZodUnion<[z.ZodString, z.ZodString]>;
+    method: z.ZodString;
+    args: z.ZodDefault<z.ZodArray<z.ZodUnion<[z.ZodString, z.ZodUnknown]>, "many">>;
+    caller: z.ZodUnion<[z.ZodString, z.ZodString]>;
+    actions: z.ZodDefault<z.ZodArray<z.ZodUnion<[z.ZodObject<{
+        action: z.ZodLiteral<"deposit">;
+        token: z.ZodUnion<[z.ZodString, z.ZodDefault<z.ZodString>]>;
+        useCreatedToken: z.ZodDefault<z.ZodBoolean>;
+        amount: z.ZodUnion<[z.ZodString, z.ZodEffects<z.ZodPipeline<z.ZodUnion<[z.ZodBigInt, z.ZodNumber, z.ZodString]>, z.ZodBigInt>, bigint, string | number | bigint>]>;
+        address: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+        autoChange: z.ZodDefault<z.ZodBoolean>;
+        changeAddress: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+        skipSelection: z.ZodDefault<z.ZodBoolean>;
+    }, "strip", z.ZodTypeAny, {
+        action: "deposit";
+        token: string;
+        amount: string | bigint;
+        autoChange: boolean;
+        useCreatedToken: boolean;
+        skipSelection: boolean;
+        address?: string | undefined;
+        changeAddress?: string | undefined;
+    }, {
+        action: "deposit";
+        amount: string | number | bigint;
+        address?: string | undefined;
+        token?: string | undefined;
+        changeAddress?: string | undefined;
+        autoChange?: boolean | undefined;
+        useCreatedToken?: boolean | undefined;
+        skipSelection?: boolean | undefined;
+    }>, z.ZodObject<{
+        action: z.ZodLiteral<"withdrawal">;
+        token: z.ZodUnion<[z.ZodString, z.ZodDefault<z.ZodString>]>;
+        amount: z.ZodUnion<[z.ZodString, z.ZodEffects<z.ZodPipeline<z.ZodUnion<[z.ZodBigInt, z.ZodNumber, z.ZodString]>, z.ZodBigInt>, bigint, string | number | bigint>]>;
+        address: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+        skipOutputs: z.ZodDefault<z.ZodBoolean>;
+    }, "strip", z.ZodTypeAny, {
+        action: "withdrawal";
+        token: string;
+        amount: string | bigint;
+        skipOutputs: boolean;
+        address?: string | undefined;
+    }, {
+        action: "withdrawal";
+        amount: string | number | bigint;
+        address?: string | undefined;
+        token?: string | undefined;
+        skipOutputs?: boolean | undefined;
+    }>, z.ZodObject<{
+        action: z.ZodLiteral<"grant_authority">;
+        token: z.ZodUnion<[z.ZodString, z.ZodString]>;
+        useCreatedToken: z.ZodDefault<z.ZodBoolean>;
+        authority: z.ZodEnum<["mint", "melt"]>;
+        address: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+        createAnotherTo: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+        skipSelection: z.ZodDefault<z.ZodBoolean>;
+    }, "strip", z.ZodTypeAny, {
+        action: "grant_authority";
+        token: string;
+        authority: "mint" | "melt";
+        useCreatedToken: boolean;
+        skipSelection: boolean;
+        address?: string | undefined;
+        createAnotherTo?: string | undefined;
+    }, {
+        action: "grant_authority";
+        token: string;
+        authority: "mint" | "melt";
+        address?: string | undefined;
+        useCreatedToken?: boolean | undefined;
+        skipSelection?: boolean | undefined;
+        createAnotherTo?: string | undefined;
+    }>, z.ZodObject<{
+        action: z.ZodLiteral<"acquire_authority">;
+        token: z.ZodUnion<[z.ZodString, z.ZodString]>;
+        authority: z.ZodEnum<["mint", "melt"]>;
+        address: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+        skipOutputs: z.ZodDefault<z.ZodBoolean>;
+    }, "strip", z.ZodTypeAny, {
+        action: "acquire_authority";
+        token: string;
+        authority: "mint" | "melt";
+        skipOutputs: boolean;
+        address?: string | undefined;
+    }, {
+        action: "acquire_authority";
+        token: string;
+        authority: "mint" | "melt";
+        address?: string | undefined;
+        skipOutputs?: boolean | undefined;
+    }>]>, "many">>;
+}, "type">, "strip", z.ZodTypeAny, {
+    id: string;
+    method: string;
+    args: unknown[];
+    actions: ({
+        action: "deposit";
+        token: string;
+        amount: string | bigint;
+        autoChange: boolean;
+        useCreatedToken: boolean;
+        skipSelection: boolean;
+        address?: string | undefined;
+        changeAddress?: string | undefined;
+    } | {
+        action: "withdrawal";
+        token: string;
+        amount: string | bigint;
+        skipOutputs: boolean;
+        address?: string | undefined;
+    } | {
+        action: "grant_authority";
+        token: string;
+        authority: "mint" | "melt";
+        useCreatedToken: boolean;
+        skipSelection: boolean;
+        address?: string | undefined;
+        createAnotherTo?: string | undefined;
+    } | {
+        action: "acquire_authority";
+        token: string;
+        authority: "mint" | "melt";
+        skipOutputs: boolean;
+        address?: string | undefined;
+    })[];
+    caller: string;
+}, {
+    id: string;
+    method: string;
+    caller: string;
+    args?: unknown[] | undefined;
+    actions?: ({
+        action: "deposit";
+        amount: string | number | bigint;
+        address?: string | undefined;
+        token?: string | undefined;
+        changeAddress?: string | undefined;
+        autoChange?: boolean | undefined;
+        useCreatedToken?: boolean | undefined;
+        skipSelection?: boolean | undefined;
+    } | {
+        action: "withdrawal";
+        amount: string | number | bigint;
+        address?: string | undefined;
+        token?: string | undefined;
+        skipOutputs?: boolean | undefined;
+    } | {
+        action: "grant_authority";
+        token: string;
+        authority: "mint" | "melt";
+        address?: string | undefined;
+        useCreatedToken?: boolean | undefined;
+        skipSelection?: boolean | undefined;
+        createAnotherTo?: string | undefined;
+    } | {
+        action: "acquire_authority";
+        token: string;
+        authority: "mint" | "melt";
+        address?: string | undefined;
+        skipOutputs?: boolean | undefined;
+    })[] | undefined;
+}>;
+export declare class TransactionTemplateBuilder {
+    template: z.infer<typeof TransactionTemplate>;
+    constructor();
+    static new(): TransactionTemplateBuilder;
+    static from(instructions: z.input<typeof TransactionTemplate>): TransactionTemplateBuilder;
+    build(): z.infer<typeof TransactionTemplate>;
+    export(space?: number): string;
+    addInstruction(ins: z.input<typeof TxTemplateInstruction>): TransactionTemplateBuilder;
+    addRawInput(ins: z.input<typeof RawInputInsArgs>): this;
+    addUtxoSelect(ins: z.input<typeof UtxoSelectInsArgs>): this;
+    addAuthoritySelect(ins: z.input<typeof AuthoritySelectInsArgs>): this;
+    addRawOutput(ins: z.input<typeof RawOutputInsArgs>): this;
+    addDataOutput(ins: z.input<typeof DataOutputInsArgs>): this;
+    addTokenOutput(ins: z.input<typeof TokenOutputInsArgs>): this;
+    addAuthorityOutput(ins: z.input<typeof AuthorityOutputInsArgs>): this;
+    addShuffleAction(ins: z.input<typeof ShuffleInsArgs>): this;
+    addCompleteAction(ins: z.input<typeof CompleteTxInsArgs>): this;
+    addConfigAction(ins: z.input<typeof ConfigInsArgs>): this;
+    addSetVarAction(ins: z.input<typeof SetVarInsArgs>): this;
+    addNanoMethodExecution(ins: z.input<typeof NanoMethodInsArgs>): this;
+}
+export {};
+//# sourceMappingURL=builder.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/template/transaction/builder.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/template/transaction/builder.d.ts.map
new file mode 100644
index 0000000..4f7a73d
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/template/transaction/builder.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"builder.d.ts","sourceRoot":"","sources":["../../../src/template/transaction/builder.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/template/transaction/builder.js b/node_modules/@hathor/wallet-lib/oldLib/template/transaction/builder.js
new file mode 100644
index 0000000..99f8ae4
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/template/transaction/builder.js
@@ -0,0 +1,175 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.TransactionTemplateBuilder = void 0;
+var _bigint = require("../../utils/bigint");
+var _instructions = require("./instructions");
+function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
+function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
+function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+// Helper schemas to validate the arguments of each command in the builder args
+const RawInputInsArgs = _instructions.RawInputInstruction.omit({
+  type: true
+});
+const UtxoSelectInsArgs = _instructions.UtxoSelectInstruction.omit({
+  type: true
+});
+const AuthoritySelectInsArgs = _instructions.AuthoritySelectInstruction.omit({
+  type: true
+});
+const RawOutputInsArgs = _instructions.RawOutputInstruction.omit({
+  type: true
+});
+const DataOutputInsArgs = _instructions.DataOutputInstruction.omit({
+  type: true
+});
+const TokenOutputInsArgs = _instructions.TokenOutputInstruction.omit({
+  type: true
+});
+const AuthorityOutputInsArgs = _instructions.AuthorityOutputInstruction.omit({
+  type: true
+});
+const ShuffleInsArgs = _instructions.ShuffleInstruction.omit({
+  type: true
+});
+const CompleteTxInsArgs = _instructions.CompleteTxInstruction.omit({
+  type: true
+});
+const ConfigInsArgs = _instructions.ConfigInstruction.omit({
+  type: true
+});
+const SetVarInsArgs = _instructions.SetVarInstruction.omit({
+  type: true
+});
+const NanoMethodInsArgs = _instructions.NanoMethodInstruction.omit({
+  type: true
+});
+class TransactionTemplateBuilder {
+  constructor() {
+    _defineProperty(this, "template", void 0);
+    this.template = [];
+  }
+  static new() {
+    return new TransactionTemplateBuilder();
+  }
+  static from(instructions) {
+    const parsedTemplate = _instructions.TransactionTemplate.parse(instructions);
+    const tt = new TransactionTemplateBuilder();
+    tt.template = parsedTemplate;
+    return tt;
+  }
+  build() {
+    return this.template;
+  }
+  export(space = 2) {
+    return _bigint.JSONBigInt.stringify(this.template, space);
+  }
+  addInstruction(ins) {
+    this.template.push(_instructions.TxTemplateInstruction.parse(ins));
+    return this;
+  }
+  addRawInput(ins) {
+    const parsedIns = _instructions.RawInputInstruction.parse({
+      type: 'input/raw',
+      ...ins
+    });
+    this.template.push(parsedIns);
+    return this;
+  }
+  addUtxoSelect(ins) {
+    const parsedIns = _instructions.UtxoSelectInstruction.parse({
+      type: 'input/utxo',
+      ...ins
+    });
+    this.template.push(parsedIns);
+    return this;
+  }
+  addAuthoritySelect(ins) {
+    const parsedIns = _instructions.AuthoritySelectInstruction.parse({
+      type: 'input/authority',
+      ...ins
+    });
+    this.template.push(parsedIns);
+    return this;
+  }
+  addRawOutput(ins) {
+    const parsedIns = _instructions.RawOutputInstruction.parse({
+      type: 'output/raw',
+      ...ins
+    });
+    this.template.push(parsedIns);
+    return this;
+  }
+  addDataOutput(ins) {
+    const parsedIns = _instructions.DataOutputInstruction.parse({
+      type: 'output/data',
+      ...ins
+    });
+    this.template.push(parsedIns);
+    return this;
+  }
+  addTokenOutput(ins) {
+    const parsedIns = _instructions.TokenOutputInstruction.parse({
+      type: 'output/token',
+      ...ins
+    });
+    this.template.push(parsedIns);
+    return this;
+  }
+  addAuthorityOutput(ins) {
+    const parsedIns = _instructions.AuthorityOutputInstruction.parse({
+      type: 'output/authority',
+      ...ins
+    });
+    this.template.push(parsedIns);
+    return this;
+  }
+  addShuffleAction(ins) {
+    const parsedIns = _instructions.ShuffleInstruction.parse({
+      type: 'action/shuffle',
+      ...ins
+    });
+    this.template.push(parsedIns);
+    return this;
+  }
+  addCompleteAction(ins) {
+    const parsedIns = _instructions.CompleteTxInstruction.parse({
+      type: 'action/complete',
+      ...ins
+    });
+    this.template.push(parsedIns);
+    return this;
+  }
+  addConfigAction(ins) {
+    const parsedIns = _instructions.ConfigInstruction.parse({
+      type: 'action/config',
+      ...ins
+    });
+    this.template.push(parsedIns);
+    return this;
+  }
+  addSetVarAction(ins) {
+    const parsedIns = _instructions.SetVarInstruction.parse({
+      type: 'action/setvar',
+      ...ins
+    });
+    this.template.push(parsedIns);
+    return this;
+  }
+  addNanoMethodExecution(ins) {
+    const parsedIns = _instructions.NanoMethodInstruction.parse({
+      type: 'nano/execute',
+      ...ins
+    });
+    this.template.push(parsedIns);
+    return this;
+  }
+}
+exports.TransactionTemplateBuilder = TransactionTemplateBuilder;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/template/transaction/context.d.ts b/node_modules/@hathor/wallet-lib/oldLib/template/transaction/context.d.ts
new file mode 100644
index 0000000..26eefc5
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/template/transaction/context.d.ts
@@ -0,0 +1,115 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+import { z } from 'zod';
+import { IHistoryTx, ILogger, OutputValueType } from '../../types';
+import Input from '../../models/input';
+import Output from '../../models/output';
+import { NanoAction } from './instructions';
+export interface TokenBalance {
+    tokens: OutputValueType;
+    mint_authorities: number;
+    melt_authorities: number;
+}
+export declare class TxBalance {
+    balance: Record<string, TokenBalance>;
+    createdTokenBalance: null | TokenBalance;
+    constructor();
+    /**
+     * Get the current balance of the given token.
+     */
+    getTokenBalance(token: string): TokenBalance;
+    /**
+     * Get the current balance of the token being created.
+     * Obs: only valid for create token transactions.
+     */
+    getCreatedTokenBalance(): TokenBalance;
+    /**
+     * Set the balance of a token.
+     */
+    setTokenBalance(token: string, balance: TokenBalance): void;
+    /**
+     * Set the balance of the created token.
+     */
+    setCreatedTokenBalance(balance: TokenBalance): void;
+    /**
+     * Add balance from utxo of the given transaction.
+     */
+    addBalanceFromUtxo(tx: IHistoryTx, index: number): void;
+    /**
+     * Remove the balance given from the token balance.
+     */
+    addOutput(amount: OutputValueType, token: string): void;
+    /**
+     * Remove the balance from the token being created.
+     */
+    addCreatedTokenOutput(amount: OutputValueType): void;
+    /**
+     * Remove the specified authority from the balance of the given token.
+     */
+    addOutputAuthority(count: number, token: string, authority: 'mint' | 'melt'): void;
+    /**
+     * Remove the authority from the balance of the token being created.
+     */
+    addCreatedTokenOutputAuthority(count: number, authority: 'mint' | 'melt'): void;
+}
+export declare class NanoContractContext {
+    id: string;
+    method: string;
+    caller: string;
+    args: unknown[];
+    actions: z.output<typeof NanoAction>[];
+    constructor(id: string, method: string, caller: string, args: unknown[], actions: z.output<typeof NanoAction>[]);
+}
+export declare class TxTemplateContext {
+    version: number;
+    signalBits: number;
+    inputs: Input[];
+    outputs: Output[];
+    tokens: string[];
+    balance: TxBalance;
+    tokenName?: string;
+    tokenSymbol?: string;
+    nanoContext?: NanoContractContext;
+    vars: Record<string, unknown>;
+    _logs: string[];
+    _logger: ILogger;
+    debug: boolean;
+    constructor(logger?: ILogger, debug?: boolean);
+    /**
+     * Add the line to the log array.
+     * Optionally use the logger to show the logs as they are being created.
+     */
+    log(message: string): void;
+    get logArray(): string[];
+    /**
+     * Change the current tx
+     */
+    useCreateTokenTxContext(): void;
+    isCreateTokenTxContext(): boolean;
+    startNanoContractExecution(id: string, method: string, caller: string, args: unknown[], actions: z.output<typeof NanoAction>[]): void;
+    isNanoMethodExecution(): boolean;
+    /**
+     * Add a token to the transaction and return its token_data.
+     * The token array order will be preserved so the token_data is final.
+     *
+     * If the transaction is a CREATE_TOKEN_TX it does not have a token array,
+     * only HTR (token_data=0) and the created token(token_data=1)
+     *
+     * @param token Token UID.
+     * @returns token_data for the requested token.
+     */
+    addToken(token: string): number;
+    /**
+     * Add inputs to the context.
+     */
+    addInputs(position: number, ...inputs: Input[]): void;
+    /**
+     * Add outputs to the context.
+     */
+    addOutputs(position: number, ...outputs: Output[]): void;
+}
+//# sourceMappingURL=context.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/template/transaction/context.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/template/transaction/context.d.ts.map
new file mode 100644
index 0000000..5e44614
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/template/transaction/context.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"context.d.ts","sourceRoot":"","sources":["../../../src/template/transaction/context.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/template/transaction/context.js b/node_modules/@hathor/wallet-lib/oldLib/template/transaction/context.js
new file mode 100644
index 0000000..ccad36e
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/template/transaction/context.js
@@ -0,0 +1,269 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.TxTemplateContext = exports.TxBalance = exports.NanoContractContext = void 0;
+var _types = require("../../types");
+var _transaction = _interopRequireDefault(require("../../utils/transaction"));
+var _constants = require("../../constants");
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
+function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
+function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */ /* eslint max-classes-per-file: ["error", 3] */
+class TxBalance {
+  constructor() {
+    _defineProperty(this, "balance", void 0);
+    _defineProperty(this, "createdTokenBalance", void 0);
+    this.balance = {};
+    this.createdTokenBalance = null;
+  }
+
+  /**
+   * Get the current balance of the given token.
+   */
+  getTokenBalance(token) {
+    if (!this.balance[token]) {
+      this.balance[token] = {
+        tokens: 0n,
+        mint_authorities: 0,
+        melt_authorities: 0
+      };
+    }
+    return this.balance[token];
+  }
+
+  /**
+   * Get the current balance of the token being created.
+   * Obs: only valid for create token transactions.
+   */
+  getCreatedTokenBalance() {
+    if (!this.createdTokenBalance) {
+      this.createdTokenBalance = {
+        tokens: 0n,
+        mint_authorities: 0,
+        melt_authorities: 0
+      };
+    }
+    return this.createdTokenBalance;
+  }
+
+  /**
+   * Set the balance of a token.
+   */
+  setTokenBalance(token, balance) {
+    this.balance[token] = balance;
+  }
+
+  /**
+   * Set the balance of the created token.
+   */
+  setCreatedTokenBalance(balance) {
+    this.createdTokenBalance = balance;
+  }
+
+  /**
+   * Add balance from utxo of the given transaction.
+   */
+  addBalanceFromUtxo(tx, index) {
+    if (tx.outputs.length <= index) {
+      throw new Error('Index does not exist on tx outputs');
+    }
+    const output = tx.outputs[index];
+    const {
+      token
+    } = output;
+    const balance = this.getTokenBalance(token);
+    if (_transaction.default.isAuthorityOutput(output)) {
+      if (_transaction.default.isMint(output)) {
+        balance.mint_authorities += 1;
+      }
+      if (_transaction.default.isMelt(output)) {
+        balance.melt_authorities += 1;
+      }
+    } else {
+      balance.tokens += output.value;
+    }
+    this.setTokenBalance(token, balance);
+  }
+
+  /**
+   * Remove the balance given from the token balance.
+   */
+  addOutput(amount, token) {
+    const balance = this.getTokenBalance(token);
+    balance.tokens -= amount;
+    this.setTokenBalance(token, balance);
+  }
+
+  /**
+   * Remove the balance from the token being created.
+   */
+  addCreatedTokenOutput(amount) {
+    const balance = this.getCreatedTokenBalance();
+    balance.tokens -= amount;
+    this.setCreatedTokenBalance(balance);
+  }
+
+  /**
+   * Remove the specified authority from the balance of the given token.
+   */
+  addOutputAuthority(count, token, authority) {
+    const balance = this.getTokenBalance(token);
+    if (authority === 'mint') {
+      balance.mint_authorities -= count;
+    }
+    if (authority === 'melt') {
+      balance.melt_authorities -= count;
+    }
+    this.setTokenBalance(token, balance);
+  }
+
+  /**
+   * Remove the authority from the balance of the token being created.
+   */
+  addCreatedTokenOutputAuthority(count, authority) {
+    const balance = this.getCreatedTokenBalance();
+    if (authority === 'mint') {
+      balance.mint_authorities -= count;
+    }
+    if (authority === 'melt') {
+      balance.melt_authorities -= count;
+    }
+    this.setCreatedTokenBalance(balance);
+  }
+}
+exports.TxBalance = TxBalance;
+class NanoContractContext {
+  constructor(id, method, caller, args, actions) {
+    _defineProperty(this, "id", void 0);
+    _defineProperty(this, "method", void 0);
+    _defineProperty(this, "caller", void 0);
+    _defineProperty(this, "args", void 0);
+    _defineProperty(this, "actions", void 0);
+    this.id = id;
+    this.method = method;
+    this.caller = caller;
+    this.args = args;
+    this.actions = actions;
+  }
+}
+exports.NanoContractContext = NanoContractContext;
+class TxTemplateContext {
+  constructor(logger, debug = false) {
+    _defineProperty(this, "version", void 0);
+    _defineProperty(this, "signalBits", void 0);
+    _defineProperty(this, "inputs", void 0);
+    _defineProperty(this, "outputs", void 0);
+    _defineProperty(this, "tokens", void 0);
+    _defineProperty(this, "balance", void 0);
+    _defineProperty(this, "tokenName", void 0);
+    _defineProperty(this, "tokenSymbol", void 0);
+    _defineProperty(this, "nanoContext", void 0);
+    _defineProperty(this, "vars", void 0);
+    _defineProperty(this, "_logs", void 0);
+    _defineProperty(this, "_logger", void 0);
+    _defineProperty(this, "debug", void 0);
+    this.inputs = [];
+    this.outputs = [];
+    this.tokens = [];
+    this.version = _constants.DEFAULT_TX_VERSION;
+    this.signalBits = 0;
+    this.balance = new TxBalance();
+    this.vars = {};
+    this._logs = [];
+    this._logger = logger ?? (0, _types.getDefaultLogger)();
+    this.debug = debug;
+  }
+
+  /**
+   * Add the line to the log array.
+   * Optionally use the logger to show the logs as they are being created.
+   */
+  log(message) {
+    this._logs.push(message);
+    if (this.debug) {
+      this._logger.info(message);
+    }
+  }
+  get logArray() {
+    return this._logs;
+  }
+
+  /**
+   * Change the current tx
+   */
+  useCreateTokenTxContext() {
+    if (this.tokens.length !== 0) {
+      throw new Error(`Trying to build a create token tx with ${this.tokens.length} tokens on the array`);
+    }
+    this.version = _constants.CREATE_TOKEN_TX_VERSION;
+  }
+  isCreateTokenTxContext() {
+    return this.version === _constants.CREATE_TOKEN_TX_VERSION;
+  }
+  startNanoContractExecution(id, method, caller, args, actions) {
+    if (this.nanoContext) {
+      throw new Error('Already building a nano contract tx.');
+    }
+    this.nanoContext = new NanoContractContext(id, method, caller, args, actions);
+  }
+  isNanoMethodExecution() {
+    return !!this.nanoContext;
+  }
+
+  /**
+   * Add a token to the transaction and return its token_data.
+   * The token array order will be preserved so the token_data is final.
+   *
+   * If the transaction is a CREATE_TOKEN_TX it does not have a token array,
+   * only HTR (token_data=0) and the created token(token_data=1)
+   *
+   * @param token Token UID.
+   * @returns token_data for the requested token.
+   */
+  addToken(token) {
+    if (token === _constants.NATIVE_TOKEN_UID) {
+      return 0;
+    }
+    if (this.version === _constants.CREATE_TOKEN_TX_VERSION) {
+      throw new Error(`Cannot add a custom token to a CREATE_TOKEN_TX`);
+    }
+    const index = this.tokens.indexOf(token);
+    if (index > -1) {
+      // Token is already on the list.
+      return index + 1;
+    }
+    // Token is not on the list, adding now
+    this.tokens.push(token);
+    return this.tokens.length;
+  }
+
+  /**
+   * Add inputs to the context.
+   */
+  addInputs(position, ...inputs) {
+    if (position === -1) {
+      this.inputs.push(...inputs);
+      return;
+    }
+    this.inputs.splice(position, 0, ...inputs);
+  }
+
+  /**
+   * Add outputs to the context.
+   */
+  addOutputs(position, ...outputs) {
+    if (position === -1) {
+      this.outputs.push(...outputs);
+      return;
+    }
+    this.outputs.splice(position, 0, ...outputs);
+  }
+}
+exports.TxTemplateContext = TxTemplateContext;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/template/transaction/executor.d.ts b/node_modules/@hathor/wallet-lib/oldLib/template/transaction/executor.d.ts
new file mode 100644
index 0000000..f90b789
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/template/transaction/executor.d.ts
@@ -0,0 +1,68 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+import { z } from 'zod';
+import { AuthorityOutputInstruction, AuthoritySelectInstruction, CompleteTxInstruction, ConfigInstruction, DataOutputInstruction, NanoMethodInstruction, RawInputInstruction, RawOutputInstruction, SetVarInstruction, ShuffleInstruction, TokenOutputInstruction, TxTemplateInstruction, UtxoSelectInstruction } from './instructions';
+import { TxTemplateContext } from './context';
+import { ITxTemplateInterpreter } from './types';
+/**
+ * Find and run the executor function for the instruction.
+ */
+export declare function runInstruction(interpreter: ITxTemplateInterpreter, ctx: TxTemplateContext, ins: z.infer<typeof TxTemplateInstruction>): Promise<void>;
+/**
+ * Get the executor function for a specific instruction.
+ * Since we parse the instruction we can guarantee the validity.
+ */
+export declare function findInstructionExecution(ins: unknown): (interpreter: ITxTemplateInterpreter, ctx: TxTemplateContext, ins: any) => Promise<void>;
+/**
+ * Execution for RawInputInstruction
+ */
+export declare function execRawInputInstruction(interpreter: ITxTemplateInterpreter, ctx: TxTemplateContext, ins: z.infer<typeof RawInputInstruction>): Promise<void>;
+/**
+ * Execution for UtxoSelectInstruction
+ */
+export declare function execUtxoSelectInstruction(interpreter: ITxTemplateInterpreter, ctx: TxTemplateContext, ins: z.infer<typeof UtxoSelectInstruction>): Promise<void>;
+/**
+ * Execution for AuthoritySelectInstruction
+ */
+export declare function execAuthoritySelectInstruction(interpreter: ITxTemplateInterpreter, ctx: TxTemplateContext, ins: z.infer<typeof AuthoritySelectInstruction>): Promise<void>;
+/**
+ * Execution for RawOutputInstruction
+ */
+export declare function execRawOutputInstruction(_interpreter: ITxTemplateInterpreter, ctx: TxTemplateContext, ins: z.infer<typeof RawOutputInstruction>): Promise<void>;
+/**
+ * Execution for DataOutputInstruction
+ */
+export declare function execDataOutputInstruction(_interpreter: ITxTemplateInterpreter, ctx: TxTemplateContext, ins: z.infer<typeof DataOutputInstruction>): Promise<void>;
+/**
+ * Execution for TokenOutputInstruction
+ */
+export declare function execTokenOutputInstruction(interpreter: ITxTemplateInterpreter, ctx: TxTemplateContext, ins: z.infer<typeof TokenOutputInstruction>): Promise<void>;
+/**
+ * Execution for AuthorityOutputInstruction
+ */
+export declare function execAuthorityOutputInstruction(interpreter: ITxTemplateInterpreter, ctx: TxTemplateContext, ins: z.infer<typeof AuthorityOutputInstruction>): Promise<void>;
+/**
+ * Execution for ShuffleInstruction
+ */
+export declare function execShuffleInstruction(_interpreter: ITxTemplateInterpreter, ctx: TxTemplateContext, ins: z.infer<typeof ShuffleInstruction>): Promise<void>;
+/**
+ * Execution for CompleteTxInstruction
+ */
+export declare function execCompleteTxInstruction(interpreter: ITxTemplateInterpreter, ctx: TxTemplateContext, ins: z.infer<typeof CompleteTxInstruction>): Promise<void>;
+/**
+ * Execution for ConfigInstruction
+ */
+export declare function execConfigInstruction(_interpreter: ITxTemplateInterpreter, ctx: TxTemplateContext, ins: z.infer<typeof ConfigInstruction>): Promise<void>;
+/**
+ * Execution for SetVarInstruction
+ */
+export declare function execSetVarInstruction(interpreter: ITxTemplateInterpreter, ctx: TxTemplateContext, ins: z.infer<typeof SetVarInstruction>): Promise<void>;
+/**
+ * Execution for NanoMethodInstruction
+ */
+export declare function execNanoMethodInstruction(_interpreter: ITxTemplateInterpreter, ctx: TxTemplateContext, ins: z.infer<typeof NanoMethodInstruction>): Promise<void>;
+//# sourceMappingURL=executor.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/template/transaction/executor.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/template/transaction/executor.d.ts.map
new file mode 100644
index 0000000..dada8c0
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/template/transaction/executor.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"executor.d.ts","sourceRoot":"","sources":["../../../src/template/transaction/executor.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/template/transaction/executor.js b/node_modules/@hathor/wallet-lib/oldLib/template/transaction/executor.js
new file mode 100644
index 0000000..31fc3d4
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/template/transaction/executor.js
@@ -0,0 +1,816 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.execAuthorityOutputInstruction = execAuthorityOutputInstruction;
+exports.execAuthoritySelectInstruction = execAuthoritySelectInstruction;
+exports.execCompleteTxInstruction = execCompleteTxInstruction;
+exports.execConfigInstruction = execConfigInstruction;
+exports.execDataOutputInstruction = execDataOutputInstruction;
+exports.execNanoMethodInstruction = execNanoMethodInstruction;
+exports.execRawInputInstruction = execRawInputInstruction;
+exports.execRawOutputInstruction = execRawOutputInstruction;
+exports.execSetVarInstruction = execSetVarInstruction;
+exports.execShuffleInstruction = execShuffleInstruction;
+exports.execTokenOutputInstruction = execTokenOutputInstruction;
+exports.execUtxoSelectInstruction = execUtxoSelectInstruction;
+exports.findInstructionExecution = findInstructionExecution;
+exports.runInstruction = runInstruction;
+var _zod = require("zod");
+var _lodash = require("lodash");
+var _instructions = require("./instructions");
+var _input = _interopRequireDefault(require("../../models/input"));
+var _output = _interopRequireDefault(require("../../models/output"));
+var _constants = require("../../constants");
+var _address = require("../../utils/address");
+var _bigint = require("../../utils/bigint");
+var _script_data = _interopRequireDefault(require("../../models/script_data"));
+var _setvarcommands = require("./setvarcommands");
+var _utils = require("./utils");
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+/**
+ * Find and run the executor function for the instruction.
+ */
+async function runInstruction(interpreter, ctx, ins) {
+  const instructionExecutor = findInstructionExecution(ins);
+  await instructionExecutor(interpreter, ctx, ins);
+}
+
+/**
+ * Get the executor function for a specific instruction.
+ * Since we parse the instruction we can guarantee the validity.
+ */
+function findInstructionExecution(ins) {
+  /* eslint-enable @typescript-eslint/no-explicit-any */
+  switch (_instructions.TxTemplateInstruction.parse(ins).type) {
+    case 'input/raw':
+      return execRawInputInstruction;
+    case 'input/utxo':
+      return execUtxoSelectInstruction;
+    case 'input/authority':
+      return execAuthoritySelectInstruction;
+    case 'output/raw':
+      return execRawOutputInstruction;
+    case 'output/data':
+      return execDataOutputInstruction;
+    case 'output/token':
+      return execTokenOutputInstruction;
+    case 'output/authority':
+      return execAuthorityOutputInstruction;
+    case 'action/shuffle':
+      return execShuffleInstruction;
+    case 'action/complete':
+      return execCompleteTxInstruction;
+    case 'action/config':
+      return execConfigInstruction;
+    case 'action/setvar':
+      return execSetVarInstruction;
+    case 'nano/execute':
+      return execNanoMethodInstruction;
+    default:
+      throw new Error('Cannot determine the instruction to run');
+  }
+}
+
+/**
+ * Execution for RawInputInstruction
+ */
+async function execRawInputInstruction(interpreter, ctx, ins) {
+  ctx.log(`Begin RawInputInstruction: ${_bigint.JSONBigInt.stringify(ins)}`);
+  const {
+    position
+  } = ins;
+  const txId = (0, _instructions.getVariable)(ins.txId, ctx.vars, _instructions.RawInputInstruction.shape.txId);
+  const index = (0, _instructions.getVariable)(ins.index, ctx.vars, _instructions.RawInputInstruction.shape.index);
+  ctx.log(`index(${index}), txId(${txId})`);
+
+  // Find the original transaction from the input
+  const origTx = await interpreter.getTx(txId);
+  // Add balance to the ctx.balance
+  ctx.balance.addBalanceFromUtxo(origTx, index);
+  const input = new _input.default(txId, index);
+  ctx.addInputs(position, input);
+}
+
+/**
+ * Execution for UtxoSelectInstruction
+ */
+async function execUtxoSelectInstruction(interpreter, ctx, ins) {
+  ctx.log(`Begin UtxoSelectInstruction: ${_bigint.JSONBigInt.stringify(ins)}`);
+  const {
+    position
+  } = ins;
+  const fill = (0, _instructions.getVariable)(ins.fill, ctx.vars, _instructions.UtxoSelectInstruction.shape.fill);
+  const token = (0, _instructions.getVariable)(ins.token, ctx.vars, _instructions.UtxoSelectInstruction.shape.token);
+  const address = (0, _instructions.getVariable)(ins.address, ctx.vars, _instructions.UtxoSelectInstruction.shape.address);
+  ctx.log(`fill(${fill}), address(${address}), token(${token})`);
+  const {
+    autoChange
+  } = ins;
+
+  // Find utxos
+  const options = {
+    token
+  };
+  if (address) {
+    options.filter_address = address;
+  }
+  const changeAddress = (0, _instructions.getVariable)(ins.changeAddress, ctx.vars, _instructions.UtxoSelectInstruction.shape.changeAddress) ?? (await interpreter.getChangeAddress(ctx));
+  await (0, _utils.selectTokens)(interpreter, ctx, fill, options, autoChange, changeAddress, position);
+}
+
+/**
+ * Execution for AuthoritySelectInstruction
+ */
+async function execAuthoritySelectInstruction(interpreter, ctx, ins) {
+  ctx.log(`Begin AuthoritySelectInstruction: ${_bigint.JSONBigInt.stringify(ins)}`);
+  const position = ins.position ?? -1;
+  const {
+    authority
+  } = ins;
+  const token = (0, _instructions.getVariable)(ins.token, ctx.vars, _instructions.AuthoritySelectInstruction.shape.token);
+  const count = (0, _instructions.getVariable)(ins.count, ctx.vars, _instructions.AuthoritySelectInstruction.shape.count);
+  const address = (0, _instructions.getVariable)(ins.address, ctx.vars, _instructions.AuthoritySelectInstruction.shape.address);
+  ctx.log(`count(${count}), address(${address}), token(${token})`);
+  let authoritiesInt = 0n;
+  if (authority === 'mint') {
+    authoritiesInt += _constants.TOKEN_MINT_MASK;
+  }
+  if (authority === 'melt') {
+    authoritiesInt += _constants.TOKEN_MELT_MASK;
+  }
+
+  // Find utxos
+  const options = {
+    token,
+    authorities: authoritiesInt
+  };
+  if (address) {
+    options.filter_address = address;
+  }
+  await (0, _utils.selectAuthorities)(interpreter, ctx, options, count, position);
+}
+
+/**
+ * Execution for RawOutputInstruction
+ */
+async function execRawOutputInstruction(_interpreter, ctx, ins) {
+  ctx.log(`Begin RawOutputInstruction: ${_bigint.JSONBigInt.stringify(ins)}`);
+  const {
+    position,
+    authority,
+    useCreatedToken
+  } = ins;
+  const scriptStr = (0, _instructions.getVariable)(ins.script, ctx.vars, _instructions.RawOutputInstruction.shape.script);
+  const script = Buffer.from(scriptStr, 'hex');
+  const token = (0, _instructions.getVariable)(ins.token, ctx.vars, _instructions.RawOutputInstruction.shape.token);
+  const timelock = (0, _instructions.getVariable)(ins.timelock, ctx.vars, _instructions.RawOutputInstruction.shape.timelock);
+  let amount = (0, _instructions.getVariable)(ins.amount, ctx.vars, _instructions.RawOutputInstruction.shape.amount);
+  ctx.log(`amount(${amount}) timelock(${timelock}) script(${script}) token(${token})`);
+  if (!(authority || amount)) {
+    throw new Error('Raw token output missing amount');
+  }
+
+  // get tokenData and update token balance on the context
+  let tokenData;
+  if (useCreatedToken) {
+    if (!ctx.isCreateTokenTxContext()) {
+      ctx.log(`Current transaction is not creating a token.`);
+      throw new Error('Current transaction is not creating a token.');
+    }
+    tokenData = 1;
+    if (authority) {
+      ctx.log(`Creating authority output`);
+      ctx.balance.addCreatedTokenOutputAuthority(1, authority);
+    } else {
+      ctx.log(`Creating token output`);
+      if (amount) {
+        ctx.balance.addCreatedTokenOutput(amount);
+      }
+    }
+  } else {
+    // Add token to tokens array
+    tokenData = ctx.addToken(token);
+    if (authority) {
+      ctx.log(`Creating authority output`);
+      ctx.balance.addOutputAuthority(1, token, authority);
+    } else {
+      ctx.log(`Creating token output`);
+      if (amount) {
+        ctx.balance.addOutput(amount, token);
+      }
+    }
+  }
+  switch (authority) {
+    case 'mint':
+      amount = _constants.TOKEN_MINT_MASK;
+      tokenData |= _constants.TOKEN_AUTHORITY_MASK;
+      break;
+    case 'melt':
+      amount = _constants.TOKEN_MELT_MASK;
+      tokenData |= _constants.TOKEN_AUTHORITY_MASK;
+      break;
+    default:
+      break;
+  }
+  if (!amount) {
+    throw new Error('Raw token output missing amount');
+  }
+  const output = new _output.default(amount, script, {
+    timelock,
+    tokenData
+  });
+  ctx.addOutputs(position, output);
+}
+
+/**
+ * Execution for DataOutputInstruction
+ */
+async function execDataOutputInstruction(_interpreter, ctx, ins) {
+  ctx.log(`Begin DataOutputInstruction: ${_bigint.JSONBigInt.stringify(ins)}`);
+  const {
+    position,
+    useCreatedToken
+  } = ins;
+  const data = (0, _instructions.getVariable)(ins.data, ctx.vars, _instructions.DataOutputInstruction.shape.data);
+  const token = (0, _instructions.getVariable)(ins.token, ctx.vars, _instructions.DataOutputInstruction.shape.token);
+  ctx.log(`Creating data(${data}) output for token(${token})`);
+  let tokenData;
+  if (useCreatedToken) {
+    if (!ctx.isCreateTokenTxContext()) {
+      ctx.log(`Current transaction is not creating a token.`);
+      throw new Error('Current transaction is not creating a token.');
+    }
+    ctx.log(`Using created token`);
+    tokenData = 1;
+    ctx.balance.addCreatedTokenOutput(1n);
+  } else {
+    ctx.log(`Using token(${token})`);
+    // Add token to tokens array
+    tokenData = ctx.addToken(token);
+    ctx.balance.addOutput(1n, token);
+  }
+  const dataScript = new _script_data.default(data);
+  const script = dataScript.createScript();
+  const output = new _output.default(1n, script, {
+    tokenData
+  });
+  ctx.addOutputs(position, output);
+}
+
+/**
+ * Execution for TokenOutputInstruction
+ */
+async function execTokenOutputInstruction(interpreter, ctx, ins) {
+  ctx.log(`Begin TokenOutputInstruction: ${_bigint.JSONBigInt.stringify(ins)}`);
+  const {
+    position,
+    useCreatedToken
+  } = ins;
+  const token = (0, _instructions.getVariable)(ins.token, ctx.vars, _instructions.TokenOutputInstruction.shape.token);
+  const address = (0, _instructions.getVariable)(ins.address, ctx.vars, _instructions.TokenOutputInstruction.shape.address);
+  const timelock = (0, _instructions.getVariable)(ins.timelock, ctx.vars, _instructions.TokenOutputInstruction.shape.timelock);
+  const amount = (0, _instructions.getVariable)(ins.amount, ctx.vars, _instructions.TokenOutputInstruction.shape.amount);
+  ctx.log(`Creating token output with amount(${amount}) address(${address}) timelock(${timelock})`);
+  let tokenData;
+  if (useCreatedToken) {
+    if (!ctx.isCreateTokenTxContext()) {
+      ctx.log(`Current transaction is not creating a token.`);
+      throw new Error('Current transaction is not creating a token.');
+    }
+    ctx.log(`Using created token`);
+    tokenData = 1;
+    ctx.balance.addCreatedTokenOutput(amount);
+  } else {
+    ctx.log(`Using token(${token})`);
+    // Add token to tokens array
+    tokenData = ctx.addToken(token);
+    ctx.balance.addOutput(amount, token);
+  }
+  const script = (0, _address.createOutputScriptFromAddress)(address, interpreter.getNetwork());
+  const output = new _output.default(amount, script, {
+    timelock,
+    tokenData
+  });
+  ctx.addOutputs(position, output);
+}
+
+/**
+ * Execution for AuthorityOutputInstruction
+ */
+async function execAuthorityOutputInstruction(interpreter, ctx, ins) {
+  ctx.log(`Begin AuthorityOutputInstruction: ${_bigint.JSONBigInt.stringify(ins)}`);
+  const {
+    authority,
+    position,
+    useCreatedToken
+  } = ins;
+  const token = (0, _instructions.getVariable)(ins.token, ctx.vars, _instructions.AuthorityOutputInstruction.shape.token);
+  const address = (0, _instructions.getVariable)(ins.address, ctx.vars, _instructions.AuthorityOutputInstruction.shape.address);
+  const timelock = (0, _instructions.getVariable)(ins.timelock, ctx.vars, _instructions.AuthorityOutputInstruction.shape.timelock);
+  const count = (0, _instructions.getVariable)(ins.count, ctx.vars, _instructions.AuthorityOutputInstruction.shape.count);
+  ctx.log(`Creating count(${count}) "${authority}" authority outputs with address(${address}) timelock(${timelock})`);
+  let tokenData;
+  if (useCreatedToken) {
+    if (!ctx.isCreateTokenTxContext()) {
+      ctx.log(`Current transaction is not creating a token.`);
+      throw new Error('Current transaction is not creating a token.');
+    }
+    ctx.log(`Using created token`);
+    tokenData = 1;
+    ctx.balance.addCreatedTokenOutputAuthority(count, authority);
+  } else {
+    if (!token) {
+      throw new Error(`token is required when trying to add an authority output`);
+    }
+    ctx.log(`Using token(${token})`);
+    // Add token to tokens array
+    tokenData = ctx.addToken(token);
+    // Add balance to the ctx.balance
+    ctx.balance.addOutputAuthority(count, token, authority);
+  }
+  let amount = 0n;
+  switch (authority) {
+    case 'mint':
+      amount = _constants.TOKEN_MINT_MASK;
+      tokenData |= _constants.TOKEN_AUTHORITY_MASK;
+      break;
+    case 'melt':
+      amount = _constants.TOKEN_MELT_MASK;
+      tokenData |= _constants.TOKEN_AUTHORITY_MASK;
+      break;
+    default:
+      throw new Error('Authority token output missing `authority`');
+  }
+  const script = (0, _address.createOutputScriptFromAddress)(address, interpreter.getNetwork());
+  const output = new _output.default(amount, script, {
+    timelock,
+    tokenData
+  });
+  // Creates `count` outputs that are copies of the `output`
+  ctx.addOutputs(position, ...Array(count).fill(output));
+}
+
+/**
+ * Execution for ShuffleInstruction
+ */
+async function execShuffleInstruction(_interpreter, ctx, ins) {
+  ctx.log(`Begin ShuffleInstruction: ${_bigint.JSONBigInt.stringify(ins)}`);
+  const {
+    target
+  } = ins;
+
+  // The token array should never be shuffled since outputs have a "pointer" to the token position
+  // on the token array, so shuffling would make the outputs target different outputs.
+
+  if (target === 'inputs' || target === 'all') {
+    ctx.inputs = (0, _lodash.shuffle)(ctx.inputs);
+  }
+  if (target === 'outputs' || target === 'all') {
+    ctx.outputs = (0, _lodash.shuffle)(ctx.outputs);
+  }
+}
+
+/**
+ * Execution for CompleteTxInstruction
+ */
+async function execCompleteTxInstruction(interpreter, ctx, ins) {
+  ctx.log(`Begin CompleteTxInstruction: ${_bigint.JSONBigInt.stringify(ins)}`);
+  const token = (0, _instructions.getVariable)(ins.token, ctx.vars, _instructions.CompleteTxInstruction.shape.token);
+  const changeAddress = (0, _instructions.getVariable)(ins.changeAddress, ctx.vars, _instructions.CompleteTxInstruction.shape.changeAddress) ?? (await interpreter.getChangeAddress(ctx));
+  const address = (0, _instructions.getVariable)(ins.address, ctx.vars, _instructions.CompleteTxInstruction.shape.address);
+  const timelock = (0, _instructions.getVariable)(ins.timelock, ctx.vars, _instructions.CompleteTxInstruction.shape.timelock);
+  const {
+    skipSelection,
+    skipAuthorities,
+    skipChange,
+    calculateFee
+  } = ins;
+  ctx.log(`changeAddress(${changeAddress}) address(${address}) timelock(${timelock}) token(${token}), calculateFee(${calculateFee}), skipSelection(${skipSelection}), skipChange(${skipChange}), skipAuthorities(${skipAuthorities})`);
+  const tokensToCheck = [];
+  if (token) {
+    tokensToCheck.push(token);
+  } else {
+    // Check HTR and all tokens on the transaction
+    tokensToCheck.push(_constants.NATIVE_TOKEN_UID);
+    ctx.tokens.forEach(tk => {
+      tokensToCheck.push(tk);
+    });
+  }
+
+  // calculate token creation fee
+  if (calculateFee && ctx.isCreateTokenTxContext()) {
+    // INFO: Currently fees only make sense for create token transactions.
+
+    const amount = ctx.balance.createdTokenBalance.tokens;
+    const deposit = interpreter.getHTRDeposit(amount);
+
+    // Add the required HTR to create the tokens
+    const balance = ctx.balance.getTokenBalance(_constants.NATIVE_TOKEN_UID);
+    balance.tokens += deposit;
+    ctx.balance.setTokenBalance(_constants.NATIVE_TOKEN_UID, balance);
+
+    // If we weren't going to check HTR, we need to include in the tokens to check
+    if (!tokensToCheck.includes(_constants.NATIVE_TOKEN_UID)) {
+      tokensToCheck.push(_constants.NATIVE_TOKEN_UID);
+    }
+  }
+  const changeScript = (0, _address.createOutputScriptFromAddress)(changeAddress, interpreter.getNetwork());
+  for (const tokenUid of tokensToCheck) {
+    ctx.log(`Completing tx for token ${tokenUid}`);
+    // Check balances for token.
+    const balance = ctx.balance.getTokenBalance(tokenUid);
+    const tokenData = ctx.addToken(tokenUid);
+    if (balance.tokens > 0 && !skipChange) {
+      const value = balance.tokens;
+      // Surplus of token on the inputs, need to add a change output
+      ctx.log(`Creating a change output for ${value} / ${tokenUid}`);
+      // Add balance to the ctx.balance
+      ctx.balance.addOutput(value, tokenUid);
+
+      // Creates an output with the value of the outstanding balance
+      const output = new _output.default(value, changeScript, {
+        timelock,
+        tokenData
+      });
+      ctx.addOutputs(-1, output);
+    } else if (balance.tokens < 0 && !skipSelection) {
+      const value = -balance.tokens;
+      ctx.log(`Finding inputs for ${value} / ${tokenUid}`);
+      // Surplus of tokens on the outputs, need to select tokens and add inputs
+      const options = {
+        token: tokenUid
+      };
+      if (address) {
+        options.filter_address = address;
+      }
+      const {
+        changeAmount,
+        utxos
+      } = await interpreter.getUtxos(value, options);
+
+      // Add utxos as inputs on the transaction
+      const inputs = [];
+      for (const utxo of utxos) {
+        ctx.log(`Found utxo with ${utxo.value} of ${utxo.tokenId}`);
+        ctx.log(`Create input ${utxo.index} / ${utxo.txId}`);
+        inputs.push(new _input.default(utxo.txId, utxo.index));
+        // Update balance
+        const origTx = await interpreter.getTx(utxo.txId);
+        ctx.balance.addBalanceFromUtxo(origTx, utxo.index);
+      }
+
+      // Then add inputs to context
+      ctx.addInputs(-1, ...inputs);
+      if (changeAmount) {
+        ctx.log(`Creating change with ${changeAmount} for address: ${changeAddress}`);
+        const output = new _output.default(changeAmount, changeScript, {
+          tokenData
+        });
+        ctx.balance.addOutput(changeAmount, tokenUid);
+        ctx.addOutputs(-1, output);
+      }
+    }
+
+    // Skip authority blocks if we wish to not include authority completion.
+    if (skipAuthorities) {
+      continue;
+    }
+    if (balance.mint_authorities > 0) {
+      const count = balance.mint_authorities;
+      ctx.log(`Creating ${count} mint outputs / ${tokenUid}`);
+      // Need to create a token output
+      // Add balance to the ctx.balance
+      ctx.balance.addOutputAuthority(count, tokenUid, 'mint');
+
+      // Creates an output with the value of the outstanding balance
+      const output = new _output.default(_constants.TOKEN_MINT_MASK, changeScript, {
+        timelock,
+        tokenData: tokenData | _constants.TOKEN_AUTHORITY_MASK
+      });
+      ctx.addOutputs(-1, ...Array(count).fill(output));
+    } else if (balance.mint_authorities < 0) {
+      const count = -balance.mint_authorities;
+      ctx.log(`Finding inputs for ${count} mint authorities / ${tokenUid}`);
+      // Need to find authorities to fill balance
+      const utxos = await interpreter.getAuthorities(count, {
+        token: tokenUid,
+        authorities: 1n // Mint
+      });
+
+      // Add utxos as inputs on the transaction
+      const inputs = [];
+      for (const utxo of utxos) {
+        ctx.log(`Found authority utxo ${utxo.authorities} of ${token}`);
+        ctx.log(`Create input ${utxo.index} / ${utxo.txId}`);
+        inputs.push(new _input.default(utxo.txId, utxo.index));
+      }
+      // First, update balance
+      for (const input of inputs) {
+        const origTx = await interpreter.getTx(input.hash);
+        ctx.balance.addBalanceFromUtxo(origTx, input.index);
+      }
+
+      // Then add inputs to context
+      ctx.addInputs(-1, ...inputs);
+    }
+    if (balance.melt_authorities > 0) {
+      const count = balance.melt_authorities;
+      ctx.log(`Creating ${count} melt outputs / ${tokenUid}`);
+      // Need to create a token output
+      // Add balance to the ctx.balance
+      ctx.balance.addOutputAuthority(count, tokenUid, 'melt');
+
+      // Creates an output with the value of the outstanding balance
+      const output = new _output.default(_constants.TOKEN_MELT_MASK, changeScript, {
+        timelock,
+        tokenData: tokenData | _constants.TOKEN_AUTHORITY_MASK
+      });
+      ctx.addOutputs(-1, ...Array(count).fill(output));
+    } else if (balance.melt_authorities < 0) {
+      const count = -balance.melt_authorities;
+      ctx.log(`Finding inputs for ${count} melt authorities / ${tokenUid}`);
+      // Need to find authorities to fill balance
+      const utxos = await interpreter.getAuthorities(count, {
+        token: tokenUid,
+        authorities: 2n // Melt
+      });
+
+      // Add utxos as inputs on the transaction
+      const inputs = [];
+      for (const utxo of utxos) {
+        ctx.log(`Found authority utxo ${utxo.authorities} of ${token}`);
+        ctx.log(`Create input ${utxo.index} / ${utxo.txId}`);
+        inputs.push(new _input.default(utxo.txId, utxo.index));
+      }
+      // First, update balance
+      for (const input of inputs) {
+        const origTx = await interpreter.getTx(input.hash);
+        ctx.balance.addBalanceFromUtxo(origTx, input.index);
+      }
+
+      // Then add inputs to context
+      ctx.addInputs(-1, ...inputs);
+    }
+  }
+}
+
+/**
+ * Execution for ConfigInstruction
+ */
+async function execConfigInstruction(_interpreter, ctx, ins) {
+  ctx.log(`Begin ConfigInstruction: ${_bigint.JSONBigInt.stringify(ins)}`);
+  const version = (0, _instructions.getVariable)(ins.version, ctx.vars, _instructions.ConfigInstruction.shape.version);
+  const signalBits = (0, _instructions.getVariable)(ins.signalBits, ctx.vars, _instructions.ConfigInstruction.shape.signalBits);
+  const tokenName = (0, _instructions.getVariable)(ins.tokenName, ctx.vars, _instructions.ConfigInstruction.shape.tokenName);
+  const tokenSymbol = (0, _instructions.getVariable)(ins.tokenSymbol, ctx.vars, _instructions.ConfigInstruction.shape.tokenSymbol);
+  const createToken = (0, _instructions.getVariable)(ins.createToken, ctx.vars, _instructions.ConfigInstruction.shape.createToken);
+  ctx.log(`version(${version}) signalBits(${signalBits}) tokenName(${tokenName}) tokenSymbol(${tokenSymbol}) createToken(${createToken})`);
+  if (version) {
+    ctx.version = version;
+  }
+  if (signalBits) {
+    ctx.signalBits = signalBits;
+  }
+  if (tokenName) {
+    ctx.tokenName = tokenName;
+  }
+  if (tokenSymbol) {
+    ctx.tokenSymbol = tokenSymbol;
+  }
+  if (createToken) {
+    ctx.useCreateTokenTxContext();
+  }
+}
+
+/**
+ * Execution for SetVarInstruction
+ */
+async function execSetVarInstruction(interpreter, ctx, ins) {
+  ctx.log(`Begin SetVarInstruction: ${_bigint.JSONBigInt.stringify(ins)}`);
+  if (!ins.call) {
+    ctx.log(`Setting ${ins.name} with ${ins.value}`);
+    ctx.vars[ins.name] = ins.value;
+    return;
+  }
+  if (ins.call.method === 'get_wallet_address') {
+    // Validate options and get token variable
+    const callArgs = _instructions.SetVarGetWalletAddressOpts.parse(ins.call);
+    // Call action with valid options
+    const address = await (0, _setvarcommands.getWalletAddress)(interpreter, ctx, callArgs);
+    ctx.log(`Setting ${ins.name} with ${address}`);
+    ctx.vars[ins.name] = address;
+    return;
+  }
+  if (ins.call.method === 'get_wallet_balance') {
+    // Validate options and get token variable
+    const callArgs = _instructions.SetVarGetWalletBalanceOpts.parse(ins.call);
+    const token = (0, _instructions.getVariable)(callArgs.token, ctx.vars, _instructions.SetVarGetWalletBalanceOpts.shape.token);
+    const newOptions = (0, _lodash.clone)(callArgs);
+    newOptions.token = token;
+    // Call action with valid options
+    const balance = await (0, _setvarcommands.getWalletBalance)(interpreter, ctx, newOptions);
+    ctx.vars[ins.name] = balance;
+    ctx.log(`Setting ${ins.name} with ${balance}`);
+    return;
+  }
+  if (ins.call.method === 'get_oracle_script') {
+    const callArgs = _instructions.SetVarGetOracleScriptOpts.parse(ins.call);
+    const oracle = await (0, _setvarcommands.getOracleScript)(interpreter, ctx, callArgs);
+    ctx.log(`Setting ${ins.name} with ${oracle}`);
+    ctx.vars[ins.name] = oracle;
+    return;
+  }
+  if (ins.call.method === 'get_oracle_signed_data') {
+    const callArgs = _instructions.SetVarGetOracleSignedDataOpts.parse(ins.call);
+    const signedData = await (0, _setvarcommands.getOracleSignedData)(interpreter, ctx, callArgs);
+    ctx.log(`Setting ${ins.name} with ${signedData}`);
+    ctx.vars[ins.name] = signedData;
+    return;
+  }
+  throw new Error('Invalid setvar command');
+}
+
+/**
+ * Validate NanoContract Deposit action
+ */
+async function validateDepositNanoAction(interpreter, ctx, action) {
+  const token = (0, _instructions.getVariable)(action.token, ctx.vars, _instructions.NanoDepositAction.shape.token);
+  ctx.addToken(token);
+  const amount = (0, _instructions.getVariable)(action.amount, ctx.vars, _instructions.NanoDepositAction.shape.amount);
+  const address = (0, _instructions.getVariable)(action.address, ctx.vars, _instructions.NanoDepositAction.shape.address);
+
+  // This is the action without variables, which will be used to create the header
+  // Change address may be a reference but since its not used on the header it makes no difference.
+  const actual = {
+    ...action,
+    token,
+    amount,
+    address
+  };
+  if (action.skipSelection || action.useCreatedToken) {
+    // Do not select inputs
+    return actual;
+  }
+
+  // Find utxos
+  const options = {
+    token
+  };
+  if (address) {
+    options.filter_address = address;
+  }
+  const changeAddress = (0, _instructions.getVariable)(action.changeAddress, ctx.vars, _instructions.NanoDepositAction.shape.changeAddress) ?? (await interpreter.getChangeAddress(ctx));
+  await (0, _utils.selectTokens)(interpreter, ctx, amount, options, action.autoChange, changeAddress);
+  return actual;
+}
+
+/**
+ * Validate NanoContract Withdrawal action
+ */
+async function validateWithdrawalNanoAction(interpreter, ctx, action) {
+  const token = (0, _instructions.getVariable)(action.token, ctx.vars, _instructions.NanoWithdrawalAction.shape.token);
+  ctx.addToken(token);
+  const amount = (0, _instructions.getVariable)(action.amount, ctx.vars, _instructions.NanoWithdrawalAction.shape.amount);
+  const address = (0, _instructions.getVariable)(action.address, ctx.vars, _instructions.NanoWithdrawalAction.shape.address) ?? (await interpreter.getAddress());
+
+  // This is the action without variables, which will be used to create the header
+  const actual = {
+    ...action,
+    token,
+    amount,
+    address
+  };
+  if (!action.skipOutputs) {
+    const tokenData = ctx.addToken(token);
+    const script = (0, _address.createOutputScriptFromAddress)(address, interpreter.getNetwork());
+    const output = new _output.default(amount, script, {
+      tokenData
+    });
+    ctx.addOutputs(-1, output);
+  }
+  return actual;
+}
+
+/**
+ * Validate NanoContract Grant Authority action
+ */
+async function validateGrantAuthorityNanoAction(interpreter, ctx, action) {
+  const token = (0, _instructions.getVariable)(action.token, ctx.vars, _instructions.NanoGrantAuthorityAction.shape.token);
+  ctx.addToken(token);
+  const {
+    authority
+  } = action;
+  const address = (0, _instructions.getVariable)(action.address, ctx.vars, _instructions.NanoGrantAuthorityAction.shape.address);
+
+  // This is the action without variables, which will be used to create the header
+  const actual = {
+    ...action,
+    token,
+    authority,
+    address
+  };
+  if (action.skipSelection || action.useCreatedToken) {
+    // Do not select inputs
+    return actual;
+  }
+  let authoritiesInt = 0n;
+  if (authority === 'mint') {
+    authoritiesInt += _constants.TOKEN_MINT_MASK;
+  }
+  if (authority === 'melt') {
+    authoritiesInt += _constants.TOKEN_MELT_MASK;
+  }
+
+  // Find utxos
+  const options = {
+    token,
+    authorities: authoritiesInt
+  };
+  if (address) {
+    options.filter_address = address;
+  }
+  await (0, _utils.selectAuthorities)(interpreter, ctx, options);
+  return actual;
+}
+
+/**
+ * Validate NanoContract Acquire Authority action
+ */
+async function validateAcquireAuthorityNanoAction(interpreter, ctx, action) {
+  const token = (0, _instructions.getVariable)(action.token, ctx.vars, _instructions.NanoAcquireAuthorityAction.shape.token);
+  ctx.addToken(token);
+  const address = (0, _instructions.getVariable)(action.address, ctx.vars, _instructions.NanoAcquireAuthorityAction.shape.address) ?? (await interpreter.getAddress());
+
+  // This is the action without variables, which will be used to create the header
+  const actual = {
+    ...action,
+    token,
+    authority: action.authority,
+    address
+  };
+  if (!action.skipOutputs) {
+    const tokenData = _constants.TOKEN_AUTHORITY_MASK | ctx.addToken(token);
+    let amount;
+    if (action.authority === 'mint') {
+      amount = _constants.TOKEN_MINT_MASK;
+    } else if (action.authority === 'melt') {
+      amount = _constants.TOKEN_MELT_MASK;
+    } else {
+      throw new Error('This should never happen');
+    }
+    const script = (0, _address.createOutputScriptFromAddress)(address, interpreter.getNetwork());
+    const output = new _output.default(amount, script, {
+      tokenData
+    });
+    ctx.addOutputs(-1, output);
+  }
+  return actual;
+}
+
+/**
+ * Execution for NanoMethodInstruction
+ */
+async function execNanoMethodInstruction(_interpreter, ctx, ins) {
+  ctx.log(`Begin NanoMethodInstruction: ${_bigint.JSONBigInt.stringify(ins)}`);
+  const id = (0, _instructions.getVariable)(ins.id, ctx.vars, _instructions.NanoMethodInstruction.shape.id);
+  const {
+    method
+  } = ins;
+  const caller = (0, _instructions.getVariable)(ins.caller, ctx.vars, _instructions.NanoMethodInstruction.shape.caller);
+  const args = [];
+  for (const arg of ins.args) {
+    const parsedArg = (0, _instructions.getVariable)(arg, ctx.vars, _zod.z.string().or(_zod.z.unknown()));
+    args.push(parsedArg);
+  }
+  ctx.log(`id(${id}) method(${method}) caller(${caller}) args(${args})`);
+  const actions = [];
+  for (const action of ins.actions || []) {
+    switch (action.action) {
+      case 'deposit':
+        actions.push(await validateDepositNanoAction(_interpreter, ctx, action));
+        break;
+      case 'withdrawal':
+        actions.push(await validateWithdrawalNanoAction(_interpreter, ctx, action));
+        break;
+      case 'grant_authority':
+        actions.push(await validateGrantAuthorityNanoAction(_interpreter, ctx, action));
+        break;
+      case 'acquire_authority':
+        actions.push(await validateAcquireAuthorityNanoAction(_interpreter, ctx, action));
+        break;
+      default:
+        ctx.log(`Called nano method execute with action ${JSON.stringify(action)}`);
+        throw new Error('This should never happen');
+    }
+  }
+  ctx.startNanoContractExecution(id, method, caller, args, actions);
+}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/template/transaction/index.d.ts b/node_modules/@hathor/wallet-lib/oldLib/template/transaction/index.d.ts
new file mode 100644
index 0000000..b26ccb5
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/template/transaction/index.d.ts
@@ -0,0 +1,4 @@
+export * from './interpreter';
+export * from './builder';
+export { TransactionTemplate } from './instructions';
+//# sourceMappingURL=index.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/template/transaction/index.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/template/transaction/index.d.ts.map
new file mode 100644
index 0000000..770c0c3
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/template/transaction/index.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../../src/template/transaction/index.ts"],"names":[],"mappings":"AAAA,cAAc,eAAe,CAAC;AAC9B,cAAc,WAAW,CAAC;AAC1B,OAAO,EAAE,mBAAmB,EAAE,MAAM,gBAAgB,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/template/transaction/index.js b/node_modules/@hathor/wallet-lib/oldLib/template/transaction/index.js
new file mode 100644
index 0000000..57697ff
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/template/transaction/index.js
@@ -0,0 +1,39 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+var _exportNames = {
+  TransactionTemplate: true
+};
+Object.defineProperty(exports, "TransactionTemplate", {
+  enumerable: true,
+  get: function () {
+    return _instructions.TransactionTemplate;
+  }
+});
+var _interpreter = require("./interpreter");
+Object.keys(_interpreter).forEach(function (key) {
+  if (key === "default" || key === "__esModule") return;
+  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
+  if (key in exports && exports[key] === _interpreter[key]) return;
+  Object.defineProperty(exports, key, {
+    enumerable: true,
+    get: function () {
+      return _interpreter[key];
+    }
+  });
+});
+var _builder = require("./builder");
+Object.keys(_builder).forEach(function (key) {
+  if (key === "default" || key === "__esModule") return;
+  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
+  if (key in exports && exports[key] === _builder[key]) return;
+  Object.defineProperty(exports, key, {
+    enumerable: true,
+    get: function () {
+      return _builder[key];
+    }
+  });
+});
+var _instructions = require("./instructions");
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/template/transaction/instructions.d.ts b/node_modules/@hathor/wallet-lib/oldLib/template/transaction/instructions.d.ts
new file mode 100644
index 0000000..47a8cbc
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/template/transaction/instructions.d.ts
@@ -0,0 +1,1793 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+import { z } from 'zod';
+export declare const TemplateRef: z.ZodString;
+/**
+ * If the key matches a template reference (i.e. `{name}`) it returns the variable of that name.
+ * If not the ref should be the actual value.
+ * This is validated by the `schema` argument which is a ZodType that parses either:
+ *   - A `TemplateRef` or;
+ *   - A ZodType that outputs `S`;
+ *
+ * The generic system allows with just the first argument a validation that the
+ * schema will parse to the expected type and that `ref` is `string | S`.
+ * This way changes on validation affect the executors and the value from vars
+ * will be of the expected type.
+ * The goal of this system is to avoid too much verbosity while keeping strong cohesive typing.
+ *
+ * @example
+ * ```
+ * const TokenSchema = TemplateRef.or(z.string().regex(/^[A-F0-9]{64}&1/));
+ * const AmountSchema = TemplateRef.or(z.bigint());
+ * const IndexSchema = TemplateRef.or(z.number().min(0));
+ *
+ * const token: string = getVariable<string>(ref1, {foo: 'bar'}, TokenSchema);
+ * const amount: bigint = getVariable<bigint>(ref2, {foo: 10n}, AmountSchema);
+ * const token: string = getVariable<number>(ref3, {foo: 27}, IndexSchema);
+ * ```
+ */
+export declare function getVariable<S, T extends z.ZodUnion<[typeof TemplateRef, z.ZodType<S, z.ZodTypeDef, unknown>]> = z.ZodUnion<[
+    typeof TemplateRef,
+    z.ZodType<S, z.ZodTypeDef, unknown>
+]>>(ref: z.infer<T>, vars: Record<string, unknown>, schema: T): S;
+export declare const Sha256HexSchema: z.ZodString;
+export declare const TxIdSchema: z.ZodString;
+export declare const CustomTokenSchema: z.ZodString;
+export declare const TokenSchema: z.ZodString;
+export declare const AddressSchema: z.ZodString;
+/**
+ * This schema is necessary because `z.coerce.bigint().optional()` throws
+ * with `undefined` input due to how coerce works (this happens even with safeParse)
+ * so we need a custom bigint that can receive number or string as input and be optional.
+ * */
+export declare const AmountSchema: z.ZodEffects<z.ZodPipeline<z.ZodUnion<[z.ZodBigInt, z.ZodNumber, z.ZodString]>, z.ZodBigInt>, bigint, string | number | bigint>;
+export declare const CountSchema: z.ZodPipeline<z.ZodUnion<[z.ZodNumber, z.ZodString]>, z.ZodNumber>;
+export declare const TxIndexSchema: z.ZodPipeline<z.ZodUnion<[z.ZodNumber, z.ZodString]>, z.ZodNumber>;
+export declare const RawInputInstruction: z.ZodObject<{
+    type: z.ZodLiteral<"input/raw">;
+    position: z.ZodDefault<z.ZodNumber>;
+    index: z.ZodUnion<[z.ZodString, z.ZodPipeline<z.ZodUnion<[z.ZodNumber, z.ZodString]>, z.ZodNumber>]>;
+    txId: z.ZodUnion<[z.ZodString, z.ZodString]>;
+}, "strip", z.ZodTypeAny, {
+    index: string | number;
+    type: "input/raw";
+    position: number;
+    txId: string;
+}, {
+    index: string | number;
+    type: "input/raw";
+    txId: string;
+    position?: number | undefined;
+}>;
+export declare const UtxoSelectInstruction: z.ZodObject<{
+    type: z.ZodLiteral<"input/utxo">;
+    position: z.ZodDefault<z.ZodNumber>;
+    fill: z.ZodUnion<[z.ZodString, z.ZodEffects<z.ZodPipeline<z.ZodUnion<[z.ZodBigInt, z.ZodNumber, z.ZodString]>, z.ZodBigInt>, bigint, string | number | bigint>]>;
+    token: z.ZodUnion<[z.ZodString, z.ZodDefault<z.ZodString>]>;
+    address: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+    autoChange: z.ZodDefault<z.ZodBoolean>;
+    changeAddress: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+}, "strip", z.ZodTypeAny, {
+    fill: string | bigint;
+    type: "input/utxo";
+    position: number;
+    token: string;
+    autoChange: boolean;
+    address?: string | undefined;
+    changeAddress?: string | undefined;
+}, {
+    fill: string | number | bigint;
+    type: "input/utxo";
+    address?: string | undefined;
+    position?: number | undefined;
+    token?: string | undefined;
+    changeAddress?: string | undefined;
+    autoChange?: boolean | undefined;
+}>;
+export declare const AuthoritySelectInstruction: z.ZodObject<{
+    type: z.ZodLiteral<"input/authority">;
+    position: z.ZodDefault<z.ZodNumber>;
+    authority: z.ZodEnum<["mint", "melt"]>;
+    token: z.ZodUnion<[z.ZodString, z.ZodString]>;
+    count: z.ZodUnion<[z.ZodString, z.ZodDefault<z.ZodPipeline<z.ZodUnion<[z.ZodNumber, z.ZodString]>, z.ZodNumber>>]>;
+    address: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+}, "strip", z.ZodTypeAny, {
+    type: "input/authority";
+    position: number;
+    token: string;
+    count: string | number;
+    authority: "mint" | "melt";
+    address?: string | undefined;
+}, {
+    type: "input/authority";
+    token: string;
+    authority: "mint" | "melt";
+    address?: string | undefined;
+    position?: number | undefined;
+    count?: string | number | undefined;
+}>;
+export declare const RawOutputInstruction: z.ZodObject<{
+    type: z.ZodLiteral<"output/raw">;
+    position: z.ZodDefault<z.ZodNumber>;
+    amount: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodEffects<z.ZodPipeline<z.ZodUnion<[z.ZodBigInt, z.ZodNumber, z.ZodString]>, z.ZodBigInt>, bigint, string | number | bigint>>]>;
+    script: z.ZodUnion<[z.ZodString, z.ZodString]>;
+    token: z.ZodUnion<[z.ZodString, z.ZodDefault<z.ZodString>]>;
+    timelock: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodNumber>]>;
+    authority: z.ZodOptional<z.ZodEnum<["mint", "melt"]>>;
+    useCreatedToken: z.ZodDefault<z.ZodBoolean>;
+}, "strip", z.ZodTypeAny, {
+    type: "output/raw";
+    position: number;
+    script: string;
+    token: string;
+    useCreatedToken: boolean;
+    timelock?: string | number | undefined;
+    amount?: string | bigint | undefined;
+    authority?: "mint" | "melt" | undefined;
+}, {
+    type: "output/raw";
+    script: string;
+    position?: number | undefined;
+    timelock?: string | number | undefined;
+    token?: string | undefined;
+    amount?: string | number | bigint | undefined;
+    authority?: "mint" | "melt" | undefined;
+    useCreatedToken?: boolean | undefined;
+}>;
+export declare const TokenOutputInstruction: z.ZodObject<{
+    type: z.ZodLiteral<"output/token">;
+    position: z.ZodDefault<z.ZodNumber>;
+    amount: z.ZodUnion<[z.ZodString, z.ZodEffects<z.ZodPipeline<z.ZodUnion<[z.ZodBigInt, z.ZodNumber, z.ZodString]>, z.ZodBigInt>, bigint, string | number | bigint>]>;
+    token: z.ZodUnion<[z.ZodString, z.ZodDefault<z.ZodString>]>;
+    address: z.ZodUnion<[z.ZodString, z.ZodString]>;
+    timelock: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodNumber>]>;
+    checkAddress: z.ZodOptional<z.ZodBoolean>;
+    useCreatedToken: z.ZodDefault<z.ZodBoolean>;
+}, "strip", z.ZodTypeAny, {
+    type: "output/token";
+    address: string;
+    position: number;
+    token: string;
+    amount: string | bigint;
+    useCreatedToken: boolean;
+    timelock?: string | number | undefined;
+    checkAddress?: boolean | undefined;
+}, {
+    type: "output/token";
+    address: string;
+    amount: string | number | bigint;
+    position?: number | undefined;
+    timelock?: string | number | undefined;
+    token?: string | undefined;
+    useCreatedToken?: boolean | undefined;
+    checkAddress?: boolean | undefined;
+}>;
+export declare const AuthorityOutputInstruction: z.ZodObject<{
+    type: z.ZodLiteral<"output/authority">;
+    position: z.ZodDefault<z.ZodNumber>;
+    count: z.ZodUnion<[z.ZodString, z.ZodDefault<z.ZodPipeline<z.ZodUnion<[z.ZodNumber, z.ZodString]>, z.ZodNumber>>]>;
+    token: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+    authority: z.ZodEnum<["mint", "melt"]>;
+    address: z.ZodUnion<[z.ZodString, z.ZodString]>;
+    timelock: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodNumber>]>;
+    checkAddress: z.ZodOptional<z.ZodBoolean>;
+    useCreatedToken: z.ZodDefault<z.ZodBoolean>;
+}, "strip", z.ZodTypeAny, {
+    type: "output/authority";
+    address: string;
+    position: number;
+    count: string | number;
+    authority: "mint" | "melt";
+    useCreatedToken: boolean;
+    timelock?: string | number | undefined;
+    token?: string | undefined;
+    checkAddress?: boolean | undefined;
+}, {
+    type: "output/authority";
+    address: string;
+    authority: "mint" | "melt";
+    position?: number | undefined;
+    timelock?: string | number | undefined;
+    token?: string | undefined;
+    count?: string | number | undefined;
+    useCreatedToken?: boolean | undefined;
+    checkAddress?: boolean | undefined;
+}>;
+export declare const DataOutputInstruction: z.ZodObject<{
+    type: z.ZodLiteral<"output/data">;
+    position: z.ZodDefault<z.ZodNumber>;
+    data: z.ZodUnion<[z.ZodString, z.ZodString]>;
+    token: z.ZodUnion<[z.ZodString, z.ZodDefault<z.ZodString>]>;
+    useCreatedToken: z.ZodDefault<z.ZodBoolean>;
+}, "strip", z.ZodTypeAny, {
+    type: "output/data";
+    data: string;
+    position: number;
+    token: string;
+    useCreatedToken: boolean;
+}, {
+    type: "output/data";
+    data: string;
+    position?: number | undefined;
+    token?: string | undefined;
+    useCreatedToken?: boolean | undefined;
+}>;
+export declare const ShuffleInstruction: z.ZodObject<{
+    type: z.ZodLiteral<"action/shuffle">;
+    target: z.ZodEnum<["inputs", "outputs", "all"]>;
+}, "strip", z.ZodTypeAny, {
+    type: "action/shuffle";
+    target: "all" | "inputs" | "outputs";
+}, {
+    type: "action/shuffle";
+    target: "all" | "inputs" | "outputs";
+}>;
+export declare const CompleteTxInstruction: z.ZodObject<{
+    type: z.ZodLiteral<"action/complete">;
+    token: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+    address: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+    changeAddress: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+    timelock: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodNumber>]>;
+    skipSelection: z.ZodDefault<z.ZodBoolean>;
+    skipChange: z.ZodDefault<z.ZodBoolean>;
+    skipAuthorities: z.ZodDefault<z.ZodBoolean>;
+    calculateFee: z.ZodDefault<z.ZodBoolean>;
+}, "strip", z.ZodTypeAny, {
+    type: "action/complete";
+    skipAuthorities: boolean;
+    skipSelection: boolean;
+    skipChange: boolean;
+    calculateFee: boolean;
+    address?: string | undefined;
+    timelock?: string | number | undefined;
+    token?: string | undefined;
+    changeAddress?: string | undefined;
+}, {
+    type: "action/complete";
+    address?: string | undefined;
+    timelock?: string | number | undefined;
+    token?: string | undefined;
+    changeAddress?: string | undefined;
+    skipAuthorities?: boolean | undefined;
+    skipSelection?: boolean | undefined;
+    skipChange?: boolean | undefined;
+    calculateFee?: boolean | undefined;
+}>;
+export declare const ConfigInstruction: z.ZodObject<{
+    type: z.ZodLiteral<"action/config">;
+    version: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodNumber>]>;
+    signalBits: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodNumber>]>;
+    createToken: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodBoolean>]>;
+    tokenName: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+    tokenSymbol: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+}, "strip", z.ZodTypeAny, {
+    type: "action/config";
+    signalBits?: string | number | undefined;
+    version?: string | number | undefined;
+    tokenName?: string | undefined;
+    tokenSymbol?: string | undefined;
+    createToken?: string | boolean | undefined;
+}, {
+    type: "action/config";
+    signalBits?: string | number | undefined;
+    version?: string | number | undefined;
+    tokenName?: string | undefined;
+    tokenSymbol?: string | undefined;
+    createToken?: string | boolean | undefined;
+}>;
+export declare const SetVarGetWalletAddressOpts: z.ZodObject<{
+    method: z.ZodLiteral<"get_wallet_address">;
+    index: z.ZodOptional<z.ZodNumber>;
+}, "strip", z.ZodTypeAny, {
+    method: "get_wallet_address";
+    index?: number | undefined;
+}, {
+    method: "get_wallet_address";
+    index?: number | undefined;
+}>;
+export declare const SetVarGetOracleScriptOpts: z.ZodObject<{
+    method: z.ZodLiteral<"get_oracle_script">;
+    index: z.ZodNumber;
+}, "strip", z.ZodTypeAny, {
+    index: number;
+    method: "get_oracle_script";
+}, {
+    index: number;
+    method: "get_oracle_script";
+}>;
+export declare const SetVarGetOracleSignedDataOpts: z.ZodObject<{
+    method: z.ZodLiteral<"get_oracle_signed_data">;
+    index: z.ZodNumber;
+    type: z.ZodString;
+    data: z.ZodUnion<[z.ZodString, z.ZodUnknown]>;
+    ncId: z.ZodUnion<[z.ZodString, z.ZodString]>;
+}, "strip", z.ZodTypeAny, {
+    index: number;
+    type: string;
+    method: "get_oracle_signed_data";
+    ncId: string;
+    data?: unknown;
+}, {
+    index: number;
+    type: string;
+    method: "get_oracle_signed_data";
+    ncId: string;
+    data?: unknown;
+}>;
+export declare const SetVarGetWalletBalanceOpts: z.ZodObject<{
+    method: z.ZodLiteral<"get_wallet_balance">;
+    token: z.ZodUnion<[z.ZodString, z.ZodDefault<z.ZodString>]>;
+    authority: z.ZodOptional<z.ZodEnum<["mint", "melt"]>>;
+}, "strip", z.ZodTypeAny, {
+    method: "get_wallet_balance";
+    token: string;
+    authority?: "mint" | "melt" | undefined;
+}, {
+    method: "get_wallet_balance";
+    token?: string | undefined;
+    authority?: "mint" | "melt" | undefined;
+}>;
+export declare const SetVarCallArgs: z.ZodDiscriminatedUnion<"method", [z.ZodObject<{
+    method: z.ZodLiteral<"get_wallet_address">;
+    index: z.ZodOptional<z.ZodNumber>;
+}, "strip", z.ZodTypeAny, {
+    method: "get_wallet_address";
+    index?: number | undefined;
+}, {
+    method: "get_wallet_address";
+    index?: number | undefined;
+}>, z.ZodObject<{
+    method: z.ZodLiteral<"get_wallet_balance">;
+    token: z.ZodUnion<[z.ZodString, z.ZodDefault<z.ZodString>]>;
+    authority: z.ZodOptional<z.ZodEnum<["mint", "melt"]>>;
+}, "strip", z.ZodTypeAny, {
+    method: "get_wallet_balance";
+    token: string;
+    authority?: "mint" | "melt" | undefined;
+}, {
+    method: "get_wallet_balance";
+    token?: string | undefined;
+    authority?: "mint" | "melt" | undefined;
+}>, z.ZodObject<{
+    method: z.ZodLiteral<"get_oracle_script">;
+    index: z.ZodNumber;
+}, "strip", z.ZodTypeAny, {
+    index: number;
+    method: "get_oracle_script";
+}, {
+    index: number;
+    method: "get_oracle_script";
+}>, z.ZodObject<{
+    method: z.ZodLiteral<"get_oracle_signed_data">;
+    index: z.ZodNumber;
+    type: z.ZodString;
+    data: z.ZodUnion<[z.ZodString, z.ZodUnknown]>;
+    ncId: z.ZodUnion<[z.ZodString, z.ZodString]>;
+}, "strip", z.ZodTypeAny, {
+    index: number;
+    type: string;
+    method: "get_oracle_signed_data";
+    ncId: string;
+    data?: unknown;
+}, {
+    index: number;
+    type: string;
+    method: "get_oracle_signed_data";
+    ncId: string;
+    data?: unknown;
+}>]>;
+export declare const SetVarInstruction: z.ZodObject<{
+    type: z.ZodLiteral<"action/setvar">;
+    name: z.ZodString;
+    value: z.ZodOptional<z.ZodUnknown>;
+    call: z.ZodOptional<z.ZodDiscriminatedUnion<"method", [z.ZodObject<{
+        method: z.ZodLiteral<"get_wallet_address">;
+        index: z.ZodOptional<z.ZodNumber>;
+    }, "strip", z.ZodTypeAny, {
+        method: "get_wallet_address";
+        index?: number | undefined;
+    }, {
+        method: "get_wallet_address";
+        index?: number | undefined;
+    }>, z.ZodObject<{
+        method: z.ZodLiteral<"get_wallet_balance">;
+        token: z.ZodUnion<[z.ZodString, z.ZodDefault<z.ZodString>]>;
+        authority: z.ZodOptional<z.ZodEnum<["mint", "melt"]>>;
+    }, "strip", z.ZodTypeAny, {
+        method: "get_wallet_balance";
+        token: string;
+        authority?: "mint" | "melt" | undefined;
+    }, {
+        method: "get_wallet_balance";
+        token?: string | undefined;
+        authority?: "mint" | "melt" | undefined;
+    }>, z.ZodObject<{
+        method: z.ZodLiteral<"get_oracle_script">;
+        index: z.ZodNumber;
+    }, "strip", z.ZodTypeAny, {
+        index: number;
+        method: "get_oracle_script";
+    }, {
+        index: number;
+        method: "get_oracle_script";
+    }>, z.ZodObject<{
+        method: z.ZodLiteral<"get_oracle_signed_data">;
+        index: z.ZodNumber;
+        type: z.ZodString;
+        data: z.ZodUnion<[z.ZodString, z.ZodUnknown]>;
+        ncId: z.ZodUnion<[z.ZodString, z.ZodString]>;
+    }, "strip", z.ZodTypeAny, {
+        index: number;
+        type: string;
+        method: "get_oracle_signed_data";
+        ncId: string;
+        data?: unknown;
+    }, {
+        index: number;
+        type: string;
+        method: "get_oracle_signed_data";
+        ncId: string;
+        data?: unknown;
+    }>]>>;
+}, "strip", z.ZodTypeAny, {
+    type: "action/setvar";
+    name: string;
+    value?: unknown;
+    call?: {
+        method: "get_wallet_address";
+        index?: number | undefined;
+    } | {
+        index: number;
+        method: "get_oracle_script";
+    } | {
+        index: number;
+        type: string;
+        method: "get_oracle_signed_data";
+        ncId: string;
+        data?: unknown;
+    } | {
+        method: "get_wallet_balance";
+        token: string;
+        authority?: "mint" | "melt" | undefined;
+    } | undefined;
+}, {
+    type: "action/setvar";
+    name: string;
+    value?: unknown;
+    call?: {
+        method: "get_wallet_address";
+        index?: number | undefined;
+    } | {
+        index: number;
+        method: "get_oracle_script";
+    } | {
+        index: number;
+        type: string;
+        method: "get_oracle_signed_data";
+        ncId: string;
+        data?: unknown;
+    } | {
+        method: "get_wallet_balance";
+        token?: string | undefined;
+        authority?: "mint" | "melt" | undefined;
+    } | undefined;
+}>;
+export declare const NanoDepositAction: z.ZodObject<{
+    action: z.ZodLiteral<"deposit">;
+    token: z.ZodUnion<[z.ZodString, z.ZodDefault<z.ZodString>]>;
+    useCreatedToken: z.ZodDefault<z.ZodBoolean>;
+    amount: z.ZodUnion<[z.ZodString, z.ZodEffects<z.ZodPipeline<z.ZodUnion<[z.ZodBigInt, z.ZodNumber, z.ZodString]>, z.ZodBigInt>, bigint, string | number | bigint>]>;
+    address: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+    autoChange: z.ZodDefault<z.ZodBoolean>;
+    changeAddress: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+    skipSelection: z.ZodDefault<z.ZodBoolean>;
+}, "strip", z.ZodTypeAny, {
+    action: "deposit";
+    token: string;
+    amount: string | bigint;
+    autoChange: boolean;
+    useCreatedToken: boolean;
+    skipSelection: boolean;
+    address?: string | undefined;
+    changeAddress?: string | undefined;
+}, {
+    action: "deposit";
+    amount: string | number | bigint;
+    address?: string | undefined;
+    token?: string | undefined;
+    changeAddress?: string | undefined;
+    autoChange?: boolean | undefined;
+    useCreatedToken?: boolean | undefined;
+    skipSelection?: boolean | undefined;
+}>;
+export declare const NanoWithdrawalAction: z.ZodObject<{
+    action: z.ZodLiteral<"withdrawal">;
+    token: z.ZodUnion<[z.ZodString, z.ZodDefault<z.ZodString>]>;
+    amount: z.ZodUnion<[z.ZodString, z.ZodEffects<z.ZodPipeline<z.ZodUnion<[z.ZodBigInt, z.ZodNumber, z.ZodString]>, z.ZodBigInt>, bigint, string | number | bigint>]>;
+    address: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+    skipOutputs: z.ZodDefault<z.ZodBoolean>;
+}, "strip", z.ZodTypeAny, {
+    action: "withdrawal";
+    token: string;
+    amount: string | bigint;
+    skipOutputs: boolean;
+    address?: string | undefined;
+}, {
+    action: "withdrawal";
+    amount: string | number | bigint;
+    address?: string | undefined;
+    token?: string | undefined;
+    skipOutputs?: boolean | undefined;
+}>;
+export declare const NanoGrantAuthorityAction: z.ZodObject<{
+    action: z.ZodLiteral<"grant_authority">;
+    token: z.ZodUnion<[z.ZodString, z.ZodString]>;
+    useCreatedToken: z.ZodDefault<z.ZodBoolean>;
+    authority: z.ZodEnum<["mint", "melt"]>;
+    address: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+    createAnotherTo: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+    skipSelection: z.ZodDefault<z.ZodBoolean>;
+}, "strip", z.ZodTypeAny, {
+    action: "grant_authority";
+    token: string;
+    authority: "mint" | "melt";
+    useCreatedToken: boolean;
+    skipSelection: boolean;
+    address?: string | undefined;
+    createAnotherTo?: string | undefined;
+}, {
+    action: "grant_authority";
+    token: string;
+    authority: "mint" | "melt";
+    address?: string | undefined;
+    useCreatedToken?: boolean | undefined;
+    skipSelection?: boolean | undefined;
+    createAnotherTo?: string | undefined;
+}>;
+export declare const NanoAcquireAuthorityAction: z.ZodObject<{
+    action: z.ZodLiteral<"acquire_authority">;
+    token: z.ZodUnion<[z.ZodString, z.ZodString]>;
+    authority: z.ZodEnum<["mint", "melt"]>;
+    address: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+    skipOutputs: z.ZodDefault<z.ZodBoolean>;
+}, "strip", z.ZodTypeAny, {
+    action: "acquire_authority";
+    token: string;
+    authority: "mint" | "melt";
+    skipOutputs: boolean;
+    address?: string | undefined;
+}, {
+    action: "acquire_authority";
+    token: string;
+    authority: "mint" | "melt";
+    address?: string | undefined;
+    skipOutputs?: boolean | undefined;
+}>;
+export declare const NanoAction: z.ZodUnion<[z.ZodObject<{
+    action: z.ZodLiteral<"deposit">;
+    token: z.ZodUnion<[z.ZodString, z.ZodDefault<z.ZodString>]>;
+    useCreatedToken: z.ZodDefault<z.ZodBoolean>;
+    amount: z.ZodUnion<[z.ZodString, z.ZodEffects<z.ZodPipeline<z.ZodUnion<[z.ZodBigInt, z.ZodNumber, z.ZodString]>, z.ZodBigInt>, bigint, string | number | bigint>]>;
+    address: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+    autoChange: z.ZodDefault<z.ZodBoolean>;
+    changeAddress: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+    skipSelection: z.ZodDefault<z.ZodBoolean>;
+}, "strip", z.ZodTypeAny, {
+    action: "deposit";
+    token: string;
+    amount: string | bigint;
+    autoChange: boolean;
+    useCreatedToken: boolean;
+    skipSelection: boolean;
+    address?: string | undefined;
+    changeAddress?: string | undefined;
+}, {
+    action: "deposit";
+    amount: string | number | bigint;
+    address?: string | undefined;
+    token?: string | undefined;
+    changeAddress?: string | undefined;
+    autoChange?: boolean | undefined;
+    useCreatedToken?: boolean | undefined;
+    skipSelection?: boolean | undefined;
+}>, z.ZodObject<{
+    action: z.ZodLiteral<"withdrawal">;
+    token: z.ZodUnion<[z.ZodString, z.ZodDefault<z.ZodString>]>;
+    amount: z.ZodUnion<[z.ZodString, z.ZodEffects<z.ZodPipeline<z.ZodUnion<[z.ZodBigInt, z.ZodNumber, z.ZodString]>, z.ZodBigInt>, bigint, string | number | bigint>]>;
+    address: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+    skipOutputs: z.ZodDefault<z.ZodBoolean>;
+}, "strip", z.ZodTypeAny, {
+    action: "withdrawal";
+    token: string;
+    amount: string | bigint;
+    skipOutputs: boolean;
+    address?: string | undefined;
+}, {
+    action: "withdrawal";
+    amount: string | number | bigint;
+    address?: string | undefined;
+    token?: string | undefined;
+    skipOutputs?: boolean | undefined;
+}>, z.ZodObject<{
+    action: z.ZodLiteral<"grant_authority">;
+    token: z.ZodUnion<[z.ZodString, z.ZodString]>;
+    useCreatedToken: z.ZodDefault<z.ZodBoolean>;
+    authority: z.ZodEnum<["mint", "melt"]>;
+    address: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+    createAnotherTo: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+    skipSelection: z.ZodDefault<z.ZodBoolean>;
+}, "strip", z.ZodTypeAny, {
+    action: "grant_authority";
+    token: string;
+    authority: "mint" | "melt";
+    useCreatedToken: boolean;
+    skipSelection: boolean;
+    address?: string | undefined;
+    createAnotherTo?: string | undefined;
+}, {
+    action: "grant_authority";
+    token: string;
+    authority: "mint" | "melt";
+    address?: string | undefined;
+    useCreatedToken?: boolean | undefined;
+    skipSelection?: boolean | undefined;
+    createAnotherTo?: string | undefined;
+}>, z.ZodObject<{
+    action: z.ZodLiteral<"acquire_authority">;
+    token: z.ZodUnion<[z.ZodString, z.ZodString]>;
+    authority: z.ZodEnum<["mint", "melt"]>;
+    address: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+    skipOutputs: z.ZodDefault<z.ZodBoolean>;
+}, "strip", z.ZodTypeAny, {
+    action: "acquire_authority";
+    token: string;
+    authority: "mint" | "melt";
+    skipOutputs: boolean;
+    address?: string | undefined;
+}, {
+    action: "acquire_authority";
+    token: string;
+    authority: "mint" | "melt";
+    address?: string | undefined;
+    skipOutputs?: boolean | undefined;
+}>]>;
+export declare const NanoMethodInstruction: z.ZodObject<{
+    type: z.ZodLiteral<"nano/execute">;
+    id: z.ZodUnion<[z.ZodString, z.ZodString]>;
+    method: z.ZodString;
+    args: z.ZodDefault<z.ZodArray<z.ZodUnion<[z.ZodString, z.ZodUnknown]>, "many">>;
+    caller: z.ZodUnion<[z.ZodString, z.ZodString]>;
+    actions: z.ZodDefault<z.ZodArray<z.ZodUnion<[z.ZodObject<{
+        action: z.ZodLiteral<"deposit">;
+        token: z.ZodUnion<[z.ZodString, z.ZodDefault<z.ZodString>]>;
+        useCreatedToken: z.ZodDefault<z.ZodBoolean>;
+        amount: z.ZodUnion<[z.ZodString, z.ZodEffects<z.ZodPipeline<z.ZodUnion<[z.ZodBigInt, z.ZodNumber, z.ZodString]>, z.ZodBigInt>, bigint, string | number | bigint>]>;
+        address: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+        autoChange: z.ZodDefault<z.ZodBoolean>;
+        changeAddress: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+        skipSelection: z.ZodDefault<z.ZodBoolean>;
+    }, "strip", z.ZodTypeAny, {
+        action: "deposit";
+        token: string;
+        amount: string | bigint;
+        autoChange: boolean;
+        useCreatedToken: boolean;
+        skipSelection: boolean;
+        address?: string | undefined;
+        changeAddress?: string | undefined;
+    }, {
+        action: "deposit";
+        amount: string | number | bigint;
+        address?: string | undefined;
+        token?: string | undefined;
+        changeAddress?: string | undefined;
+        autoChange?: boolean | undefined;
+        useCreatedToken?: boolean | undefined;
+        skipSelection?: boolean | undefined;
+    }>, z.ZodObject<{
+        action: z.ZodLiteral<"withdrawal">;
+        token: z.ZodUnion<[z.ZodString, z.ZodDefault<z.ZodString>]>;
+        amount: z.ZodUnion<[z.ZodString, z.ZodEffects<z.ZodPipeline<z.ZodUnion<[z.ZodBigInt, z.ZodNumber, z.ZodString]>, z.ZodBigInt>, bigint, string | number | bigint>]>;
+        address: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+        skipOutputs: z.ZodDefault<z.ZodBoolean>;
+    }, "strip", z.ZodTypeAny, {
+        action: "withdrawal";
+        token: string;
+        amount: string | bigint;
+        skipOutputs: boolean;
+        address?: string | undefined;
+    }, {
+        action: "withdrawal";
+        amount: string | number | bigint;
+        address?: string | undefined;
+        token?: string | undefined;
+        skipOutputs?: boolean | undefined;
+    }>, z.ZodObject<{
+        action: z.ZodLiteral<"grant_authority">;
+        token: z.ZodUnion<[z.ZodString, z.ZodString]>;
+        useCreatedToken: z.ZodDefault<z.ZodBoolean>;
+        authority: z.ZodEnum<["mint", "melt"]>;
+        address: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+        createAnotherTo: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+        skipSelection: z.ZodDefault<z.ZodBoolean>;
+    }, "strip", z.ZodTypeAny, {
+        action: "grant_authority";
+        token: string;
+        authority: "mint" | "melt";
+        useCreatedToken: boolean;
+        skipSelection: boolean;
+        address?: string | undefined;
+        createAnotherTo?: string | undefined;
+    }, {
+        action: "grant_authority";
+        token: string;
+        authority: "mint" | "melt";
+        address?: string | undefined;
+        useCreatedToken?: boolean | undefined;
+        skipSelection?: boolean | undefined;
+        createAnotherTo?: string | undefined;
+    }>, z.ZodObject<{
+        action: z.ZodLiteral<"acquire_authority">;
+        token: z.ZodUnion<[z.ZodString, z.ZodString]>;
+        authority: z.ZodEnum<["mint", "melt"]>;
+        address: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+        skipOutputs: z.ZodDefault<z.ZodBoolean>;
+    }, "strip", z.ZodTypeAny, {
+        action: "acquire_authority";
+        token: string;
+        authority: "mint" | "melt";
+        skipOutputs: boolean;
+        address?: string | undefined;
+    }, {
+        action: "acquire_authority";
+        token: string;
+        authority: "mint" | "melt";
+        address?: string | undefined;
+        skipOutputs?: boolean | undefined;
+    }>]>, "many">>;
+}, "strip", z.ZodTypeAny, {
+    type: "nano/execute";
+    id: string;
+    method: string;
+    args: unknown[];
+    actions: ({
+        action: "deposit";
+        token: string;
+        amount: string | bigint;
+        autoChange: boolean;
+        useCreatedToken: boolean;
+        skipSelection: boolean;
+        address?: string | undefined;
+        changeAddress?: string | undefined;
+    } | {
+        action: "withdrawal";
+        token: string;
+        amount: string | bigint;
+        skipOutputs: boolean;
+        address?: string | undefined;
+    } | {
+        action: "grant_authority";
+        token: string;
+        authority: "mint" | "melt";
+        useCreatedToken: boolean;
+        skipSelection: boolean;
+        address?: string | undefined;
+        createAnotherTo?: string | undefined;
+    } | {
+        action: "acquire_authority";
+        token: string;
+        authority: "mint" | "melt";
+        skipOutputs: boolean;
+        address?: string | undefined;
+    })[];
+    caller: string;
+}, {
+    type: "nano/execute";
+    id: string;
+    method: string;
+    caller: string;
+    args?: unknown[] | undefined;
+    actions?: ({
+        action: "deposit";
+        amount: string | number | bigint;
+        address?: string | undefined;
+        token?: string | undefined;
+        changeAddress?: string | undefined;
+        autoChange?: boolean | undefined;
+        useCreatedToken?: boolean | undefined;
+        skipSelection?: boolean | undefined;
+    } | {
+        action: "withdrawal";
+        amount: string | number | bigint;
+        address?: string | undefined;
+        token?: string | undefined;
+        skipOutputs?: boolean | undefined;
+    } | {
+        action: "grant_authority";
+        token: string;
+        authority: "mint" | "melt";
+        address?: string | undefined;
+        useCreatedToken?: boolean | undefined;
+        skipSelection?: boolean | undefined;
+        createAnotherTo?: string | undefined;
+    } | {
+        action: "acquire_authority";
+        token: string;
+        authority: "mint" | "melt";
+        address?: string | undefined;
+        skipOutputs?: boolean | undefined;
+    })[] | undefined;
+}>;
+export declare const TxTemplateInstruction: z.ZodDiscriminatedUnion<"type", [z.ZodObject<{
+    type: z.ZodLiteral<"input/raw">;
+    position: z.ZodDefault<z.ZodNumber>;
+    index: z.ZodUnion<[z.ZodString, z.ZodPipeline<z.ZodUnion<[z.ZodNumber, z.ZodString]>, z.ZodNumber>]>;
+    txId: z.ZodUnion<[z.ZodString, z.ZodString]>;
+}, "strip", z.ZodTypeAny, {
+    index: string | number;
+    type: "input/raw";
+    position: number;
+    txId: string;
+}, {
+    index: string | number;
+    type: "input/raw";
+    txId: string;
+    position?: number | undefined;
+}>, z.ZodObject<{
+    type: z.ZodLiteral<"input/utxo">;
+    position: z.ZodDefault<z.ZodNumber>;
+    fill: z.ZodUnion<[z.ZodString, z.ZodEffects<z.ZodPipeline<z.ZodUnion<[z.ZodBigInt, z.ZodNumber, z.ZodString]>, z.ZodBigInt>, bigint, string | number | bigint>]>;
+    token: z.ZodUnion<[z.ZodString, z.ZodDefault<z.ZodString>]>;
+    address: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+    autoChange: z.ZodDefault<z.ZodBoolean>;
+    changeAddress: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+}, "strip", z.ZodTypeAny, {
+    fill: string | bigint;
+    type: "input/utxo";
+    position: number;
+    token: string;
+    autoChange: boolean;
+    address?: string | undefined;
+    changeAddress?: string | undefined;
+}, {
+    fill: string | number | bigint;
+    type: "input/utxo";
+    address?: string | undefined;
+    position?: number | undefined;
+    token?: string | undefined;
+    changeAddress?: string | undefined;
+    autoChange?: boolean | undefined;
+}>, z.ZodObject<{
+    type: z.ZodLiteral<"input/authority">;
+    position: z.ZodDefault<z.ZodNumber>;
+    authority: z.ZodEnum<["mint", "melt"]>;
+    token: z.ZodUnion<[z.ZodString, z.ZodString]>;
+    count: z.ZodUnion<[z.ZodString, z.ZodDefault<z.ZodPipeline<z.ZodUnion<[z.ZodNumber, z.ZodString]>, z.ZodNumber>>]>;
+    address: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+}, "strip", z.ZodTypeAny, {
+    type: "input/authority";
+    position: number;
+    token: string;
+    count: string | number;
+    authority: "mint" | "melt";
+    address?: string | undefined;
+}, {
+    type: "input/authority";
+    token: string;
+    authority: "mint" | "melt";
+    address?: string | undefined;
+    position?: number | undefined;
+    count?: string | number | undefined;
+}>, z.ZodObject<{
+    type: z.ZodLiteral<"output/raw">;
+    position: z.ZodDefault<z.ZodNumber>;
+    amount: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodEffects<z.ZodPipeline<z.ZodUnion<[z.ZodBigInt, z.ZodNumber, z.ZodString]>, z.ZodBigInt>, bigint, string | number | bigint>>]>;
+    script: z.ZodUnion<[z.ZodString, z.ZodString]>;
+    token: z.ZodUnion<[z.ZodString, z.ZodDefault<z.ZodString>]>;
+    timelock: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodNumber>]>;
+    authority: z.ZodOptional<z.ZodEnum<["mint", "melt"]>>;
+    useCreatedToken: z.ZodDefault<z.ZodBoolean>;
+}, "strip", z.ZodTypeAny, {
+    type: "output/raw";
+    position: number;
+    script: string;
+    token: string;
+    useCreatedToken: boolean;
+    timelock?: string | number | undefined;
+    amount?: string | bigint | undefined;
+    authority?: "mint" | "melt" | undefined;
+}, {
+    type: "output/raw";
+    script: string;
+    position?: number | undefined;
+    timelock?: string | number | undefined;
+    token?: string | undefined;
+    amount?: string | number | bigint | undefined;
+    authority?: "mint" | "melt" | undefined;
+    useCreatedToken?: boolean | undefined;
+}>, z.ZodObject<{
+    type: z.ZodLiteral<"output/data">;
+    position: z.ZodDefault<z.ZodNumber>;
+    data: z.ZodUnion<[z.ZodString, z.ZodString]>;
+    token: z.ZodUnion<[z.ZodString, z.ZodDefault<z.ZodString>]>;
+    useCreatedToken: z.ZodDefault<z.ZodBoolean>;
+}, "strip", z.ZodTypeAny, {
+    type: "output/data";
+    data: string;
+    position: number;
+    token: string;
+    useCreatedToken: boolean;
+}, {
+    type: "output/data";
+    data: string;
+    position?: number | undefined;
+    token?: string | undefined;
+    useCreatedToken?: boolean | undefined;
+}>, z.ZodObject<{
+    type: z.ZodLiteral<"output/token">;
+    position: z.ZodDefault<z.ZodNumber>;
+    amount: z.ZodUnion<[z.ZodString, z.ZodEffects<z.ZodPipeline<z.ZodUnion<[z.ZodBigInt, z.ZodNumber, z.ZodString]>, z.ZodBigInt>, bigint, string | number | bigint>]>;
+    token: z.ZodUnion<[z.ZodString, z.ZodDefault<z.ZodString>]>;
+    address: z.ZodUnion<[z.ZodString, z.ZodString]>;
+    timelock: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodNumber>]>;
+    checkAddress: z.ZodOptional<z.ZodBoolean>;
+    useCreatedToken: z.ZodDefault<z.ZodBoolean>;
+}, "strip", z.ZodTypeAny, {
+    type: "output/token";
+    address: string;
+    position: number;
+    token: string;
+    amount: string | bigint;
+    useCreatedToken: boolean;
+    timelock?: string | number | undefined;
+    checkAddress?: boolean | undefined;
+}, {
+    type: "output/token";
+    address: string;
+    amount: string | number | bigint;
+    position?: number | undefined;
+    timelock?: string | number | undefined;
+    token?: string | undefined;
+    useCreatedToken?: boolean | undefined;
+    checkAddress?: boolean | undefined;
+}>, z.ZodObject<{
+    type: z.ZodLiteral<"output/authority">;
+    position: z.ZodDefault<z.ZodNumber>;
+    count: z.ZodUnion<[z.ZodString, z.ZodDefault<z.ZodPipeline<z.ZodUnion<[z.ZodNumber, z.ZodString]>, z.ZodNumber>>]>;
+    token: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+    authority: z.ZodEnum<["mint", "melt"]>;
+    address: z.ZodUnion<[z.ZodString, z.ZodString]>;
+    timelock: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodNumber>]>;
+    checkAddress: z.ZodOptional<z.ZodBoolean>;
+    useCreatedToken: z.ZodDefault<z.ZodBoolean>;
+}, "strip", z.ZodTypeAny, {
+    type: "output/authority";
+    address: string;
+    position: number;
+    count: string | number;
+    authority: "mint" | "melt";
+    useCreatedToken: boolean;
+    timelock?: string | number | undefined;
+    token?: string | undefined;
+    checkAddress?: boolean | undefined;
+}, {
+    type: "output/authority";
+    address: string;
+    authority: "mint" | "melt";
+    position?: number | undefined;
+    timelock?: string | number | undefined;
+    token?: string | undefined;
+    count?: string | number | undefined;
+    useCreatedToken?: boolean | undefined;
+    checkAddress?: boolean | undefined;
+}>, z.ZodObject<{
+    type: z.ZodLiteral<"action/shuffle">;
+    target: z.ZodEnum<["inputs", "outputs", "all"]>;
+}, "strip", z.ZodTypeAny, {
+    type: "action/shuffle";
+    target: "all" | "inputs" | "outputs";
+}, {
+    type: "action/shuffle";
+    target: "all" | "inputs" | "outputs";
+}>, z.ZodObject<{
+    type: z.ZodLiteral<"action/complete">;
+    token: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+    address: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+    changeAddress: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+    timelock: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodNumber>]>;
+    skipSelection: z.ZodDefault<z.ZodBoolean>;
+    skipChange: z.ZodDefault<z.ZodBoolean>;
+    skipAuthorities: z.ZodDefault<z.ZodBoolean>;
+    calculateFee: z.ZodDefault<z.ZodBoolean>;
+}, "strip", z.ZodTypeAny, {
+    type: "action/complete";
+    skipAuthorities: boolean;
+    skipSelection: boolean;
+    skipChange: boolean;
+    calculateFee: boolean;
+    address?: string | undefined;
+    timelock?: string | number | undefined;
+    token?: string | undefined;
+    changeAddress?: string | undefined;
+}, {
+    type: "action/complete";
+    address?: string | undefined;
+    timelock?: string | number | undefined;
+    token?: string | undefined;
+    changeAddress?: string | undefined;
+    skipAuthorities?: boolean | undefined;
+    skipSelection?: boolean | undefined;
+    skipChange?: boolean | undefined;
+    calculateFee?: boolean | undefined;
+}>, z.ZodObject<{
+    type: z.ZodLiteral<"action/config">;
+    version: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodNumber>]>;
+    signalBits: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodNumber>]>;
+    createToken: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodBoolean>]>;
+    tokenName: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+    tokenSymbol: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+}, "strip", z.ZodTypeAny, {
+    type: "action/config";
+    signalBits?: string | number | undefined;
+    version?: string | number | undefined;
+    tokenName?: string | undefined;
+    tokenSymbol?: string | undefined;
+    createToken?: string | boolean | undefined;
+}, {
+    type: "action/config";
+    signalBits?: string | number | undefined;
+    version?: string | number | undefined;
+    tokenName?: string | undefined;
+    tokenSymbol?: string | undefined;
+    createToken?: string | boolean | undefined;
+}>, z.ZodObject<{
+    type: z.ZodLiteral<"action/setvar">;
+    name: z.ZodString;
+    value: z.ZodOptional<z.ZodUnknown>;
+    call: z.ZodOptional<z.ZodDiscriminatedUnion<"method", [z.ZodObject<{
+        method: z.ZodLiteral<"get_wallet_address">;
+        index: z.ZodOptional<z.ZodNumber>;
+    }, "strip", z.ZodTypeAny, {
+        method: "get_wallet_address";
+        index?: number | undefined;
+    }, {
+        method: "get_wallet_address";
+        index?: number | undefined;
+    }>, z.ZodObject<{
+        method: z.ZodLiteral<"get_wallet_balance">;
+        token: z.ZodUnion<[z.ZodString, z.ZodDefault<z.ZodString>]>;
+        authority: z.ZodOptional<z.ZodEnum<["mint", "melt"]>>;
+    }, "strip", z.ZodTypeAny, {
+        method: "get_wallet_balance";
+        token: string;
+        authority?: "mint" | "melt" | undefined;
+    }, {
+        method: "get_wallet_balance";
+        token?: string | undefined;
+        authority?: "mint" | "melt" | undefined;
+    }>, z.ZodObject<{
+        method: z.ZodLiteral<"get_oracle_script">;
+        index: z.ZodNumber;
+    }, "strip", z.ZodTypeAny, {
+        index: number;
+        method: "get_oracle_script";
+    }, {
+        index: number;
+        method: "get_oracle_script";
+    }>, z.ZodObject<{
+        method: z.ZodLiteral<"get_oracle_signed_data">;
+        index: z.ZodNumber;
+        type: z.ZodString;
+        data: z.ZodUnion<[z.ZodString, z.ZodUnknown]>;
+        ncId: z.ZodUnion<[z.ZodString, z.ZodString]>;
+    }, "strip", z.ZodTypeAny, {
+        index: number;
+        type: string;
+        method: "get_oracle_signed_data";
+        ncId: string;
+        data?: unknown;
+    }, {
+        index: number;
+        type: string;
+        method: "get_oracle_signed_data";
+        ncId: string;
+        data?: unknown;
+    }>]>>;
+}, "strip", z.ZodTypeAny, {
+    type: "action/setvar";
+    name: string;
+    value?: unknown;
+    call?: {
+        method: "get_wallet_address";
+        index?: number | undefined;
+    } | {
+        index: number;
+        method: "get_oracle_script";
+    } | {
+        index: number;
+        type: string;
+        method: "get_oracle_signed_data";
+        ncId: string;
+        data?: unknown;
+    } | {
+        method: "get_wallet_balance";
+        token: string;
+        authority?: "mint" | "melt" | undefined;
+    } | undefined;
+}, {
+    type: "action/setvar";
+    name: string;
+    value?: unknown;
+    call?: {
+        method: "get_wallet_address";
+        index?: number | undefined;
+    } | {
+        index: number;
+        method: "get_oracle_script";
+    } | {
+        index: number;
+        type: string;
+        method: "get_oracle_signed_data";
+        ncId: string;
+        data?: unknown;
+    } | {
+        method: "get_wallet_balance";
+        token?: string | undefined;
+        authority?: "mint" | "melt" | undefined;
+    } | undefined;
+}>, z.ZodObject<{
+    type: z.ZodLiteral<"nano/execute">;
+    id: z.ZodUnion<[z.ZodString, z.ZodString]>;
+    method: z.ZodString;
+    args: z.ZodDefault<z.ZodArray<z.ZodUnion<[z.ZodString, z.ZodUnknown]>, "many">>;
+    caller: z.ZodUnion<[z.ZodString, z.ZodString]>;
+    actions: z.ZodDefault<z.ZodArray<z.ZodUnion<[z.ZodObject<{
+        action: z.ZodLiteral<"deposit">;
+        token: z.ZodUnion<[z.ZodString, z.ZodDefault<z.ZodString>]>;
+        useCreatedToken: z.ZodDefault<z.ZodBoolean>;
+        amount: z.ZodUnion<[z.ZodString, z.ZodEffects<z.ZodPipeline<z.ZodUnion<[z.ZodBigInt, z.ZodNumber, z.ZodString]>, z.ZodBigInt>, bigint, string | number | bigint>]>;
+        address: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+        autoChange: z.ZodDefault<z.ZodBoolean>;
+        changeAddress: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+        skipSelection: z.ZodDefault<z.ZodBoolean>;
+    }, "strip", z.ZodTypeAny, {
+        action: "deposit";
+        token: string;
+        amount: string | bigint;
+        autoChange: boolean;
+        useCreatedToken: boolean;
+        skipSelection: boolean;
+        address?: string | undefined;
+        changeAddress?: string | undefined;
+    }, {
+        action: "deposit";
+        amount: string | number | bigint;
+        address?: string | undefined;
+        token?: string | undefined;
+        changeAddress?: string | undefined;
+        autoChange?: boolean | undefined;
+        useCreatedToken?: boolean | undefined;
+        skipSelection?: boolean | undefined;
+    }>, z.ZodObject<{
+        action: z.ZodLiteral<"withdrawal">;
+        token: z.ZodUnion<[z.ZodString, z.ZodDefault<z.ZodString>]>;
+        amount: z.ZodUnion<[z.ZodString, z.ZodEffects<z.ZodPipeline<z.ZodUnion<[z.ZodBigInt, z.ZodNumber, z.ZodString]>, z.ZodBigInt>, bigint, string | number | bigint>]>;
+        address: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+        skipOutputs: z.ZodDefault<z.ZodBoolean>;
+    }, "strip", z.ZodTypeAny, {
+        action: "withdrawal";
+        token: string;
+        amount: string | bigint;
+        skipOutputs: boolean;
+        address?: string | undefined;
+    }, {
+        action: "withdrawal";
+        amount: string | number | bigint;
+        address?: string | undefined;
+        token?: string | undefined;
+        skipOutputs?: boolean | undefined;
+    }>, z.ZodObject<{
+        action: z.ZodLiteral<"grant_authority">;
+        token: z.ZodUnion<[z.ZodString, z.ZodString]>;
+        useCreatedToken: z.ZodDefault<z.ZodBoolean>;
+        authority: z.ZodEnum<["mint", "melt"]>;
+        address: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+        createAnotherTo: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+        skipSelection: z.ZodDefault<z.ZodBoolean>;
+    }, "strip", z.ZodTypeAny, {
+        action: "grant_authority";
+        token: string;
+        authority: "mint" | "melt";
+        useCreatedToken: boolean;
+        skipSelection: boolean;
+        address?: string | undefined;
+        createAnotherTo?: string | undefined;
+    }, {
+        action: "grant_authority";
+        token: string;
+        authority: "mint" | "melt";
+        address?: string | undefined;
+        useCreatedToken?: boolean | undefined;
+        skipSelection?: boolean | undefined;
+        createAnotherTo?: string | undefined;
+    }>, z.ZodObject<{
+        action: z.ZodLiteral<"acquire_authority">;
+        token: z.ZodUnion<[z.ZodString, z.ZodString]>;
+        authority: z.ZodEnum<["mint", "melt"]>;
+        address: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+        skipOutputs: z.ZodDefault<z.ZodBoolean>;
+    }, "strip", z.ZodTypeAny, {
+        action: "acquire_authority";
+        token: string;
+        authority: "mint" | "melt";
+        skipOutputs: boolean;
+        address?: string | undefined;
+    }, {
+        action: "acquire_authority";
+        token: string;
+        authority: "mint" | "melt";
+        address?: string | undefined;
+        skipOutputs?: boolean | undefined;
+    }>]>, "many">>;
+}, "strip", z.ZodTypeAny, {
+    type: "nano/execute";
+    id: string;
+    method: string;
+    args: unknown[];
+    actions: ({
+        action: "deposit";
+        token: string;
+        amount: string | bigint;
+        autoChange: boolean;
+        useCreatedToken: boolean;
+        skipSelection: boolean;
+        address?: string | undefined;
+        changeAddress?: string | undefined;
+    } | {
+        action: "withdrawal";
+        token: string;
+        amount: string | bigint;
+        skipOutputs: boolean;
+        address?: string | undefined;
+    } | {
+        action: "grant_authority";
+        token: string;
+        authority: "mint" | "melt";
+        useCreatedToken: boolean;
+        skipSelection: boolean;
+        address?: string | undefined;
+        createAnotherTo?: string | undefined;
+    } | {
+        action: "acquire_authority";
+        token: string;
+        authority: "mint" | "melt";
+        skipOutputs: boolean;
+        address?: string | undefined;
+    })[];
+    caller: string;
+}, {
+    type: "nano/execute";
+    id: string;
+    method: string;
+    caller: string;
+    args?: unknown[] | undefined;
+    actions?: ({
+        action: "deposit";
+        amount: string | number | bigint;
+        address?: string | undefined;
+        token?: string | undefined;
+        changeAddress?: string | undefined;
+        autoChange?: boolean | undefined;
+        useCreatedToken?: boolean | undefined;
+        skipSelection?: boolean | undefined;
+    } | {
+        action: "withdrawal";
+        amount: string | number | bigint;
+        address?: string | undefined;
+        token?: string | undefined;
+        skipOutputs?: boolean | undefined;
+    } | {
+        action: "grant_authority";
+        token: string;
+        authority: "mint" | "melt";
+        address?: string | undefined;
+        useCreatedToken?: boolean | undefined;
+        skipSelection?: boolean | undefined;
+        createAnotherTo?: string | undefined;
+    } | {
+        action: "acquire_authority";
+        token: string;
+        authority: "mint" | "melt";
+        address?: string | undefined;
+        skipOutputs?: boolean | undefined;
+    })[] | undefined;
+}>]>;
+export declare const TransactionTemplate: z.ZodArray<z.ZodDiscriminatedUnion<"type", [z.ZodObject<{
+    type: z.ZodLiteral<"input/raw">;
+    position: z.ZodDefault<z.ZodNumber>;
+    index: z.ZodUnion<[z.ZodString, z.ZodPipeline<z.ZodUnion<[z.ZodNumber, z.ZodString]>, z.ZodNumber>]>;
+    txId: z.ZodUnion<[z.ZodString, z.ZodString]>;
+}, "strip", z.ZodTypeAny, {
+    index: string | number;
+    type: "input/raw";
+    position: number;
+    txId: string;
+}, {
+    index: string | number;
+    type: "input/raw";
+    txId: string;
+    position?: number | undefined;
+}>, z.ZodObject<{
+    type: z.ZodLiteral<"input/utxo">;
+    position: z.ZodDefault<z.ZodNumber>;
+    fill: z.ZodUnion<[z.ZodString, z.ZodEffects<z.ZodPipeline<z.ZodUnion<[z.ZodBigInt, z.ZodNumber, z.ZodString]>, z.ZodBigInt>, bigint, string | number | bigint>]>;
+    token: z.ZodUnion<[z.ZodString, z.ZodDefault<z.ZodString>]>;
+    address: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+    autoChange: z.ZodDefault<z.ZodBoolean>;
+    changeAddress: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+}, "strip", z.ZodTypeAny, {
+    fill: string | bigint;
+    type: "input/utxo";
+    position: number;
+    token: string;
+    autoChange: boolean;
+    address?: string | undefined;
+    changeAddress?: string | undefined;
+}, {
+    fill: string | number | bigint;
+    type: "input/utxo";
+    address?: string | undefined;
+    position?: number | undefined;
+    token?: string | undefined;
+    changeAddress?: string | undefined;
+    autoChange?: boolean | undefined;
+}>, z.ZodObject<{
+    type: z.ZodLiteral<"input/authority">;
+    position: z.ZodDefault<z.ZodNumber>;
+    authority: z.ZodEnum<["mint", "melt"]>;
+    token: z.ZodUnion<[z.ZodString, z.ZodString]>;
+    count: z.ZodUnion<[z.ZodString, z.ZodDefault<z.ZodPipeline<z.ZodUnion<[z.ZodNumber, z.ZodString]>, z.ZodNumber>>]>;
+    address: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+}, "strip", z.ZodTypeAny, {
+    type: "input/authority";
+    position: number;
+    token: string;
+    count: string | number;
+    authority: "mint" | "melt";
+    address?: string | undefined;
+}, {
+    type: "input/authority";
+    token: string;
+    authority: "mint" | "melt";
+    address?: string | undefined;
+    position?: number | undefined;
+    count?: string | number | undefined;
+}>, z.ZodObject<{
+    type: z.ZodLiteral<"output/raw">;
+    position: z.ZodDefault<z.ZodNumber>;
+    amount: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodEffects<z.ZodPipeline<z.ZodUnion<[z.ZodBigInt, z.ZodNumber, z.ZodString]>, z.ZodBigInt>, bigint, string | number | bigint>>]>;
+    script: z.ZodUnion<[z.ZodString, z.ZodString]>;
+    token: z.ZodUnion<[z.ZodString, z.ZodDefault<z.ZodString>]>;
+    timelock: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodNumber>]>;
+    authority: z.ZodOptional<z.ZodEnum<["mint", "melt"]>>;
+    useCreatedToken: z.ZodDefault<z.ZodBoolean>;
+}, "strip", z.ZodTypeAny, {
+    type: "output/raw";
+    position: number;
+    script: string;
+    token: string;
+    useCreatedToken: boolean;
+    timelock?: string | number | undefined;
+    amount?: string | bigint | undefined;
+    authority?: "mint" | "melt" | undefined;
+}, {
+    type: "output/raw";
+    script: string;
+    position?: number | undefined;
+    timelock?: string | number | undefined;
+    token?: string | undefined;
+    amount?: string | number | bigint | undefined;
+    authority?: "mint" | "melt" | undefined;
+    useCreatedToken?: boolean | undefined;
+}>, z.ZodObject<{
+    type: z.ZodLiteral<"output/data">;
+    position: z.ZodDefault<z.ZodNumber>;
+    data: z.ZodUnion<[z.ZodString, z.ZodString]>;
+    token: z.ZodUnion<[z.ZodString, z.ZodDefault<z.ZodString>]>;
+    useCreatedToken: z.ZodDefault<z.ZodBoolean>;
+}, "strip", z.ZodTypeAny, {
+    type: "output/data";
+    data: string;
+    position: number;
+    token: string;
+    useCreatedToken: boolean;
+}, {
+    type: "output/data";
+    data: string;
+    position?: number | undefined;
+    token?: string | undefined;
+    useCreatedToken?: boolean | undefined;
+}>, z.ZodObject<{
+    type: z.ZodLiteral<"output/token">;
+    position: z.ZodDefault<z.ZodNumber>;
+    amount: z.ZodUnion<[z.ZodString, z.ZodEffects<z.ZodPipeline<z.ZodUnion<[z.ZodBigInt, z.ZodNumber, z.ZodString]>, z.ZodBigInt>, bigint, string | number | bigint>]>;
+    token: z.ZodUnion<[z.ZodString, z.ZodDefault<z.ZodString>]>;
+    address: z.ZodUnion<[z.ZodString, z.ZodString]>;
+    timelock: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodNumber>]>;
+    checkAddress: z.ZodOptional<z.ZodBoolean>;
+    useCreatedToken: z.ZodDefault<z.ZodBoolean>;
+}, "strip", z.ZodTypeAny, {
+    type: "output/token";
+    address: string;
+    position: number;
+    token: string;
+    amount: string | bigint;
+    useCreatedToken: boolean;
+    timelock?: string | number | undefined;
+    checkAddress?: boolean | undefined;
+}, {
+    type: "output/token";
+    address: string;
+    amount: string | number | bigint;
+    position?: number | undefined;
+    timelock?: string | number | undefined;
+    token?: string | undefined;
+    useCreatedToken?: boolean | undefined;
+    checkAddress?: boolean | undefined;
+}>, z.ZodObject<{
+    type: z.ZodLiteral<"output/authority">;
+    position: z.ZodDefault<z.ZodNumber>;
+    count: z.ZodUnion<[z.ZodString, z.ZodDefault<z.ZodPipeline<z.ZodUnion<[z.ZodNumber, z.ZodString]>, z.ZodNumber>>]>;
+    token: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+    authority: z.ZodEnum<["mint", "melt"]>;
+    address: z.ZodUnion<[z.ZodString, z.ZodString]>;
+    timelock: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodNumber>]>;
+    checkAddress: z.ZodOptional<z.ZodBoolean>;
+    useCreatedToken: z.ZodDefault<z.ZodBoolean>;
+}, "strip", z.ZodTypeAny, {
+    type: "output/authority";
+    address: string;
+    position: number;
+    count: string | number;
+    authority: "mint" | "melt";
+    useCreatedToken: boolean;
+    timelock?: string | number | undefined;
+    token?: string | undefined;
+    checkAddress?: boolean | undefined;
+}, {
+    type: "output/authority";
+    address: string;
+    authority: "mint" | "melt";
+    position?: number | undefined;
+    timelock?: string | number | undefined;
+    token?: string | undefined;
+    count?: string | number | undefined;
+    useCreatedToken?: boolean | undefined;
+    checkAddress?: boolean | undefined;
+}>, z.ZodObject<{
+    type: z.ZodLiteral<"action/shuffle">;
+    target: z.ZodEnum<["inputs", "outputs", "all"]>;
+}, "strip", z.ZodTypeAny, {
+    type: "action/shuffle";
+    target: "all" | "inputs" | "outputs";
+}, {
+    type: "action/shuffle";
+    target: "all" | "inputs" | "outputs";
+}>, z.ZodObject<{
+    type: z.ZodLiteral<"action/complete">;
+    token: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+    address: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+    changeAddress: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+    timelock: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodNumber>]>;
+    skipSelection: z.ZodDefault<z.ZodBoolean>;
+    skipChange: z.ZodDefault<z.ZodBoolean>;
+    skipAuthorities: z.ZodDefault<z.ZodBoolean>;
+    calculateFee: z.ZodDefault<z.ZodBoolean>;
+}, "strip", z.ZodTypeAny, {
+    type: "action/complete";
+    skipAuthorities: boolean;
+    skipSelection: boolean;
+    skipChange: boolean;
+    calculateFee: boolean;
+    address?: string | undefined;
+    timelock?: string | number | undefined;
+    token?: string | undefined;
+    changeAddress?: string | undefined;
+}, {
+    type: "action/complete";
+    address?: string | undefined;
+    timelock?: string | number | undefined;
+    token?: string | undefined;
+    changeAddress?: string | undefined;
+    skipAuthorities?: boolean | undefined;
+    skipSelection?: boolean | undefined;
+    skipChange?: boolean | undefined;
+    calculateFee?: boolean | undefined;
+}>, z.ZodObject<{
+    type: z.ZodLiteral<"action/config">;
+    version: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodNumber>]>;
+    signalBits: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodNumber>]>;
+    createToken: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodBoolean>]>;
+    tokenName: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+    tokenSymbol: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+}, "strip", z.ZodTypeAny, {
+    type: "action/config";
+    signalBits?: string | number | undefined;
+    version?: string | number | undefined;
+    tokenName?: string | undefined;
+    tokenSymbol?: string | undefined;
+    createToken?: string | boolean | undefined;
+}, {
+    type: "action/config";
+    signalBits?: string | number | undefined;
+    version?: string | number | undefined;
+    tokenName?: string | undefined;
+    tokenSymbol?: string | undefined;
+    createToken?: string | boolean | undefined;
+}>, z.ZodObject<{
+    type: z.ZodLiteral<"action/setvar">;
+    name: z.ZodString;
+    value: z.ZodOptional<z.ZodUnknown>;
+    call: z.ZodOptional<z.ZodDiscriminatedUnion<"method", [z.ZodObject<{
+        method: z.ZodLiteral<"get_wallet_address">;
+        index: z.ZodOptional<z.ZodNumber>;
+    }, "strip", z.ZodTypeAny, {
+        method: "get_wallet_address";
+        index?: number | undefined;
+    }, {
+        method: "get_wallet_address";
+        index?: number | undefined;
+    }>, z.ZodObject<{
+        method: z.ZodLiteral<"get_wallet_balance">;
+        token: z.ZodUnion<[z.ZodString, z.ZodDefault<z.ZodString>]>;
+        authority: z.ZodOptional<z.ZodEnum<["mint", "melt"]>>;
+    }, "strip", z.ZodTypeAny, {
+        method: "get_wallet_balance";
+        token: string;
+        authority?: "mint" | "melt" | undefined;
+    }, {
+        method: "get_wallet_balance";
+        token?: string | undefined;
+        authority?: "mint" | "melt" | undefined;
+    }>, z.ZodObject<{
+        method: z.ZodLiteral<"get_oracle_script">;
+        index: z.ZodNumber;
+    }, "strip", z.ZodTypeAny, {
+        index: number;
+        method: "get_oracle_script";
+    }, {
+        index: number;
+        method: "get_oracle_script";
+    }>, z.ZodObject<{
+        method: z.ZodLiteral<"get_oracle_signed_data">;
+        index: z.ZodNumber;
+        type: z.ZodString;
+        data: z.ZodUnion<[z.ZodString, z.ZodUnknown]>;
+        ncId: z.ZodUnion<[z.ZodString, z.ZodString]>;
+    }, "strip", z.ZodTypeAny, {
+        index: number;
+        type: string;
+        method: "get_oracle_signed_data";
+        ncId: string;
+        data?: unknown;
+    }, {
+        index: number;
+        type: string;
+        method: "get_oracle_signed_data";
+        ncId: string;
+        data?: unknown;
+    }>]>>;
+}, "strip", z.ZodTypeAny, {
+    type: "action/setvar";
+    name: string;
+    value?: unknown;
+    call?: {
+        method: "get_wallet_address";
+        index?: number | undefined;
+    } | {
+        index: number;
+        method: "get_oracle_script";
+    } | {
+        index: number;
+        type: string;
+        method: "get_oracle_signed_data";
+        ncId: string;
+        data?: unknown;
+    } | {
+        method: "get_wallet_balance";
+        token: string;
+        authority?: "mint" | "melt" | undefined;
+    } | undefined;
+}, {
+    type: "action/setvar";
+    name: string;
+    value?: unknown;
+    call?: {
+        method: "get_wallet_address";
+        index?: number | undefined;
+    } | {
+        index: number;
+        method: "get_oracle_script";
+    } | {
+        index: number;
+        type: string;
+        method: "get_oracle_signed_data";
+        ncId: string;
+        data?: unknown;
+    } | {
+        method: "get_wallet_balance";
+        token?: string | undefined;
+        authority?: "mint" | "melt" | undefined;
+    } | undefined;
+}>, z.ZodObject<{
+    type: z.ZodLiteral<"nano/execute">;
+    id: z.ZodUnion<[z.ZodString, z.ZodString]>;
+    method: z.ZodString;
+    args: z.ZodDefault<z.ZodArray<z.ZodUnion<[z.ZodString, z.ZodUnknown]>, "many">>;
+    caller: z.ZodUnion<[z.ZodString, z.ZodString]>;
+    actions: z.ZodDefault<z.ZodArray<z.ZodUnion<[z.ZodObject<{
+        action: z.ZodLiteral<"deposit">;
+        token: z.ZodUnion<[z.ZodString, z.ZodDefault<z.ZodString>]>;
+        useCreatedToken: z.ZodDefault<z.ZodBoolean>;
+        amount: z.ZodUnion<[z.ZodString, z.ZodEffects<z.ZodPipeline<z.ZodUnion<[z.ZodBigInt, z.ZodNumber, z.ZodString]>, z.ZodBigInt>, bigint, string | number | bigint>]>;
+        address: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+        autoChange: z.ZodDefault<z.ZodBoolean>;
+        changeAddress: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+        skipSelection: z.ZodDefault<z.ZodBoolean>;
+    }, "strip", z.ZodTypeAny, {
+        action: "deposit";
+        token: string;
+        amount: string | bigint;
+        autoChange: boolean;
+        useCreatedToken: boolean;
+        skipSelection: boolean;
+        address?: string | undefined;
+        changeAddress?: string | undefined;
+    }, {
+        action: "deposit";
+        amount: string | number | bigint;
+        address?: string | undefined;
+        token?: string | undefined;
+        changeAddress?: string | undefined;
+        autoChange?: boolean | undefined;
+        useCreatedToken?: boolean | undefined;
+        skipSelection?: boolean | undefined;
+    }>, z.ZodObject<{
+        action: z.ZodLiteral<"withdrawal">;
+        token: z.ZodUnion<[z.ZodString, z.ZodDefault<z.ZodString>]>;
+        amount: z.ZodUnion<[z.ZodString, z.ZodEffects<z.ZodPipeline<z.ZodUnion<[z.ZodBigInt, z.ZodNumber, z.ZodString]>, z.ZodBigInt>, bigint, string | number | bigint>]>;
+        address: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+        skipOutputs: z.ZodDefault<z.ZodBoolean>;
+    }, "strip", z.ZodTypeAny, {
+        action: "withdrawal";
+        token: string;
+        amount: string | bigint;
+        skipOutputs: boolean;
+        address?: string | undefined;
+    }, {
+        action: "withdrawal";
+        amount: string | number | bigint;
+        address?: string | undefined;
+        token?: string | undefined;
+        skipOutputs?: boolean | undefined;
+    }>, z.ZodObject<{
+        action: z.ZodLiteral<"grant_authority">;
+        token: z.ZodUnion<[z.ZodString, z.ZodString]>;
+        useCreatedToken: z.ZodDefault<z.ZodBoolean>;
+        authority: z.ZodEnum<["mint", "melt"]>;
+        address: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+        createAnotherTo: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+        skipSelection: z.ZodDefault<z.ZodBoolean>;
+    }, "strip", z.ZodTypeAny, {
+        action: "grant_authority";
+        token: string;
+        authority: "mint" | "melt";
+        useCreatedToken: boolean;
+        skipSelection: boolean;
+        address?: string | undefined;
+        createAnotherTo?: string | undefined;
+    }, {
+        action: "grant_authority";
+        token: string;
+        authority: "mint" | "melt";
+        address?: string | undefined;
+        useCreatedToken?: boolean | undefined;
+        skipSelection?: boolean | undefined;
+        createAnotherTo?: string | undefined;
+    }>, z.ZodObject<{
+        action: z.ZodLiteral<"acquire_authority">;
+        token: z.ZodUnion<[z.ZodString, z.ZodString]>;
+        authority: z.ZodEnum<["mint", "melt"]>;
+        address: z.ZodUnion<[z.ZodString, z.ZodOptional<z.ZodString>]>;
+        skipOutputs: z.ZodDefault<z.ZodBoolean>;
+    }, "strip", z.ZodTypeAny, {
+        action: "acquire_authority";
+        token: string;
+        authority: "mint" | "melt";
+        skipOutputs: boolean;
+        address?: string | undefined;
+    }, {
+        action: "acquire_authority";
+        token: string;
+        authority: "mint" | "melt";
+        address?: string | undefined;
+        skipOutputs?: boolean | undefined;
+    }>]>, "many">>;
+}, "strip", z.ZodTypeAny, {
+    type: "nano/execute";
+    id: string;
+    method: string;
+    args: unknown[];
+    actions: ({
+        action: "deposit";
+        token: string;
+        amount: string | bigint;
+        autoChange: boolean;
+        useCreatedToken: boolean;
+        skipSelection: boolean;
+        address?: string | undefined;
+        changeAddress?: string | undefined;
+    } | {
+        action: "withdrawal";
+        token: string;
+        amount: string | bigint;
+        skipOutputs: boolean;
+        address?: string | undefined;
+    } | {
+        action: "grant_authority";
+        token: string;
+        authority: "mint" | "melt";
+        useCreatedToken: boolean;
+        skipSelection: boolean;
+        address?: string | undefined;
+        createAnotherTo?: string | undefined;
+    } | {
+        action: "acquire_authority";
+        token: string;
+        authority: "mint" | "melt";
+        skipOutputs: boolean;
+        address?: string | undefined;
+    })[];
+    caller: string;
+}, {
+    type: "nano/execute";
+    id: string;
+    method: string;
+    caller: string;
+    args?: unknown[] | undefined;
+    actions?: ({
+        action: "deposit";
+        amount: string | number | bigint;
+        address?: string | undefined;
+        token?: string | undefined;
+        changeAddress?: string | undefined;
+        autoChange?: boolean | undefined;
+        useCreatedToken?: boolean | undefined;
+        skipSelection?: boolean | undefined;
+    } | {
+        action: "withdrawal";
+        amount: string | number | bigint;
+        address?: string | undefined;
+        token?: string | undefined;
+        skipOutputs?: boolean | undefined;
+    } | {
+        action: "grant_authority";
+        token: string;
+        authority: "mint" | "melt";
+        address?: string | undefined;
+        useCreatedToken?: boolean | undefined;
+        skipSelection?: boolean | undefined;
+        createAnotherTo?: string | undefined;
+    } | {
+        action: "acquire_authority";
+        token: string;
+        authority: "mint" | "melt";
+        address?: string | undefined;
+        skipOutputs?: boolean | undefined;
+    })[] | undefined;
+}>]>, "many">;
+//# sourceMappingURL=instructions.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/template/transaction/instructions.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/template/transaction/instructions.d.ts.map
new file mode 100644
index 0000000..f9b028a
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/template/transaction/instructions.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"instructions.d.ts","sourceRoot":"","sources":["../../../src/template/transaction/instructions.ts"],"names":[],"mappings":"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;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IAahC,CAAC;AAEH,eAAO,MAAM,mBAAmB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;aAAiC,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/template/transaction/instructions.js b/node_modules/@hathor/wallet-lib/oldLib/template/transaction/instructions.js
new file mode 100644
index 0000000..982bbcc
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/template/transaction/instructions.js
@@ -0,0 +1,239 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.UtxoSelectInstruction = exports.TxTemplateInstruction = exports.TxIndexSchema = exports.TxIdSchema = exports.TransactionTemplate = exports.TokenSchema = exports.TokenOutputInstruction = exports.TemplateRef = exports.ShuffleInstruction = exports.Sha256HexSchema = exports.SetVarInstruction = exports.SetVarGetWalletBalanceOpts = exports.SetVarGetWalletAddressOpts = exports.SetVarGetOracleSignedDataOpts = exports.SetVarGetOracleScriptOpts = exports.SetVarCallArgs = exports.RawOutputInstruction = exports.RawInputInstruction = exports.NanoWithdrawalAction = exports.NanoMethodInstruction = exports.NanoGrantAuthorityAction = exports.NanoDepositAction = exports.NanoAction = exports.NanoAcquireAuthorityAction = exports.DataOutputInstruction = exports.CustomTokenSchema = exports.CountSchema = exports.ConfigInstruction = exports.CompleteTxInstruction = exports.AuthoritySelectInstruction = exports.AuthorityOutputInstruction = exports.AmountSchema = exports.AddressSchema = void 0;
+exports.getVariable = getVariable;
+var _zod = require("zod");
+var _constants = require("../../constants");
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+const TEMPLATE_REFERENCE_NAME_RE = /[\w\d]+/;
+const TEMPLATE_REFERENCE_RE = /\{([\w\d]+)\}/;
+const TemplateRef = exports.TemplateRef = _zod.z.string().regex(TEMPLATE_REFERENCE_RE);
+
+/**
+ * If the key matches a template reference (i.e. `{name}`) it returns the variable of that name.
+ * If not the ref should be the actual value.
+ * This is validated by the `schema` argument which is a ZodType that parses either:
+ *   - A `TemplateRef` or;
+ *   - A ZodType that outputs `S`;
+ *
+ * The generic system allows with just the first argument a validation that the
+ * schema will parse to the expected type and that `ref` is `string | S`.
+ * This way changes on validation affect the executors and the value from vars
+ * will be of the expected type.
+ * The goal of this system is to avoid too much verbosity while keeping strong cohesive typing.
+ *
+ * @example
+ * ```
+ * const TokenSchema = TemplateRef.or(z.string().regex(/^[A-F0-9]{64}&1/));
+ * const AmountSchema = TemplateRef.or(z.bigint());
+ * const IndexSchema = TemplateRef.or(z.number().min(0));
+ *
+ * const token: string = getVariable<string>(ref1, {foo: 'bar'}, TokenSchema);
+ * const amount: bigint = getVariable<bigint>(ref2, {foo: 10n}, AmountSchema);
+ * const token: string = getVariable<number>(ref3, {foo: 27}, IndexSchema);
+ * ```
+ */
+function getVariable(ref, vars, schema) {
+  let val = ref; // type should be: string | S
+  const parsed = TemplateRef.safeParse(ref);
+  if (parsed.success) {
+    const match = parsed.data.match(TEMPLATE_REFERENCE_RE);
+    if (match !== null) {
+      const key = match[1];
+      if (!(key in vars)) {
+        throw new Error(`Variable ${key} not found in available variables`);
+      }
+      // We assume that the variable in the context is of type S and we validate this.
+      // The case where a `{...}` string is saved is not possible since we do not
+      // allow this type of string as variable.
+      val = vars[key];
+    }
+  }
+  return schema.parse(val);
+}
+
+// Transaction IDs and Custom Tokens are sha256 hex encoded
+const Sha256HexSchema = exports.Sha256HexSchema = _zod.z.string().regex(/^[a-fA-F0-9]{64}$/);
+const TxIdSchema = exports.TxIdSchema = Sha256HexSchema;
+const CustomTokenSchema = exports.CustomTokenSchema = Sha256HexSchema;
+// If we want to represent all tokens we need to include the native token uid 00
+const TokenSchema = exports.TokenSchema = _zod.z.string().regex(/^[a-fA-F0-9]{64}$|^00$/);
+// Addresses are base58 with length 34, may be 35 depending on the choice of version byte
+const AddressSchema = exports.AddressSchema = _zod.z.string().regex(/^[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{34,35}$/);
+
+/**
+ * This schema is necessary because `z.coerce.bigint().optional()` throws
+ * with `undefined` input due to how coerce works (this happens even with safeParse)
+ * so we need a custom bigint that can receive number or string as input and be optional.
+ * */
+const AmountSchema = exports.AmountSchema = _zod.z.union([_zod.z.bigint(), _zod.z.number(), _zod.z.string().regex(/^\d+$/)]).pipe(_zod.z.coerce.bigint()).refine(val => val > 0n, 'Amount must be positive non-zero');
+const CountSchema = exports.CountSchema = _zod.z.union([_zod.z.number(), _zod.z.string().regex(/^\d+$/)]).pipe(_zod.z.coerce.number().gte(1).lte(0xff));
+const TxIndexSchema = exports.TxIndexSchema = _zod.z.union([_zod.z.number(), _zod.z.string().regex(/^\d+$/)]).pipe(_zod.z.coerce.number().gte(0).lte(0xff));
+const RawInputInstruction = exports.RawInputInstruction = _zod.z.object({
+  type: _zod.z.literal('input/raw'),
+  position: _zod.z.number().default(-1),
+  index: TemplateRef.or(TxIndexSchema),
+  txId: TemplateRef.or(TxIdSchema)
+});
+const UtxoSelectInstruction = exports.UtxoSelectInstruction = _zod.z.object({
+  type: _zod.z.literal('input/utxo'),
+  position: _zod.z.number().default(-1),
+  fill: TemplateRef.or(AmountSchema),
+  token: TemplateRef.or(TokenSchema.default(_constants.NATIVE_TOKEN_UID)),
+  address: TemplateRef.or(AddressSchema.optional()),
+  autoChange: _zod.z.boolean().default(true),
+  changeAddress: TemplateRef.or(AddressSchema.optional())
+});
+const AuthoritySelectInstruction = exports.AuthoritySelectInstruction = _zod.z.object({
+  type: _zod.z.literal('input/authority'),
+  position: _zod.z.number().default(-1),
+  authority: _zod.z.enum(['mint', 'melt']),
+  token: TemplateRef.or(CustomTokenSchema),
+  count: TemplateRef.or(CountSchema.default(1)),
+  address: TemplateRef.or(AddressSchema.optional())
+});
+const RawOutputInstruction = exports.RawOutputInstruction = _zod.z.object({
+  type: _zod.z.literal('output/raw'),
+  position: _zod.z.number().default(-1),
+  amount: TemplateRef.or(AmountSchema.optional()),
+  script: TemplateRef.or(_zod.z.string().regex(/^([a-fA-F0-9]{2})+$/)),
+  token: TemplateRef.or(TokenSchema.default(_constants.NATIVE_TOKEN_UID)),
+  timelock: TemplateRef.or(_zod.z.number().gte(0).optional()),
+  authority: _zod.z.enum(['mint', 'melt']).optional(),
+  useCreatedToken: _zod.z.boolean().default(false)
+});
+const TokenOutputInstruction = exports.TokenOutputInstruction = _zod.z.object({
+  type: _zod.z.literal('output/token'),
+  position: _zod.z.number().default(-1),
+  amount: TemplateRef.or(AmountSchema),
+  token: TemplateRef.or(TokenSchema.default(_constants.NATIVE_TOKEN_UID)),
+  address: TemplateRef.or(AddressSchema),
+  timelock: TemplateRef.or(_zod.z.number().gte(0).optional()),
+  checkAddress: _zod.z.boolean().optional(),
+  useCreatedToken: _zod.z.boolean().default(false)
+});
+const AuthorityOutputInstruction = exports.AuthorityOutputInstruction = _zod.z.object({
+  type: _zod.z.literal('output/authority'),
+  position: _zod.z.number().default(-1),
+  count: TemplateRef.or(CountSchema.default(1)),
+  token: TemplateRef.or(CustomTokenSchema.optional()),
+  authority: _zod.z.enum(['mint', 'melt']),
+  address: TemplateRef.or(AddressSchema),
+  timelock: TemplateRef.or(_zod.z.number().gte(0).optional()),
+  checkAddress: _zod.z.boolean().optional(),
+  useCreatedToken: _zod.z.boolean().default(false)
+});
+const DataOutputInstruction = exports.DataOutputInstruction = _zod.z.object({
+  type: _zod.z.literal('output/data'),
+  position: _zod.z.number().default(-1),
+  data: TemplateRef.or(_zod.z.string()),
+  token: TemplateRef.or(TokenSchema.default(_constants.NATIVE_TOKEN_UID)),
+  useCreatedToken: _zod.z.boolean().default(false)
+});
+const ShuffleInstruction = exports.ShuffleInstruction = _zod.z.object({
+  type: _zod.z.literal('action/shuffle'),
+  target: _zod.z.enum(['inputs', 'outputs', 'all'])
+});
+const CompleteTxInstruction = exports.CompleteTxInstruction = _zod.z.object({
+  type: _zod.z.literal('action/complete'),
+  token: TemplateRef.or(TokenSchema.optional()),
+  address: TemplateRef.or(_zod.z.string().optional()),
+  changeAddress: TemplateRef.or(AddressSchema.optional()),
+  timelock: TemplateRef.or(_zod.z.number().gte(0).optional()),
+  skipSelection: _zod.z.boolean().default(false),
+  // do NOT add inputs to the tx
+  skipChange: _zod.z.boolean().default(false),
+  // do NOT add outputs from outstanding tokens.
+  skipAuthorities: _zod.z.boolean().default(false),
+  // Only select tokens
+  calculateFee: _zod.z.boolean().default(false) // For token creation
+});
+const ConfigInstruction = exports.ConfigInstruction = _zod.z.object({
+  type: _zod.z.literal('action/config'),
+  version: TemplateRef.or(_zod.z.number().gte(0).lte(0xff).optional()),
+  signalBits: TemplateRef.or(_zod.z.number().gte(0).lte(0xff).optional()),
+  createToken: TemplateRef.or(_zod.z.boolean().optional()),
+  tokenName: TemplateRef.or(_zod.z.string().min(1).max(30).optional()),
+  tokenSymbol: TemplateRef.or(_zod.z.string().min(1).max(5).optional())
+});
+const SetVarGetWalletAddressOpts = exports.SetVarGetWalletAddressOpts = _zod.z.object({
+  method: _zod.z.literal('get_wallet_address'),
+  index: _zod.z.number().optional()
+});
+const SetVarGetOracleScriptOpts = exports.SetVarGetOracleScriptOpts = _zod.z.object({
+  method: _zod.z.literal('get_oracle_script'),
+  index: _zod.z.number()
+});
+const SetVarGetOracleSignedDataOpts = exports.SetVarGetOracleSignedDataOpts = _zod.z.object({
+  method: _zod.z.literal('get_oracle_signed_data'),
+  index: _zod.z.number(),
+  type: _zod.z.string(),
+  data: TemplateRef.or(_zod.z.unknown()),
+  ncId: TemplateRef.or(TxIdSchema)
+});
+const SetVarGetWalletBalanceOpts = exports.SetVarGetWalletBalanceOpts = _zod.z.object({
+  method: _zod.z.literal('get_wallet_balance'),
+  token: TemplateRef.or(TokenSchema.default('00')),
+  authority: _zod.z.enum(['mint', 'melt']).optional()
+});
+const SetVarCallArgs = exports.SetVarCallArgs = _zod.z.discriminatedUnion('method', [SetVarGetWalletAddressOpts, SetVarGetWalletBalanceOpts, SetVarGetOracleScriptOpts, SetVarGetOracleSignedDataOpts]);
+const SetVarInstruction = exports.SetVarInstruction = _zod.z.object({
+  type: _zod.z.literal('action/setvar'),
+  name: _zod.z.string().regex(TEMPLATE_REFERENCE_NAME_RE),
+  value: _zod.z.unknown().optional(),
+  call: SetVarCallArgs.optional()
+});
+const NanoDepositAction = exports.NanoDepositAction = _zod.z.object({
+  action: _zod.z.literal('deposit'),
+  token: TemplateRef.or(TokenSchema.default('00')),
+  useCreatedToken: _zod.z.boolean().default(false),
+  amount: TemplateRef.or(AmountSchema),
+  address: TemplateRef.or(AddressSchema.optional()),
+  autoChange: _zod.z.boolean().default(true),
+  changeAddress: TemplateRef.or(AddressSchema.optional()),
+  skipSelection: _zod.z.boolean().default(false)
+});
+const NanoWithdrawalAction = exports.NanoWithdrawalAction = _zod.z.object({
+  action: _zod.z.literal('withdrawal'),
+  token: TemplateRef.or(TokenSchema.default('00')),
+  amount: TemplateRef.or(AmountSchema),
+  address: TemplateRef.or(AddressSchema.optional()),
+  skipOutputs: _zod.z.boolean().default(false)
+});
+const NanoGrantAuthorityAction = exports.NanoGrantAuthorityAction = _zod.z.object({
+  action: _zod.z.literal('grant_authority'),
+  token: TemplateRef.or(CustomTokenSchema),
+  useCreatedToken: _zod.z.boolean().default(false),
+  authority: _zod.z.enum(['mint', 'melt']),
+  address: TemplateRef.or(AddressSchema.optional()),
+  createAnotherTo: TemplateRef.or(AddressSchema.optional()),
+  skipSelection: _zod.z.boolean().default(false)
+});
+const NanoAcquireAuthorityAction = exports.NanoAcquireAuthorityAction = _zod.z.object({
+  action: _zod.z.literal('acquire_authority'),
+  token: TemplateRef.or(CustomTokenSchema),
+  authority: _zod.z.enum(['mint', 'melt']),
+  address: TemplateRef.or(AddressSchema.optional()),
+  skipOutputs: _zod.z.boolean().default(false)
+});
+const NanoAction = exports.NanoAction = _zod.z.union([NanoDepositAction, NanoWithdrawalAction, NanoGrantAuthorityAction, NanoAcquireAuthorityAction]);
+const NanoMethodInstruction = exports.NanoMethodInstruction = _zod.z.object({
+  type: _zod.z.literal('nano/execute'),
+  // Nano Contract id or Blueprint id, depending on the method
+  id: TemplateRef.or(Sha256HexSchema),
+  method: _zod.z.string(),
+  args: TemplateRef.or(_zod.z.unknown()).array().default([]),
+  caller: TemplateRef.or(AddressSchema),
+  actions: NanoAction.array().default([])
+});
+const TxTemplateInstruction = exports.TxTemplateInstruction = _zod.z.discriminatedUnion('type', [RawInputInstruction, UtxoSelectInstruction, AuthoritySelectInstruction, RawOutputInstruction, DataOutputInstruction, TokenOutputInstruction, AuthorityOutputInstruction, ShuffleInstruction, CompleteTxInstruction, ConfigInstruction, SetVarInstruction, NanoMethodInstruction]);
+const TransactionTemplate = exports.TransactionTemplate = _zod.z.array(TxTemplateInstruction);
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/template/transaction/interpreter.d.ts b/node_modules/@hathor/wallet-lib/oldLib/template/transaction/interpreter.d.ts
new file mode 100644
index 0000000..6e37c9f
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/template/transaction/interpreter.d.ts
@@ -0,0 +1,41 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+import { z } from 'zod';
+import { TransactionTemplate, NanoAction } from './instructions';
+import { TxTemplateContext, NanoContractContext } from './context';
+import { ITxTemplateInterpreter, IGetUtxosOptions, IGetUtxoResponse, IWalletBalanceData, TxInstance } from './types';
+import { IHistoryTx, OutputValueType } from '../../types';
+import { IHathorWallet, Utxo } from '../../wallet/types';
+import HathorWallet from '../../new/wallet';
+import Network from '../../models/network';
+import NanoContractHeader from '../../nano_contracts/header';
+import { NanoContractActionHeader } from '../../nano_contracts/types';
+export declare class WalletTxTemplateInterpreter implements ITxTemplateInterpreter {
+    wallet: HathorWallet;
+    txCache: Record<string, IHistoryTx>;
+    constructor(wallet: HathorWallet);
+    getBlueprintId(nanoCtx: NanoContractContext): Promise<string>;
+    static mapActionInstructionToAction(ctx: TxTemplateContext, action: z.output<typeof NanoAction>): NanoContractActionHeader;
+    buildNanoHeader(ctx: TxTemplateContext): Promise<NanoContractHeader>;
+    build(instructions: z.infer<typeof TransactionTemplate>, debug?: boolean): Promise<TxInstance>;
+    buildAndSign(instructions: z.infer<typeof TransactionTemplate>, pinCode: string, debug?: boolean): Promise<TxInstance>;
+    getAddress(markAsUsed?: boolean): Promise<string>;
+    getAddressAtIndex(index: number): Promise<string>;
+    getBalance(token: string): Promise<IWalletBalanceData>;
+    /**
+     * XXX: maybe we can save the change address chosen on the context.
+     * This way the same change address would be used throughout the transaction
+     */
+    getChangeAddress(_ctx: TxTemplateContext): Promise<any>;
+    getUtxos(amount: OutputValueType, options: IGetUtxosOptions): Promise<IGetUtxoResponse>;
+    getAuthorities(count: number, options: IGetUtxosOptions): Promise<Utxo[]>;
+    getTx(txId: string): Promise<IHistoryTx>;
+    getNetwork(): Network;
+    getWallet(): IHathorWallet;
+    getHTRDeposit(mintAmount: OutputValueType): OutputValueType;
+}
+//# sourceMappingURL=interpreter.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/template/transaction/interpreter.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/template/transaction/interpreter.d.ts.map
new file mode 100644
index 0000000..eb9d697
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/template/transaction/interpreter.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"interpreter.d.ts","sourceRoot":"","sources":["../../../src/template/transaction/interpreter.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;AAEH,OAAO,EAAE,CAAC,EAAE,MAAM,KAAK,CAAC;AAExB,OAAO,EAAE,mBAAmB,EAAE,UAAU,EAAE,MAAM,gBAAgB,CAAC;AAEjE,OAAO,EAAE,iBAAiB,EAAE,mBAAmB,EAAE,MAAM,WAAW,CAAC;AACnE,OAAO,EACL,sBAAsB,EACtB,gBAAgB,EAChB,gBAAgB,EAChB,kBAAkB,EAClB,UAAU,EACX,MAAM,SAAS,CAAC;AACjB,OAAO,EAAE,UAAU,EAAE,eAAe,EAAE,MAAM,aAAa,CAAC;AAC1D,OAAO,EAAE,aAAa,EAAE,IAAI,EAAE,MAAM,oBAAoB,CAAC;AAGzD,OAAO,YAAY,MAAM,kBAAkB,CAAC;AAW5C,OAAO,OAAO,MAAM,sBAAsB,CAAC;AAE3C,OAAO,kBAAkB,MAAM,6BAA6B,CAAC;AAC7D,OAAO,EAAgC,wBAAwB,EAAE,MAAM,4BAA4B,CAAC;AAIpG,qBAAa,2BAA4B,YAAW,sBAAsB;IACxE,MAAM,EAAE,YAAY,CAAC;IAErB,OAAO,EAAE,MAAM,CAAC,MAAM,EAAE,UAAU,CAAC,CAAC;gBAExB,MAAM,EAAE,YAAY;IAK1B,cAAc,CAAC,OAAO,EAAE,mBAAmB,GAAG,OAAO,CAAC,MAAM,CAAC;IAmBnE,MAAM,CAAC,4BAA4B,CACjC,GAAG,EAAE,iBAAiB,EACtB,MAAM,EAAE,CAAC,CAAC,MAAM,CAAC,OAAO,UAAU,CAAC,GAClC,wBAAwB;IAwCrB,eAAe,CAAC,GAAG,EAAE,iBAAiB,GAAG,OAAO,CAAC,kBAAkB,CAAC;IA0CpE,KAAK,CACT,YAAY,EAAE,CAAC,CAAC,KAAK,CAAC,OAAO,mBAAmB,CAAC,EACjD,KAAK,GAAE,OAAe,GACrB,OAAO,CAAC,UAAU,CAAC;IAoChB,YAAY,CAChB,YAAY,EAAE,CAAC,CAAC,KAAK,CAAC,OAAO,mBAAmB,CAAC,EACjD,OAAO,EAAE,MAAM,EACf,KAAK,GAAE,OAAe,GACrB,OAAO,CAAC,UAAU,CAAC;IAOhB,UAAU,CAAC,UAAU,GAAE,OAAe,GAAG,OAAO,CAAC,MAAM,CAAC;IAKxD,iBAAiB,CAAC,KAAK,EAAE,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;IAIjD,UAAU,CAAC,KAAK,EAAE,MAAM,GAAG,OAAO,CAAC,kBAAkB,CAAC;IAK5D;;;OAGG;IACG,gBAAgB,CAAC,IAAI,EAAE,iBAAiB;IAKxC,QAAQ,CAAC,MAAM,EAAE,eAAe,EAAE,OAAO,EAAE,gBAAgB,GAAG,OAAO,CAAC,gBAAgB,CAAC;IAKvF,cAAc,CAAC,KAAK,EAAE,MAAM,EAAE,OAAO,EAAE,gBAAgB,GAAG,OAAO,CAAC,IAAI,EAAE,CAAC;IAazE,KAAK,CAAC,IAAI,EAAE,MAAM,GAAG,OAAO,CAAC,UAAU,CAAC;IAkB9C,UAAU,IAAI,OAAO;IAIrB,SAAS,IAAI,aAAa;IAI1B,aAAa,CAAC,UAAU,EAAE,eAAe,GAAG,eAAe;CAG5D"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/template/transaction/interpreter.js b/node_modules/@hathor/wallet-lib/oldLib/template/transaction/interpreter.js
new file mode 100644
index 0000000..b92bcd7
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/template/transaction/interpreter.js
@@ -0,0 +1,242 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.WalletTxTemplateInterpreter = void 0;
+var _zod = require("zod");
+var _instructions = require("./instructions");
+var _executor = require("./executor");
+var _context = require("./context");
+var _transaction = _interopRequireDefault(require("../../models/transaction"));
+var _address = _interopRequireDefault(require("../../models/address"));
+var _constants = require("../../constants");
+var _transaction2 = _interopRequireDefault(require("../../utils/transaction"));
+var _leb = _interopRequireDefault(require("../../utils/leb128"));
+var _tokens = _interopRequireDefault(require("../../utils/tokens"));
+var _create_token_transaction = _interopRequireDefault(require("../../models/create_token_transaction"));
+var _header = _interopRequireDefault(require("../../nano_contracts/header"));
+var _types = require("../../nano_contracts/types");
+var _utils = require("../../nano_contracts/utils");
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
+function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
+function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
+function _asyncIterator(r) { var n, t, o, e = 2; for ("undefined" != typeof Symbol && (t = Symbol.asyncIterator, o = Symbol.iterator); e--;) { if (t && null != (n = r[t])) return n.call(r); if (o && null != (n = r[o])) return new AsyncFromSyncIterator(n.call(r)); t = "@@asyncIterator", o = "@@iterator"; } throw new TypeError("Object is not async iterable"); }
+function AsyncFromSyncIterator(r) { function AsyncFromSyncIteratorContinuation(r) { if (Object(r) !== r) return Promise.reject(new TypeError(r + " is not an object.")); var n = r.done; return Promise.resolve(r.value).then(function (r) { return { value: r, done: n }; }); } return AsyncFromSyncIterator = function (r) { this.s = r, this.n = r.next; }, AsyncFromSyncIterator.prototype = { s: null, n: null, next: function () { return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments)); }, return: function (r) { var n = this.s.return; return void 0 === n ? Promise.resolve({ value: r, done: !0 }) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments)); }, throw: function (r) { var n = this.s.return; return void 0 === n ? Promise.reject(r) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments)); } }, new AsyncFromSyncIterator(r); } /**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+class WalletTxTemplateInterpreter {
+  constructor(wallet) {
+    _defineProperty(this, "wallet", void 0);
+    _defineProperty(this, "txCache", void 0);
+    this.wallet = wallet;
+    this.txCache = {};
+  }
+  async getBlueprintId(nanoCtx) {
+    if (nanoCtx.method === _constants.NANO_CONTRACTS_INITIALIZE_METHOD) {
+      return nanoCtx.id;
+    }
+    let response;
+    try {
+      response = await this.wallet.getFullTxById(nanoCtx.id);
+    } catch (ex) {
+      throw new Error(`Error getting nano contract transaction with id ${nanoCtx.id}.`);
+    }
+    if (!response.tx.nc_id) {
+      throw new Error(`Transaction ${nanoCtx.id} is not a nano contract.`);
+    }
+    return response.tx.nc_blueprint_id;
+  }
+  static mapActionInstructionToAction(ctx, action) {
+    const tokens = ctx.tokens.map(t => ({
+      uid: t,
+      name: '',
+      symbol: ''
+    }));
+    const {
+      token
+    } = action;
+    let amount = 0n;
+
+    // Prepare amount
+    if (action.action === 'deposit' || action.action === 'withdrawal') {
+      // This parse is because action.amount may be a template reference name.
+      // The actual amount is discovered when running the instructions and inputed on the action.
+      // So this should be a bigint, but if it is not (for any reason) we would throw an error.
+      amount = _zod.z.bigint().parse(action.amount);
+    }
+    if (action.action === 'grant_authority' || action.action === 'acquire_authority') {
+      if (action.authority === 'mint') {
+        amount += _constants.TOKEN_MINT_MASK;
+      }
+      if (action.authority === 'melt') {
+        amount += _constants.TOKEN_MELT_MASK;
+      }
+    }
+    if (amount === 0n) {
+      throw new Error('Action amount cannot be zero');
+    }
+    let tokenIndex = 0;
+    // Prepare tokenIndex
+    if (action.action === 'deposit' || action.action === 'grant_authority') {
+      tokenIndex = action.useCreatedToken ? 1 : _tokens.default.getTokenIndex(tokens, token);
+    }
+    if (action.action === 'withdrawal' || action.action === 'acquire_authority') {
+      tokenIndex = _tokens.default.getTokenIndex(tokens, token);
+    }
+    return {
+      type: _types.ActionTypeToActionHeaderType[action.action],
+      amount,
+      tokenIndex
+    };
+  }
+  async buildNanoHeader(ctx) {
+    const nanoCtx = ctx.nanoContext;
+    if (!nanoCtx) {
+      throw new Error('Cannot build the header without the nano context data');
+    }
+    const blueprintId = await this.getBlueprintId(nanoCtx);
+    const network = this.getNetwork();
+    const address = new _address.default(nanoCtx.caller, {
+      network
+    });
+    try {
+      address.validateAddress();
+    } catch (err) {
+      const message = err instanceof Error ? err.message : 'Could not validate caller address';
+      throw new Error(message);
+    }
+    const args = await (0, _utils.validateAndParseBlueprintMethodArgs)(blueprintId, nanoCtx.method, nanoCtx.args, network);
+    const arr = [_leb.default.encodeUnsigned(args.length)];
+    args.forEach(arg => {
+      arr.push(arg.field.toBuffer());
+    });
+    const serializedArgs = Buffer.concat(arr);
+    const seqnum = await this.wallet.getNanoHeaderSeqnum(address);
+    const nanoHeaderActions = nanoCtx.actions.map(action => WalletTxTemplateInterpreter.mapActionInstructionToAction(ctx, action));
+    return new _header.default(nanoCtx.id, nanoCtx.method, serializedArgs, nanoHeaderActions, seqnum, address, null);
+  }
+  async build(instructions, debug = false) {
+    const context = new _context.TxTemplateContext(this.wallet.logger, debug);
+    for (const ins of _instructions.TransactionTemplate.parse(instructions)) {
+      await (0, _executor.runInstruction)(this, context, ins);
+    }
+    const headers = [];
+    if (context.nanoContext) {
+      const nanoHeader = await this.buildNanoHeader(context);
+      headers.push(nanoHeader);
+    }
+    if (context.version === _constants.DEFAULT_TX_VERSION) {
+      return new _transaction.default(context.inputs, context.outputs, {
+        signalBits: context.signalBits,
+        version: context.version,
+        tokens: context.tokens,
+        headers
+      });
+    }
+    if (context.version === _constants.CREATE_TOKEN_TX_VERSION) {
+      if (!context.tokenName || !context.tokenSymbol) {
+        throw new Error('Cannot create a token without a name or symbol');
+      }
+      return new _create_token_transaction.default(context.tokenName, context.tokenSymbol, context.inputs, context.outputs, {
+        signalBits: context.signalBits,
+        headers
+      });
+    }
+    throw new Error('Unsupported Version byte provided');
+  }
+  async buildAndSign(instructions, pinCode, debug = false) {
+    let tx = await this.build(instructions, debug);
+    tx = await _transaction2.default.signTransaction(tx, this.wallet.storage, pinCode);
+    tx.prepareToSend();
+    return tx;
+  }
+  async getAddress(markAsUsed = false) {
+    const addr = await this.wallet.getCurrentAddress({
+      markAsUsed
+    });
+    return addr.address;
+  }
+  async getAddressAtIndex(index) {
+    return this.wallet.getAddressAtIndex(index);
+  }
+  async getBalance(token) {
+    const balance = await this.wallet.getBalance(token);
+    return balance[0];
+  }
+
+  /**
+   * XXX: maybe we can save the change address chosen on the context.
+   * This way the same change address would be used throughout the transaction
+   */
+  async getChangeAddress(_ctx) {
+    const addr = await this.wallet.getCurrentAddress();
+    return addr.address;
+  }
+  async getUtxos(amount, options) {
+    // XXX: This may throw, but maybe we should let it.
+    return this.wallet.getUtxosForAmount(amount, options);
+  }
+  async getAuthorities(count, options) {
+    const newOptions = {
+      ...options,
+      max_utxos: count
+    };
+    const utxos = [];
+    // XXX: This may throw, but maybe we should let it.
+    var _iteratorAbruptCompletion = false;
+    var _didIteratorError = false;
+    var _iteratorError;
+    try {
+      for (var _iterator = _asyncIterator(this.wallet.storage.selectUtxos(newOptions)), _step; _iteratorAbruptCompletion = !(_step = await _iterator.next()).done; _iteratorAbruptCompletion = false) {
+        const utxo = _step.value;
+        {
+          utxos.push(utxo);
+        }
+      }
+    } catch (err) {
+      _didIteratorError = true;
+      _iteratorError = err;
+    } finally {
+      try {
+        if (_iteratorAbruptCompletion && _iterator.return != null) {
+          await _iterator.return();
+        }
+      } finally {
+        if (_didIteratorError) {
+          throw _iteratorError;
+        }
+      }
+    }
+    return utxos;
+  }
+  async getTx(txId) {
+    if (this.txCache[txId]) {
+      return this.txCache[txId];
+    }
+    const histtx = await this.wallet.getTx(txId);
+    if (histtx) {
+      this.txCache[txId] = histtx;
+      return this.txCache[txId];
+    }
+    const resp = await this.wallet.getFullTxById(txId);
+    // We can assume the wallet handles any network errors
+    const normalizedTx = _transaction2.default.convertFullNodeTxToHistoryTx(resp);
+    this.txCache[txId] = normalizedTx;
+    return this.txCache[txId];
+  }
+  getNetwork() {
+    return this.wallet.getNetworkObject();
+  }
+  getWallet() {
+    return this.wallet;
+  }
+  getHTRDeposit(mintAmount) {
+    return _tokens.default.getMintDeposit(mintAmount, this.wallet.storage);
+  }
+}
+exports.WalletTxTemplateInterpreter = WalletTxTemplateInterpreter;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/template/transaction/setvarcommands.d.ts b/node_modules/@hathor/wallet-lib/oldLib/template/transaction/setvarcommands.d.ts
new file mode 100644
index 0000000..a16519e
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/template/transaction/setvarcommands.d.ts
@@ -0,0 +1,16 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+import { z } from 'zod';
+import { ITxTemplateInterpreter } from './types';
+import { TxTemplateContext } from './context';
+import { SetVarGetOracleScriptOpts, SetVarGetOracleSignedDataOpts, SetVarGetWalletAddressOpts, SetVarGetWalletBalanceOpts } from './instructions';
+import { IUserSignedData } from '../../nano_contracts/fields/signedData';
+export declare function getWalletAddress(interpreter: ITxTemplateInterpreter, _ctx: TxTemplateContext, options: z.infer<typeof SetVarGetWalletAddressOpts>): Promise<string>;
+export declare function getWalletBalance(interpreter: ITxTemplateInterpreter, _ctx: TxTemplateContext, options: z.infer<typeof SetVarGetWalletBalanceOpts>): Promise<number | bigint>;
+export declare function getOracleScript(interpreter: ITxTemplateInterpreter, _ctx: TxTemplateContext, options: z.infer<typeof SetVarGetOracleScriptOpts>): Promise<string>;
+export declare function getOracleSignedData(interpreter: ITxTemplateInterpreter, _ctx: TxTemplateContext, options: z.infer<typeof SetVarGetOracleSignedDataOpts>): Promise<IUserSignedData>;
+//# sourceMappingURL=setvarcommands.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/template/transaction/setvarcommands.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/template/transaction/setvarcommands.d.ts.map
new file mode 100644
index 0000000..7e6837c
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/template/transaction/setvarcommands.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"setvarcommands.d.ts","sourceRoot":"","sources":["../../../src/template/transaction/setvarcommands.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;AAEH,OAAO,EAAE,CAAC,EAAE,MAAM,KAAK,CAAC;AACxB,OAAO,EAAE,sBAAsB,EAAE,MAAM,SAAS,CAAC;AACjD,OAAO,EAAE,iBAAiB,EAAE,MAAM,WAAW,CAAC;AAC9C,OAAO,EACL,yBAAyB,EACzB,6BAA6B,EAC7B,0BAA0B,EAC1B,0BAA0B,EAE3B,MAAM,gBAAgB,CAAC;AAExB,OAAO,EAAE,eAAe,EAAE,MAAM,wCAAwC,CAAC;AAEzE,wBAAsB,gBAAgB,CACpC,WAAW,EAAE,sBAAsB,EACnC,IAAI,EAAE,iBAAiB,EACvB,OAAO,EAAE,CAAC,CAAC,KAAK,CAAC,OAAO,0BAA0B,CAAC,GAClD,OAAO,CAAC,MAAM,CAAC,CAKjB;AAED,wBAAsB,gBAAgB,CACpC,WAAW,EAAE,sBAAsB,EACnC,IAAI,EAAE,iBAAiB,EACvB,OAAO,EAAE,CAAC,CAAC,KAAK,CAAC,OAAO,0BAA0B,CAAC,GAClD,OAAO,CAAC,MAAM,GAAG,MAAM,CAAC,CAU1B;AAED,wBAAsB,eAAe,CACnC,WAAW,EAAE,sBAAsB,EACnC,IAAI,EAAE,iBAAiB,EACvB,OAAO,EAAE,CAAC,CAAC,KAAK,CAAC,OAAO,yBAAyB,CAAC,GACjD,OAAO,CAAC,MAAM,CAAC,CAIjB;AAED,wBAAsB,mBAAmB,CACvC,WAAW,EAAE,sBAAsB,EACnC,IAAI,EAAE,iBAAiB,EACvB,OAAO,EAAE,CAAC,CAAC,KAAK,CAAC,OAAO,6BAA6B,CAAC,GACrD,OAAO,CAAC,eAAe,CAAC,CAgB1B"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/template/transaction/setvarcommands.js b/node_modules/@hathor/wallet-lib/oldLib/template/transaction/setvarcommands.js
new file mode 100644
index 0000000..0530199
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/template/transaction/setvarcommands.js
@@ -0,0 +1,47 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.getOracleScript = getOracleScript;
+exports.getOracleSignedData = getOracleSignedData;
+exports.getWalletAddress = getWalletAddress;
+exports.getWalletBalance = getWalletBalance;
+var _instructions = require("./instructions");
+var _utils = require("../../nano_contracts/utils");
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+async function getWalletAddress(interpreter, _ctx, options) {
+  if (options.index) {
+    return interpreter.getAddressAtIndex(options.index);
+  }
+  return interpreter.getAddress();
+}
+async function getWalletBalance(interpreter, _ctx, options) {
+  const data = await interpreter.getBalance(options.token);
+  switch (options.authority) {
+    case 'mint':
+      return data.tokenAuthorities.unlocked.mint;
+    case 'melt':
+      return data.tokenAuthorities.unlocked.melt;
+    default:
+      return data.balance.unlocked;
+  }
+}
+async function getOracleScript(interpreter, _ctx, options) {
+  const address = await interpreter.getAddressAtIndex(options.index);
+  const oracle = (0, _utils.getOracleBuffer)(address, interpreter.getNetwork());
+  return oracle.toString('hex');
+}
+async function getOracleSignedData(interpreter, _ctx, options) {
+  const address = await interpreter.getAddressAtIndex(options.index);
+  const oracle = (0, _utils.getOracleBuffer)(address, interpreter.getNetwork());
+  const data = (0, _instructions.getVariable)(options.data, _ctx.vars, _instructions.SetVarGetOracleSignedDataOpts.shape.data);
+  const ncId = (0, _instructions.getVariable)(options.ncId, _ctx.vars, _instructions.SetVarGetOracleSignedDataOpts.shape.ncId);
+  return (0, _utils.getOracleSignedDataFromUser)(oracle, ncId, options.type, data, interpreter.getWallet());
+}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/template/transaction/types.d.ts b/node_modules/@hathor/wallet-lib/oldLib/template/transaction/types.d.ts
new file mode 100644
index 0000000..aeb76d4
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/template/transaction/types.d.ts
@@ -0,0 +1,53 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+import { z } from 'zod';
+import { TransactionTemplate } from './instructions';
+import { TxTemplateContext } from './context';
+import { IHistoryTx, ITokenBalance, ITokenData, OutputValueType } from '../../types';
+import Transaction from '../../models/transaction';
+import Network from '../../models/network';
+import { IHathorWallet, Utxo } from '../../wallet/types';
+import CreateTokenTransaction from '../../models/create_token_transaction';
+export type TxInstance = Transaction | CreateTokenTransaction;
+export interface IGetUtxosOptions {
+    token?: string;
+    authorities?: OutputValueType;
+    filter_address?: string;
+}
+export interface IGetUtxoResponse {
+    utxos: Utxo[];
+    changeAmount: OutputValueType;
+}
+export interface IWalletBalanceData {
+    token: ITokenData;
+    balance: ITokenBalance;
+    transactions: number;
+    tokenAuthorities: {
+        unlocked: {
+            mint: number;
+            melt: number;
+        };
+        locked: {
+            mint: number;
+            melt: number;
+        };
+    };
+}
+export interface ITxTemplateInterpreter {
+    build(instructions: z.infer<typeof TransactionTemplate>, debug: boolean): Promise<TxInstance>;
+    getAddress(markAsUsed?: boolean): Promise<string>;
+    getAddressAtIndex(index: number): Promise<string>;
+    getBalance(token: string): Promise<IWalletBalanceData>;
+    getChangeAddress(ctx: TxTemplateContext): Promise<string>;
+    getUtxos(amount: OutputValueType, options: IGetUtxosOptions): Promise<IGetUtxoResponse>;
+    getAuthorities(count: number, options: IGetUtxosOptions): Promise<Utxo[]>;
+    getTx(txId: string): Promise<IHistoryTx>;
+    getNetwork(): Network;
+    getWallet(): IHathorWallet;
+    getHTRDeposit(mintAmount: OutputValueType): OutputValueType;
+}
+//# sourceMappingURL=types.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/template/transaction/types.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/template/transaction/types.d.ts.map
new file mode 100644
index 0000000..3731323
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/template/transaction/types.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"types.d.ts","sourceRoot":"","sources":["../../../src/template/transaction/types.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;AAEH,OAAO,EAAE,CAAC,EAAE,MAAM,KAAK,CAAC;AACxB,OAAO,EAAE,mBAAmB,EAAE,MAAM,gBAAgB,CAAC;AACrD,OAAO,EAAE,iBAAiB,EAAE,MAAM,WAAW,CAAC;AAC9C,OAAO,EAAE,UAAU,EAAE,aAAa,EAAE,UAAU,EAAE,eAAe,EAAE,MAAM,aAAa,CAAC;AACrF,OAAO,WAAW,MAAM,0BAA0B,CAAC;AACnD,OAAO,OAAO,MAAM,sBAAsB,CAAC;AAC3C,OAAO,EAAE,aAAa,EAAE,IAAI,EAAE,MAAM,oBAAoB,CAAC;AACzD,OAAO,sBAAsB,MAAM,uCAAuC,CAAC;AAE3E,MAAM,MAAM,UAAU,GAAG,WAAW,GAAG,sBAAsB,CAAC;AAE9D,MAAM,WAAW,gBAAgB;IAC/B,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,WAAW,CAAC,EAAE,eAAe,CAAC;IAC9B,cAAc,CAAC,EAAE,MAAM,CAAC;CAczB;AAED,MAAM,WAAW,gBAAgB;IAC/B,KAAK,EAAE,IAAI,EAAE,CAAC;IACd,YAAY,EAAE,eAAe,CAAC;CAC/B;AAED,MAAM,WAAW,kBAAkB;IACjC,KAAK,EAAE,UAAU,CAAC;IAClB,OAAO,EAAE,aAAa,CAAC;IACvB,YAAY,EAAE,MAAM,CAAC;IACrB,gBAAgB,EAAE;QAChB,QAAQ,EAAE;YAAE,IAAI,EAAE,MAAM,CAAC;YAAC,IAAI,EAAE,MAAM,CAAA;SAAE,CAAC;QACzC,MAAM,EAAE;YAAE,IAAI,EAAE,MAAM,CAAC;YAAC,IAAI,EAAE,MAAM,CAAA;SAAE,CAAC;KACxC,CAAC;CACH;AAED,MAAM,WAAW,sBAAsB;IACrC,KAAK,CAAC,YAAY,EAAE,CAAC,CAAC,KAAK,CAAC,OAAO,mBAAmB,CAAC,EAAE,KAAK,EAAE,OAAO,GAAG,OAAO,CAAC,UAAU,CAAC,CAAC;IAC9F,UAAU,CAAC,UAAU,CAAC,EAAE,OAAO,GAAG,OAAO,CAAC,MAAM,CAAC,CAAC;IAClD,iBAAiB,CAAC,KAAK,EAAE,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC,CAAC;IAClD,UAAU,CAAC,KAAK,EAAE,MAAM,GAAG,OAAO,CAAC,kBAAkB,CAAC,CAAC;IACvD,gBAAgB,CAAC,GAAG,EAAE,iBAAiB,GAAG,OAAO,CAAC,MAAM,CAAC,CAAC;IAC1D,QAAQ,CAAC,MAAM,EAAE,eAAe,EAAE,OAAO,EAAE,gBAAgB,GAAG,OAAO,CAAC,gBAAgB,CAAC,CAAC;IACxF,cAAc,CAAC,KAAK,EAAE,MAAM,EAAE,OAAO,EAAE,gBAAgB,GAAG,OAAO,CAAC,IAAI,EAAE,CAAC,CAAC;IAC1E,KAAK,CAAC,IAAI,EAAE,MAAM,GAAG,OAAO,CAAC,UAAU,CAAC,CAAC;IACzC,UAAU,IAAI,OAAO,CAAC;IACtB,SAAS,IAAI,aAAa,CAAC;IAC3B,aAAa,CAAC,UAAU,EAAE,eAAe,GAAG,eAAe,CAAC;CAC7D"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/template/transaction/types.js b/node_modules/@hathor/wallet-lib/oldLib/template/transaction/types.js
new file mode 100644
index 0000000..430afc1
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/template/transaction/types.js
@@ -0,0 +1,5 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/template/transaction/utils.d.ts b/node_modules/@hathor/wallet-lib/oldLib/template/transaction/utils.d.ts
new file mode 100644
index 0000000..87e7a21
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/template/transaction/utils.d.ts
@@ -0,0 +1,18 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+import { OutputValueType } from '../../types';
+import { TxTemplateContext } from './context';
+import { ITxTemplateInterpreter, IGetUtxosOptions } from './types';
+/**
+ * Select tokens from interpreter and modify context as required by the tokens found.
+ */
+export declare function selectTokens(interpreter: ITxTemplateInterpreter, ctx: TxTemplateContext, amount: OutputValueType, options: IGetUtxosOptions, autoChange: boolean, changeAddress: string, position?: number): Promise<void>;
+/**
+ * Select authorities from interpreter and modify context as required by the selection.
+ */
+export declare function selectAuthorities(interpreter: ITxTemplateInterpreter, ctx: TxTemplateContext, options: IGetUtxosOptions, count?: number, position?: number): Promise<void>;
+//# sourceMappingURL=utils.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/template/transaction/utils.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/template/transaction/utils.d.ts.map
new file mode 100644
index 0000000..7f9edf9
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/template/transaction/utils.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"utils.d.ts","sourceRoot":"","sources":["../../../src/template/transaction/utils.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;AAEH,OAAO,EAAE,eAAe,EAAE,MAAM,aAAa,CAAC;AAE9C,OAAO,EAAE,iBAAiB,EAAE,MAAM,WAAW,CAAC;AAC9C,OAAO,EAAE,sBAAsB,EAAE,gBAAgB,EAAE,MAAM,SAAS,CAAC;AAKnE;;GAEG;AACH,wBAAsB,YAAY,CAChC,WAAW,EAAE,sBAAsB,EACnC,GAAG,EAAE,iBAAiB,EACtB,MAAM,EAAE,eAAe,EACvB,OAAO,EAAE,gBAAgB,EACzB,UAAU,EAAE,OAAO,EACnB,aAAa,EAAE,MAAM,EACrB,QAAQ,GAAE,MAAW,iBA8BtB;AAED;;GAEG;AACH,wBAAsB,iBAAiB,CACrC,WAAW,EAAE,sBAAsB,EACnC,GAAG,EAAE,iBAAiB,EACtB,OAAO,EAAE,gBAAgB,EACzB,KAAK,GAAE,MAAU,EACjB,QAAQ,GAAE,MAAW,iBAkBtB"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/template/transaction/utils.js b/node_modules/@hathor/wallet-lib/oldLib/template/transaction/utils.js
new file mode 100644
index 0000000..3ebe9a1
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/template/transaction/utils.js
@@ -0,0 +1,77 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.selectAuthorities = selectAuthorities;
+exports.selectTokens = selectTokens;
+var _constants = require("../../constants");
+var _address = require("../../utils/address");
+var _input = _interopRequireDefault(require("../../models/input"));
+var _output = _interopRequireDefault(require("../../models/output"));
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+/**
+ * Select tokens from interpreter and modify context as required by the tokens found.
+ */
+async function selectTokens(interpreter, ctx, amount, options, autoChange, changeAddress, position = -1) {
+  const token = options.token ?? _constants.NATIVE_TOKEN_UID;
+  const {
+    changeAmount,
+    utxos
+  } = await interpreter.getUtxos(amount, options);
+
+  // Add utxos as inputs on the transaction
+  const inputs = [];
+  for (const utxo of utxos) {
+    ctx.log(`Found utxo with ${utxo.value} of ${utxo.tokenId}`);
+    ctx.log(`Create input ${utxo.index} / ${utxo.txId}`);
+    inputs.push(new _input.default(utxo.txId, utxo.index));
+    // Update the balance
+    const origTx = await interpreter.getTx(utxo.txId);
+    ctx.balance.addBalanceFromUtxo(origTx, utxo.index);
+  }
+
+  // Then add inputs to context
+  ctx.addInputs(position, ...inputs);
+  ctx.log(`changeAmount: ${changeAmount} autoChange(${autoChange})`);
+  if (autoChange && changeAmount) {
+    ctx.log(`Creating change for address: ${changeAddress}`);
+    // Token should only be on the array if present on the outputs
+    const tokenData = ctx.addToken(token);
+    const script = (0, _address.createOutputScriptFromAddress)(changeAddress, interpreter.getNetwork());
+    const output = new _output.default(changeAmount, script, {
+      tokenData
+    });
+    ctx.balance.addOutput(changeAmount, token);
+    ctx.addOutputs(-1, output);
+  }
+}
+
+/**
+ * Select authorities from interpreter and modify context as required by the selection.
+ */
+async function selectAuthorities(interpreter, ctx, options, count = 1, position = -1) {
+  const token = options.token ?? _constants.NATIVE_TOKEN_UID;
+  const utxos = await interpreter.getAuthorities(count, options);
+
+  // Add utxos as inputs on the transaction
+  const inputs = [];
+  for (const utxo of utxos) {
+    ctx.log(`Found authority utxo ${utxo.authorities} of ${token}`);
+    ctx.log(`Create input ${utxo.index} / ${utxo.txId}`);
+    inputs.push(new _input.default(utxo.txId, utxo.index));
+    // Update the balance
+    const origTx = await interpreter.getTx(utxo.txId);
+    ctx.balance.addBalanceFromUtxo(origTx, utxo.index);
+  }
+
+  // Then add inputs to context
+  ctx.addInputs(position, ...inputs);
+}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/types.d.ts b/node_modules/@hathor/wallet-lib/oldLib/types.d.ts
new file mode 100644
index 0000000..c5b5068
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/types.d.ts
@@ -0,0 +1,497 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/// <reference types="node" />
+import { Config } from './config';
+import Transaction from './models/transaction';
+import Input from './models/input';
+import FullNodeConnection from './new/connection';
+/**
+ * Logger interface where each method is a leveled log method.
+ */
+export interface ILogger {
+    debug: (...args: any[]) => void;
+    info: (...args: any[]) => void;
+    warn: (...args: any[]) => void;
+    error: (...args: any[]) => void;
+}
+/**
+ * Get the default logger instance, the console
+ */
+export declare function getDefaultLogger(): ILogger;
+export type OutputValueType = bigint;
+export interface ITxSignatureData {
+    ncCallerSignature: Buffer | null;
+    inputSignatures: IInputSignature[];
+}
+export interface IInputSignature {
+    inputIndex: number;
+    addressIndex: number;
+    signature: Buffer;
+    pubkey: Buffer;
+}
+export declare enum HistorySyncMode {
+    POLLING_HTTP_API = "polling-http-api",
+    MANUAL_STREAM_WS = "manual-stream-ws",
+    XPUB_STREAM_WS = "xpub-stream-ws"
+}
+/**
+ * This is the method signature for a method that signs a transaction and
+ * returns an array with signature information.
+ */
+export type EcdsaTxSign = (tx: Transaction, storage: IStorage, pinCode: string) => Promise<ITxSignatureData>;
+export type HistorySyncFunction = (startIndex: number, count: number, storage: IStorage, connection: FullNodeConnection, shouldProcessHistory?: boolean) => Promise<void>;
+export interface IAddressInfo {
+    base58: string;
+    bip32AddressIndex: number;
+    publicKey?: string;
+}
+export interface IAddressMetadata {
+    numTransactions: number;
+    balance: Map<string, IBalance>;
+    seqnum: number;
+}
+export interface IAddressMetadataAsRecord {
+    numTransactions: number;
+    balance: Record<string, IBalance>;
+    seqnum: number;
+}
+export interface ITokenData {
+    uid: string;
+    name: string;
+    symbol: string;
+}
+export interface ITokenMetadata {
+    numTransactions: number;
+    balance: IBalance;
+}
+export interface IBalance {
+    tokens: ITokenBalance;
+    authorities: IAuthoritiesBalance;
+}
+export interface ITokenBalance {
+    locked: OutputValueType;
+    unlocked: OutputValueType;
+}
+export interface IAuthoritiesBalance {
+    mint: ITokenBalance;
+    melt: ITokenBalance;
+}
+export interface IHistoryNanoContractActionWithdrawal {
+    type: 'withdrawal';
+    token_uid: string;
+    amount: OutputValueType;
+}
+export interface IHistoryNanoContractActionDeposit {
+    type: 'deposit';
+    token_uid: string;
+    amount: OutputValueType;
+}
+export interface IHistoryNanoContractActionGrantAuthority {
+    type: 'grant_authority';
+    token_uid: string;
+    mint: boolean;
+    melt: boolean;
+}
+export interface IHistoryNanoContractActionAcquireAuthority {
+    type: 'acquire_authority';
+    token_uid: string;
+    mint: boolean;
+    melt: boolean;
+}
+export type IHistoryNanoContractAction = IHistoryNanoContractActionDeposit | IHistoryNanoContractActionWithdrawal | IHistoryNanoContractActionGrantAuthority | IHistoryNanoContractActionAcquireAuthority;
+export interface IHistoryNanoContractContext {
+    actions: IHistoryNanoContractAction[];
+    address: string;
+    timestamp: number;
+}
+export interface IHistoryTx {
+    tx_id: string;
+    signalBits?: number;
+    version: number;
+    weight: number;
+    timestamp: number;
+    is_voided: boolean;
+    nonce?: number;
+    inputs: IHistoryInput[];
+    outputs: IHistoryOutput[];
+    parents: string[];
+    token_name?: string;
+    token_symbol?: string;
+    tokens?: string[];
+    height?: number;
+    processingStatus?: TxHistoryProcessingStatus;
+    nc_id?: string;
+    nc_blueprint_id?: string;
+    nc_method?: string;
+    nc_args?: string;
+    nc_address?: string;
+    nc_pubkey?: string;
+    nc_context?: IHistoryNanoContractContext;
+    nc_seqnum?: number;
+    first_block?: string | null;
+}
+export declare enum TxHistoryProcessingStatus {
+    PROCESSING = "processing",
+    FINISHED = "finished"
+}
+export interface IHistoryInput {
+    value: OutputValueType;
+    token_data: number;
+    script: string;
+    decoded: IHistoryOutputDecoded;
+    token: string;
+    tx_id: string;
+    index: number;
+}
+export interface IHistoryOutputDecoded {
+    type?: string;
+    address?: string;
+    timelock?: number | null;
+    data?: string;
+}
+export interface IHistoryOutput {
+    value: OutputValueType;
+    token_data: number;
+    script: string;
+    decoded: IHistoryOutputDecoded;
+    token: string;
+    spent_by: string | null;
+    selected_as_input?: boolean;
+}
+export interface IDataOutputData {
+    type: 'data';
+    token: string;
+    value: OutputValueType;
+    authorities: OutputValueType;
+    data: string;
+}
+export declare function isDataOutputData(output: IDataOutput): output is IDataOutputData;
+export interface IDataOutputAddress {
+    type: 'p2pkh' | 'p2sh';
+    token: string;
+    value: OutputValueType;
+    authorities: OutputValueType;
+    address: string;
+    timelock: number | null;
+}
+export declare function isDataOutputAddress(output: IDataOutput): output is IDataOutputAddress;
+export interface IDataOutputCreateToken {
+    type: 'mint' | 'melt';
+    value: OutputValueType;
+    address: string;
+    timelock: number | null;
+    authorities: OutputValueType;
+}
+export declare function isDataOutputCreateToken(output: IDataOutput): output is IDataOutputCreateToken;
+export interface IDataOutputOptionals {
+    isChange?: boolean;
+}
+export type IDataOutput = (IDataOutputData | IDataOutputAddress | IDataOutputCreateToken) & IDataOutputOptionals;
+export interface IDataInput {
+    txId: string;
+    index: number;
+    value: OutputValueType;
+    authorities: OutputValueType;
+    token: string;
+    address: string;
+    data?: string;
+}
+export interface IDataTx {
+    signalBits?: number;
+    version?: number;
+    inputs: IDataInput[];
+    outputs: IDataOutput[];
+    tokens: string[];
+    weight?: number;
+    nonce?: number;
+    timestamp?: number;
+    parents?: string[];
+    name?: string;
+    symbol?: string;
+}
+export interface IUtxoId {
+    txId: string;
+    index: number;
+}
+export interface IUtxo {
+    txId: string;
+    index: number;
+    token: string;
+    address: string;
+    value: OutputValueType;
+    authorities: OutputValueType;
+    timelock: number | null;
+    type: number;
+    height: number | null;
+}
+export interface ILockedUtxo {
+    tx: IHistoryTx;
+    index: number;
+}
+export declare enum WalletType {
+    P2PKH = "p2pkh",
+    MULTISIG = "multisig"
+}
+export declare enum WALLET_FLAGS {
+    READONLY = 1,
+    HARDWARE = 2
+}
+export interface IWalletAccessData {
+    xpubkey: string;
+    mainKey?: IEncryptedData;
+    acctPathKey?: IEncryptedData;
+    words?: IEncryptedData;
+    authKey?: IEncryptedData;
+    multisigData?: IMultisigData;
+    walletType: WalletType;
+    walletFlags: number;
+}
+export declare enum SCANNING_POLICY {
+    GAP_LIMIT = "gap-limit",
+    INDEX_LIMIT = "index-limit"
+}
+export interface IGapLimitAddressScanPolicy {
+    policy: SCANNING_POLICY.GAP_LIMIT;
+    gapLimit: number;
+}
+export interface IIndexLimitAddressScanPolicy {
+    policy: SCANNING_POLICY.INDEX_LIMIT;
+    startIndex: number;
+    endIndex: number;
+}
+/**
+ * This is a request from the scanning policy to load `count` addresses starting from nextIndex.
+ */
+export interface IScanPolicyLoadAddresses {
+    nextIndex: number;
+    count: number;
+}
+export type AddressScanPolicy = SCANNING_POLICY.GAP_LIMIT | SCANNING_POLICY.INDEX_LIMIT;
+export type AddressScanPolicyData = IGapLimitAddressScanPolicy | IIndexLimitAddressScanPolicy;
+export declare function isGapLimitScanPolicy(scanPolicyData: AddressScanPolicyData): scanPolicyData is IGapLimitAddressScanPolicy;
+export declare function isIndexLimitScanPolicy(scanPolicyData: AddressScanPolicyData): scanPolicyData is IIndexLimitAddressScanPolicy;
+export interface IWalletData {
+    lastLoadedAddressIndex: number;
+    lastUsedAddressIndex: number;
+    currentAddressIndex: number;
+    bestBlockHeight: number;
+    scanPolicyData: AddressScanPolicyData;
+}
+export interface IEncryptedData {
+    data: string;
+    hash: string;
+    salt: string;
+    iterations: number;
+    pbkdf2Hasher: string;
+}
+export interface IMultisigData {
+    pubkey?: string;
+    pubkeys: string[];
+    numSignatures: number;
+}
+export interface IUtxoFilterOptions {
+    token?: string;
+    authorities?: OutputValueType;
+    max_utxos?: number;
+    filter_address?: string;
+    target_amount?: OutputValueType;
+    max_amount?: OutputValueType;
+    amount_smaller_than?: OutputValueType;
+    amount_bigger_than?: OutputValueType;
+    only_available_utxos?: boolean;
+    filter_method?: (utxo: IUtxo) => boolean;
+    reward_lock?: number;
+    order_by_value?: 'asc' | 'desc';
+}
+export type UtxoSelectionAlgorithm = (storage: IStorage, token: string, amount: OutputValueType) => Promise<{
+    utxos: IUtxo[];
+    amount: OutputValueType;
+    available?: OutputValueType;
+}>;
+export interface IUtxoSelectionOptions {
+    token?: string;
+    changeAddress?: string;
+    chooseInputs?: boolean;
+    utxoSelectionMethod?: UtxoSelectionAlgorithm;
+}
+export interface IFillTxOptions {
+    changeAddress?: string;
+    skipAuthorities?: boolean;
+    chooseInputs?: boolean;
+}
+export interface ApiVersion {
+    version: string;
+    network: string;
+    min_tx_weight: number;
+    min_tx_weight_coefficient: number;
+    min_tx_weight_k: number;
+    token_deposit_percentage: number;
+    reward_spend_min_blocks: number;
+    max_number_inputs: number;
+    max_number_outputs: number;
+    decimal_places: number;
+    native_token: Omit<ITokenData, 'uid'> | null | undefined;
+}
+export interface IStore {
+    validate(): Promise<void>;
+    preProcessHistory(): Promise<void>;
+    addressIter(): AsyncGenerator<IAddressInfo>;
+    getAddress(base58: string): Promise<IAddressInfo | null>;
+    getAddressMeta(base58: string): Promise<IAddressMetadata | null>;
+    getAddressAtIndex(index: number): Promise<IAddressInfo | null>;
+    saveAddress(info: IAddressInfo): Promise<void>;
+    addressExists(base58: string): Promise<boolean>;
+    addressCount(): Promise<number>;
+    editAddressMeta(base58: string, meta: IAddressMetadata): Promise<void>;
+    historyIter(tokenUid?: string): AsyncGenerator<IHistoryTx>;
+    saveTx(tx: IHistoryTx): Promise<void>;
+    getTx(txId: string): Promise<IHistoryTx | null>;
+    historyCount(): Promise<number>;
+    tokenIter(): AsyncGenerator<ITokenData & Partial<ITokenMetadata>>;
+    registeredTokenIter(): AsyncGenerator<ITokenData & Partial<ITokenMetadata>>;
+    getToken(tokenUid: string): Promise<(ITokenData & Partial<ITokenMetadata>) | null>;
+    getTokenMeta(tokenUid: string): Promise<ITokenMetadata | null>;
+    saveToken(tokenConfig: ITokenData, meta?: ITokenMetadata): Promise<void>;
+    registerToken(token: ITokenData): Promise<void>;
+    unregisterToken(tokenUid: string): Promise<void>;
+    isTokenRegistered(tokenUid: string): Promise<boolean>;
+    editTokenMeta(tokenUid: string, meta: ITokenMetadata): Promise<void>;
+    utxoIter(): AsyncGenerator<IUtxo>;
+    selectUtxos(options: IUtxoFilterOptions): AsyncGenerator<IUtxo>;
+    saveUtxo(utxo: IUtxo): Promise<void>;
+    saveLockedUtxo(lockedUtxo: ILockedUtxo): Promise<void>;
+    iterateLockedUtxos(): AsyncGenerator<ILockedUtxo>;
+    unlockUtxo(lockedUtxo: ILockedUtxo): Promise<void>;
+    deleteUtxo(utxoId: IUtxo): Promise<void>;
+    getAccessData(): Promise<IWalletAccessData | null>;
+    saveAccessData(data: IWalletAccessData): Promise<void>;
+    getWalletData(): Promise<IWalletData>;
+    getLastLoadedAddressIndex(): Promise<number>;
+    getLastUsedAddressIndex(): Promise<number>;
+    setLastUsedAddressIndex(index: number): Promise<void>;
+    getCurrentHeight(): Promise<number>;
+    setCurrentHeight(height: number): Promise<void>;
+    getCurrentAddress(markAsUsed?: boolean): Promise<string>;
+    setCurrentAddressIndex(index: number): Promise<void>;
+    setGapLimit(value: number): Promise<void>;
+    getGapLimit(): Promise<number>;
+    getIndexLimit(): Promise<Omit<IIndexLimitAddressScanPolicy, 'policy'> | null>;
+    getScanningPolicy(): Promise<AddressScanPolicy>;
+    setScanningPolicyData(data: AddressScanPolicyData): Promise<void>;
+    getScanningPolicyData(): Promise<AddressScanPolicyData>;
+    isNanoContractRegistered(ncId: string): Promise<boolean>;
+    registeredNanoContractsIter(): AsyncGenerator<INcData>;
+    getNanoContract(ncId: string): Promise<INcData | null>;
+    registerNanoContract(ncId: string, ncValue: INcData): Promise<void>;
+    unregisterNanoContract(ncId: string): Promise<void>;
+    updateNanoContractRegisteredAddress(ncId: string, address: string): Promise<void>;
+    getItem(key: string): Promise<unknown>;
+    setItem(key: string, value: unknown): Promise<void>;
+    cleanStorage(cleanHistory?: boolean, cleanAddresses?: boolean, cleanTokens?: boolean): Promise<void>;
+    cleanMetadata(): Promise<void>;
+}
+export interface IStorage {
+    store: IStore;
+    config: Config;
+    version: ApiVersion | null;
+    logger: ILogger;
+    setApiVersion(version: ApiVersion): void;
+    getDecimalPlaces(): number;
+    saveNativeToken(): Promise<void>;
+    getNativeTokenData(): ITokenData;
+    setLogger(logger: ILogger): void;
+    hasTxSignatureMethod(): boolean;
+    setTxSignatureMethod(txSign: EcdsaTxSign): void;
+    getTxSignatures(tx: Transaction, pinCode: string): Promise<ITxSignatureData>;
+    getAllAddresses(): AsyncGenerator<IAddressInfo & IAddressMetadata>;
+    getAddressInfo(base58: string): Promise<(IAddressInfo & IAddressMetadata) | null>;
+    getAddressAtIndex(index: number): Promise<IAddressInfo | null>;
+    getAddressPubkey(index: number): Promise<string>;
+    saveAddress(info: IAddressInfo): Promise<void>;
+    isAddressMine(base58: string): Promise<boolean>;
+    getCurrentAddress(markAsUsed?: boolean): Promise<string>;
+    getChangeAddress(options?: {
+        changeAddress?: null | string;
+    }): Promise<string>;
+    txHistory(): AsyncGenerator<IHistoryTx>;
+    tokenHistory(tokenUid?: string): AsyncGenerator<IHistoryTx>;
+    getTx(txId: string): Promise<IHistoryTx | null>;
+    getSpentTxs(inputs: Input[]): AsyncGenerator<{
+        tx: IHistoryTx;
+        input: Input;
+        index: number;
+    }>;
+    addTx(tx: IHistoryTx): Promise<void>;
+    processHistory(): Promise<void>;
+    processNewTx(tx: IHistoryTx): Promise<void>;
+    addToken(data: ITokenData): Promise<void>;
+    isTokenRegistered(tokenUid: string): Promise<boolean>;
+    registerToken(token: ITokenData): Promise<void>;
+    unregisterToken(tokenUid: string): Promise<void>;
+    getToken(uid: string): Promise<(ITokenData & Partial<ITokenMetadata>) | null>;
+    getAllTokens(): AsyncGenerator<ITokenData & Partial<ITokenMetadata>>;
+    getRegisteredTokens(): AsyncGenerator<ITokenData & Partial<ITokenMetadata>>;
+    getAllUtxos(): AsyncGenerator<IUtxo>;
+    selectUtxos(options: Omit<IUtxoFilterOptions, 'reward_lock'>): AsyncGenerator<IUtxo>;
+    fillTx(token: string, tx: IDataTx, options: IFillTxOptions): Promise<{
+        inputs: IDataInput[];
+        outputs: IDataOutput[];
+    }>;
+    utxoSelectAsInput(utxo: IUtxoId, markAs: boolean, ttl?: number): Promise<void>;
+    isUtxoSelectedAsInput(utxo: IUtxoId): Promise<boolean>;
+    utxoSelectedAsInputIter(): AsyncGenerator<IUtxoId>;
+    unlockUtxos(height: number): Promise<void>;
+    processLockedUtxos(height: number): Promise<void>;
+    getAccessData(): Promise<IWalletAccessData | null>;
+    saveAccessData(data: IWalletAccessData): Promise<void>;
+    getMainXPrivKey(pinCode: string): Promise<string>;
+    getAcctPathXPrivKey(pinCode: string): Promise<string>;
+    getAuthPrivKey(pinCode: string): Promise<string>;
+    getWalletData(): Promise<IWalletData>;
+    getWalletType(): Promise<WalletType>;
+    getCurrentHeight(): Promise<number>;
+    setCurrentHeight(height: number): Promise<void>;
+    isReadonly(): Promise<boolean>;
+    changePin(oldPin: string, newPin: string): Promise<void>;
+    changePassword(oldPassword: string, newPassword: string): Promise<void>;
+    setGapLimit(value: number): Promise<void>;
+    getGapLimit(): Promise<number>;
+    getIndexLimit(): Promise<Omit<IIndexLimitAddressScanPolicy, 'policy'> | null>;
+    cleanStorage(cleanHistory?: boolean, cleanAddresses?: boolean, cleanTokens?: boolean): Promise<void>;
+    handleStop(options: {
+        connection?: FullNodeConnection;
+        cleanStorage?: boolean;
+        cleanAddresses?: boolean;
+    }): Promise<void>;
+    getTokenDepositPercentage(): number;
+    checkPin(pinCode: string): Promise<boolean>;
+    checkPassword(password: string): Promise<boolean>;
+    isHardwareWallet(): Promise<boolean>;
+    getScanningPolicy(): Promise<AddressScanPolicy>;
+    getScanningPolicyData(): Promise<AddressScanPolicyData>;
+    setScanningPolicyData(data: AddressScanPolicyData | null): Promise<void>;
+    isNanoContractRegistered(ncId: string): Promise<boolean>;
+    getRegisteredNanoContracts(): AsyncGenerator<INcData>;
+    getNanoContract(ncId: string): Promise<INcData | null>;
+    registerNanoContract(ncId: string, ncValue: INcData): Promise<void>;
+    unregisterNanoContract(ncId: string): Promise<void>;
+    updateNanoContractRegisteredAddress(ncId: string, address: string): Promise<void>;
+}
+export interface AddressIndexValidateResponse {
+    firstIndex: number;
+    lastIndex: number;
+}
+export interface HistoryIndexValidateResponse {
+    count: number;
+}
+export interface INcData {
+    ncId: string;
+    address: string;
+    blueprintId: string;
+    blueprintName: string;
+}
+//# sourceMappingURL=types.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/types.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/types.d.ts.map
new file mode 100644
index 0000000..a903936
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/types.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"types.d.ts","sourceRoot":"","sources":["../src/types.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/types.js b/node_modules/@hathor/wallet-lib/oldLib/types.js
new file mode 100644
index 0000000..bb7601b
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/types.js
@@ -0,0 +1,83 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.WalletType = exports.WALLET_FLAGS = exports.TxHistoryProcessingStatus = exports.SCANNING_POLICY = exports.HistorySyncMode = void 0;
+exports.getDefaultLogger = getDefaultLogger;
+exports.isDataOutputAddress = isDataOutputAddress;
+exports.isDataOutputCreateToken = isDataOutputCreateToken;
+exports.isDataOutputData = isDataOutputData;
+exports.isGapLimitScanPolicy = isGapLimitScanPolicy;
+exports.isIndexLimitScanPolicy = isIndexLimitScanPolicy;
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+/**
+ * Logger interface where each method is a leveled log method.
+ */
+
+/**
+ * Get the default logger instance, the console
+ */
+function getDefaultLogger() {
+  return console;
+}
+let HistorySyncMode = exports.HistorySyncMode = /*#__PURE__*/function (HistorySyncMode) {
+  HistorySyncMode["POLLING_HTTP_API"] = "polling-http-api";
+  HistorySyncMode["MANUAL_STREAM_WS"] = "manual-stream-ws";
+  HistorySyncMode["XPUB_STREAM_WS"] = "xpub-stream-ws";
+  return HistorySyncMode;
+}({});
+/**
+ * This is the method signature for a method that signs a transaction and
+ * returns an array with signature information.
+ */
+let TxHistoryProcessingStatus = exports.TxHistoryProcessingStatus = /*#__PURE__*/function (TxHistoryProcessingStatus) {
+  TxHistoryProcessingStatus["PROCESSING"] = "processing";
+  TxHistoryProcessingStatus["FINISHED"] = "finished";
+  return TxHistoryProcessingStatus;
+}({}); // Obs: this will change with nano contracts
+function isDataOutputData(output) {
+  return output.type === 'data';
+}
+function isDataOutputAddress(output) {
+  return ['p2pkh', 'p2sh'].includes(output.type);
+}
+
+// This is for create token transactions, where we dont have a token uid yet
+
+function isDataOutputCreateToken(output) {
+  return ['mint', 'melt'].includes(output.type);
+}
+
+// XXX: This type is meant to be used as an intermediary for building transactions
+// It should have everything we need to build and push transactions.
+let WalletType = exports.WalletType = /*#__PURE__*/function (WalletType) {
+  WalletType["P2PKH"] = "p2pkh";
+  WalletType["MULTISIG"] = "multisig";
+  return WalletType;
+}({});
+let WALLET_FLAGS = exports.WALLET_FLAGS = /*#__PURE__*/function (WALLET_FLAGS) {
+  WALLET_FLAGS[WALLET_FLAGS["READONLY"] = 1] = "READONLY";
+  WALLET_FLAGS[WALLET_FLAGS["HARDWARE"] = 2] = "HARDWARE";
+  return WALLET_FLAGS;
+}({});
+let SCANNING_POLICY = exports.SCANNING_POLICY = /*#__PURE__*/function (SCANNING_POLICY) {
+  SCANNING_POLICY["GAP_LIMIT"] = "gap-limit";
+  SCANNING_POLICY["INDEX_LIMIT"] = "index-limit";
+  return SCANNING_POLICY;
+}({});
+/**
+ * This is a request from the scanning policy to load `count` addresses starting from nextIndex.
+ */
+function isGapLimitScanPolicy(scanPolicyData) {
+  return scanPolicyData.policy === SCANNING_POLICY.GAP_LIMIT;
+}
+function isIndexLimitScanPolicy(scanPolicyData) {
+  return scanPolicyData.policy === SCANNING_POLICY.INDEX_LIMIT;
+}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/utils/address.d.ts b/node_modules/@hathor/wallet-lib/oldLib/utils/address.d.ts
new file mode 100644
index 0000000..1d42d72
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/utils/address.d.ts
@@ -0,0 +1,50 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/// <reference types="node" />
+import Address from '../models/address';
+import Network from '../models/network';
+import { IMultisigData, IStorage, IAddressInfo } from '../types';
+/**
+ * Parse address and return the address type
+ *
+ * @param {string} address
+ * @param {Network} network
+ *
+ * @returns {string} output type of the address (p2pkh or p2sh)
+ */
+export declare function getAddressType(address: string, network: Network): 'p2pkh' | 'p2sh';
+export declare function deriveAddressFromXPubP2PKH(xpubkey: string, index: number, networkName: string): IAddressInfo;
+export declare function deriveAddressP2PKH(index: number, storage: IStorage): Promise<IAddressInfo>;
+export declare function deriveAddressFromDataP2SH(multisigData: IMultisigData, index: number, networkName: string): IAddressInfo;
+/**
+ * Derive a p2sh address at a given index with the data from a loaded storage.
+ *
+ * @param {number} index Address index
+ * @param {IStorage} storage Wallet storage to get p2sh and access data
+ *
+ * @async
+ * @returns {Promise<IAddressInfo>}
+ */
+export declare function deriveAddressP2SH(index: number, storage: IStorage): Promise<IAddressInfo>;
+/**
+ * Create an output script from a base58 address
+ * It may be P2PKH or P2SH
+ *
+ * @param {output} Output with data to create the script
+ *
+ * @throws {AddressError} If the address is invalid
+ */
+export declare function createOutputScriptFromAddress(address: string, network: Network): Buffer;
+/**
+ * Parse the public key and return an address.
+ *
+ * @param pubkey Hex string conveying the public key.
+ * @param network Address's network.
+ * @returns The address object from parsed publicKey
+ */
+export declare function getAddressFromPubkey(pubkey: string, network: Network): Address;
+//# sourceMappingURL=address.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/utils/address.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/utils/address.d.ts.map
new file mode 100644
index 0000000..feaf149
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/utils/address.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"address.d.ts","sourceRoot":"","sources":["../../src/utils/address.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;;AAQH,OAAO,OAAO,MAAM,mBAAmB,CAAC;AAGxC,OAAO,OAAO,MAAM,mBAAmB,CAAC;AAExC,OAAO,EAAE,aAAa,EAAE,QAAQ,EAAE,YAAY,EAAE,MAAM,UAAU,CAAC;AAGjE;;;;;;;GAOG;AACH,wBAAgB,cAAc,CAAC,OAAO,EAAE,MAAM,EAAE,OAAO,EAAE,OAAO,GAAG,OAAO,GAAG,MAAM,CAGlF;AAED,wBAAgB,0BAA0B,CACxC,OAAO,EAAE,MAAM,EACf,KAAK,EAAE,MAAM,EACb,WAAW,EAAE,MAAM,GAClB,YAAY,CASd;AAED,wBAAsB,kBAAkB,CAAC,KAAK,EAAE,MAAM,EAAE,OAAO,EAAE,QAAQ,GAAG,OAAO,CAAC,YAAY,CAAC,CAMhG;AAED,wBAAgB,yBAAyB,CACvC,YAAY,EAAE,aAAa,EAC3B,KAAK,EAAE,MAAM,EACb,WAAW,EAAE,MAAM,GAClB,YAAY,CAgBd;AAED;;;;;;;;GAQG;AACH,wBAAsB,iBAAiB,CAAC,KAAK,EAAE,MAAM,EAAE,OAAO,EAAE,QAAQ,GAAG,OAAO,CAAC,YAAY,CAAC,CAU/F;AAED;;;;;;;GAOG;AACH,wBAAgB,6BAA6B,CAAC,OAAO,EAAE,MAAM,EAAE,OAAO,EAAE,OAAO,GAAG,MAAM,CAgBvF;AAED;;;;;;GAMG;AACH,wBAAgB,oBAAoB,CAAC,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,OAAO,GAAG,OAAO,CAO9E"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/utils/address.js b/node_modules/@hathor/wallet-lib/oldLib/utils/address.js
new file mode 100644
index 0000000..3d6076e
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/utils/address.js
@@ -0,0 +1,134 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.createOutputScriptFromAddress = createOutputScriptFromAddress;
+exports.deriveAddressFromDataP2SH = deriveAddressFromDataP2SH;
+exports.deriveAddressFromXPubP2PKH = deriveAddressFromXPubP2PKH;
+exports.deriveAddressP2PKH = deriveAddressP2PKH;
+exports.deriveAddressP2SH = deriveAddressP2SH;
+exports.getAddressFromPubkey = getAddressFromPubkey;
+exports.getAddressType = getAddressType;
+var _bitcoreLib = require("bitcore-lib");
+var _address = _interopRequireDefault(require("../models/address"));
+var _p2pkh = _interopRequireDefault(require("../models/p2pkh"));
+var _p2sh = _interopRequireDefault(require("../models/p2sh"));
+var _network = _interopRequireDefault(require("../models/network"));
+var _buffer = require("./buffer");
+var _scripts = require("./scripts");
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+/**
+ * Parse address and return the address type
+ *
+ * @param {string} address
+ * @param {Network} network
+ *
+ * @returns {string} output type of the address (p2pkh or p2sh)
+ */
+function getAddressType(address, network) {
+  const addressObj = new _address.default(address, {
+    network
+  });
+  return addressObj.getType();
+}
+function deriveAddressFromXPubP2PKH(xpubkey, index, networkName) {
+  const network = new _network.default(networkName);
+  const hdpubkey = new _bitcoreLib.HDPublicKey(xpubkey);
+  const key = hdpubkey.deriveChild(index);
+  return {
+    base58: new _bitcoreLib.Address(key.publicKey, network.bitcoreNetwork).toString(),
+    bip32AddressIndex: index,
+    publicKey: key.publicKey.toString('hex')
+  };
+}
+async function deriveAddressP2PKH(index, storage) {
+  const accessData = await storage.getAccessData();
+  if (accessData === null) {
+    throw new Error('No access data');
+  }
+  return deriveAddressFromXPubP2PKH(accessData.xpubkey, index, storage.config.getNetwork().name);
+}
+function deriveAddressFromDataP2SH(multisigData, index, networkName) {
+  const network = new _network.default(networkName);
+  const redeemScript = (0, _scripts.createP2SHRedeemScript)(multisigData.pubkeys, multisigData.numSignatures, index);
+  // eslint-disable-next-line new-cap -- Cannot change the dependency method name
+  const address = new _bitcoreLib.Address.payingTo(_bitcoreLib.Script.fromBuffer(redeemScript), network.bitcoreNetwork);
+  return {
+    base58: address.toString(),
+    bip32AddressIndex: index
+  };
+}
+
+/**
+ * Derive a p2sh address at a given index with the data from a loaded storage.
+ *
+ * @param {number} index Address index
+ * @param {IStorage} storage Wallet storage to get p2sh and access data
+ *
+ * @async
+ * @returns {Promise<IAddressInfo>}
+ */
+async function deriveAddressP2SH(index, storage) {
+  const accessData = await storage.getAccessData();
+  if (accessData === null) {
+    throw new Error('No access data');
+  }
+  const {
+    multisigData
+  } = accessData;
+  if (multisigData === undefined) {
+    throw new Error('No multisig data');
+  }
+  return deriveAddressFromDataP2SH(multisigData, index, storage.config.getNetwork().name);
+}
+
+/**
+ * Create an output script from a base58 address
+ * It may be P2PKH or P2SH
+ *
+ * @param {output} Output with data to create the script
+ *
+ * @throws {AddressError} If the address is invalid
+ */
+function createOutputScriptFromAddress(address, network) {
+  const addressObj = new _address.default(address, {
+    network
+  });
+  // This will throw AddressError in case the address is invalid
+  addressObj.validateAddress();
+  const addressType = addressObj.getType();
+  if (addressType === 'p2sh') {
+    // P2SH
+    const p2sh = new _p2sh.default(addressObj);
+    return p2sh.createScript();
+  }
+  if (addressType === 'p2pkh') {
+    // P2PKH
+    const p2pkh = new _p2pkh.default(addressObj);
+    return p2pkh.createScript();
+  }
+  throw new Error('Invalid address type');
+}
+
+/**
+ * Parse the public key and return an address.
+ *
+ * @param pubkey Hex string conveying the public key.
+ * @param network Address's network.
+ * @returns The address object from parsed publicKey
+ */
+function getAddressFromPubkey(pubkey, network) {
+  const pubkeyBuffer = (0, _buffer.hexToBuffer)(pubkey);
+  const base58 = new _bitcoreLib.Address((0, _bitcoreLib.PublicKey)(pubkeyBuffer), network.bitcoreNetwork).toString();
+  return new _address.default(base58, {
+    network
+  });
+}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/utils/bigint.d.ts b/node_modules/@hathor/wallet-lib/oldLib/utils/bigint.d.ts
new file mode 100644
index 0000000..5e9e3b9
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/utils/bigint.d.ts
@@ -0,0 +1,53 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+import { z } from 'zod';
+/**
+ * An object equivalent to the native global JSON, providing `parse()` and `stringify()` functions with compatible signatures, except
+ * for the `reviver` and `replacer` parameters that are not supported to prevent accidental override of the custom BigInt behavior.
+ *
+ * If the JSON string to be parsed contains large integers that would lose precision with the `number` type, they're parsed as `bigint`s,
+ * and analogously for `stringify`. The `any` type is allowed as it conforms to the original signatures.
+ */
+export declare const JSONBigInt: {
+    parse(text: string): any;
+    stringify(value: any, space?: string | number): string;
+    bigIntReviver(_key: string, value: any, context: {
+        source: string;
+    }): any;
+    bigIntReplacer(_key: string, value_: any): any;
+};
+/**
+ * A utility Zod schema for `bigint` properties that can be instantiated from a coercible type, that is, a `number`, `string`, or `bigint` itself.
+ */
+export declare const bigIntCoercibleSchema: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+/**
+ * A type alias for a Zod schema with `unknown` input and generic output.
+ */
+export type ZodSchema<T> = z.ZodSchema<T, z.ZodTypeDef, unknown>;
+/**
+ * Parse some `unknown` data with a Zod schema. If parsing fails, it logs the error and throws.
+ */
+export declare function parseSchema<T>(data: unknown, schema: ZodSchema<T>): T;
+/**
+ * Parse some JSON string with a Zod schema.
+ *
+ * If the JSON string contains large integers that would lose precision with the `number` type, they're parsed as `bigint`s.
+ * This means that `z.bigint()` properties would fail for small integers, as they would be parsed as `number`s.
+ * To mitigate this, use the `bigIntCoercibleSchema` utility, which will coerce the property to a `bigint` output.
+ *
+ * If parsing fails, it logs the error and throws.
+ */
+export declare function parseJsonBigInt<T>(text: string, schema: ZodSchema<T>): T;
+/**
+ * A utility function to be used with `transformResponse` in Axios requests with support for `bigint` properties, powered by Zod schemas.
+ *
+ * If the JSON string contains large integers that would lose precision with the `number` type, they're parsed as `bigint`s.
+ * This means that `z.bigint()` properties would fail for small integers, as they would be parsed as `number`s.
+ * To mitigate this, use the `bigIntCoercibleSchema` utility, which will coerce the property to a `bigint` output.
+ */
+export declare function transformJsonBigIntResponse<T>(data: unknown, schema: ZodSchema<T>): T;
+//# sourceMappingURL=bigint.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/utils/bigint.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/utils/bigint.d.ts.map
new file mode 100644
index 0000000..d939b76
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/utils/bigint.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"bigint.d.ts","sourceRoot":"","sources":["../../src/utils/bigint.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;AAEH,OAAO,EAAE,CAAC,EAAE,MAAM,KAAK,CAAC;AAGxB;;;;;;GAMG;AACH,eAAO,MAAM,UAAU;gBAET,MAAM,GAAG,GAAG;qBAKP,GAAG,UAAU,MAAM,GAAG,MAAM,GAAG,MAAM;wBAIlC,MAAM,SAAS,GAAG,WAAW;QAAE,MAAM,EAAE,MAAM,CAAA;KAAE,GAAG,GAAG;yBAgCpD,MAAM,UAAU,GAAG,GAAG,GAAG;CAM/C,CAAC;AAEF;;GAEG;AACH,eAAO,MAAM,qBAAqB,+FAIR,CAAC;AAE3B;;GAEG;AACH,MAAM,MAAM,SAAS,CAAC,CAAC,IAAI,CAAC,CAAC,SAAS,CAAC,CAAC,EAAE,CAAC,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;AAEjE;;GAEG;AACH,wBAAgB,WAAW,CAAC,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE,MAAM,EAAE,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAUrE;AAED;;;;;;;;GAQG;AACH,wBAAgB,eAAe,CAAC,CAAC,EAAE,IAAI,EAAE,MAAM,EAAE,MAAM,EAAE,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAiBxE;AAED;;;;;;GAMG;AACH,wBAAgB,2BAA2B,CAAC,CAAC,EAAE,IAAI,EAAE,OAAO,EAAE,MAAM,EAAE,SAAS,CAAC,CAAC,CAAC,GAAG,CAAC,CAErF"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/utils/bigint.js b/node_modules/@hathor/wallet-lib/oldLib/utils/bigint.js
new file mode 100644
index 0000000..8c56ad2
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/utils/bigint.js
@@ -0,0 +1,124 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.bigIntCoercibleSchema = exports.JSONBigInt = void 0;
+exports.parseJsonBigInt = parseJsonBigInt;
+exports.parseSchema = parseSchema;
+exports.transformJsonBigIntResponse = transformJsonBigIntResponse;
+var _zod = require("zod");
+var _types = require("../types");
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+/**
+ * An object equivalent to the native global JSON, providing `parse()` and `stringify()` functions with compatible signatures, except
+ * for the `reviver` and `replacer` parameters that are not supported to prevent accidental override of the custom BigInt behavior.
+ *
+ * If the JSON string to be parsed contains large integers that would lose precision with the `number` type, they're parsed as `bigint`s,
+ * and analogously for `stringify`. The `any` type is allowed as it conforms to the original signatures.
+ */
+const JSONBigInt = exports.JSONBigInt = {
+  /* eslint-disable @typescript-eslint/no-explicit-any */
+  parse(text) {
+    // @ts-expect-error TypeScript hasn't been updated with the `context` argument from Node v22.
+    return JSON.parse(text, this.bigIntReviver);
+  },
+  stringify(value, space) {
+    return JSON.stringify(value, this.bigIntReplacer, space);
+  },
+  bigIntReviver(_key, value, context) {
+    if (typeof value !== 'number') {
+      // No special handling needed for non-number values.
+      return value;
+    }
+    try {
+      const bigIntValue = BigInt(context.source);
+      if (bigIntValue < Number.MIN_SAFE_INTEGER || bigIntValue > Number.MAX_SAFE_INTEGER) {
+        // We only return the value as a BigInt if it's in the unsafe range.
+        return bigIntValue;
+      }
+
+      // Otherwise, we can keep it as a Number.
+      return value;
+    } catch (e) {
+      if (e instanceof SyntaxError && (e.message === `Cannot convert ${context.source} to a BigInt` || e.message === `invalid BigInt syntax`)) {
+        // When this error happens, it means the number cannot be converted to a BigInt,
+        // so it's a double, for example '123.456' or '1e2'.
+        return value;
+      }
+      // This should never happen, any other error thrown by BigInt() is unexpected.
+      const logger = (0, _types.getDefaultLogger)();
+      logger.error(`unexpected error in bigIntReviver: ${e}`);
+      throw e;
+    }
+  },
+  bigIntReplacer(_key, value_) {
+    // If the value is a BigInt, we simply return its string representation.
+    // @ts-expect-error TypeScript hasn't been updated with the `rawJSON` function from Node v22.
+    return typeof value_ === 'bigint' ? JSON.rawJSON(value_.toString()) : value_;
+  }
+  /* eslint-enable @typescript-eslint/no-explicit-any */
+};
+
+/**
+ * A utility Zod schema for `bigint` properties that can be instantiated from a coercible type, that is, a `number`, `string`, or `bigint` itself.
+ */
+const bigIntCoercibleSchema = exports.bigIntCoercibleSchema = _zod.z.bigint().or(_zod.z.number()).or(_zod.z.string()).pipe(_zod.z.coerce.bigint());
+
+/**
+ * A type alias for a Zod schema with `unknown` input and generic output.
+ */
+
+/**
+ * Parse some `unknown` data with a Zod schema. If parsing fails, it logs the error and throws.
+ */
+function parseSchema(data, schema) {
+  const result = schema.safeParse(data);
+  if (!result.success) {
+    const logger = (0, _types.getDefaultLogger)();
+    logger.error(`error: ${result.error.message}\ncaused by input: ${JSONBigInt.stringify(data)}`);
+    throw result.error;
+  }
+  return result.data;
+}
+
+/**
+ * Parse some JSON string with a Zod schema.
+ *
+ * If the JSON string contains large integers that would lose precision with the `number` type, they're parsed as `bigint`s.
+ * This means that `z.bigint()` properties would fail for small integers, as they would be parsed as `number`s.
+ * To mitigate this, use the `bigIntCoercibleSchema` utility, which will coerce the property to a `bigint` output.
+ *
+ * If parsing fails, it logs the error and throws.
+ */
+function parseJsonBigInt(text, schema) {
+  const jsonSchema = _zod.z.string().transform((str, ctx) => {
+    try {
+      return JSONBigInt.parse(str);
+    } catch (e) {
+      ctx.addIssue({
+        code: _zod.z.ZodIssueCode.custom,
+        message: `Could not parse with JSONBigInt. Error: ${e}`
+      });
+      return _zod.z.NEVER;
+    }
+  }).pipe(schema);
+  return parseSchema(text, jsonSchema);
+}
+
+/**
+ * A utility function to be used with `transformResponse` in Axios requests with support for `bigint` properties, powered by Zod schemas.
+ *
+ * If the JSON string contains large integers that would lose precision with the `number` type, they're parsed as `bigint`s.
+ * This means that `z.bigint()` properties would fail for small integers, as they would be parsed as `number`s.
+ * To mitigate this, use the `bigIntCoercibleSchema` utility, which will coerce the property to a `bigint` output.
+ */
+function transformJsonBigIntResponse(data, schema) {
+  return typeof data === 'string' ? parseJsonBigInt(data, schema) : parseSchema(data, schema);
+}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/utils/buffer.d.ts b/node_modules/@hathor/wallet-lib/oldLib/utils/buffer.d.ts
new file mode 100644
index 0000000..52d585a
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/utils/buffer.d.ts
@@ -0,0 +1,113 @@
+/// <reference types="node" />
+import buffer from 'buffer';
+import { OutputValueType } from '../types';
+/**
+ * Transform int to bytes
+ *
+ * @param {number} value Integer to be transformed to bytes
+ * @param {number} bytes How many bytes this number uses
+ *
+ * @return {Buffer} number in bytes
+ * @inner
+ */
+export declare function intToBytes(value: number, bytes: number): Buffer;
+/**
+ * Transform signed int to bytes (1, 2, or 4 bytes)
+ *
+ * @param {number} value Integer to be transformed to bytes
+ * @param {number} bytes How many bytes this number uses
+ *
+ * @return {Buffer} number in bytes
+ * @inner
+ */
+export declare function signedIntToBytes(value: number, bytes: number): Buffer;
+/**
+ * Transform a signed `bigint` to bytes (4 or 8 bytes).
+ *
+ * @param {bigint} value BigInt to be transformed to bytes
+ * @param {number} bytes How many bytes this number uses
+ */
+export declare function bigIntToBytes(value: bigint, bytes: 4 | 8): Buffer;
+/**
+ * Transform float to bytes
+ *
+ * @param {number} value Integer to be transformed to bytes
+ * @param {number} bytes How many bytes this number uses
+ *
+ * @return {Buffer} number in bytes
+ * @inner
+ */
+export declare function floatToBytes(value: number, bytes: number): Buffer;
+export declare const hexToBuffer: (value: string) => Buffer;
+/**
+ * Unpacks a buffer size
+ *
+ * @param {number} n The size of the buffer to unpack
+ * @param {Buffer} buff The buffer to unpack
+ *
+ * @return {[Buffer, Buffer]} The unpacked buffer followed by the rest of the buffer
+ */
+export declare const unpackLen: (n: number, buff: Buffer) => [Buffer, Buffer];
+/**
+ * Unpacks an integer from a buffer
+ *
+ * @param {number} n The size of the number in bytes
+ * @param {boolean} signed If the number is signed
+ * @param {Buffer} buff The buffer to unpack
+ *
+ * @return {[number, Buffer]} The unpacked number followed by the rest of the buffer
+ */
+export declare const unpackToInt: (n: number, signed: boolean, buff: Buffer) => [number, Buffer];
+/**
+ * Unpacks a `bigint` from a buffer, used for 64-bit integers.
+ *
+ * @param {8} n The size of the number in bytes, should always be 8
+ * @param {boolean} signed If the number is signed
+ * @param {Buffer} buff The buffer to unpack
+ *
+ * @return {[bigint, Buffer]} The unpacked `bigint` followed by the rest of the buffer
+ */
+export declare const unpackToBigInt: (n: 8, signed: boolean, buff: Buffer) => [bigint, Buffer];
+/**
+ * Unpacks a float from a buffer
+ *
+ * @param {Buffer} buff The buffer to unpack
+ *
+ * @return {[number, Buffer]} The unpacked float followed by the rest of the buffer
+ */
+export declare const unpackToFloat: (buff: Buffer) => [number, Buffer];
+/**
+ * Unpacks a hex from a buffer
+ *
+ * @param {number} n The size of the hex to unpack
+ * @param {Buffer} buff The buffer to unpack
+ *
+ * @return {[string, Buffer]} The unpacked hex followed by the rest of the buffer
+ */
+export declare const unpackToHex: (n: number, buff: Buffer) => [string, Buffer];
+/**
+ * Transforms buffer to hex
+ *
+ * @param {Buffer} buff The buffer to be transformed to hex
+ *
+ * @return {string} Hexadecimal of the buffer
+ */
+export declare const bufferToHex: (buff: Buffer) => string;
+/**
+ * Transforms buffer to output value
+ * First we get the highByte value to check if it was a 8-byte or 4-byte value
+ * Then we unpack the integer and multiply by the sign.
+ *
+ * @param srcBuf The buffer to unpack the value
+ *
+ * @return Output value and rest of buffer after unpacking
+ */
+export declare const bytesToOutputValue: (srcBuf: Buffer) => [OutputValueType, Buffer];
+/**
+ * Get the bytes from the value
+ * If value is above the maximum for 32 bits we get from 8 bytes, otherwise only 4 bytes
+ *
+ * @throws {OutputValueError} Will throw an error if output value is invalid
+ */
+export declare const outputValueToBytes: (value: OutputValueType) => Buffer;
+//# sourceMappingURL=buffer.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/utils/buffer.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/utils/buffer.d.ts.map
new file mode 100644
index 0000000..9edfc33
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/utils/buffer.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"buffer.d.ts","sourceRoot":"","sources":["../../src/utils/buffer.ts"],"names":[],"mappings":";AAAA,OAAO,MAAM,MAAM,QAAQ,CAAC;AAE5B,OAAO,EAAE,eAAe,EAAE,MAAM,UAAU,CAAC;AAS3C;;;;;;;;GAQG;AACH,wBAAgB,UAAU,CAAC,KAAK,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM,GAAG,MAAM,CAc/D;AAED;;;;;;;;GAQG;AACH,wBAAgB,gBAAgB,CAAC,KAAK,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM,GAAG,MAAM,CAarE;AAED;;;;;GAKG;AACH,wBAAgB,aAAa,CAAC,KAAK,EAAE,MAAM,EAAE,KAAK,EAAE,CAAC,GAAG,CAAC,GAAG,MAAM,CAoBjE;AAED;;;;;;;;GAQG;AACH,wBAAgB,YAAY,CAAC,KAAK,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM,GAAG,MAAM,CAQjE;AAED,eAAO,MAAM,WAAW,UAAW,MAAM,KAAG,MAK3C,CAAC;AAkBF;;;;;;;GAOG;AACH,eAAO,MAAM,SAAS,MAAO,MAAM,QAAQ,MAAM,KAAG,CAAC,MAAM,EAAE,MAAM,CAIlE,CAAC;AAEF;;;;;;;;GAQG;AACH,eAAO,MAAM,WAAW,MAAO,MAAM,UAAU,OAAO,QAAQ,MAAM,KAAG,CAAC,MAAM,EAAE,MAAM,CA4BrF,CAAC;AAEF;;;;;;;;GAQG;AACH,eAAO,MAAM,cAAc,MAAO,CAAC,UAAU,OAAO,QAAQ,MAAM,KAAG,CAAC,MAAM,EAAE,MAAM,CAUnF,CAAC;AAEF;;;;;;GAMG;AACH,eAAO,MAAM,aAAa,SAAU,MAAM,KAAG,CAAC,MAAM,EAAE,MAAM,CAM3D,CAAC;AAEF;;;;;;;GAOG;AACH,eAAO,MAAM,WAAW,MAAO,MAAM,QAAQ,MAAM,KAAG,CAAC,MAAM,EAAE,MAAM,CAKpE,CAAC;AAEF;;;;;;GAMG;AACH,eAAO,MAAM,WAAW,SAAU,MAAM,KAAG,MAE1C,CAAC;AAEF;;;;;;;;GAQG;AACH,eAAO,MAAM,kBAAkB,WAAY,MAAM,KAAG,CAAC,eAAe,EAAE,MAAM,CAoB3E,CAAC;AAEF;;;;;GAKG;AACH,eAAO,MAAM,kBAAkB,UAAW,eAAe,KAAG,MAW3D,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/utils/buffer.js b/node_modules/@hathor/wallet-lib/oldLib/utils/buffer.js
new file mode 100644
index 0000000..4f9fc18
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/utils/buffer.js
@@ -0,0 +1,303 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.bigIntToBytes = bigIntToBytes;
+exports.bytesToOutputValue = exports.bufferToHex = void 0;
+exports.floatToBytes = floatToBytes;
+exports.hexToBuffer = void 0;
+exports.intToBytes = intToBytes;
+exports.outputValueToBytes = void 0;
+exports.signedIntToBytes = signedIntToBytes;
+exports.unpackToInt = exports.unpackToHex = exports.unpackToFloat = exports.unpackToBigInt = exports.unpackLen = void 0;
+var _buffer = _interopRequireDefault(require("buffer"));
+var _errors = require("../errors");
+var _constants = require("../constants");
+var _numbers = require("./numbers");
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+const isHexa = value => {
+  // test if value is string?
+  return /^[0-9a-fA-F]*$/.test(value);
+};
+
+/**
+ * Transform int to bytes
+ *
+ * @param {number} value Integer to be transformed to bytes
+ * @param {number} bytes How many bytes this number uses
+ *
+ * @return {Buffer} number in bytes
+ * @inner
+ */
+function intToBytes(value, bytes) {
+  const arr = new ArrayBuffer(bytes);
+  const view = new DataView(arr);
+  if (bytes === 1) {
+    // byteOffset = 0;
+    view.setUint8(0, value);
+  } else if (bytes === 2) {
+    // byteOffset = 0; isLittleEndian = false
+    view.setUint16(0, value, false);
+  } else if (bytes === 4) {
+    // byteOffset = 0; isLittleEndian = false
+    view.setUint32(0, value, false);
+  }
+  return _buffer.default.Buffer.from(arr);
+}
+
+/**
+ * Transform signed int to bytes (1, 2, or 4 bytes)
+ *
+ * @param {number} value Integer to be transformed to bytes
+ * @param {number} bytes How many bytes this number uses
+ *
+ * @return {Buffer} number in bytes
+ * @inner
+ */
+function signedIntToBytes(value, bytes) {
+  const arr = new ArrayBuffer(bytes);
+  const view = new DataView(arr);
+  if (bytes === 1) {
+    // byteOffset = 0
+    view.setInt8(0, value);
+  } else if (bytes === 2) {
+    // byteOffset = 0; isLittleEndian = false
+    view.setInt16(0, value, false);
+  } else if (bytes === 4) {
+    view.setInt32(0, value, false);
+  }
+  return _buffer.default.Buffer.from(arr);
+}
+
+/**
+ * Transform a signed `bigint` to bytes (4 or 8 bytes).
+ *
+ * @param {bigint} value BigInt to be transformed to bytes
+ * @param {number} bytes How many bytes this number uses
+ */
+function bigIntToBytes(value, bytes) {
+  const arr = new ArrayBuffer(bytes);
+  const view = new DataView(arr);
+  switch (bytes) {
+    case 4:
+      if (value < -(2n ** 31n) || 2n ** 31n - 1n < value) {
+        throw new Error(`value too large for 4 bytes: ${value}`);
+      }
+      view.setInt32(0, Number(value), false);
+      break;
+    case 8:
+      if (value < -(2n ** 63n) || 2n ** 63n - 1n < value) {
+        throw new Error(`value too large for 8 bytes: ${value}`);
+      }
+      view.setBigInt64(0, value, false);
+      break;
+    default:
+      throw new Error(`invalid bytes size: ${bytes}`);
+  }
+  return _buffer.default.Buffer.from(arr);
+}
+
+/**
+ * Transform float to bytes
+ *
+ * @param {number} value Integer to be transformed to bytes
+ * @param {number} bytes How many bytes this number uses
+ *
+ * @return {Buffer} number in bytes
+ * @inner
+ */
+function floatToBytes(value, bytes) {
+  const arr = new ArrayBuffer(bytes);
+  const view = new DataView(arr);
+  if (bytes === 8) {
+    // byteOffset = 0; isLitteEndian = false
+    view.setFloat64(0, value, false);
+  }
+  return _buffer.default.Buffer.from(arr);
+}
+const hexToBuffer = value => {
+  if (!isHexa(value)) {
+    throw new Error('hexToBuffer: argument must be a strict hex string.');
+  }
+  return Buffer.from(value, 'hex');
+};
+
+/**
+ * Validates if buffer has enough bytes to unpack
+ *
+ * @param {number} n The size to unpack
+ * @param {Buffer} buff The buffer to unpack
+ *
+ * @throws ParseError when requests to unpack more bytes than the buffer size
+ */
+exports.hexToBuffer = hexToBuffer;
+const validateLenToUnpack = (n, buff) => {
+  if (buff.length < n) {
+    throw new _errors.ParseError(`Don't have enough bytes to unpack. Requested ${n} and buffer has ${buff.length}`);
+  }
+};
+
+/**
+ * Unpacks a buffer size
+ *
+ * @param {number} n The size of the buffer to unpack
+ * @param {Buffer} buff The buffer to unpack
+ *
+ * @return {[Buffer, Buffer]} The unpacked buffer followed by the rest of the buffer
+ */
+const unpackLen = (n, buff) => {
+  validateLenToUnpack(n, buff);
+  return [buff.subarray(0, n), buff.subarray(n)];
+};
+
+/**
+ * Unpacks an integer from a buffer
+ *
+ * @param {number} n The size of the number in bytes
+ * @param {boolean} signed If the number is signed
+ * @param {Buffer} buff The buffer to unpack
+ *
+ * @return {[number, Buffer]} The unpacked number followed by the rest of the buffer
+ */
+exports.unpackLen = unpackLen;
+const unpackToInt = (n, signed, buff) => {
+  validateLenToUnpack(n, buff);
+  let retInt;
+  const slicedBuff = buff.slice(0, n);
+  if (n === 1) {
+    if (signed) {
+      retInt = slicedBuff.readInt8(0);
+    } else {
+      retInt = slicedBuff.readUInt8(0);
+    }
+  } else if (n === 2) {
+    if (signed) {
+      retInt = slicedBuff.readInt16BE(0);
+    } else {
+      retInt = slicedBuff.readUInt16BE(0);
+    }
+  } else if (n === 4) {
+    if (signed) {
+      retInt = slicedBuff.readInt32BE(0);
+    } else {
+      retInt = slicedBuff.readUInt32BE(0);
+    }
+  } else {
+    throw new _errors.ParseError('Invalid value for n.');
+  }
+  return [retInt, buff.slice(n)];
+};
+
+/**
+ * Unpacks a `bigint` from a buffer, used for 64-bit integers.
+ *
+ * @param {8} n The size of the number in bytes, should always be 8
+ * @param {boolean} signed If the number is signed
+ * @param {Buffer} buff The buffer to unpack
+ *
+ * @return {[bigint, Buffer]} The unpacked `bigint` followed by the rest of the buffer
+ */
+exports.unpackToInt = unpackToInt;
+const unpackToBigInt = (n, signed, buff) => {
+  validateLenToUnpack(n, buff);
+  const [buf, rest] = [buff.subarray(0, n), buff.subarray(n)];
+  if (n !== 8) {
+    throw new Error(`invalid bytes size: ${n}`);
+  }
+  const value = signed ? buf.readBigInt64BE(0) : buf.readBigUInt64BE(0);
+  return [value, rest];
+};
+
+/**
+ * Unpacks a float from a buffer
+ *
+ * @param {Buffer} buff The buffer to unpack
+ *
+ * @return {[number, Buffer]} The unpacked float followed by the rest of the buffer
+ */
+exports.unpackToBigInt = unpackToBigInt;
+const unpackToFloat = buff => {
+  const n = 8;
+  validateLenToUnpack(n, buff);
+  const retFloat = buff.slice(0, n).readDoubleBE(0);
+  return [retFloat, buff.slice(n)];
+};
+
+/**
+ * Unpacks a hex from a buffer
+ *
+ * @param {number} n The size of the hex to unpack
+ * @param {Buffer} buff The buffer to unpack
+ *
+ * @return {[string, Buffer]} The unpacked hex followed by the rest of the buffer
+ */
+exports.unpackToFloat = unpackToFloat;
+const unpackToHex = (n, buff) => {
+  const unpackedRet = unpackLen(n, buff);
+  const unpackedHex = bufferToHex(unpackedRet[0]);
+  return [unpackedHex, unpackedRet[1]];
+};
+
+/**
+ * Transforms buffer to hex
+ *
+ * @param {Buffer} buff The buffer to be transformed to hex
+ *
+ * @return {string} Hexadecimal of the buffer
+ */
+exports.unpackToHex = unpackToHex;
+const bufferToHex = buff => {
+  return buff.toString('hex');
+};
+
+/**
+ * Transforms buffer to output value
+ * First we get the highByte value to check if it was a 8-byte or 4-byte value
+ * Then we unpack the integer and multiply by the sign.
+ *
+ * @param srcBuf The buffer to unpack the value
+ *
+ * @return Output value and rest of buffer after unpacking
+ */
+exports.bufferToHex = bufferToHex;
+const bytesToOutputValue = srcBuf => {
+  // Copies buffer locally, not to change the original parameter
+  let buff = Buffer.from(srcBuf);
+  const [highByte] = unpackToInt(1, true, buff);
+  let sign;
+  let value;
+  if (highByte < 0) {
+    // 8 bytes
+    sign = -1n;
+    [value, buff] = unpackToBigInt(8, true, buff);
+  } else {
+    // 4 bytes
+    sign = 1n;
+    let numberValue;
+    [numberValue, buff] = unpackToInt(4, true, buff);
+    value = BigInt(numberValue);
+  }
+  return [value * sign, buff];
+};
+
+/**
+ * Get the bytes from the value
+ * If value is above the maximum for 32 bits we get from 8 bytes, otherwise only 4 bytes
+ *
+ * @throws {OutputValueError} Will throw an error if output value is invalid
+ */
+exports.bytesToOutputValue = bytesToOutputValue;
+const outputValueToBytes = value => {
+  if (value <= 0) {
+    throw new _errors.OutputValueError('Output value must be positive');
+  }
+  if (value > _constants.MAX_OUTPUT_VALUE) {
+    throw new _errors.OutputValueError(`Maximum value is ${(0, _numbers.prettyValue)(_constants.MAX_OUTPUT_VALUE)}`);
+  }
+  if (value > _constants.MAX_OUTPUT_VALUE_32) {
+    return bigIntToBytes(-value, 8);
+  }
+  return bigIntToBytes(value, 4);
+};
+exports.outputValueToBytes = outputValueToBytes;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/utils/connection.d.ts b/node_modules/@hathor/wallet-lib/oldLib/utils/connection.d.ts
new file mode 100644
index 0000000..c7d242d
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/utils/connection.d.ts
@@ -0,0 +1,15 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+import { IStorage } from '../types';
+export declare function handleWsDashboard(storage: IStorage): (data: {
+    best_block_height: number;
+}) => void;
+export declare function handleSubscribeAddress(): (data: {
+    success?: boolean;
+    message?: string;
+}) => void;
+//# sourceMappingURL=connection.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/utils/connection.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/utils/connection.d.ts.map
new file mode 100644
index 0000000..f1c3574
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/utils/connection.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"connection.d.ts","sourceRoot":"","sources":["../../src/utils/connection.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;AAEH,OAAO,EAAE,QAAQ,EAAE,MAAM,UAAU,CAAC;AAEpC,wBAAgB,iBAAiB,CAAC,OAAO,EAAE,QAAQ,UACnC;IAAE,iBAAiB,EAAE,MAAM,CAAA;CAAE,UAU5C;AAED,wBAAgB,sBAAsB,WACtB;IAAE,OAAO,CAAC,EAAE,OAAO,CAAC;IAAC,OAAO,CAAC,EAAE,MAAM,CAAA;CAAE,UAMtD"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/utils/connection.js b/node_modules/@hathor/wallet-lib/oldLib/utils/connection.js
new file mode 100644
index 0000000..2319095
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/utils/connection.js
@@ -0,0 +1,34 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.handleSubscribeAddress = handleSubscribeAddress;
+exports.handleWsDashboard = handleWsDashboard;
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+function handleWsDashboard(storage) {
+  return data => {
+    // update network height
+    const height = data.best_block_height;
+    storage.getCurrentHeight().then(currentHeight => {
+      if (height !== currentHeight) {
+        storage.setCurrentHeight(height);
+        storage.unlockUtxos(height);
+      }
+    });
+  };
+}
+function handleSubscribeAddress() {
+  return data => {
+    if (data.success === false) {
+      // If an address subscription fails we stop the service
+      throw new Error(data.message);
+    }
+  };
+}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/utils/crypto.d.ts b/node_modules/@hathor/wallet-lib/oldLib/utils/crypto.d.ts
new file mode 100644
index 0000000..245db59
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/utils/crypto.d.ts
@@ -0,0 +1,92 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+import bitcore from 'bitcore-lib';
+import { IEncryptedData } from '../types';
+/**
+ * Hash a piece of information with the given options.
+ *
+ * pbkdf2Hasher is the name of the hash implementation to use with PBKDF2.
+ * Currently supported hash algorithms are:
+ * - sha1
+ * - sha256
+ *
+ * @param {string} data Data to hash
+ * @param {{salt: string, iterations: number, pbkdf2Hasher: string}} [options={}] options for the hash algo
+ * @returns {{hash: string, salt: string, iterations: number, pbkdf2Hasher: string}}
+ */
+export declare function hashData(data: string, { salt, iterations, pbkdf2Hasher, }?: {
+    salt?: string;
+    iterations?: number;
+    pbkdf2Hasher?: string;
+}): {
+    hash: string;
+    salt: string;
+    iterations: number;
+    pbkdf2Hasher: string;
+};
+/**
+ * Encrypt a piece of information with a password and add metadata for password validation.
+ *
+ * @param {string} data Data to encrypt
+ * @param {string} password Encryption password to use
+ * @param {{salt: string, iterations: number, pbkdf2Hasher: string}} [options={}] Options to hash the password, for validation
+ * @returns {IEncryptedData} Encrypted data with encryption metadata
+ */
+export declare function encryptData(data: string, password: string, { salt, iterations, pbkdf2Hasher, }?: {
+    salt?: string;
+    iterations?: number;
+    pbkdf2Hasher?: string;
+}): IEncryptedData;
+/**
+ * Validate the password and decrypt the data
+ *
+ * @param {IEncryptedData} data Encrypted data, complete with metadata
+ * @param {string} password The encryption password
+ * @returns {string} The decrypted data
+ */
+export declare function decryptData(data: IEncryptedData, password: string): string;
+/**
+ * Validate that the hashed data matches the given data
+ * Obs: This is used for password validation
+ *
+ * @param {string} dataToValidate What the caller thinks is the original data
+ * @param {string} hashedData The hashed data we use to compare
+ * @param {{salt: string, iterations: number, pbkdf2Hasher: string}} options Options for the hash algo
+ * @returns {boolean} if the data matches
+ */
+export declare function validateHash(dataToValidate: string, hashedData: string, { salt, iterations, pbkdf2Hasher, }?: {
+    salt?: string;
+    iterations?: number;
+    pbkdf2Hasher?: string;
+}): boolean;
+/**
+ * Check that the given password was used to encrypt the given data.
+ * @param {IEncryptedData} data The encrypted data.
+ * @param {string} password The password we want to check against the data.
+ *
+ * @returns {boolean}
+ */
+export declare function checkPassword(data: IEncryptedData, password: string): boolean;
+/**
+ * Signs an arbitrary message given a private key
+ * @param {string} message The message to be signed using a privateKey
+ * @param {bitcore.PrivateKey} privateKey The privateKey to sign the message with
+ *
+ * @returns {string} Base64 encoded signature
+ */
+export declare function signMessage(message: string, privateKey: bitcore.PrivateKey): string;
+/**
+ * Verifies that a message was signed with an address' privateKey
+ *
+ * @param {string} message The message to be signed using a privateKey
+ * @param {string} signature The signature in base64
+ * @param {string} address The address which the message was signed with
+ *
+ * @returns {boolean}
+ */
+export declare function verifyMessage(message: string, signature: string, address: string): boolean;
+//# sourceMappingURL=crypto.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/utils/crypto.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/utils/crypto.d.ts.map
new file mode 100644
index 0000000..c11852e
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/utils/crypto.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"crypto.d.ts","sourceRoot":"","sources":["../../src/utils/crypto.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;AAGH,OAAO,OAAO,MAAM,aAAa,CAAC;AAGlC,OAAO,EAAE,cAAc,EAAE,MAAM,UAAU,CAAC;AAK1C;;;;;;;;;;;GAWG;AACH,wBAAgB,QAAQ,CACtB,IAAI,EAAE,MAAM,EACZ,EACE,IAAI,EACJ,UAA4B,EAC5B,YAAqB,GACtB,GAAE;IAAE,IAAI,CAAC,EAAE,MAAM,CAAC;IAAC,UAAU,CAAC,EAAE,MAAM,CAAC;IAAC,YAAY,CAAC,EAAE,MAAM,CAAA;CAAO,GACpE;IAAE,IAAI,EAAE,MAAM,CAAC;IAAC,IAAI,EAAE,MAAM,CAAC;IAAC,UAAU,EAAE,MAAM,CAAC;IAAC,YAAY,EAAE,MAAM,CAAA;CAAE,CA+B1E;AAED;;;;;;;GAOG;AACH,wBAAgB,WAAW,CACzB,IAAI,EAAE,MAAM,EACZ,QAAQ,EAAE,MAAM,EAChB,EACE,IAAI,EACJ,UAA4B,EAC5B,YAAqB,GACtB,GAAE;IAAE,IAAI,CAAC,EAAE,MAAM,CAAC;IAAC,UAAU,CAAC,EAAE,MAAM,CAAC;IAAC,YAAY,CAAC,EAAE,MAAM,CAAA;CAAO,GACpE,cAAc,CAIhB;AAcD;;;;;;GAMG;AACH,wBAAgB,WAAW,CAAC,IAAI,EAAE,cAAc,EAAE,QAAQ,EAAE,MAAM,GAAG,MAAM,CAuB1E;AAED;;;;;;;;GAQG;AACH,wBAAgB,YAAY,CAC1B,cAAc,EAAE,MAAM,EACtB,UAAU,EAAE,MAAM,EAClB,EACE,IAAI,EACJ,UAA4B,EAC5B,YAAqB,GACtB,GAAE;IAAE,IAAI,CAAC,EAAE,MAAM,CAAC;IAAC,UAAU,CAAC,EAAE,MAAM,CAAC;IAAC,YAAY,CAAC,EAAE,MAAM,CAAA;CAAO,GACpE,OAAO,CAGT;AAED;;;;;;GAMG;AACH,wBAAgB,aAAa,CAAC,IAAI,EAAE,cAAc,EAAE,QAAQ,EAAE,MAAM,GAAG,OAAO,CAO7E;AAED;;;;;;GAMG;AACH,wBAAgB,WAAW,CAAC,OAAO,EAAE,MAAM,EAAE,UAAU,EAAE,OAAO,CAAC,UAAU,GAAG,MAAM,CAGnF;AAED;;;;;;;;GAQG;AACH,wBAAgB,aAAa,CAAC,OAAO,EAAE,MAAM,EAAE,SAAS,EAAE,MAAM,EAAE,OAAO,EAAE,MAAM,GAAG,OAAO,CAI1F"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/utils/crypto.js b/node_modules/@hathor/wallet-lib/oldLib/utils/crypto.js
new file mode 100644
index 0000000..6195362
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/utils/crypto.js
@@ -0,0 +1,204 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.checkPassword = checkPassword;
+exports.decryptData = decryptData;
+exports.encryptData = encryptData;
+exports.hashData = hashData;
+exports.signMessage = signMessage;
+exports.validateHash = validateHash;
+exports.verifyMessage = verifyMessage;
+var _cryptoJs = _interopRequireDefault(require("crypto-js"));
+var _bitcoreLib = _interopRequireDefault(require("bitcore-lib"));
+var _errors = require("../errors");
+var _constants = require("../constants");
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+// Monkey-patch MAGIC_BYTES to use Hathor's
+_bitcoreLib.default.Message.MAGIC_BYTES = Buffer.from(_constants.HATHOR_MAGIC_BYTES);
+
+/**
+ * Hash a piece of information with the given options.
+ *
+ * pbkdf2Hasher is the name of the hash implementation to use with PBKDF2.
+ * Currently supported hash algorithms are:
+ * - sha1
+ * - sha256
+ *
+ * @param {string} data Data to hash
+ * @param {{salt: string, iterations: number, pbkdf2Hasher: string}} [options={}] options for the hash algo
+ * @returns {{hash: string, salt: string, iterations: number, pbkdf2Hasher: string}}
+ */
+function hashData(data, {
+  salt,
+  iterations = _constants.HASH_ITERATIONS,
+  pbkdf2Hasher = 'sha1'
+} = {}) {
+  // eslint-disable-next-line @typescript-eslint/no-explicit-any -- HasherStatic type is not exported by its lib
+  const hashers = new Map([['sha1', _cryptoJs.default.algo.SHA1], ['sha256', _cryptoJs.default.algo.SHA256]]);
+  const hasher = hashers.get(pbkdf2Hasher);
+  if (!hasher) {
+    // Used an unsupported hasher algorithm
+    throw new _errors.UnsupportedHasherError(`Invalid hasher: ${pbkdf2Hasher}`);
+  }
+  const actualSalt = salt || _cryptoJs.default.lib.WordArray.random(128 / 8).toString();
+
+  // NIST has issued Special Publication SP 800-132 recommending PBKDF2
+  // For further information, see https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf
+  // The default hash algorithm used by CryptoJS.PBKDF2 is SHA1
+  // https://github.com/brix/crypto-js/blob/develop/src/pbkdf2.js#L24
+  const hash = _cryptoJs.default.PBKDF2(data, actualSalt, {
+    keySize: _constants.HASH_KEY_SIZE / 32,
+    hasher,
+    iterations
+  });
+  return {
+    hash: hash.toString(),
+    salt: actualSalt,
+    iterations,
+    pbkdf2Hasher
+  };
+}
+
+/**
+ * Encrypt a piece of information with a password and add metadata for password validation.
+ *
+ * @param {string} data Data to encrypt
+ * @param {string} password Encryption password to use
+ * @param {{salt: string, iterations: number, pbkdf2Hasher: string}} [options={}] Options to hash the password, for validation
+ * @returns {IEncryptedData} Encrypted data with encryption metadata
+ */
+function encryptData(data, password, {
+  salt,
+  iterations = _constants.HASH_ITERATIONS,
+  pbkdf2Hasher = 'sha1'
+} = {}) {
+  const encrypted = _cryptoJs.default.AES.encrypt(data, password);
+  const hash = hashData(password, {
+    salt,
+    iterations,
+    pbkdf2Hasher
+  });
+  return {
+    data: encrypted.toString(),
+    ...hash
+  };
+}
+
+/**
+ * Decrypt and encode data.
+ *
+ * @param {string} data Encrypted string of data
+ * @param {string} password Encryption password
+ * @returns {string} Original data
+ */
+function _decryptData(data, password) {
+  const decrypted = _cryptoJs.default.AES.decrypt(data, password);
+  return decrypted.toString(_cryptoJs.default.enc.Utf8);
+}
+
+/**
+ * Validate the password and decrypt the data
+ *
+ * @param {IEncryptedData} data Encrypted data, complete with metadata
+ * @param {string} password The encryption password
+ * @returns {string} The decrypted data
+ */
+function decryptData(data, password) {
+  const keyData = data.data;
+  const {
+    hash
+  } = data;
+  const options = {
+    salt: data.salt,
+    iterations: data.iterations,
+    pbkdf2Hasher: data.pbkdf2Hasher
+  };
+  if (validateHash(password, hash, options)) {
+    try {
+      const originalData = _decryptData(keyData, password);
+      if (originalData.length === 0) {
+        // For certain NodeJS versions the CryptoJS.lib.WordArray will not raise an exception for malformed data.
+        // It will just return an empty string, so we throw an error to mark the data as invalid.
+        throw new _errors.DecryptionError();
+      }
+      return originalData;
+    } catch (err) {
+      throw new _errors.DecryptionError();
+    }
+  } else {
+    throw new _errors.InvalidPasswdError();
+  }
+}
+
+/**
+ * Validate that the hashed data matches the given data
+ * Obs: This is used for password validation
+ *
+ * @param {string} dataToValidate What the caller thinks is the original data
+ * @param {string} hashedData The hashed data we use to compare
+ * @param {{salt: string, iterations: number, pbkdf2Hasher: string}} options Options for the hash algo
+ * @returns {boolean} if the data matches
+ */
+function validateHash(dataToValidate, hashedData, {
+  salt,
+  iterations = _constants.HASH_ITERATIONS,
+  pbkdf2Hasher = 'sha1'
+} = {}) {
+  const hash = hashData(dataToValidate, {
+    salt,
+    iterations,
+    pbkdf2Hasher
+  });
+  return hash.hash === hashedData;
+}
+
+/**
+ * Check that the given password was used to encrypt the given data.
+ * @param {IEncryptedData} data The encrypted data.
+ * @param {string} password The password we want to check against the data.
+ *
+ * @returns {boolean}
+ */
+function checkPassword(data, password) {
+  const options = {
+    salt: data.salt,
+    iterations: data.iterations,
+    pbkdf2Hasher: data.pbkdf2Hasher
+  };
+  return validateHash(password, data.hash, options);
+}
+
+/**
+ * Signs an arbitrary message given a private key
+ * @param {string} message The message to be signed using a privateKey
+ * @param {bitcore.PrivateKey} privateKey The privateKey to sign the message with
+ *
+ * @returns {string} Base64 encoded signature
+ */
+function signMessage(message, privateKey) {
+  const signature = _bitcoreLib.default.Message(message).sign(privateKey);
+  return signature;
+}
+
+/**
+ * Verifies that a message was signed with an address' privateKey
+ *
+ * @param {string} message The message to be signed using a privateKey
+ * @param {string} signature The signature in base64
+ * @param {string} address The address which the message was signed with
+ *
+ * @returns {boolean}
+ */
+function verifyMessage(message, signature, address) {
+  const bitcoreLibMessage = new _bitcoreLib.default.Message(message);
+  return bitcoreLibMessage.verify(new _bitcoreLib.default.Address(address), signature);
+}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/utils/date.d.ts b/node_modules/@hathor/wallet-lib/oldLib/utils/date.d.ts
new file mode 100644
index 0000000..7987841
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/utils/date.d.ts
@@ -0,0 +1,50 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/**
+ * Util methods to help handle date
+ *
+ * @namespace Date
+ */
+declare const dateFormatter: {
+    /**
+     * Get locale date from timestamp
+     * en-US date format (m/d/yyyy hh:mm:ss AM/PM)
+     *
+     * @param {number} timestamp Timestamp to be parsed
+     *
+     * @return {string} Locale date and time
+     *
+     * @memberof Date
+     * @inner
+     */
+    parseTimestamp(timestamp: number, timezone?: string | null): string;
+    /**
+     * Get formatted seconds
+     * From seconds transform into days, hours, minutes and seconds
+     *
+     * @param paramUptime Seconds of uptime
+     *
+     * @return Formatted uptime seconds
+     *
+     * @memberof Date
+     * @inner
+     */
+    uptimeFormat(paramUptime: number): string;
+    /**
+     * Get timestamp from date
+     *
+     * @param {Object} date Date object to get timestamp from
+     *
+     * @return {number} Timestamp of the date
+     *
+     * @memberof Date
+     * @inner
+     */
+    dateToTimestamp(date: Date): number;
+};
+export default dateFormatter;
+//# sourceMappingURL=date.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/utils/date.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/utils/date.d.ts.map
new file mode 100644
index 0000000..96e978e
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/utils/date.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"date.d.ts","sourceRoot":"","sources":["../../src/utils/date.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;AAEH;;;;GAIG;AACH,QAAA,MAAM,aAAa;IACjB;;;;;;;;;;OAUG;8BACuB,MAAM,aAAY,MAAM,GAAG,IAAI,GAAU,MAAM;IAMzE;;;;;;;;;;OAUG;8BACuB,MAAM,GAAG,MAAM;IAczC;;;;;;;;;OASG;0BACmB,IAAI,GAAG,MAAM;CAGpC,CAAC;AAEF,eAAe,aAAa,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/utils/date.js b/node_modules/@hathor/wallet-lib/oldLib/utils/date.js
new file mode 100644
index 0000000..a2665e5
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/utils/date.js
@@ -0,0 +1,76 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+/**
+ * Util methods to help handle date
+ *
+ * @namespace Date
+ */
+const dateFormatter = {
+  /**
+   * Get locale date from timestamp
+   * en-US date format (m/d/yyyy hh:mm:ss AM/PM)
+   *
+   * @param {number} timestamp Timestamp to be parsed
+   *
+   * @return {string} Locale date and time
+   *
+   * @memberof Date
+   * @inner
+   */
+  parseTimestamp(timestamp, timezone = null) {
+    const d = new Date(timestamp * 1000); // new Date in js expect milliseconds
+    const options = timezone ? {
+      timeZone: timezone
+    } : {};
+    return `${d.toLocaleDateString('en-US', options)} ${d.toLocaleTimeString('en-US', options)}`;
+  },
+  /**
+   * Get formatted seconds
+   * From seconds transform into days, hours, minutes and seconds
+   *
+   * @param paramUptime Seconds of uptime
+   *
+   * @return Formatted uptime seconds
+   *
+   * @memberof Date
+   * @inner
+   */
+  uptimeFormat(paramUptime) {
+    let uptime = Math.floor(paramUptime);
+    const days = Math.floor(uptime / 3600 / 24);
+    uptime %= 3600 * 24;
+    const hours = Math.floor(uptime / 3600);
+    uptime %= 3600;
+    const minutes = Math.floor(uptime / 60);
+    uptime %= 60;
+    const seconds = uptime;
+    const pad = n => Math.abs(n) >= 10 ? n : `0${n}`;
+    const uptime_str = `${days} days, ${pad(hours)}:${pad(minutes)}:${pad(seconds)}`;
+    return uptime_str;
+  },
+  /**
+   * Get timestamp from date
+   *
+   * @param {Object} date Date object to get timestamp from
+   *
+   * @return {number} Timestamp of the date
+   *
+   * @memberof Date
+   * @inner
+   */
+  dateToTimestamp(date) {
+    return Math.floor(date.getTime() / 1000);
+  }
+};
+var _default = exports.default = dateFormatter;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/utils/helpers.d.ts b/node_modules/@hathor/wallet-lib/oldLib/utils/helpers.d.ts
new file mode 100644
index 0000000..5ff39bf
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/utils/helpers.d.ts
@@ -0,0 +1,312 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/// <reference types="node" />
+import buffer from 'buffer';
+import { AxiosInstance, AxiosRequestConfig } from 'axios';
+import Transaction from '../models/transaction';
+import { HistoryTransaction, HistoryTransactionOutput } from '../models/types';
+import CreateTokenTransaction from '../models/create_token_transaction';
+import Output from '../models/output';
+import Network from '../models/network';
+import Address from '../models/address';
+import { IDataInput, IUtxo } from '../types';
+/**
+ * Helper methods
+ *
+ * @namespace Helpers
+ */
+declare const helpers: {
+    /**
+     * Round float to closest int
+     *
+     * @param {number} n Number to be rounded
+     *
+     * @return {number} Closest integer to n passed
+     *
+     * @memberof Helpers
+     * @inner
+     */
+    roundFloat(n: number): number;
+    /**
+     * Validate if the passed version is valid, comparing with the minVersion
+     *
+     * @param {string} version Version to check if is valid
+     * @param {string} minVersion Minimum allowed version
+     *
+     * @return {boolean}
+     *
+     * @memberof Helpers
+     * @inner
+     */
+    isVersionAllowed(version: string, minVersion: string): boolean;
+    /**
+     * Get the version numbers separated by dot
+     * For example: if you haver version 0.3.1-beta you will get ['0', '3', '1']
+     *
+     * @param {string} version
+     *
+     * @return {Array} Array of numbers with each version number
+     *
+     * @memberof Helpers
+     * @inner
+     */
+    getCleanVersionArray(version: string): string[];
+    /**
+     * Push data to the stack checking if need to add the OP_PUSHDATA1 opcode
+     * We push the length of data and the data
+     * In case the data has length > 75, we need to push the OP_PUSHDATA1 before the length
+     * We always push bytes
+     *
+     * We update the array of Buffer sent as parameter, so we don't return a new one
+     *
+     * @param {Array} stack Stack of bytes from the script
+     * @param {Buffer} data Data to be pushed to stack
+     *
+     * @memberof Helpers
+     * @inner
+     */
+    pushDataToStack(stack: Buffer[], data: Buffer): void;
+    /**
+     * Push an integer to the stack
+     * We always push an opcode representing the number from 0 to 16 (or OP_0 to OP_16)
+     *
+     * We update the array of Buffer sent as parameter, so we don't return a new one
+     *
+     * @param {Array} stack Stack of bytes from the script
+     * @param {number} value number to be pushed on stack
+     *
+     * @memberof Helpers
+     * @inner
+     */
+    pushIntToStack(stack: Buffer[], value: number): void;
+    /**
+     * Return the checksum of the bytes passed
+     * Checksum is calculated as the 4 first bytes of the double sha256
+     *
+     * @param {Buffer} bytes Data from where the checksum is calculated
+     *
+     * @return {Buffer}
+     * @memberof Helpers
+     * @inner
+     */
+    getChecksum(bytes: Buffer): Buffer;
+    /**
+     * Read address bytes validating information.
+     *
+     * @returns address read from bytes
+     */
+    getAddressFromBytes(addressBytes: Buffer, network: Network): Address;
+    /**
+     * Get encoded address object from address hash (20 bytes) and network
+     * We complete the address bytes with the network byte and checksum
+     * then we encode to base 58 and create the address object
+     *
+     * @param {Buffer} addressHash 20 bytes of the address hash in the output script
+     * @param {Network} network Network to get the address first byte parameter
+     *
+     * @return {Address}
+     * @memberof Helpers
+     * @inner
+     */
+    encodeAddress(addressHash: Buffer, network: Network): Address;
+    /**
+     * Get encoded address object from script hash (20 bytes) and network.
+     * We use bitcore's Address module to build the address from the hash.
+     *
+     * @param {Buffer} scriptHash 20 bytes of the script hash in the output script
+     * @param {Network} network Network to get the address first byte parameter
+     *
+     * @return {Address}
+     * @memberof Helpers
+     * @inner
+     */
+    encodeAddressP2SH(scriptHash: Buffer, network: Network): Address;
+    /**
+     * Create a transaction from bytes
+     * First we get the version value from the bytes to discover the
+     * transaction type. We currently support only regular transactions and
+     * create token transactions.
+     *
+     * @param {Buffer} bytes Transaction in bytes
+     * @param {Network} network Network to get the address first byte parameter
+     *
+     * @throws ParseError if sequence of bytes is invalid or network is undefined/null
+     *
+     * @return {Transaction | CreateTokenTransaction}
+     * @memberof Helpers
+     * @inner
+     */
+    createTxFromBytes(bytes: Buffer, network: Network): Transaction | CreateTokenTransaction;
+    /**
+     * Create a transaction from hex
+     * We transform the hex in bytes and call the function to get transaction from bytes
+     *
+     * @param {string} hex Transaction in hexadecimal
+     * @param {Network} network Network to get the address first byte parameter
+     *
+     * @return {Transaction | CreateTokenTransaction}
+     * @memberof Helpers
+     * @inner
+     */
+    createTxFromHex(hex: string, network: Network): Transaction | CreateTokenTransaction;
+    /**
+     * Asyncronous sleep
+     * Creates a promise that will be resolved after sleep time
+     *
+     * @param {number} milliseconds Sleep time in milliseconds
+     *
+     * @return {Promise}
+     * @memberof Helpers
+     * @inner
+     */
+    sleep(milliseconds: number): Promise<void>;
+    /**
+     * Create a transaction from object data
+     * We used to work only with data object to handle transactions in the past inside the lib
+     * This method was created to transform those objects into Transaction class instances
+     *
+     * @param {Object} 'data': {'version', 'weight', 'timestamp', 'tokens', 'inputs': [{'tx_id', 'index'}], 'outputs': [{'address', 'value', 'tokenData', 'timelock'}]}
+     *
+     * if it's a create token transaction, then it expects 'name' and 'symbol' as well.
+     *
+     * @param {Network} network Network to get the address first byte parameter
+     *
+     * @throws {AddressError} If the address used in the P2PKH outputs is invalid
+     *
+     * @memberof Helpers
+     * @inner
+     */
+    createTxFromData(data: any, network: Network): Transaction | CreateTokenTransaction;
+    /**
+     * Creates a Transaction instance from a populated object from the wallet's history methods.
+     *
+     * _Note_: This helper does not need a _Network_ parameter, since all the output scripts were already decoded.
+     * @param {HistoryTransaction} historyTx A transaction formatted as an instance of a wallet history
+     *
+     * @memberof Helpers
+     * @inner
+     *
+     * @example
+     * const historyTx = myHathorWallet.getTx(myTxHash);
+     * const txInstance = helpers.createTxFromHistoryObject(historyTx);
+     */
+    createTxFromHistoryObject(historyTx: HistoryTransaction): Transaction | CreateTokenTransaction;
+    /**
+     * Creates an Output from an object extracted from the wallet's history.
+     * @param {HistoryTransactionOutput} historyOutput An output from a tx populated and formatted by the wallet's
+     *                                                 history methods
+     *
+     * @memberof Helpers
+     * @inner
+     *
+     * @example
+     * const historyTx = myHathorWallet.getTx(myTxHash);
+     * const outputInstance = heleprs.createOutputFromHistoryObject(historyTx.outputs[0]);
+     */
+    createOutputFromHistoryObject(historyOutput: HistoryTransactionOutput): Output;
+    /**
+     * Create NFT output from data string
+     *
+     * @memberof Helpers
+     * @inner
+     */
+    createNFTOutput(data: string): Output;
+    /**
+     * Create an output with data script
+     *
+     * @memberof Helpers
+     * @inner
+     */
+    createDataScriptOutput(data: string): Output;
+    /**
+     * From the base58 of an address we get the type of it, i.e. 'p2pkh' or 'p2sh'
+     *
+     * @memberof Helpers
+     * @inner
+     */
+    getOutputTypeFromAddress(address: string, network: Network): string;
+    /**
+     * Get the URL to connect to the websocket from the server URL of the wallet
+     *
+     * @return {string} Websocket URL
+     *
+     * @memberof Helpers
+     * @inner
+     */
+    getWSServerURL(url?: string | null): string;
+    /**
+     * Handle error for method transaction.prepareData
+     * Check if error is one of the expected and return the message
+     * Otherwise, throws the unexpected error
+     *
+     * @param {unknown} e Error thrown
+     *
+     * @return {string} Error message
+     * @memberof Helpers
+     * @inner
+     */
+    handlePrepareDataError(e: unknown): string;
+    /**
+     * Cleans a string for comparison. Remove multiple spaces, and spaces at the beginning and end, and transform to lowercase.
+     *
+     * @param {string} s String to be cleaned
+     * @return {string} String after clean
+     * @memberof Helpers
+     */
+    cleanupString(s: string): string;
+    /**
+     * Axios fails merging this configuration to the default configuration because it has an issue
+     * with circular structures: https://github.com/mzabriskie/axios/issues/370
+     * Got this code from https://github.com/softonic/axios-retry/blob/master/es/index.mjs#L203
+     *
+     * Warning: This function mutates the `config` parameter
+     *
+     * @param {AxiosInstance} axios Axios instance
+     * @param {AxiosRequestConfig} configObj New axios config
+     *
+     * @memberof Helpers
+     * @inner
+     */
+    fixAxiosConfig(axios: AxiosInstance, configObj: AxiosRequestConfig): void;
+    /**
+     * Returns a string with the short version of the id of a transaction
+     * Returns {first12Chars}...{last12Chars}
+     *
+     * @param {string} hash Transaction ID to be shortened
+     *
+     * @return {string}
+     * @memberof Helpers
+     * @inner
+     *
+     */
+    getShortHash(hash: string): string;
+    /**
+     * Returns IDataInput formatted from an IUtxo object
+     *
+     * @param {IUtxo} utxo Utxo to get IDataInput from
+     *
+     * @return {IDataInput}
+     * @memberof Helpers
+     * @inner
+     *
+     */
+    getDataInputFromUtxo(utxo: IUtxo): IDataInput;
+    /**
+     * The library network must be 'mainnet', 'testnet', or 'privatenet'
+     * The full node has 'mainnet', 'testnet-bravo', 'nano-testnet-alpha' and
+     * we must translate it into library networks.
+     *
+     * @param {string} fullNodeNetwork The network from full node API
+     *
+     * @memberof Helpers
+     * @inner
+     *
+     */
+    getNetworkFromFullNodeNetwork(fullNodeNetwork: string): string;
+};
+export default helpers;
+//# sourceMappingURL=helpers.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/utils/helpers.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/utils/helpers.d.ts.map
new file mode 100644
index 0000000..94ea68a
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/utils/helpers.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"helpers.d.ts","sourceRoot":"","sources":["../../src/utils/helpers.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;;AAGH,OAAO,MAAM,MAAM,QAAQ,CAAC;AAG5B,OAAO,EAAE,aAAa,EAAE,kBAAkB,EAAE,MAAM,OAAO,CAAC;AAG1D,OAAO,WAAW,MAAM,uBAAuB,CAAC;AAChD,OAAO,EAAE,kBAAkB,EAAE,wBAAwB,EAAE,MAAM,iBAAiB,CAAC;AAI/E,OAAO,sBAAsB,MAAM,oCAAoC,CAAC;AAExE,OAAO,MAAM,MAAM,kBAAkB,CAAC;AACtC,OAAO,OAAO,MAAM,mBAAmB,CAAC;AACxC,OAAO,OAAO,MAAM,mBAAmB,CAAC;AAcxC,OAAO,EAAE,UAAU,EAAE,KAAK,EAAE,MAAM,UAAU,CAAC;AAE7C;;;;GAIG;AAEH,QAAA,MAAM,OAAO;IACX;;;;;;;;;OASG;kBACW,MAAM,GAAG,MAAM;IAI7B;;;;;;;;;;OAUG;8BACuB,MAAM,cAAc,MAAM,GAAG,OAAO;IAuB9D;;;;;;;;;;OAUG;kCAC2B,MAAM,GAAG,MAAM,EAAE;IAI/C;;;;;;;;;;;;;OAaG;2BACoB,MAAM,EAAE,QAAQ,MAAM;IAS7C;;;;;;;;;;;OAWG;0BACmB,MAAM,EAAE,SAAS,MAAM;IAQ7C;;;;;;;;;OASG;uBACgB,MAAM,GAAG,MAAM;IAIlC;;;;OAIG;sCAC+B,MAAM,WAAW,OAAO,GAAG,OAAO;IAoCpE;;;;;;;;;;;OAWG;+BACwB,MAAM,WAAW,OAAO,GAAG,OAAO;IAc7D;;;;;;;;;;OAUG;kCAC2B,MAAM,WAAW,OAAO,GAAG,OAAO;IAUhE;;;;;;;;;;;;;;OAcG;6BACsB,MAAM,WAAW,OAAO,GAAG,WAAW,GAAG,sBAAsB;IA0BxF;;;;;;;;;;OAUG;yBACkB,MAAM,WAAW,OAAO,GAAG,WAAW,GAAG,sBAAsB;IAIpF;;;;;;;;;OASG;wBACuB,MAAM,GAAG,QAAQ,IAAI,CAAC;IAShD;;;;;;;;;;;;;;;OAeG;yCAC6B,OAAO,GAAG,WAAW,GAAG,sBAAsB;IAuD9E;;;;;;;;;;;;OAYG;yCACkC,kBAAkB,GAAG,WAAW,GAAG,sBAAsB;IAuB9F;;;;;;;;;;;OAWG;iDAC0C,wBAAwB,GAAG,MAAM;IAO9E;;;;;OAKG;0BACmB,MAAM,GAAG,MAAM;IAIrC;;;;;OAKG;iCAC0B,MAAM,GAAG,MAAM;IAM5C;;;;;OAKG;sCAC+B,MAAM,WAAW,OAAO,GAAG,MAAM;IAKnE;;;;;;;OAOG;yBACiB,MAAM,GAAG,IAAI,GAAU,MAAM;IAuBjD;;;;;;;;;;OAUG;8BACuB,OAAO,GAAG,MAAM;IAe1C;;;;;;OAMG;qBACc,MAAM,GAAG,MAAM;IAIhC;;;;;;;;;;;;OAYG;0BACmB,aAAa,aAAa,kBAAkB;IAalE;;;;;;;;;;OAUG;uBACgB,MAAM,GAAG,MAAM;IAIlC;;;;;;;;;OASG;+BACwB,KAAK,GAAG,UAAU;IAW7C;;;;;;;;;;OAUG;mDAC4C,MAAM,GAAG,MAAM;CAW/D,CAAC;AAEF,eAAe,OAAO,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/utils/helpers.js b/node_modules/@hathor/wallet-lib/oldLib/utils/helpers.js
new file mode 100644
index 0000000..9266a29
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/utils/helpers.js
@@ -0,0 +1,597 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+var _path = _interopRequireDefault(require("path"));
+var _buffer = _interopRequireDefault(require("buffer"));
+var _bitcoreLib = require("bitcore-lib");
+var _lodash = require("lodash");
+var _opcodes = require("../opcodes");
+var _constants = require("../constants");
+var _transaction = _interopRequireDefault(require("../models/transaction"));
+var _p2pkh = _interopRequireDefault(require("../models/p2pkh"));
+var _p2sh = _interopRequireDefault(require("../models/p2sh"));
+var _script_data = _interopRequireDefault(require("../models/script_data"));
+var _create_token_transaction = _interopRequireDefault(require("../models/create_token_transaction"));
+var _input = _interopRequireDefault(require("../models/input"));
+var _output = _interopRequireDefault(require("../models/output"));
+var _address = _interopRequireDefault(require("../models/address"));
+var _buffer2 = require("./buffer");
+var _errors = require("../errors");
+var _errorMessages = require("../errorMessages");
+var _config = _interopRequireDefault(require("../config"));
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+/**
+ * Helper methods
+ *
+ * @namespace Helpers
+ */
+
+const helpers = {
+  /**
+   * Round float to closest int
+   *
+   * @param {number} n Number to be rounded
+   *
+   * @return {number} Closest integer to n passed
+   *
+   * @memberof Helpers
+   * @inner
+   */
+  roundFloat(n) {
+    return Math.round(n * 100) / 100;
+  },
+  /**
+   * Validate if the passed version is valid, comparing with the minVersion
+   *
+   * @param {string} version Version to check if is valid
+   * @param {string} minVersion Minimum allowed version
+   *
+   * @return {boolean}
+   *
+   * @memberof Helpers
+   * @inner
+   */
+  isVersionAllowed(version, minVersion) {
+    // Verifies if the version in parameter is allowed to make requests to other min version
+    if (version.includes('beta') !== minVersion.includes('beta')) {
+      // If one version is beta and the other is not, it's not allowed to use it
+      return false;
+    }
+
+    // Clean the version string to have an array of integers
+    // Check for each value if the version is allowed
+    const versionTestArr = this.getCleanVersionArray(version);
+    const minVersionArr = this.getCleanVersionArray(minVersion);
+    for (let i = 0; i < minVersionArr.length; i++) {
+      if (minVersionArr[i] > versionTestArr[i]) {
+        return false;
+      }
+      if (minVersionArr[i] < versionTestArr[i]) {
+        return true;
+      }
+    }
+    return true;
+  },
+  /**
+   * Get the version numbers separated by dot
+   * For example: if you haver version 0.3.1-beta you will get ['0', '3', '1']
+   *
+   * @param {string} version
+   *
+   * @return {Array} Array of numbers with each version number
+   *
+   * @memberof Helpers
+   * @inner
+   */
+  getCleanVersionArray(version) {
+    return version.replace(/[^\d.]/g, '').split('.');
+  },
+  /**
+   * Push data to the stack checking if need to add the OP_PUSHDATA1 opcode
+   * We push the length of data and the data
+   * In case the data has length > 75, we need to push the OP_PUSHDATA1 before the length
+   * We always push bytes
+   *
+   * We update the array of Buffer sent as parameter, so we don't return a new one
+   *
+   * @param {Array} stack Stack of bytes from the script
+   * @param {Buffer} data Data to be pushed to stack
+   *
+   * @memberof Helpers
+   * @inner
+   */
+  pushDataToStack(stack, data) {
+    // In case data has length bigger than 75, we need to add a pushdata opcode
+    if (data.length > 75) {
+      stack.push(_opcodes.OP_PUSHDATA1);
+    }
+    stack.push((0, _buffer2.intToBytes)(data.length, 1));
+    stack.push(data);
+  },
+  /**
+   * Push an integer to the stack
+   * We always push an opcode representing the number from 0 to 16 (or OP_0 to OP_16)
+   *
+   * We update the array of Buffer sent as parameter, so we don't return a new one
+   *
+   * @param {Array} stack Stack of bytes from the script
+   * @param {number} value number to be pushed on stack
+   *
+   * @memberof Helpers
+   * @inner
+   */
+  pushIntToStack(stack, value) {
+    if (value < 0 || value > 16) {
+      throw new Error('Invalid OP_N, must be [0,16].');
+    }
+    // OP_0 is 0x50 (hex) or 80 (decimal), and OP_N is n + OP_0
+    stack.push(Buffer.from([value + 80]));
+  },
+  /**
+   * Return the checksum of the bytes passed
+   * Checksum is calculated as the 4 first bytes of the double sha256
+   *
+   * @param {Buffer} bytes Data from where the checksum is calculated
+   *
+   * @return {Buffer}
+   * @memberof Helpers
+   * @inner
+   */
+  getChecksum(bytes) {
+    return _bitcoreLib.crypto.Hash.sha256sha256(bytes).slice(0, 4);
+  },
+  /**
+   * Read address bytes validating information.
+   *
+   * @returns address read from bytes
+   */
+  getAddressFromBytes(addressBytes, network) {
+    if (addressBytes.length !== 25) {
+      throw new Error('Address bytes should be 25 bytes long');
+    }
+    const versionByte = addressBytes[0];
+    const hashBytes = addressBytes.subarray(1, 21);
+    const recvChecksum = addressBytes.subarray(21);
+    let address;
+    switch (versionByte) {
+      case network.versionBytes.p2pkh:
+        address = this.encodeAddress(hashBytes, network);
+        break;
+      case network.versionBytes.p2sh:
+        address = this.encodeAddressP2SH(hashBytes, network);
+        break;
+      default:
+        throw new Error('Invalid version byte');
+    }
+    address.validateAddress();
+    const decoded = address.decode();
+    if (decoded[0] !== versionByte) {
+      throw new Error('Version byte mismatch');
+    }
+    const calcChecksum = decoded.subarray(21);
+    if (!calcChecksum.equals(recvChecksum)) {
+      throw new Error(`Generated checksum(${calcChecksum.toString('hex')}) does not match received checksum(${recvChecksum.toString('hex')})`);
+    }
+    return address;
+  },
+  /**
+   * Get encoded address object from address hash (20 bytes) and network
+   * We complete the address bytes with the network byte and checksum
+   * then we encode to base 58 and create the address object
+   *
+   * @param {Buffer} addressHash 20 bytes of the address hash in the output script
+   * @param {Network} network Network to get the address first byte parameter
+   *
+   * @return {Address}
+   * @memberof Helpers
+   * @inner
+   */
+  encodeAddress(addressHash, network) {
+    if (addressHash.length !== 20) {
+      throw new Error('Expect address hash that must have 20 bytes.');
+    }
+    const addressVersionBytes = _buffer.default.Buffer.from([network.versionBytes.p2pkh]);
+
+    // With this sliced address we can calculate the checksum
+    const slicedAddress = _buffer.default.Buffer.concat([addressVersionBytes, addressHash]);
+    const checksum = this.getChecksum(slicedAddress);
+    const addressBytes = _buffer.default.Buffer.concat([slicedAddress, checksum]);
+    return new _address.default(_bitcoreLib.encoding.Base58.encode(addressBytes), {
+      network
+    });
+  },
+  /**
+   * Get encoded address object from script hash (20 bytes) and network.
+   * We use bitcore's Address module to build the address from the hash.
+   *
+   * @param {Buffer} scriptHash 20 bytes of the script hash in the output script
+   * @param {Network} network Network to get the address first byte parameter
+   *
+   * @return {Address}
+   * @memberof Helpers
+   * @inner
+   */
+  encodeAddressP2SH(scriptHash, network) {
+    if (scriptHash.length !== 20) {
+      throw new Error('Expect script hash that must have 20 bytes.');
+    }
+    const addr = _bitcoreLib.Address.fromScriptHash(scriptHash, network.getNetwork());
+    return new _address.default(addr.toString(), {
+      network
+    });
+  },
+  /**
+   * Create a transaction from bytes
+   * First we get the version value from the bytes to discover the
+   * transaction type. We currently support only regular transactions and
+   * create token transactions.
+   *
+   * @param {Buffer} bytes Transaction in bytes
+   * @param {Network} network Network to get the address first byte parameter
+   *
+   * @throws ParseError if sequence of bytes is invalid or network is undefined/null
+   *
+   * @return {Transaction | CreateTokenTransaction}
+   * @memberof Helpers
+   * @inner
+   */
+  createTxFromBytes(bytes, network) {
+    if (!network) {
+      throw new _errors.ParseError('Invalid network parameter.');
+    }
+
+    // We should clone the buffer being sent in order to never mutate
+    // what comes from outside the library
+    // as soon as it's available natively we should use an immutable buffer
+    const cloneBuffer = (0, _lodash.clone)(bytes);
+
+    // Get version
+    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- No use for signalBits in this context
+    const [_signalBits, buf] = (0, _buffer2.unpackToInt)(1, false, cloneBuffer);
+    const [version] = (0, _buffer2.unpackToInt)(1, false, buf);
+    if (version === _constants.DEFAULT_TX_VERSION) {
+      return _transaction.default.createFromBytes(cloneBuffer, network);
+    }
+    if (version === _constants.CREATE_TOKEN_TX_VERSION) {
+      return _create_token_transaction.default.createFromBytes(cloneBuffer, network);
+    }
+    throw new _errors.ParseError('We currently support only the Transaction and CreateTokenTransaction types. Other types will be supported in the future.');
+  },
+  /**
+   * Create a transaction from hex
+   * We transform the hex in bytes and call the function to get transaction from bytes
+   *
+   * @param {string} hex Transaction in hexadecimal
+   * @param {Network} network Network to get the address first byte parameter
+   *
+   * @return {Transaction | CreateTokenTransaction}
+   * @memberof Helpers
+   * @inner
+   */
+  createTxFromHex(hex, network) {
+    return this.createTxFromBytes((0, _buffer2.hexToBuffer)(hex), network);
+  },
+  /**
+   * Asyncronous sleep
+   * Creates a promise that will be resolved after sleep time
+   *
+   * @param {number} milliseconds Sleep time in milliseconds
+   *
+   * @return {Promise}
+   * @memberof Helpers
+   * @inner
+   */
+  async sleep(milliseconds) {
+    const promise = new Promise(resolve => {
+      setTimeout(() => {
+        resolve();
+      }, milliseconds);
+    });
+    return promise;
+  },
+  /**
+   * Create a transaction from object data
+   * We used to work only with data object to handle transactions in the past inside the lib
+   * This method was created to transform those objects into Transaction class instances
+   *
+   * @param {Object} 'data': {'version', 'weight', 'timestamp', 'tokens', 'inputs': [{'tx_id', 'index'}], 'outputs': [{'address', 'value', 'tokenData', 'timelock'}]}
+   *
+   * if it's a create token transaction, then it expects 'name' and 'symbol' as well.
+   *
+   * @param {Network} network Network to get the address first byte parameter
+   *
+   * @throws {AddressError} If the address used in the P2PKH outputs is invalid
+   *
+   * @memberof Helpers
+   * @inner
+   */
+  createTxFromData(data, network) {
+    const inputs = [];
+    for (const input of data.inputs) {
+      const inputObj = new _input.default(input.tx_id, input.index, {
+        data: input.data
+      });
+      inputs.push(inputObj);
+    }
+    const outputs = [];
+    for (const output of data.outputs) {
+      let outputObj;
+      if (output.type === 'data') {
+        // Is NFT output
+        outputObj = this.createNFTOutput(output.data);
+      } else if (output.type === 'p2sh') {
+        // P2SH
+        const address = new _address.default(output.address, {
+          network
+        });
+        // This will throw AddressError in case the adress is invalid
+        address.validateAddress();
+        const p2sh = new _p2sh.default(address, {
+          timelock: output.timelock || null
+        });
+        const p2shScript = p2sh.createScript();
+        outputObj = new _output.default(output.value, p2shScript, {
+          tokenData: output.tokenData
+        });
+      } else if (output.type === 'p2pkh' || output.type === undefined) {
+        // P2PKH
+        // for compatibility reasons we will accept an output without type as p2pkh as fallback
+        const address = new _address.default(output.address, {
+          network
+        });
+        // This will throw AddressError in case the adress is invalid
+        address.validateAddress();
+        const p2pkh = new _p2pkh.default(address, {
+          timelock: output.timelock || null
+        });
+        const p2pkhScript = p2pkh.createScript();
+        outputObj = new _output.default(output.value, p2pkhScript, {
+          tokenData: output.tokenData
+        });
+      } else {
+        throw new Error('Invalid output type.');
+      }
+      outputs.push(outputObj);
+    }
+    const options = {
+      signalBits: data.signalBits,
+      version: data.version,
+      weight: data.weight,
+      timestamp: data.timestamp,
+      tokens: data.tokens
+    };
+    if (data.version === _constants.CREATE_TOKEN_TX_VERSION) {
+      return new _create_token_transaction.default(data.name, data.symbol, inputs, outputs, options);
+    }
+    if (data.version === _constants.DEFAULT_TX_VERSION) {
+      return new _transaction.default(inputs, outputs, options);
+    }
+    throw new _errors.ParseError(_errorMessages.ErrorMessages.UNSUPPORTED_TX_TYPE);
+  },
+  /**
+   * Creates a Transaction instance from a populated object from the wallet's history methods.
+   *
+   * _Note_: This helper does not need a _Network_ parameter, since all the output scripts were already decoded.
+   * @param {HistoryTransaction} historyTx A transaction formatted as an instance of a wallet history
+   *
+   * @memberof Helpers
+   * @inner
+   *
+   * @example
+   * const historyTx = myHathorWallet.getTx(myTxHash);
+   * const txInstance = helpers.createTxFromHistoryObject(historyTx);
+   */
+  createTxFromHistoryObject(historyTx) {
+    // Processing a token creation transaction
+    const isCreateTokenTx = historyTx.version === _constants.CREATE_TOKEN_TX_VERSION;
+    if (isCreateTokenTx && (!historyTx?.token_name || !historyTx?.token_symbol)) {
+      throw new _errors.CreateTokenTxInvalid(`Missing token name or symbol`);
+    }
+    const inputs = historyTx.inputs.map(i => new _input.default(i.tx_id, i.index));
+    const outputs = historyTx.outputs.map(this.createOutputFromHistoryObject);
+    if (isCreateTokenTx) {
+      return new _create_token_transaction.default(historyTx.token_name, historyTx.token_symbol, inputs, outputs, {
+        ...historyTx
+      });
+    }
+    return new _transaction.default(inputs, outputs, {
+      ...historyTx
+    });
+  },
+  /**
+   * Creates an Output from an object extracted from the wallet's history.
+   * @param {HistoryTransactionOutput} historyOutput An output from a tx populated and formatted by the wallet's
+   *                                                 history methods
+   *
+   * @memberof Helpers
+   * @inner
+   *
+   * @example
+   * const historyTx = myHathorWallet.getTx(myTxHash);
+   * const outputInstance = heleprs.createOutputFromHistoryObject(historyTx.outputs[0]);
+   */
+  createOutputFromHistoryObject(historyOutput) {
+    return new _output.default(historyOutput.value, Buffer.from(historyOutput.script, 'base64'), {
+      timelock: historyOutput.decoded.timelock || null,
+      tokenData: historyOutput.token_data
+    });
+  },
+  /**
+   * Create NFT output from data string
+   *
+   * @memberof Helpers
+   * @inner
+   */
+  createNFTOutput(data) {
+    return this.createDataScriptOutput(data);
+  },
+  /**
+   * Create an output with data script
+   *
+   * @memberof Helpers
+   * @inner
+   */
+  createDataScriptOutput(data) {
+    const scriptData = new _script_data.default(data);
+    // Value 1 and token HTR
+    return new _output.default(1n, scriptData.createScript());
+  },
+  /**
+   * From the base58 of an address we get the type of it, i.e. 'p2pkh' or 'p2sh'
+   *
+   * @memberof Helpers
+   * @inner
+   */
+  getOutputTypeFromAddress(address, network) {
+    const addressObj = new _address.default(address, {
+      network
+    });
+    return addressObj.getType();
+  },
+  /**
+   * Get the URL to connect to the websocket from the server URL of the wallet
+   *
+   * @return {string} Websocket URL
+   *
+   * @memberof Helpers
+   * @inner
+   */
+  getWSServerURL(url = null) {
+    let serverURL;
+    if (url === null) {
+      serverURL = _config.default.getServerUrl();
+    } else {
+      serverURL = url;
+    }
+    const pieces = serverURL.split(':');
+    const firstPiece = pieces.splice(0, 1);
+    let protocol = '';
+    if (firstPiece[0].indexOf('s') > -1) {
+      // Has ssl
+      protocol = 'wss';
+    } else {
+      // No ssl
+      protocol = 'ws';
+    }
+    serverURL = _path.default.join(`${pieces.join(':')}`, 'ws/');
+    serverURL = `${protocol}:/${serverURL}`;
+    return serverURL;
+  },
+  /**
+   * Handle error for method transaction.prepareData
+   * Check if error is one of the expected and return the message
+   * Otherwise, throws the unexpected error
+   *
+   * @param {unknown} e Error thrown
+   *
+   * @return {string} Error message
+   * @memberof Helpers
+   * @inner
+   */
+  handlePrepareDataError(e) {
+    if (e instanceof _errors.AddressError || e instanceof _errors.OutputValueError || e instanceof _errors.ConstantNotSet || e instanceof _errors.CreateTokenTxInvalid || e instanceof _errors.MaximumNumberOutputsError || e instanceof _errors.MaximumNumberInputsError) {
+      return e.message;
+    }
+    // Unhandled error
+    throw e;
+  },
+  /**
+   * Cleans a string for comparison. Remove multiple spaces, and spaces at the beginning and end, and transform to lowercase.
+   *
+   * @param {string} s String to be cleaned
+   * @return {string} String after clean
+   * @memberof Helpers
+   */
+  cleanupString(s) {
+    return s.replace(/\s\s+/g, ' ').trim().toLowerCase();
+  },
+  /**
+   * Axios fails merging this configuration to the default configuration because it has an issue
+   * with circular structures: https://github.com/mzabriskie/axios/issues/370
+   * Got this code from https://github.com/softonic/axios-retry/blob/master/es/index.mjs#L203
+   *
+   * Warning: This function mutates the `config` parameter
+   *
+   * @param {AxiosInstance} axios Axios instance
+   * @param {AxiosRequestConfig} configObj New axios config
+   *
+   * @memberof Helpers
+   * @inner
+   */
+  fixAxiosConfig(axios, configObj) {
+    /* eslint-disable no-param-reassign */
+    if (axios.defaults.httpAgent === configObj.httpAgent) {
+      delete configObj.httpAgent;
+    }
+    if (axios.defaults.httpsAgent === configObj.httpsAgent) {
+      delete configObj.httpsAgent;
+    }
+    configObj.transformRequest = [data => data];
+    /* eslint-enable no-param-reassign */
+  },
+  /**
+   * Returns a string with the short version of the id of a transaction
+   * Returns {first12Chars}...{last12Chars}
+   *
+   * @param {string} hash Transaction ID to be shortened
+   *
+   * @return {string}
+   * @memberof Helpers
+   * @inner
+   *
+   */
+  getShortHash(hash) {
+    return `${hash.substring(0, 12)}...${hash.substring(52, 64)}`;
+  },
+  /**
+   * Returns IDataInput formatted from an IUtxo object
+   *
+   * @param {IUtxo} utxo Utxo to get IDataInput from
+   *
+   * @return {IDataInput}
+   * @memberof Helpers
+   * @inner
+   *
+   */
+  getDataInputFromUtxo(utxo) {
+    return {
+      txId: utxo.txId,
+      index: utxo.index,
+      value: utxo.value,
+      authorities: utxo.authorities,
+      token: utxo.token,
+      address: utxo.address
+    };
+  },
+  /**
+   * The library network must be 'mainnet', 'testnet', or 'privatenet'
+   * The full node has 'mainnet', 'testnet-bravo', 'nano-testnet-alpha' and
+   * we must translate it into library networks.
+   *
+   * @param {string} fullNodeNetwork The network from full node API
+   *
+   * @memberof Helpers
+   * @inner
+   *
+   */
+  getNetworkFromFullNodeNetwork(fullNodeNetwork) {
+    if (fullNodeNetwork === 'mainnet') {
+      return fullNodeNetwork;
+    }
+    if (fullNodeNetwork.includes('testnet')) {
+      return 'testnet';
+    }
+    return 'privatenet';
+  }
+};
+var _default = exports.default = helpers;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/utils/leb128.d.ts b/node_modules/@hathor/wallet-lib/oldLib/utils/leb128.d.ts
new file mode 100644
index 0000000..3e91005
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/utils/leb128.d.ts
@@ -0,0 +1,52 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/// <reference types="node" />
+export interface Leb128DecodeResult {
+    value: bigint;
+    rest: Buffer;
+    bytesRead: number;
+}
+/**
+ * Encode a number into a leb128 encoded buffer.
+ * @param value The actual value to encode.
+ * @param [signed=true] Differentiate signed and unsigned encoded numbers.
+ * @param [maxBytes=null] Max allowed size of the output buffer.
+ */
+export declare function encodeLeb128(value: bigint | number, signed?: boolean, maxBytes?: number | null): Buffer;
+/**
+ * Decode a leb128 buffer into a number if possible.
+ * @param buf The buffer with the actual data.
+ * @param [signed=true] Differentiate signed and unsigned encoded numbers.
+ * @param [maxBytes=null] Max allowed size of the output buffer.
+ */
+export declare function decodeLeb128(buf: Buffer, signed?: boolean, maxBytes?: number | null): Leb128DecodeResult;
+/**
+ * Encode signed leb128 number
+ */
+export declare function encodeSigned(value: bigint | number, maxBytes?: number | null): Buffer;
+/**
+ * Decode signed leb128 number
+ */
+export declare function decodeSigned(buf: Buffer, maxBytes?: number | null): Leb128DecodeResult;
+/**
+ * Encode unsigned leb128 number
+ */
+export declare function encodeUnsigned(value: bigint | number, maxBytes?: number | null): Buffer;
+/**
+ * Decode unsigned leb128 number
+ */
+export declare function decodeUnsigned(buf: Buffer, maxBytes?: number | null): Leb128DecodeResult;
+declare const _default: {
+    encodeLeb128: typeof encodeLeb128;
+    decodeLeb128: typeof decodeLeb128;
+    encodeSigned: typeof encodeSigned;
+    decodeSigned: typeof decodeSigned;
+    encodeUnsigned: typeof encodeUnsigned;
+    decodeUnsigned: typeof decodeUnsigned;
+};
+export default _default;
+//# sourceMappingURL=leb128.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/utils/leb128.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/utils/leb128.d.ts.map
new file mode 100644
index 0000000..fc2f645
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/utils/leb128.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"leb128.d.ts","sourceRoot":"","sources":["../../src/utils/leb128.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;;AAEH,MAAM,WAAW,kBAAkB;IACjC,KAAK,EAAE,MAAM,CAAC;IACd,IAAI,EAAE,MAAM,CAAC;IACb,SAAS,EAAE,MAAM,CAAC;CACnB;AAED;;;;;GAKG;AACH,wBAAgB,YAAY,CAC1B,KAAK,EAAE,MAAM,GAAG,MAAM,EACtB,MAAM,GAAE,OAAc,EACtB,QAAQ,GAAE,MAAM,GAAG,IAAW,UAoC/B;AAED;;;;;GAKG;AACH,wBAAgB,YAAY,CAC1B,GAAG,EAAE,MAAM,EACX,MAAM,GAAE,OAAc,EACtB,QAAQ,GAAE,MAAM,GAAG,IAAW,GAC7B,kBAAkB,CAsCpB;AAED;;GAEG;AACH,wBAAgB,YAAY,CAAC,KAAK,EAAE,MAAM,GAAG,MAAM,EAAE,QAAQ,GAAE,MAAM,GAAG,IAAW,GAAG,MAAM,CAE3F;AAED;;GAEG;AACH,wBAAgB,YAAY,CAAC,GAAG,EAAE,MAAM,EAAE,QAAQ,GAAE,MAAM,GAAG,IAAW,GAAG,kBAAkB,CAE5F;AAED;;GAEG;AACH,wBAAgB,cAAc,CAAC,KAAK,EAAE,MAAM,GAAG,MAAM,EAAE,QAAQ,GAAE,MAAM,GAAG,IAAW,GAAG,MAAM,CAE7F;AAED;;GAEG;AACH,wBAAgB,cAAc,CAAC,GAAG,EAAE,MAAM,EAAE,QAAQ,GAAE,MAAM,GAAG,IAAW,GAAG,kBAAkB,CAE9F;;;;;;;;;AAED,wBAQE"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/utils/leb128.js b/node_modules/@hathor/wallet-lib/oldLib/utils/leb128.js
new file mode 100644
index 0000000..9829302
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/utils/leb128.js
@@ -0,0 +1,137 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.decodeLeb128 = decodeLeb128;
+exports.decodeSigned = decodeSigned;
+exports.decodeUnsigned = decodeUnsigned;
+exports.default = void 0;
+exports.encodeLeb128 = encodeLeb128;
+exports.encodeSigned = encodeSigned;
+exports.encodeUnsigned = encodeUnsigned;
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+/**
+ * Encode a number into a leb128 encoded buffer.
+ * @param value The actual value to encode.
+ * @param [signed=true] Differentiate signed and unsigned encoded numbers.
+ * @param [maxBytes=null] Max allowed size of the output buffer.
+ */
+function encodeLeb128(value, signed = true, maxBytes = null) {
+  let val = BigInt(value);
+  if (!signed && val < 0n) {
+    throw new Error('Cannot encode an unsigned negative value');
+  }
+  const result = [];
+  while (true) {
+    const byte = val & 0b0111_1111n;
+    val >>= 7n;
+    let isLastByte = false;
+    if (signed) {
+      // signed check for last byte
+      isLastByte = val === 0n && (byte & 0b0100_0000n) === 0n || val === -1n && (byte & 0b0100_0000n) !== 0n;
+    } else {
+      // unsigned check for last byte
+      isLastByte = val === 0n && (byte & 0b1000_0000n) === 0n;
+    }
+    if (isLastByte) {
+      result.push(byte);
+      if (maxBytes !== null && result.length > maxBytes) {
+        throw new Error(`Cannot encode more than ${maxBytes} bytes`);
+      }
+      // Need to convert the bigint values of `result` into Number to use with Buffer.
+      // This is a safe operation since the value of the elements can only go up to 0xFF
+      return Buffer.from(result.map(b => Number(b)));
+    }
+
+    // Add 7 bits + first bit indicating the existence of the next block.
+    result.push(byte | 0b1000_0000n);
+    if (maxBytes !== null && result.length > maxBytes) {
+      throw new Error(`Cannot encode more than ${maxBytes} bytes`);
+    }
+  }
+}
+
+/**
+ * Decode a leb128 buffer into a number if possible.
+ * @param buf The buffer with the actual data.
+ * @param [signed=true] Differentiate signed and unsigned encoded numbers.
+ * @param [maxBytes=null] Max allowed size of the output buffer.
+ */
+function decodeLeb128(buf, signed = true, maxBytes = null) {
+  const byte_list = Array.from(buf.values()).map(v => BigInt(v));
+  let result = 0n;
+  let shift = 0n;
+  let bytesRead = 0;
+  while (true) {
+    bytesRead += 1;
+    const byte = byte_list.shift();
+    if (byte === undefined) {
+      throw new Error('Buffer is not valid leb128, cannot read from empty buffer');
+    }
+    result |= (byte & 0b0111_1111n) << shift;
+    shift += 7n;
+    if (shift % 7n !== 0n) throw new Error(`AssertionError: shift is ${shift} and is not divisible by 7`);
+    if (maxBytes !== null && shift / 7n > maxBytes) {
+      throw new Error(`Cannot decode more than the max ${maxBytes} bytes`);
+    }
+    if ((byte & 0b1000_0000n) === 0n) {
+      // Last byte
+      if (signed && (byte & 0b0100_0000n) !== 0n) {
+        // Negative sign
+        return {
+          value: result | -(1n << shift),
+          rest: Buffer.from(byte_list.map(b => Number(b))),
+          bytesRead
+        };
+      }
+      return {
+        value: result,
+        rest: Buffer.from(byte_list.map(b => Number(b))),
+        bytesRead
+      };
+    }
+  }
+}
+
+/**
+ * Encode signed leb128 number
+ */
+function encodeSigned(value, maxBytes = null) {
+  return encodeLeb128(value, true, maxBytes);
+}
+
+/**
+ * Decode signed leb128 number
+ */
+function decodeSigned(buf, maxBytes = null) {
+  return decodeLeb128(buf, true, maxBytes);
+}
+
+/**
+ * Encode unsigned leb128 number
+ */
+function encodeUnsigned(value, maxBytes = null) {
+  return encodeLeb128(value, false, maxBytes);
+}
+
+/**
+ * Decode unsigned leb128 number
+ */
+function decodeUnsigned(buf, maxBytes = null) {
+  return decodeLeb128(buf, false, maxBytes);
+}
+var _default = exports.default = {
+  encodeLeb128,
+  decodeLeb128,
+  encodeSigned,
+  decodeSigned,
+  encodeUnsigned,
+  decodeUnsigned
+};
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/utils/numbers.d.ts b/node_modules/@hathor/wallet-lib/oldLib/utils/numbers.d.ts
new file mode 100644
index 0000000..0b145a5
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/utils/numbers.d.ts
@@ -0,0 +1,12 @@
+/**
+ * Get the formatted value with decimal places and thousand separators
+ *
+ * @param inputValue Amount to be formatted
+ * @param [decimalPlaces=DECIMAL_PLACES] Number of decimal places
+ *
+ * @return {string} Formatted value
+ *
+ * @inner
+ */
+export declare function prettyValue(inputValue: bigint | number | string, decimalPlaces?: number): string;
+//# sourceMappingURL=numbers.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/utils/numbers.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/utils/numbers.d.ts.map
new file mode 100644
index 0000000..59196fb
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/utils/numbers.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"numbers.d.ts","sourceRoot":"","sources":["../../src/utils/numbers.ts"],"names":[],"mappings":"AA0BA;;;;;;;;;GASG;AACH,wBAAgB,WAAW,CACzB,UAAU,EAAE,MAAM,GAAG,MAAM,GAAG,MAAM,EACpC,aAAa,SAAiB,GAC7B,MAAM,CAgBR"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/utils/numbers.js b/node_modules/@hathor/wallet-lib/oldLib/utils/numbers.js
new file mode 100644
index 0000000..40f9eef
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/utils/numbers.js
@@ -0,0 +1,58 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.prettyValue = prettyValue;
+var _constants = require("../constants");
+const formatter = new Intl.NumberFormat('en-US');
+
+/**
+ * Get the formatted integer value with thousand separators
+ *
+ * Hermes does not have support for Intl.NumberFormat format method
+ * with bigint values, and we use it in the Android for a better performance.
+ * The iOS app runs with JSC, which doesn't work with bigint and toLocaleString.
+ * Then I have this method that tries both options to format the integer value.
+ *
+ * @param value Amount to be formatted
+ *
+ * @return {string} Formatted value
+ *
+ * @inner
+ */
+function getLocaleString(value) {
+  try {
+    return formatter.format(value);
+  } catch (e) {
+    return value.toLocaleString('en-US');
+  }
+}
+
+/**
+ * Get the formatted value with decimal places and thousand separators
+ *
+ * @param inputValue Amount to be formatted
+ * @param [decimalPlaces=DECIMAL_PLACES] Number of decimal places
+ *
+ * @return {string} Formatted value
+ *
+ * @inner
+ */
+function prettyValue(inputValue, decimalPlaces = _constants.DECIMAL_PLACES) {
+  const value = BigInt(inputValue);
+  if (typeof value !== 'bigint') {
+    throw Error(`value ${value} should be a bigint`);
+  }
+  if (decimalPlaces === 0) {
+    return getLocaleString(value);
+  }
+  const absValue = value >= 0 ? value : -value;
+  const decimalDivisor = 10n ** BigInt(decimalPlaces);
+  const integerPart = absValue / decimalDivisor;
+  const decimalPart = absValue % decimalDivisor;
+  const signal = value < 0 ? '-' : '';
+  const integerString = getLocaleString(integerPart);
+  const decimalString = decimalPart.toString().padStart(decimalPlaces, '0');
+  return `${signal}${integerString}.${decimalString}`;
+}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/utils/scripts.d.ts b/node_modules/@hathor/wallet-lib/oldLib/utils/scripts.d.ts
new file mode 100644
index 0000000..e10cac5
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/utils/scripts.d.ts
@@ -0,0 +1,61 @@
+/// <reference types="node" />
+import P2PKH from '../models/p2pkh';
+import P2SH from '../models/p2sh';
+import ScriptData from '../models/script_data';
+import Network from '../models/network';
+/**
+ * Parse P2PKH output script
+ *
+ * @param {Buffer} buff Output script
+ * @param {Network} network Network to get the address first byte parameter
+ *
+ * @return {P2PKH} P2PKH object
+ */
+export declare const parseP2PKH: (buff: Buffer, network: Network) => P2PKH;
+/**
+ * Parse P2SH output script
+ *
+ * @param {Buffer} buff Output script
+ * @param {Network} network Network to get the address first byte parameter
+ *
+ * @return {P2SH} P2PKH object
+ */
+export declare const parseP2SH: (buff: Buffer, network: Network) => P2SH;
+/**
+ * Parse Data output script
+ *
+ * @param {Buffer} buff Output script
+ *
+ * @return {ScriptData} ScriptData object
+ */
+export declare const parseScriptData: (buff: Buffer) => ScriptData;
+/**
+ * Parse buffer to data decoding pushdata opcodes
+ *
+ * @param {Buffer} buff Buffer to get pushdata
+ *
+ * @return {Buffer} Data extracted from buffer
+ */
+export declare const getPushData: (buff: Buffer) => Buffer;
+/**
+ * Create a P2SH MultiSig redeem script
+ *
+ * @param {string[]} xpubs The list of xpubkeys involved in this MultiSig
+ * @param {number} numSignatures Minimum number of signatures to send a
+ * transaction with this MultiSig
+ * @param {number} index Index to derive the xpubs
+ *
+ * @return {Buffer} A buffer with the redeemScript
+ * @throws {XPubError} In case any of the given xpubs are invalid
+ */
+export declare function createP2SHRedeemScript(xpubs: string[], numSignatures: number, index: number): Buffer;
+/**
+ * Parse script to get an object corresponding to the script data
+ *
+ * @param {Buffer} script Output script to parse
+ * @param {Network} network Network to get the address first byte parameter
+ *
+ * @return {P2PKH | P2SH | ScriptData | null} Parsed script object
+ */
+export declare const parseScript: (script: Buffer, network: Network) => P2PKH | P2SH | ScriptData | null;
+//# sourceMappingURL=scripts.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/utils/scripts.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/utils/scripts.d.ts.map
new file mode 100644
index 0000000..46980a0
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/utils/scripts.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"scripts.d.ts","sourceRoot":"","sources":["../../src/utils/scripts.ts"],"names":[],"mappings":";AAEA,OAAO,KAAK,MAAM,iBAAiB,CAAC;AACpC,OAAO,IAAI,MAAM,gBAAgB,CAAC;AAClC,OAAO,UAAU,MAAM,uBAAuB,CAAC;AAC/C,OAAO,OAAO,MAAM,mBAAmB,CAAC;AAMxC;;;;;;;GAOG;AACH,eAAO,MAAM,UAAU,SAAU,MAAM,WAAW,OAAO,KAAG,KAoB3D,CAAC;AAEF;;;;;;;GAOG;AACH,eAAO,MAAM,SAAS,SAAU,MAAM,WAAW,OAAO,KAAG,IAoB1D,CAAC;AAEF;;;;;;GAMG;AACH,eAAO,MAAM,eAAe,SAAU,MAAM,KAAG,UAmD9C,CAAC;AAEF;;;;;;GAMG;AACH,eAAO,MAAM,WAAW,SAAU,MAAM,KAAG,MAsB1C,CAAC;AAEF;;;;;;;;;;GAUG;AACH,wBAAgB,sBAAsB,CACpC,KAAK,EAAE,MAAM,EAAE,EACf,aAAa,EAAE,MAAM,EACrB,KAAK,EAAE,MAAM,GACZ,MAAM,CAqBR;AAED;;;;;;;GAOG;AACH,eAAO,MAAM,WAAW,WAAY,MAAM,WAAW,OAAO,KAAG,KAAK,GAAG,IAAI,GAAG,UAAU,GAAG,IA0B1F,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/utils/scripts.js b/node_modules/@hathor/wallet-lib/oldLib/utils/scripts.js
new file mode 100644
index 0000000..a593243
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/utils/scripts.js
@@ -0,0 +1,232 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.createP2SHRedeemScript = createP2SHRedeemScript;
+exports.parseScriptData = exports.parseScript = exports.parseP2SH = exports.parseP2PKH = exports.getPushData = void 0;
+var _lodash = _interopRequireDefault(require("lodash"));
+var _bitcoreLib = require("bitcore-lib");
+var _p2pkh = _interopRequireDefault(require("../models/p2pkh"));
+var _p2sh = _interopRequireDefault(require("../models/p2sh"));
+var _script_data = _interopRequireDefault(require("../models/script_data"));
+var _helpers = _interopRequireDefault(require("./helpers"));
+var _buffer = require("./buffer");
+var _errors = require("../errors");
+var _opcodes = require("../opcodes");
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+/**
+ * Parse P2PKH output script
+ *
+ * @param {Buffer} buff Output script
+ * @param {Network} network Network to get the address first byte parameter
+ *
+ * @return {P2PKH} P2PKH object
+ */
+const parseP2PKH = (buff, network) => {
+  let timelock = null;
+  let offset = 0;
+
+  // We should clone the buffer being sent in order to never mutate
+  // what comes from outside the library
+  let scriptBuf = _lodash.default.clone(buff);
+  if (scriptBuf.length === 31) {
+    // There is timelock in this script
+    // First byte is len, which is always 4 bytes
+    [timelock, scriptBuf] = (0, _buffer.unpackToInt)(4, false, scriptBuf.slice(1));
+    offset = 1;
+  } else if (scriptBuf.length !== 25) {
+    // It's not a P2PKH
+    throw new _errors.ParseScriptError('Invalid output script.');
+  }
+  const [addressHash] = (0, _buffer.unpackLen)(20, scriptBuf.slice(3 + offset));
+  return new _p2pkh.default(_helpers.default.encodeAddress(addressHash, network), {
+    timelock
+  });
+};
+
+/**
+ * Parse P2SH output script
+ *
+ * @param {Buffer} buff Output script
+ * @param {Network} network Network to get the address first byte parameter
+ *
+ * @return {P2SH} P2PKH object
+ */
+exports.parseP2PKH = parseP2PKH;
+const parseP2SH = (buff, network) => {
+  let timelock = null;
+  let offset = 0;
+
+  // We should clone the buffer being sent in order to never mutate
+  // what comes from outside the library
+  let scriptBuf = _lodash.default.clone(buff);
+  if (scriptBuf.length === 29) {
+    // There is timelock in this script
+    // First byte is len, which is always 4 bytes
+    [timelock, scriptBuf] = (0, _buffer.unpackToInt)(4, false, scriptBuf.slice(1));
+    offset = 1;
+  } else if (scriptBuf.length !== 23) {
+    // It's not a P2PKH
+    throw new _errors.ParseScriptError('Invalid output script.');
+  }
+  const [scriptHash] = (0, _buffer.unpackLen)(20, scriptBuf.slice(2 + offset));
+  return new _p2sh.default(_helpers.default.encodeAddressP2SH(scriptHash, network), {
+    timelock
+  });
+};
+
+/**
+ * Parse Data output script
+ *
+ * @param {Buffer} buff Output script
+ *
+ * @return {ScriptData} ScriptData object
+ */
+exports.parseP2SH = parseP2SH;
+const parseScriptData = buff => {
+  // We should clone the buffer being sent in order to never mutate
+  // what comes from outside the library
+  const scriptBuf = _lodash.default.clone(buff);
+  if (scriptBuf.length < 2) {
+    // At least 1 byte for len data and 1 byte for OP_CHECKSIG
+    throw new _errors.ParseScriptError('Invalid output script. Script must have at least 2 bytes.');
+  }
+
+  // The expected len will be at least 2 bytes
+  // 1 for the script len and 1 for the OP_CHECKSIG in the end
+  let expectedLen = 2;
+  let dataBytesLen;
+
+  // If we have OP_PUSHDATA1 as first byte, the second byte has the length of data
+  // otherwise, the first byte already has the length of data
+  if (scriptBuf[0] === _opcodes.OP_PUSHDATA1[0]) {
+    expectedLen += 1;
+    // eslint-disable-next-line prefer-destructuring -- Destructuring would make this harder to read
+    dataBytesLen = scriptBuf[1];
+  } else {
+    // eslint-disable-next-line prefer-destructuring -- Destructuring would make this harder to read
+    dataBytesLen = scriptBuf[0];
+  }
+
+  // Set the expected length
+  expectedLen += dataBytesLen;
+  if (expectedLen !== scriptBuf.length) {
+    // The script has different qty of bytes than expected
+    throw new _errors.ParseScriptError(`Invalid output script. Expected len ${expectedLen} and received len ${scriptBuf.length}.`);
+  }
+  if (scriptBuf[expectedLen - 1] !== _opcodes.OP_CHECKSIG[0]) {
+    // Last byte must be an OP_CHECKSIG
+    throw new _errors.ParseScriptError('Invalid output script. Last byte must be OP_CHECKSIG.');
+  }
+
+  // Get data from the script
+  const data = getPushData(scriptBuf);
+  let decodedData;
+  try {
+    decodedData = data.toString('utf-8');
+  } catch (e) {
+    throw new _errors.ParseScriptError('Invalid output script. Error decoding data to utf-8.');
+  }
+  return new _script_data.default(decodedData);
+};
+
+/**
+ * Parse buffer to data decoding pushdata opcodes
+ *
+ * @param {Buffer} buff Buffer to get pushdata
+ *
+ * @return {Buffer} Data extracted from buffer
+ */
+exports.parseScriptData = parseScriptData;
+const getPushData = buff => {
+  // We should clone the buffer being sent in order to never mutate
+  // what comes from outside the library
+  const scriptBuf = _lodash.default.clone(buff);
+  if (scriptBuf.length === 0) {
+    throw new _errors.ParseError('Invalid buffer.');
+  }
+  let lenData;
+  let start;
+  if (scriptBuf[0] > 75) {
+    // eslint-disable-next-line prefer-destructuring -- Destructuring would make this harder to read
+    lenData = scriptBuf[1];
+    start = 2;
+  } else {
+    // eslint-disable-next-line prefer-destructuring -- Destructuring would make this harder to read
+    lenData = scriptBuf[0];
+    start = 1;
+  }
+  return scriptBuf.slice(start, start + lenData);
+};
+
+/**
+ * Create a P2SH MultiSig redeem script
+ *
+ * @param {string[]} xpubs The list of xpubkeys involved in this MultiSig
+ * @param {number} numSignatures Minimum number of signatures to send a
+ * transaction with this MultiSig
+ * @param {number} index Index to derive the xpubs
+ *
+ * @return {Buffer} A buffer with the redeemScript
+ * @throws {XPubError} In case any of the given xpubs are invalid
+ */
+exports.getPushData = getPushData;
+function createP2SHRedeemScript(xpubs, numSignatures, index) {
+  let sortedXpubs;
+  try {
+    sortedXpubs = _lodash.default.sortBy(xpubs.map(xp => new _bitcoreLib.HDPublicKey(xp)), xpub => {
+      return xpub.publicKey.toString('hex');
+    });
+  } catch (e) {
+    throw new _errors.XPubError('Invalid xpub');
+  }
+
+  // xpub comes derived to m/45'/280'/0'
+  // Derive to m/45'/280'/0'/0/index
+  const pubkeys = sortedXpubs.map(xpub => xpub.deriveChild(0).deriveChild(index).publicKey);
+
+  // bitcore-lib sorts the public keys by default before building the script
+  // noSorting prevents that and keeps our order
+  const redeemScript = _bitcoreLib.Script.buildMultisigOut(pubkeys, numSignatures, {
+    noSorting: true
+  });
+  return redeemScript.toBuffer();
+}
+
+/**
+ * Parse script to get an object corresponding to the script data
+ *
+ * @param {Buffer} script Output script to parse
+ * @param {Network} network Network to get the address first byte parameter
+ *
+ * @return {P2PKH | P2SH | ScriptData | null} Parsed script object
+ */
+const parseScript = (script, network) => {
+  // It's still unsure how expensive it is to throw an exception in JavaScript. Some languages are really
+  // inefficient when it comes to exceptions while others are totally efficient. If it is efficient,
+  // we can keep throwing the error. Otherwise, we should just return null
+  // because this method will be used together with others when we are trying to parse a given script.
+
+  try {
+    let parsedScript;
+    if (_p2pkh.default.identify(script)) {
+      // This is a P2PKH script
+      parsedScript = parseP2PKH(script, network);
+    } else if (_p2sh.default.identify(script)) {
+      // This is a P2SH script
+      parsedScript = parseP2SH(script, network);
+    } else {
+      // defaults to data script
+      parsedScript = parseScriptData(script);
+    }
+    return parsedScript;
+  } catch (error) {
+    if (error instanceof _errors.ParseError) {
+      // We don't know how to parse this script
+      return null;
+    }
+    throw error;
+  }
+};
+exports.parseScript = parseScript;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/utils/storage.d.ts b/node_modules/@hathor/wallet-lib/oldLib/utils/storage.d.ts
new file mode 100644
index 0000000..1e55f67
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/utils/storage.d.ts
@@ -0,0 +1,145 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+import FullnodeConnection from '../new/connection';
+import { IStorage, IHistoryTx, ILockedUtxo, IScanPolicyLoadAddresses, HistorySyncMode, HistorySyncFunction } from '../types';
+import CreateTokenTransaction from '../models/create_token_transaction';
+/**
+ * Get history sync method for a given mode
+ * @param {HistorySyncMode} mode The mode of the stream
+ * @returns {HistorySyncFunction}
+ */
+export declare function getHistorySyncMethod(mode: HistorySyncMode): HistorySyncFunction;
+export declare function getSupportedSyncMode(storage: IStorage): Promise<HistorySyncMode[]>;
+/**
+ * Derive requested addresses (if not already loaded), save them on storage then return them.
+ * @param {number} startIndex Index to start loading addresses
+ * @param {number} count Number of addresses to load
+ * @param {IStorage} storage The storage to load the addresses
+ * @returns {Promise<stringp[]>} List of loaded addresses in base58
+ */
+export declare function loadAddresses(startIndex: number, count: number, storage: IStorage): Promise<string[]>;
+/**
+ * Fetch the history of the addresses and save it on storage.
+ * Optionally process the history after loading it.
+ *
+ * @param {number} startIndex Index to start loading addresses
+ * @param {number} count Number of addresses to load
+ * @param {IStorage} storage The storage to load the addresses
+ * @param {FullnodeConnection} connection Connection to the full node
+ * @param {boolean} shouldProcessHistory If we should process the history after loading it.
+ */
+export declare function apiSyncHistory(startIndex: number, count: number, storage: IStorage, connection: FullnodeConnection, shouldProcessHistory?: boolean): Promise<void>;
+/**
+ * Fetch the tx history for a chunkified list of addresses.
+ * This method returns an AsyncGenerator so that the caller can update the UI if any transaction is found during the load process.
+ *
+ * @param {stringp[]} addresses List of addresses to load history
+ * @param {IStorage} storage The storage to load the addresses
+ * @returns {AsyncGenerator<boolean>} If we found any transaction in the history
+ */
+export declare function loadAddressHistory(addresses: string[], storage: IStorage): AsyncGenerator<boolean>;
+/**
+ * Get the starting addresses to load from the scanning policy
+ * @param {IStorage} storage The storage instance
+ * @returns {Promise<IScanPolicyLoadAddresses>}
+ */
+export declare function scanPolicyStartAddresses(storage: IStorage): Promise<IScanPolicyLoadAddresses>;
+/**
+ * Use the correct method for the configured address scanning policy to check if we should
+ * load more addresses
+ * @param {IStorage} storage The storage instance
+ * @returns {Promise<IScanPolicyLoadAddresses|null>}
+ */
+export declare function checkScanningPolicy(storage: IStorage): Promise<IScanPolicyLoadAddresses | null>;
+/**
+ * Check if the addresses loaded in storage are within policy specifications.
+ * If it doesn't, it will return the next index to load and the number of addresses to fill the gap.
+ * @param {IStorage} storage The storage instance
+ * @returns {Promise<IScanPolicyLoadAddresses|null>}
+ */
+export declare function checkIndexLimit(storage: IStorage): Promise<IScanPolicyLoadAddresses | null>;
+/**
+ * Check if the storage has at least `gapLimit` addresses loaded without any transaction.
+ * If it doesn't, it will return the next index to load and the number of addresses to fill the gap.
+ * @param {IStorage} storage The storage instance
+ * @returns {Promise<IScanPolicyLoadAddresses|null>}
+ */
+export declare function checkGapLimit(storage: IStorage): Promise<IScanPolicyLoadAddresses | null>;
+/**
+ * Process the history of transactions and create metadata to be used by the wallet.
+ *
+ * History processing is a complex and nuanced method so we created a utility to avoid errors on other store implementations.
+ * This utility only uses the store methods so it can be used by any store implementation.
+ *
+ * @param {IStorage} storage Storage instance.
+ * @param {{rewardLock: number}} [options={}] Use this configuration when processing the storage
+ * @async
+ * @returns {Promise<void>}
+ */
+export declare function processHistory(storage: IStorage, { rewardLock }?: {
+    rewardLock?: number;
+}): Promise<void>;
+export declare function processSingleTx(storage: IStorage, tx: IHistoryTx, { rewardLock }?: {
+    rewardLock?: number;
+}): Promise<void>;
+/**
+ * Some metadata changed and may need processing.
+ * void txs are not treated here.
+ * Only idempodent changes should be processed here since this can be called multiple times.
+ */
+export declare function processMetadataChanged(storage: IStorage, tx: IHistoryTx): Promise<void>;
+/**
+ * Fetch and save the data of the token set on the storage
+ * @param {IStorage} storage - Storage to save the tokens.
+ * @param {Set<string>} tokens - set of tokens to fetch and save.
+ * @returns {Promise<void>}
+ */
+export declare function _updateTokensData(storage: IStorage, tokens: Set<string>): Promise<void>;
+/**
+ * Process a new transaction, adding or creating the metadata for the addresses and tokens involved.
+ * Will update relevant wallet data and utxos.
+ * The return object contains the max address index used and the tokens found in the transaction.
+ *
+ * @param {IStorage} storage Storage instance.
+ * @param {IHistoryTx} tx The new transaction to be processed
+ * @param {Object} [options]
+ * @param {number} [options.rewardLock] The reward lock of the network
+ * @param {number} [options.nowTs] The current timestamp
+ * @param {number} [options.currentHeight] The current height of the best chain
+ * @returns {Promise<{ maxAddressIndex: number, tokens: Set<string> }>}
+ */
+export declare function processNewTx(storage: IStorage, tx: IHistoryTx, { rewardLock, nowTs, currentHeight, }?: {
+    rewardLock?: number;
+    nowTs?: number;
+    currentHeight?: number;
+}): Promise<{
+    maxAddressIndex: number;
+    tokens: Set<string>;
+}>;
+/**
+ * Process locked utxo and update the balances.
+ * If the utxo is still locked nothing is done.
+ *
+ * @param {IStorage} storage Storage instance.
+ * @param {ILockedUtxo} lockedUtxo The utxo to be unlocked
+ * @param {Object} [options]
+ * @param {number} [options.rewardLock] The reward lock of the network
+ * @param {number} [options.nowTs] The current timestamp
+ * @param {number} [options.currentHeight] The current height of the best chain
+ * @returns {Promise<void>}
+ */
+export declare function processUtxoUnlock(storage: IStorage, lockedUtxo: ILockedUtxo, { rewardLock, nowTs, currentHeight, }?: {
+    rewardLock?: number;
+    nowTs?: number;
+    currentHeight?: number;
+}): Promise<void>;
+/**
+ * Extracts the ITokenData from the CreateTokenTransaction instance and save
+ * the token on the storage.
+ */
+export declare function addCreatedTokenFromTx(tx: CreateTokenTransaction, storage: IStorage): Promise<void>;
+//# sourceMappingURL=storage.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/utils/storage.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/utils/storage.d.ts.map
new file mode 100644
index 0000000..f9014d0
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/utils/storage.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"storage.d.ts","sourceRoot":"","sources":["../../src/utils/storage.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;AAKH,OAAO,kBAAkB,MAAM,mBAAmB,CAAC;AACnD,OAAO,EACL,QAAQ,EAER,UAAU,EAEV,WAAW,EAEX,wBAAwB,EAGxB,eAAe,EACf,mBAAmB,EAIpB,MAAM,UAAU,CAAC;AAelB,OAAO,sBAAsB,MAAM,oCAAoC,CAAC;AAGxE;;;;GAIG;AACH,wBAAgB,oBAAoB,CAAC,IAAI,EAAE,eAAe,GAAG,mBAAmB,CAU/E;AAED,wBAAsB,oBAAoB,CAAC,OAAO,EAAE,QAAQ,GAAG,OAAO,CAAC,eAAe,EAAE,CAAC,CAaxF;AAED;;;;;;GAMG;AACH,wBAAsB,aAAa,CACjC,UAAU,EAAE,MAAM,EAClB,KAAK,EAAE,MAAM,EACb,OAAO,EAAE,QAAQ,GAChB,OAAO,CAAC,MAAM,EAAE,CAAC,CAsBnB;AAED;;;;;;;;;GASG;AACH,wBAAsB,cAAc,CAClC,UAAU,EAAE,MAAM,EAClB,KAAK,EAAE,MAAM,EACb,OAAO,EAAE,QAAQ,EACjB,UAAU,EAAE,kBAAkB,EAC9B,oBAAoB,GAAE,OAAe,iBAmCtC;AAED;;;;;;;GAOG;AACH,wBAAuB,kBAAkB,CACvC,SAAS,EAAE,MAAM,EAAE,EACnB,OAAO,EAAE,QAAQ,GAChB,cAAc,CAAC,OAAO,CAAC,CAyEzB;AAED;;;;GAIG;AACH,wBAAsB,wBAAwB,CAC5C,OAAO,EAAE,QAAQ,GAChB,OAAO,CAAC,wBAAwB,CAAC,CAqBnC;AAED;;;;;GAKG;AACH,wBAAsB,mBAAmB,CACvC,OAAO,EAAE,QAAQ,GAChB,OAAO,CAAC,wBAAwB,GAAG,IAAI,CAAC,CAU1C;AAED;;;;;GAKG;AACH,wBAAsB,eAAe,CAAC,OAAO,EAAE,QAAQ,GAAG,OAAO,CAAC,wBAAwB,GAAG,IAAI,CAAC,CA4BjG;AAED;;;;;GAKG;AACH,wBAAsB,aAAa,CAAC,OAAO,EAAE,QAAQ,GAAG,OAAO,CAAC,wBAAwB,GAAG,IAAI,CAAC,CAuB/F;AAED;;;;;;;;;;GAUG;AACH,wBAAsB,cAAc,CAClC,OAAO,EAAE,QAAQ,EACjB,EAAE,UAAU,EAAE,GAAE;IAAE,UAAU,CAAC,EAAE,MAAM,CAAA;CAAO,GAC3C,OAAO,CAAC,IAAI,CAAC,CAqBf;AAED,wBAAsB,eAAe,CACnC,OAAO,EAAE,QAAQ,EACjB,EAAE,EAAE,UAAU,EACd,EAAE,UAAU,EAAE,GAAE;IAAE,UAAU,CAAC,EAAE,MAAM,CAAA;CAAO,GAC3C,OAAO,CAAC,IAAI,CAAC,CAqDf;AAED;;;;GAIG;AACH,wBAAsB,sBAAsB,CAAC,OAAO,EAAE,QAAQ,EAAE,EAAE,EAAE,UAAU,GAAG,OAAO,CAAC,IAAI,CAAC,CAiC7F;AAED;;;;;GAKG;AACH,wBAAsB,iBAAiB,CAAC,OAAO,EAAE,QAAQ,EAAE,MAAM,EAAE,GAAG,CAAC,MAAM,CAAC,GAAG,OAAO,CAAC,IAAI,CAAC,CAyD7F;AAkCD;;;;;;;;;;;;GAYG;AACH,wBAAsB,YAAY,CAChC,OAAO,EAAE,QAAQ,EACjB,EAAE,EAAE,UAAU,EACd,EACE,UAAU,EACV,KAAK,EACL,aAAa,GACd,GAAE;IAAE,UAAU,CAAC,EAAE,MAAM,CAAC;IAAC,KAAK,CAAC,EAAE,MAAM,CAAC;IAAC,aAAa,CAAC,EAAE,MAAM,CAAA;CAAO,GACtE,OAAO,CAAC;IACT,eAAe,EAAE,MAAM,CAAC;IACxB,MAAM,EAAE,GAAG,CAAC,MAAM,CAAC,CAAC;CACrB,CAAC,CA6PD;AAED;;;;;;;;;;;GAWG;AACH,wBAAsB,iBAAiB,CACrC,OAAO,EAAE,QAAQ,EACjB,UAAU,EAAE,WAAW,EACvB,EACE,UAAU,EACV,KAAK,EACL,aAAa,GACd,GAAE;IAAE,UAAU,CAAC,EAAE,MAAM,CAAC;IAAC,KAAK,CAAC,EAAE,MAAM,CAAC;IAAC,aAAa,CAAC,EAAE,MAAM,CAAA;CAAO,GACtE,OAAO,CAAC,IAAI,CAAC,CAkFf;AAED;;;GAGG;AACH,wBAAsB,qBAAqB,CACzC,EAAE,EAAE,sBAAsB,EAC1B,OAAO,EAAE,QAAQ,GAChB,OAAO,CAAC,IAAI,CAAC,CAgBf"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/utils/storage.js b/node_modules/@hathor/wallet-lib/oldLib/utils/storage.js
new file mode 100644
index 0000000..0649b4b
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/utils/storage.js
@@ -0,0 +1,1051 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports._updateTokensData = _updateTokensData;
+exports.addCreatedTokenFromTx = addCreatedTokenFromTx;
+exports.apiSyncHistory = apiSyncHistory;
+exports.checkGapLimit = checkGapLimit;
+exports.checkIndexLimit = checkIndexLimit;
+exports.checkScanningPolicy = checkScanningPolicy;
+exports.getHistorySyncMethod = getHistorySyncMethod;
+exports.getSupportedSyncMode = getSupportedSyncMode;
+exports.loadAddressHistory = loadAddressHistory;
+exports.loadAddresses = loadAddresses;
+exports.processHistory = processHistory;
+exports.processMetadataChanged = processMetadataChanged;
+exports.processNewTx = processNewTx;
+exports.processSingleTx = processSingleTx;
+exports.processUtxoUnlock = processUtxoUnlock;
+exports.scanPolicyStartAddresses = scanPolicyStartAddresses;
+var _lodash = require("lodash");
+var _axios = _interopRequireDefault(require("axios"));
+var _types = require("../types");
+var _wallet = _interopRequireDefault(require("../api/wallet"));
+var _helpers = _interopRequireDefault(require("./helpers"));
+var _transaction = _interopRequireDefault(require("./transaction"));
+var _address = require("./address");
+var _stream = require("../sync/stream");
+var _constants = require("../constants");
+var _storage = require("../storage/storage");
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+function _awaitAsyncGenerator(e) { return new _OverloadYield(e, 0); }
+function _wrapAsyncGenerator(e) { return function () { return new AsyncGenerator(e.apply(this, arguments)); }; }
+function AsyncGenerator(e) { var r, t; function resume(r, t) { try { var n = e[r](t), o = n.value, u = o instanceof _OverloadYield; Promise.resolve(u ? o.v : o).then(function (t) { if (u) { var i = "return" === r ? "return" : "next"; if (!o.k || t.done) return resume(i, t); t = e[i](t).value; } settle(n.done ? "return" : "normal", t); }, function (e) { resume("throw", e); }); } catch (e) { settle("throw", e); } } function settle(e, n) { switch (e) { case "return": r.resolve({ value: n, done: !0 }); break; case "throw": r.reject(n); break; default: r.resolve({ value: n, done: !1 }); } (r = r.next) ? resume(r.key, r.arg) : t = null; } this._invoke = function (e, n) { return new Promise(function (o, u) { var i = { key: e, arg: n, resolve: o, reject: u, next: null }; t ? t = t.next = i : (r = t = i, resume(e, n)); }); }, "function" != typeof e.return && (this.return = void 0); }
+AsyncGenerator.prototype["function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator"] = function () { return this; }, AsyncGenerator.prototype.next = function (e) { return this._invoke("next", e); }, AsyncGenerator.prototype.throw = function (e) { return this._invoke("throw", e); }, AsyncGenerator.prototype.return = function (e) { return this._invoke("return", e); };
+function _OverloadYield(e, d) { this.v = e, this.k = d; }
+function _asyncIterator(r) { var n, t, o, e = 2; for ("undefined" != typeof Symbol && (t = Symbol.asyncIterator, o = Symbol.iterator); e--;) { if (t && null != (n = r[t])) return n.call(r); if (o && null != (n = r[o])) return new AsyncFromSyncIterator(n.call(r)); t = "@@asyncIterator", o = "@@iterator"; } throw new TypeError("Object is not async iterable"); }
+function AsyncFromSyncIterator(r) { function AsyncFromSyncIteratorContinuation(r) { if (Object(r) !== r) return Promise.reject(new TypeError(r + " is not an object.")); var n = r.done; return Promise.resolve(r.value).then(function (r) { return { value: r, done: n }; }); } return AsyncFromSyncIterator = function (r) { this.s = r, this.n = r.next; }, AsyncFromSyncIterator.prototype = { s: null, n: null, next: function () { return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments)); }, return: function (r) { var n = this.s.return; return void 0 === n ? Promise.resolve({ value: r, done: !0 }) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments)); }, throw: function (r) { var n = this.s.return; return void 0 === n ? Promise.reject(r) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments)); } }, new AsyncFromSyncIterator(r); } /**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/**
+ * Get history sync method for a given mode
+ * @param {HistorySyncMode} mode The mode of the stream
+ * @returns {HistorySyncFunction}
+ */
+function getHistorySyncMethod(mode) {
+  switch (mode) {
+    case _types.HistorySyncMode.MANUAL_STREAM_WS:
+      return _stream.manualStreamSyncHistory;
+    case _types.HistorySyncMode.XPUB_STREAM_WS:
+      return _stream.xpubStreamSyncHistory;
+    case _types.HistorySyncMode.POLLING_HTTP_API:
+    default:
+      return apiSyncHistory;
+  }
+}
+async function getSupportedSyncMode(storage) {
+  const walletType = await storage.getWalletType();
+  if (walletType === _types.WalletType.P2PKH) {
+    return [_types.HistorySyncMode.MANUAL_STREAM_WS, _types.HistorySyncMode.POLLING_HTTP_API, _types.HistorySyncMode.XPUB_STREAM_WS];
+  }
+  if (walletType === _types.WalletType.MULTISIG) {
+    return [_types.HistorySyncMode.POLLING_HTTP_API];
+  }
+  return [];
+}
+
+/**
+ * Derive requested addresses (if not already loaded), save them on storage then return them.
+ * @param {number} startIndex Index to start loading addresses
+ * @param {number} count Number of addresses to load
+ * @param {IStorage} storage The storage to load the addresses
+ * @returns {Promise<stringp[]>} List of loaded addresses in base58
+ */
+async function loadAddresses(startIndex, count, storage) {
+  const addresses = [];
+  const stopIndex = startIndex + count;
+  for (let i = startIndex; i < stopIndex; i++) {
+    const storageAddr = await storage.getAddressAtIndex(i);
+    if (storageAddr !== null) {
+      // This address is already generated, we can skip derivation
+      addresses.push(storageAddr.base58);
+      continue;
+    }
+    // derive address at index i
+    let address;
+    if ((await storage.getWalletType()) === 'p2pkh') {
+      address = await (0, _address.deriveAddressP2PKH)(i, storage);
+    } else {
+      address = await (0, _address.deriveAddressP2SH)(i, storage);
+    }
+    await storage.saveAddress(address);
+    addresses.push(address.base58);
+  }
+  return addresses;
+}
+
+/**
+ * Fetch the history of the addresses and save it on storage.
+ * Optionally process the history after loading it.
+ *
+ * @param {number} startIndex Index to start loading addresses
+ * @param {number} count Number of addresses to load
+ * @param {IStorage} storage The storage to load the addresses
+ * @param {FullnodeConnection} connection Connection to the full node
+ * @param {boolean} shouldProcessHistory If we should process the history after loading it.
+ */
+async function apiSyncHistory(startIndex, count, storage, connection, shouldProcessHistory = false) {
+  let itStartIndex = startIndex;
+  let itCount = count;
+  let foundAnyTx = false;
+  while (true) {
+    const addresses = await loadAddresses(itStartIndex, itCount, storage);
+    // subscribe to addresses
+    connection.subscribeAddresses(addresses);
+    var _iteratorAbruptCompletion = false;
+    var _didIteratorError = false;
+    var _iteratorError;
+    try {
+      for (var _iterator = _asyncIterator(loadAddressHistory(addresses, storage)), _step; _iteratorAbruptCompletion = !(_step = await _iterator.next()).done; _iteratorAbruptCompletion = false) {
+        const gotTx = _step.value;
+        {
+          if (gotTx) {
+            // This will signal we have found a transaction when syncing the history
+            foundAnyTx = true;
+          }
+          // update UI
+          connection.emit('wallet-load-partial-update', {
+            addressesFound: await storage.store.addressCount(),
+            historyLength: await storage.store.historyCount()
+          });
+        }
+      }
+
+      // Check if we need to load more addresses from the address scanning policy
+    } catch (err) {
+      _didIteratorError = true;
+      _iteratorError = err;
+    } finally {
+      try {
+        if (_iteratorAbruptCompletion && _iterator.return != null) {
+          await _iterator.return();
+        }
+      } finally {
+        if (_didIteratorError) {
+          throw _iteratorError;
+        }
+      }
+    }
+    const loadMoreAddresses = await checkScanningPolicy(storage);
+    if (loadMoreAddresses === null) {
+      // No more addresses to load
+      break;
+    }
+    // The scanning policy configured requires more addresses to be loaded
+    itStartIndex = loadMoreAddresses.nextIndex;
+    itCount = loadMoreAddresses.count;
+  }
+  if (foundAnyTx && shouldProcessHistory) {
+    await storage.processHistory();
+  }
+}
+
+/**
+ * Fetch the tx history for a chunkified list of addresses.
+ * This method returns an AsyncGenerator so that the caller can update the UI if any transaction is found during the load process.
+ *
+ * @param {stringp[]} addresses List of addresses to load history
+ * @param {IStorage} storage The storage to load the addresses
+ * @returns {AsyncGenerator<boolean>} If we found any transaction in the history
+ */
+function loadAddressHistory(_x, _x2) {
+  return _loadAddressHistory.apply(this, arguments);
+}
+/**
+ * Get the starting addresses to load from the scanning policy
+ * @param {IStorage} storage The storage instance
+ * @returns {Promise<IScanPolicyLoadAddresses>}
+ */
+function _loadAddressHistory() {
+  _loadAddressHistory = _wrapAsyncGenerator(function* (addresses, storage) {
+    let foundAnyTx = false;
+    // chunkify addresses
+    const addressesChunks = (0, _lodash.chunk)(addresses, _constants.MAX_ADDRESSES_GET);
+    let retryCount = 0;
+    for (let i = 0; i < addressesChunks.length; i++) {
+      let hasMore = true;
+      let firstHash = null;
+      let addrsToSearch = addressesChunks[i];
+      while (hasMore === true) {
+        let response;
+        try {
+          response = yield _awaitAsyncGenerator(_wallet.default.getAddressHistoryForAwait(addrsToSearch, firstHash));
+        } catch (e) {
+          if (!_axios.default.isAxiosError(e)) {
+            // We only treat AxiosError
+            throw e;
+          }
+          const err = e;
+          // We will retry the request that fails with client timeout
+          // in this request error we don't have the response because
+          // the client closed the connection
+          //
+          // There are some error reports about it (https://github.com/axios/axios/issues/2716)
+          // Besides that, there are some problems happening in newer axios versions (https://github.com/axios/axios/issues/2710)
+          // One user that opened a PR for axios said he is checking the timeout error with the message includes condition
+          // https://github.com/axios/axios/pull/2874#discussion_r403753852
+          if (err.code === 'ECONNABORTED' && err.response === undefined && err.message.toLowerCase().includes('timeout')) {
+            // in this case we retry
+            continue;
+          }
+          if (retryCount > _constants.LOAD_WALLET_MAX_RETRY) {
+            throw e;
+          }
+          retryCount++;
+          yield _awaitAsyncGenerator(_helpers.default.sleep(_constants.LOAD_WALLET_RETRY_SLEEP));
+          continue;
+        }
+        // Request has succeeded, reset retry count
+        retryCount = 0;
+        const result = response.data;
+        if (result.success) {
+          for (const tx of result.history) {
+            foundAnyTx = true;
+            yield _awaitAsyncGenerator(storage.addTx(tx));
+          }
+          hasMore = result.has_more;
+          if (hasMore) {
+            // prepare next page parameters
+            firstHash = result.first_hash || null;
+            const addrIndex = addrsToSearch.indexOf(result.first_address || '');
+            if (addrIndex === -1) {
+              throw Error('Invalid address returned from the server.');
+            }
+            addrsToSearch = addrsToSearch.slice(addrIndex);
+          } else {
+            // Signal that we have more data to update the UI
+            yield foundAnyTx;
+          }
+        } else {
+          throw new Error(result.message);
+        }
+      }
+    }
+  });
+  return _loadAddressHistory.apply(this, arguments);
+}
+async function scanPolicyStartAddresses(storage) {
+  const scanPolicy = await storage.getScanningPolicy();
+  let limits;
+  switch (scanPolicy) {
+    case _types.SCANNING_POLICY.INDEX_LIMIT:
+      limits = await storage.getIndexLimit();
+      if (!limits) {
+        // This should not happen but it enforces the limits type
+        throw new Error('Index limit is not configured');
+      }
+      return {
+        nextIndex: limits.startIndex,
+        count: limits.endIndex - limits.startIndex + 1
+      };
+    case _types.SCANNING_POLICY.GAP_LIMIT:
+    default:
+      return {
+        nextIndex: 0,
+        count: await storage.getGapLimit()
+      };
+  }
+}
+
+/**
+ * Use the correct method for the configured address scanning policy to check if we should
+ * load more addresses
+ * @param {IStorage} storage The storage instance
+ * @returns {Promise<IScanPolicyLoadAddresses|null>}
+ */
+async function checkScanningPolicy(storage) {
+  const scanPolicy = await storage.getScanningPolicy();
+  switch (scanPolicy) {
+    case _types.SCANNING_POLICY.INDEX_LIMIT:
+      return checkIndexLimit(storage);
+    case _types.SCANNING_POLICY.GAP_LIMIT:
+      return checkGapLimit(storage);
+    default:
+      return null;
+  }
+}
+
+/**
+ * Check if the addresses loaded in storage are within policy specifications.
+ * If it doesn't, it will return the next index to load and the number of addresses to fill the gap.
+ * @param {IStorage} storage The storage instance
+ * @returns {Promise<IScanPolicyLoadAddresses|null>}
+ */
+async function checkIndexLimit(storage) {
+  if ((await storage.getScanningPolicy()) !== _types.SCANNING_POLICY.INDEX_LIMIT) {
+    // Since the wallet is not configured to use index-limit this is a no-op
+    return null;
+  }
+  const {
+    lastLoadedAddressIndex,
+    scanPolicyData
+  } = await storage.getWalletData();
+  if (!(0, _types.isIndexLimitScanPolicy)(scanPolicyData)) {
+    // This error should never happen, but this enforces scanPolicyData typing
+    throw new Error('Wallet is configured to use index-limit but the scan policy data is not configured as index-limit');
+  }
+  const limits = await storage.getIndexLimit();
+  if (!limits) {
+    // This should not happen but it enforces the limits type
+    return null;
+  }
+  // If the last loaded address is below the end index, load addresses until we reach the end index
+  if (lastLoadedAddressIndex < limits.endIndex) {
+    return {
+      nextIndex: lastLoadedAddressIndex + 1,
+      count: limits.endIndex - lastLoadedAddressIndex
+    };
+  }
+
+  // Index limit does not automatically load more addresses, only if configured by the user.
+  return null;
+}
+
+/**
+ * Check if the storage has at least `gapLimit` addresses loaded without any transaction.
+ * If it doesn't, it will return the next index to load and the number of addresses to fill the gap.
+ * @param {IStorage} storage The storage instance
+ * @returns {Promise<IScanPolicyLoadAddresses|null>}
+ */
+async function checkGapLimit(storage) {
+  if ((await storage.getScanningPolicy()) !== _types.SCANNING_POLICY.GAP_LIMIT) {
+    // Since the wallet is not configured to use gap-limit this is a no-op
+    return null;
+  }
+  // check gap limit
+  const {
+    lastLoadedAddressIndex,
+    lastUsedAddressIndex
+  } = await storage.getWalletData();
+  const scanPolicyData = await storage.getScanningPolicyData();
+  if (!(0, _types.isGapLimitScanPolicy)(scanPolicyData)) {
+    // This error should never happen, but this enforces scanPolicyData typing
+    throw new Error('Wallet is configured to use gap-limit but the scan policy data is not configured as gap-limit');
+  }
+  const {
+    gapLimit
+  } = scanPolicyData;
+  if (lastUsedAddressIndex + gapLimit > lastLoadedAddressIndex) {
+    // we need to generate more addresses to fill the gap limit
+    return {
+      nextIndex: lastLoadedAddressIndex + 1,
+      count: lastUsedAddressIndex + gapLimit - lastLoadedAddressIndex
+    };
+  }
+  return null;
+}
+
+/**
+ * Process the history of transactions and create metadata to be used by the wallet.
+ *
+ * History processing is a complex and nuanced method so we created a utility to avoid errors on other store implementations.
+ * This utility only uses the store methods so it can be used by any store implementation.
+ *
+ * @param {IStorage} storage Storage instance.
+ * @param {{rewardLock: number}} [options={}] Use this configuration when processing the storage
+ * @async
+ * @returns {Promise<void>}
+ */
+async function processHistory(storage, {
+  rewardLock
+} = {}) {
+  const {
+    store
+  } = storage;
+  // We have an additive method to update metadata so we need to clean the current metadata before processing.
+  await store.cleanMetadata();
+  const nowTs = Math.floor(Date.now() / 1000);
+  const currentHeight = await store.getCurrentHeight();
+  const tokens = new Set();
+  let maxIndexUsed = -1;
+  // Iterate on all txs of the history updating the metadata as we go
+  var _iteratorAbruptCompletion2 = false;
+  var _didIteratorError2 = false;
+  var _iteratorError2;
+  try {
+    for (var _iterator2 = _asyncIterator(store.historyIter()), _step2; _iteratorAbruptCompletion2 = !(_step2 = await _iterator2.next()).done; _iteratorAbruptCompletion2 = false) {
+      const tx = _step2.value;
+      {
+        const processedData = await processNewTx(storage, tx, {
+          rewardLock,
+          nowTs,
+          currentHeight
+        });
+        maxIndexUsed = Math.max(maxIndexUsed, processedData.maxAddressIndex);
+        for (const token of processedData.tokens) {
+          tokens.add(token);
+        }
+      }
+    }
+
+    // Update wallet data
+  } catch (err) {
+    _didIteratorError2 = true;
+    _iteratorError2 = err;
+  } finally {
+    try {
+      if (_iteratorAbruptCompletion2 && _iterator2.return != null) {
+        await _iterator2.return();
+      }
+    } finally {
+      if (_didIteratorError2) {
+        throw _iteratorError2;
+      }
+    }
+  }
+  await updateWalletMetadataFromProcessedTxData(storage, {
+    maxIndexUsed,
+    tokens
+  });
+}
+async function processSingleTx(storage, tx, {
+  rewardLock
+} = {}) {
+  const {
+    store
+  } = storage;
+  const nowTs = Math.floor(Date.now() / 1000);
+  const currentHeight = await store.getCurrentHeight();
+  const tokens = new Set();
+  const processedData = await processNewTx(storage, tx, {
+    rewardLock,
+    nowTs,
+    currentHeight
+  });
+  const maxIndexUsed = processedData.maxAddressIndex;
+  for (const token of processedData.tokens) {
+    tokens.add(token);
+  }
+  for (const input of tx.inputs) {
+    const origTx = await storage.getTx(input.tx_id);
+    if (!origTx) {
+      // The tx being spent is not from the wallet.
+      continue;
+    }
+    if (origTx.outputs.length <= input.index) {
+      throw new Error('Spending an unexistent output');
+    }
+    const output = origTx.outputs[input.index];
+    if (!output.decoded.address) {
+      // Tx is ours but output is not from an address.
+      continue;
+    }
+    if (!(await storage.isAddressMine(output.decoded.address))) {
+      // Address is not ours.
+      continue;
+    }
+
+    // Now we get the utxo object to be deleted from the store
+    const utxo = {
+      txId: input.tx_id,
+      index: input.index,
+      token: output.token,
+      address: output.decoded.address,
+      authorities: _transaction.default.isAuthorityOutput(output) ? output.value : 0n,
+      value: output.value,
+      timelock: output.decoded?.timelock ?? null,
+      type: origTx.version,
+      height: origTx.height ?? null
+    };
+
+    // Delete utxo
+    await store.deleteUtxo(utxo);
+  }
+
+  // Update wallet data in the store
+  await updateWalletMetadataFromProcessedTxData(storage, {
+    maxIndexUsed,
+    tokens
+  });
+}
+
+/**
+ * Some metadata changed and may need processing.
+ * void txs are not treated here.
+ * Only idempodent changes should be processed here since this can be called multiple times.
+ */
+async function processMetadataChanged(storage, tx) {
+  const {
+    store
+  } = storage;
+  for (let index = 0; index < tx.outputs.length; index++) {
+    const output = tx.outputs[index];
+    if (!output.decoded.address) {
+      // Tx is ours but output is not from an address.
+      continue;
+    }
+    if (!(await storage.isAddressMine(output.decoded.address))) {
+      // Address is not ours.
+      continue;
+    }
+    if (output.spent_by === null) {
+      await store.saveUtxo({
+        txId: tx.tx_id,
+        index,
+        type: tx.version,
+        authorities: _transaction.default.isAuthorityOutput(output) ? output.value : 0n,
+        address: output.decoded.address,
+        token: output.token,
+        value: output.value,
+        timelock: output.decoded.timelock || null,
+        height: tx.height || null
+      });
+    } else if (await storage.isUtxoSelectedAsInput({
+      txId: tx.tx_id,
+      index
+    })) {
+      // If the output is spent we remove it from the utxos selected_as_inputs if it's there
+      await storage.utxoSelectAsInput({
+        txId: tx.tx_id,
+        index
+      }, false);
+    }
+  }
+}
+
+/**
+ * Fetch and save the data of the token set on the storage
+ * @param {IStorage} storage - Storage to save the tokens.
+ * @param {Set<string>} tokens - set of tokens to fetch and save.
+ * @returns {Promise<void>}
+ */
+async function _updateTokensData(storage, tokens) {
+  async function fetchTokenData(uid) {
+    let retryCount = 0;
+    if (uid === _constants.NATIVE_TOKEN_UID) {
+      const nativeToken = storage.getNativeTokenData();
+      return {
+        success: true,
+        name: nativeToken.name,
+        symbol: nativeToken.symbol
+      };
+    }
+    while (retryCount <= 5) {
+      try {
+        // Fetch and return the api response
+        const result = await new Promise((resolve, reject) => {
+          _wallet.default.getGeneralTokenInfo(uid, resolve).catch(err => reject(err));
+        });
+        return result;
+      } catch (err) {
+        storage.logger.error(err);
+        // This delay will give us the exponential backoff intervals of
+        // 500ms, 1s, 2s, 4s and 8s
+        const delay = 500 * 2 ** retryCount;
+        // Increase the retry counter and try again
+        retryCount += 1;
+        // Wait `delay` ms before another attempt
+        await new Promise(resolve => {
+          setTimeout(resolve, delay);
+        });
+        continue;
+      }
+    }
+    throw new Error(`Too many attempts at fetchTokenData for ${uid}`);
+  }
+  const {
+    store
+  } = storage;
+  for (const uid of tokens) {
+    const tokenInfo = await store.getToken(uid);
+    if (!tokenInfo) {
+      // The only error that can be thrown is 'too many retries'
+      const response = await fetchTokenData(uid);
+      if (!response.success) {
+        throw new Error(response.message);
+      }
+      const {
+        name,
+        symbol
+      } = response;
+      const tokenData = {
+        uid,
+        name,
+        symbol
+      };
+      await storage.addToken(tokenData);
+    }
+  }
+}
+
+/**
+ * Update the store wallet data based on accumulated data from processed txs.
+ * @param {IStorage} storage Storage instance.
+ * @param {Object} options
+ * @param {number} options.maxIndexUsed The maximum index used in the processed txs
+ * @param {Set<string>} options.tokens A set of tokens found in the processed txs
+ */
+async function updateWalletMetadataFromProcessedTxData(storage, {
+  maxIndexUsed,
+  tokens
+}) {
+  const {
+    store
+  } = storage;
+  // Update wallet data
+  const walletData = await store.getWalletData();
+  if (maxIndexUsed > -1) {
+    // If maxIndexUsed is -1 it means we didn't find any tx, so we don't need to update the wallet data
+    if (walletData.lastUsedAddressIndex <= maxIndexUsed) {
+      if (walletData.currentAddressIndex <= maxIndexUsed) {
+        await store.setCurrentAddressIndex(Math.min(maxIndexUsed + 1, walletData.lastLoadedAddressIndex));
+      }
+      await store.setLastUsedAddressIndex(maxIndexUsed);
+    }
+  }
+
+  // Update token config
+  // Up until now we have updated the tokens metadata, but the token config may be missing
+  // So we will check if we have each token found, if not we will fetch the token config from the api.
+  await _updateTokensData(storage, tokens);
+}
+
+/**
+ * Process a new transaction, adding or creating the metadata for the addresses and tokens involved.
+ * Will update relevant wallet data and utxos.
+ * The return object contains the max address index used and the tokens found in the transaction.
+ *
+ * @param {IStorage} storage Storage instance.
+ * @param {IHistoryTx} tx The new transaction to be processed
+ * @param {Object} [options]
+ * @param {number} [options.rewardLock] The reward lock of the network
+ * @param {number} [options.nowTs] The current timestamp
+ * @param {number} [options.currentHeight] The current height of the best chain
+ * @returns {Promise<{ maxAddressIndex: number, tokens: Set<string> }>}
+ */
+async function processNewTx(storage, tx, {
+  rewardLock,
+  nowTs,
+  currentHeight
+} = {}) {
+  function getEmptyBalance() {
+    return {
+      tokens: {
+        unlocked: 0n,
+        locked: 0n
+      },
+      authorities: {
+        mint: {
+          unlocked: 0n,
+          locked: 0n
+        },
+        melt: {
+          unlocked: 0n,
+          locked: 0n
+        }
+      }
+    };
+  }
+  const {
+    store
+  } = storage;
+  if (tx.is_voided && tx.nc_id && tx.first_block) {
+    // If a nano transaction is voided but has first block
+    // we need to increase the seqnum of the caller address
+    if (!tx.nc_address) {
+      throw new Error(`Nano contract tx(${tx.tx_id}) with caller address ${tx.nc_address}`);
+    }
+    const caller = tx.nc_address;
+    const callerAddressInfo = await store.getAddress(caller);
+    // if address is not in wallet, ignore
+    if (callerAddressInfo) {
+      // create metadata for address if it does not exist
+      let addressMeta = await store.getAddressMeta(caller);
+      if (!addressMeta) {
+        addressMeta = {
+          ..._storage.DEFAULT_ADDRESS_META
+        };
+      }
+      if (tx.nc_seqnum > addressMeta.seqnum) {
+        addressMeta.seqnum = tx.nc_seqnum;
+      }
+      await store.editAddressMeta(caller, addressMeta);
+    }
+  }
+
+  // We ignore voided transactions
+  if (tx.is_voided) return {
+    maxAddressIndex: -1,
+    tokens: new Set()
+  };
+  const isHeightLocked = _transaction.default.isHeightLocked(tx.height, currentHeight, rewardLock);
+  const txAddresses = new Set();
+  const txTokens = new Set();
+  let maxIndexUsed = -1;
+  for (const [index, output] of tx.outputs.entries()) {
+    // Skip data outputs since they do not have an address and do not "belong" in a wallet
+    if (!output.decoded.address) continue;
+    const addressInfo = await store.getAddress(output.decoded.address);
+    // if address is not in wallet, ignore
+    if (!addressInfo) continue;
+
+    // Check if this output is locked
+    const isLocked = _transaction.default.isOutputLocked(output, {
+      refTs: nowTs
+    }) || isHeightLocked;
+    const isAuthority = _transaction.default.isAuthorityOutput(output);
+    let addressMeta = await store.getAddressMeta(output.decoded.address);
+    let tokenMeta = await store.getTokenMeta(output.token);
+
+    // check if the current address is the highest index used
+    // Update the max index used if it is
+    if (addressInfo.bip32AddressIndex > maxIndexUsed) {
+      maxIndexUsed = addressInfo.bip32AddressIndex;
+    }
+
+    // create metadata for address and token if it does not exist
+    if (!addressMeta) {
+      addressMeta = {
+        ..._storage.DEFAULT_ADDRESS_META
+      };
+    }
+    if (!tokenMeta) {
+      tokenMeta = {
+        numTransactions: 0,
+        balance: getEmptyBalance()
+      };
+    }
+    if (!addressMeta.balance.has(output.token)) {
+      // Add the current token to the address balance if not present
+      addressMeta.balance.set(output.token, getEmptyBalance());
+    }
+
+    // update metadata
+    txTokens.add(output.token);
+    txAddresses.add(output.decoded.address);
+
+    // calculate balance
+    // The balance for authority outputs is the count of outputs
+    // While the balance for non-authority outputs is the sum of the value.
+    // The balance will also be split into unlocked and locked.
+    // We will update both the address and token metadata separately.
+    if (isAuthority) {
+      if (isLocked) {
+        if (_transaction.default.isMint(output)) {
+          tokenMeta.balance.authorities.mint.locked += 1n;
+          addressMeta.balance.get(output.token).authorities.mint.locked += 1n;
+        }
+        if (_transaction.default.isMelt(output)) {
+          tokenMeta.balance.authorities.melt.locked += 1n;
+          addressMeta.balance.get(output.token).authorities.melt.locked += 1n;
+        }
+      } else {
+        if (_transaction.default.isMint(output)) {
+          tokenMeta.balance.authorities.mint.unlocked += 1n;
+          addressMeta.balance.get(output.token).authorities.mint.unlocked += 1n;
+        }
+        if (_transaction.default.isMelt(output)) {
+          tokenMeta.balance.authorities.melt.unlocked += 1n;
+          addressMeta.balance.get(output.token).authorities.melt.unlocked += 1n;
+        }
+      }
+    } else if (isLocked) {
+      tokenMeta.balance.tokens.locked += output.value;
+      addressMeta.balance.get(output.token).tokens.locked += output.value;
+    } else {
+      tokenMeta.balance.tokens.unlocked += output.value;
+      addressMeta.balance.get(output.token).tokens.unlocked += output.value;
+    }
+
+    // Add utxo to the storage if unspent
+    // This is idempotent so it's safe to call it multiple times
+    if (output.spent_by === null) {
+      await store.saveUtxo({
+        txId: tx.tx_id,
+        index,
+        type: tx.version,
+        authorities: _transaction.default.isAuthorityOutput(output) ? output.value : 0n,
+        address: output.decoded.address,
+        token: output.token,
+        value: output.value,
+        timelock: output.decoded.timelock || null,
+        height: tx.height || null
+      });
+      if (isLocked) {
+        // We will save this utxo on the index of locked utxos
+        // So that later when it becomes unlocked we can update the balances with processUtxoUnlock
+        await store.saveLockedUtxo({
+          tx,
+          index
+        });
+      }
+    } else if (await storage.isUtxoSelectedAsInput({
+      txId: tx.tx_id,
+      index
+    })) {
+      // If the output is spent we remove it from the utxos selected_as_inputs if it's there
+      await storage.utxoSelectAsInput({
+        txId: tx.tx_id,
+        index
+      }, false);
+    }
+    await store.editTokenMeta(output.token, tokenMeta);
+    await store.editAddressMeta(output.decoded.address, addressMeta);
+  }
+  for (const input of tx.inputs) {
+    // We ignore data inputs since they do not have an address
+    if (!input.decoded.address) continue;
+    const addressInfo = await store.getAddress(input.decoded.address);
+    // This is not our address, ignore
+    if (!addressInfo) continue;
+    const isAuthority = _transaction.default.isAuthorityOutput(input);
+    let addressMeta = await store.getAddressMeta(input.decoded.address);
+    let tokenMeta = await store.getTokenMeta(input.token);
+
+    // We also check the index of the input addresses, but they should have been processed as outputs of another transaction.
+    if (addressInfo.bip32AddressIndex > maxIndexUsed) {
+      maxIndexUsed = addressInfo.bip32AddressIndex;
+    }
+
+    // create metadata for address and token if it does not exist
+    if (!addressMeta) {
+      addressMeta = {
+        ..._storage.DEFAULT_ADDRESS_META
+      };
+    }
+    if (!tokenMeta) {
+      tokenMeta = {
+        numTransactions: 0,
+        balance: getEmptyBalance()
+      };
+    }
+    if (!addressMeta.balance.has(input.token)) {
+      // Add the current token to the address balance if not present
+      addressMeta.balance.set(input.token, getEmptyBalance());
+    }
+
+    // update counters
+    txTokens.add(input.token);
+    txAddresses.add(input.decoded.address);
+    if (isAuthority) {
+      if (_transaction.default.isMint(input)) {
+        tokenMeta.balance.authorities.mint.unlocked -= 1n;
+        addressMeta.balance.get(input.token).authorities.mint.unlocked -= 1n;
+      }
+      if (_transaction.default.isMelt(input)) {
+        tokenMeta.balance.authorities.melt.unlocked -= 1n;
+        addressMeta.balance.get(input.token).authorities.melt.unlocked -= 1n;
+      }
+    } else {
+      tokenMeta.balance.tokens.unlocked -= input.value;
+      addressMeta.balance.get(input.token).tokens.unlocked -= input.value;
+    }
+
+    // save address and token metadata
+    await store.editTokenMeta(input.token, tokenMeta);
+    await store.editAddressMeta(input.decoded.address, addressMeta);
+  }
+
+  // Nano contract and ocb transactions have the address used to sign the tx
+  // and we must consider this to the address metadata
+  // The IHistoryTx object has data from the full node that doesn't have the headers
+  // only the nano parameters in the data
+  if (tx.nc_id || tx.version === _constants.ON_CHAIN_BLUEPRINTS_VERSION) {
+    let caller;
+    if (tx.version === _constants.ON_CHAIN_BLUEPRINTS_VERSION) {
+      if (!tx.nc_pubkey) {
+        throw new Error(`OnChainBlueprint tx(${tx.tx_id}) with caller pubkey ${tx.nc_pubkey}`);
+      }
+      const callerAddress = (0, _address.getAddressFromPubkey)(tx.nc_pubkey, storage.config.getNetwork());
+      caller = callerAddress.base58;
+    } else {
+      // This is a nano contract
+      if (!tx.nc_address) {
+        throw new Error(`Nano contract tx(${tx.tx_id}) with caller address ${tx.nc_address}`);
+      }
+      caller = tx.nc_address;
+    }
+    const callerAddressInfo = await store.getAddress(caller);
+    // if address is not in wallet, ignore
+    if (callerAddressInfo) {
+      // create metadata for address if it does not exist
+      let addressMeta = await store.getAddressMeta(caller);
+      if (!addressMeta) {
+        addressMeta = {
+          ..._storage.DEFAULT_ADDRESS_META
+        };
+      }
+      if (tx.nc_id) {
+        if (tx.nc_seqnum > addressMeta.seqnum) {
+          addressMeta.seqnum = tx.nc_seqnum;
+        }
+      }
+      await store.editAddressMeta(caller, addressMeta);
+      txAddresses.add(caller);
+    }
+  }
+  for (const token of txTokens) {
+    const tokenMeta = await store.getTokenMeta(token);
+    if (tokenMeta === null) continue;
+    tokenMeta.numTransactions += 1;
+    await store.editTokenMeta(token, tokenMeta);
+  }
+  for (const address of txAddresses) {
+    const addressMeta = await store.getAddressMeta(address);
+    if (addressMeta === null) continue;
+    addressMeta.numTransactions += 1;
+    await store.editAddressMeta(address, addressMeta);
+  }
+  return {
+    maxAddressIndex: maxIndexUsed,
+    tokens: txTokens
+  };
+}
+
+/**
+ * Process locked utxo and update the balances.
+ * If the utxo is still locked nothing is done.
+ *
+ * @param {IStorage} storage Storage instance.
+ * @param {ILockedUtxo} lockedUtxo The utxo to be unlocked
+ * @param {Object} [options]
+ * @param {number} [options.rewardLock] The reward lock of the network
+ * @param {number} [options.nowTs] The current timestamp
+ * @param {number} [options.currentHeight] The current height of the best chain
+ * @returns {Promise<void>}
+ */
+async function processUtxoUnlock(storage, lockedUtxo, {
+  rewardLock,
+  nowTs,
+  currentHeight
+} = {}) {
+  function getEmptyBalance() {
+    return {
+      tokens: {
+        unlocked: 0n,
+        locked: 0n
+      },
+      authorities: {
+        mint: {
+          unlocked: 0n,
+          locked: 0n
+        },
+        melt: {
+          unlocked: 0n,
+          locked: 0n
+        }
+      }
+    };
+  }
+  const {
+    store
+  } = storage;
+  const {
+    tx
+  } = lockedUtxo;
+  const output = tx.outputs[lockedUtxo.index];
+  // Skip data outputs since they do not have an address and do not "belong" in a wallet
+  // This shouldn't happen, but we check it just in case
+  if (!output.decoded.address) return;
+  const isTimelocked = _transaction.default.isOutputLocked(output, {
+    refTs: nowTs
+  });
+  const isHeightLocked = _transaction.default.isHeightLocked(tx.height, currentHeight, rewardLock);
+  if (isTimelocked || isHeightLocked) {
+    // This utxo is still locked, no need to process it
+    return;
+  }
+  const addressInfo = await store.getAddress(output.decoded.address);
+  // if address is not in wallet, ignore
+  if (!addressInfo) return;
+  const isAuthority = _transaction.default.isAuthorityOutput(output);
+  let addressMeta = await store.getAddressMeta(output.decoded.address);
+  let tokenMeta = await store.getTokenMeta(output.token);
+
+  // create metadata for address and token if it does not exist
+  // This should not happen, but we check so that typescript compiler can guarantee the type
+  if (!addressMeta) {
+    addressMeta = {
+      ..._storage.DEFAULT_ADDRESS_META
+    };
+  }
+  if (!tokenMeta) {
+    tokenMeta = {
+      numTransactions: 0,
+      balance: getEmptyBalance()
+    };
+  }
+  if (!addressMeta.balance.has(output.token)) {
+    // Add the current token to the address balance if not present
+    addressMeta.balance.set(output.token, getEmptyBalance());
+  }
+
+  // update balance
+  // The balance for authority outputs is the count of outputs
+  // While the balance for non-authority outputs is the sum of the value.
+  // Since this is processing a locked utxo that became unlocked we will
+  // add the value or count to the unlocked balance and remove it from the locked balance
+  if (isAuthority) {
+    if (_transaction.default.isMint(output)) {
+      // remove from locked balance
+      tokenMeta.balance.authorities.mint.locked -= 1n;
+      addressMeta.balance.get(output.token).authorities.mint.locked -= 1n;
+      // Add to the unlocked balance
+      tokenMeta.balance.authorities.mint.unlocked += 1n;
+      addressMeta.balance.get(output.token).authorities.mint.unlocked += 1n;
+    }
+    if (_transaction.default.isMelt(output)) {
+      // remove from locked balance
+      tokenMeta.balance.authorities.melt.locked -= 1n;
+      addressMeta.balance.get(output.token).authorities.melt.locked -= 1n;
+      // Add to the unlocked balance
+      tokenMeta.balance.authorities.melt.unlocked += 1n;
+      addressMeta.balance.get(output.token).authorities.melt.unlocked += 1n;
+    }
+  } else {
+    // remove from locked balance
+    tokenMeta.balance.tokens.locked -= output.value;
+    addressMeta.balance.get(output.token).tokens.locked -= output.value;
+    // Add to the unlocked balance
+    tokenMeta.balance.tokens.unlocked += output.value;
+    addressMeta.balance.get(output.token).tokens.unlocked += output.value;
+  }
+  await store.editTokenMeta(output.token, tokenMeta);
+  await store.editAddressMeta(output.decoded.address, addressMeta);
+  // Remove utxo from locked utxos so that it is not processed again
+  await store.unlockUtxo(lockedUtxo);
+}
+
+/**
+ * Extracts the ITokenData from the CreateTokenTransaction instance and save
+ * the token on the storage.
+ */
+async function addCreatedTokenFromTx(tx, storage) {
+  if (tx.version !== _constants.CREATE_TOKEN_TX_VERSION) {
+    return;
+  }
+  if (!tx.hash) {
+    throw new Error('Cannot infer UID from transaction without hash');
+  }
+  const tokenInfo = {
+    uid: tx.hash,
+    name: tx.name,
+    symbol: tx.symbol
+  };
+  await storage.addToken(tokenInfo);
+}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/utils/tokens.d.ts b/node_modules/@hathor/wallet-lib/oldLib/utils/tokens.d.ts
new file mode 100644
index 0000000..858efcd
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/utils/tokens.d.ts
@@ -0,0 +1,260 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+import { IDataInput, IDataTx, IStorage, ITokenData, OutputValueType, UtxoSelectionAlgorithm } from '../types';
+declare const tokens: {
+    /**
+     * Validate the configuration string and if we should register the token in it.
+     *
+     * @param {string} config Configuration string to check
+     * @param {IStorage | undefined} storage To check if we have a similarly named token in storage.
+     * @param {string | undefined} uid Check that the configuration string matches this uid.
+     * @returns {Promise<ITokenData>}
+     */
+    validateTokenToAddByConfigurationString(config: string, storage?: IStorage, uid?: string): Promise<ITokenData>;
+    /**
+     * Validate the token data and if we should register the token in it.
+     *
+     * - Check if the token is already registered.
+     * - Check if we have a token in storage with the same name or symbol.
+     * - Check the uid with the fullnode and fail if the name or symbol does not match.
+     *
+     * @param {ITokenData} tokenData Token data to check.
+     * @param {IStorage | undefined} storage to check if we have a similarly named token in storage.
+     * @returns {Promise<void>}
+     */
+    validadateTokenToAddByData(tokenData: ITokenData, storage?: IStorage): Promise<void>;
+    /**
+     * Check if we have a token with the same name or symbol in the storage.
+     *
+     * @param {IStorage} storage to retrieve the registered tokens.
+     * @param {ITokenData} tokenData token we are searching.
+     * @returns {Promise<null | { token: ITokenData, key: string }>}
+     */
+    checkDuplicateTokenInfo(tokenData: ITokenData, storage: IStorage): Promise<null | {
+        token: ITokenData;
+        key: string;
+    }>;
+    /**
+     * Check if string is a valid configuration token string.
+     *
+     * @param {string} config Token configuration string
+     *
+     * @return {Boolean} If config string is valid
+     *
+     * @memberof Tokens
+     * @inner
+     */
+    isConfigurationStringValid(config: string): boolean;
+    /**
+     * Returns token configuration string
+     *
+     * @param {string} uid Token uid
+     * @param {string} name Token name
+     * @param {string} symbol Token symbol
+     *
+     * @return {string} Configuration string of the token
+     *
+     * @memberof Tokens
+     * @inner
+     *
+     */
+    getConfigurationString(uid: string, name: string, symbol: string): string;
+    /**
+     * Returns token from configuration string
+     * Configuration string has the following format:
+     * [name:symbol:uid:checksum]
+     *
+     * @param {string} config Configuration string with token data plus a checksum
+     *
+     * @return {Object} token {'uid', 'name', 'symbol'} or null in case config is invalid
+     *
+     * @memberof Tokens
+     * @inner
+     *
+     */
+    getTokenFromConfigurationString(config: string): ITokenData | null;
+    /**
+     * Gets the token index to be added to the tokenData in the output from tx
+     *
+     * @param {Object} tokensArray Array of token configs
+     * @param {Object} uid Token uid to return the index
+     *
+     * @return {number} Index of token to be set as tokenData in output tx
+     *
+     * @memberof Tokens
+     * @inner
+     */
+    getTokenIndex(tokensArray: ITokenData[], uid: string): number;
+    /**
+     * Get token index from tokenData in output.
+     * 0 is HTR and any other are mapped to the tx tokens array at index = tokenIndex - 1.
+     * @param {number} tokenData Token data from output
+     * @returns {number} Token index
+     */
+    getTokenIndexFromData(tokenData: number): number;
+    /**
+     * Checks if the uid passed is from Hathor token
+     *
+     * @param {string} uid UID to check if is Hathor's
+     *
+     * @return {boolean} true if is Hathor uid, false otherwise
+     *
+     * @memberof Tokens
+     * @inner
+     */
+    isHathorToken(uid: string): boolean;
+    /**
+     * Calculate deposit value for the given token mint amount
+     *
+     * @param {OutputValueType} mintAmount Amount of tokens being minted
+     * @param {number} [depositPercent=TOKEN_DEPOSIT_PERCENTAGE] token deposit percentage.
+     *
+     * @return {number}
+     * @memberof Tokens
+     * @inner
+     *
+     */
+    getDepositAmount(mintAmount: OutputValueType, depositPercent?: number): OutputValueType;
+    /**
+     * Get the HTR value of the fee to add a data script output
+     * @returns {OutputValueType} The fee to have a data script output
+     */
+    getDataScriptOutputFee(): OutputValueType;
+    /**
+     * Calculate withdraw value for the given token melt amount
+     *
+     * @param {OutputValueType} meltAmount Amount of tokens being melted
+     * @param {number} [depositPercent=TOKEN_DEPOSIT_PERCENTAGE] token deposit percentage.
+     *
+     * @return {number}
+     * @memberof Tokens
+     * @inner
+     *
+     */
+    getWithdrawAmount(meltAmount: OutputValueType, depositPercent?: number): OutputValueType;
+    /**
+     * Prepare the transaction data for minting tokens or creating tokens.
+     *
+     * @param address Where to send the minted tokens
+     * @param amount Amount of tokens to mint
+     * @param storage Storage instance of the wallet
+     * @param [options={}] Options to mint tokens
+     * @param {string|null} [options.token=null] Token to mint, may be null if we are creating the token
+     * @param {IDataInput|null} [options.mintInput=null] Input to spend, may be null if we are creating the token
+     * @param {boolean} [options.createAnotherMint=true] If a mint authority should be created on the transaction.
+     * @param {string|null} [options.mintAuthorityAddress=null] The address to send the new mint authority created
+     * @param {string|null} [options.changeAddress=null] The address to send any change output.
+     * @param {boolean|null} [options.unshiftData=null] Whether to unshift the data script output.
+     * @param {string[]|null} [options.data=null] list of data strings using utf8 encoding to add each as a data script output
+     * @param {function} [options.utxoSelection=bestUtxoSelection] Algorithm to select utxos. Use the best method by default
+     * @param {boolean} [options.skipDepositFee=false] if it should skip utxo selection for token deposit fee
+     *
+     * @returns {Promise<IDataTx>} The transaction data
+     */
+    prepareMintTxData(address: string, amount: OutputValueType, storage: IStorage, { token, mintInput, createAnotherMint, changeAddress, unshiftData, data, mintAuthorityAddress, utxoSelection, skipDepositFee, }?: {
+        token?: string | null;
+        mintInput?: IDataInput | null;
+        createAnotherMint?: boolean;
+        changeAddress?: string | null;
+        unshiftData?: boolean | null;
+        data?: string[] | null;
+        mintAuthorityAddress?: string | null;
+        utxoSelection?: UtxoSelectionAlgorithm;
+        skipDepositFee?: boolean;
+    }): Promise<IDataTx>;
+    /**
+     * Generate melt transaction data
+     *
+     * @param {string} token Token to melt
+     * @param {IDataInput} authorityMeltInput Input with authority to melt
+     * @param {string} address Address to send the melted HTR tokens
+     * @param {OutputValueType} amount The amount of tokens to melt
+     * @param {IStorage} storage The storage object
+     * @param {Object} [options={}] Options to create the melt transaction
+     * @param {boolean} [options.createAnotherMelt=true] If should create another melt authority
+     * @param {string | null} [options.meltAuthorityAddress=null] Address to send the new melt authority created
+     * @param {string | null} [options.changeAddress=null] Address to send the change
+     * @param {boolean|null} [options.unshiftData=null] Whether to unshift the data script output.
+     * @param {string[]|null} [options.data=null] list of data strings using utf8 encoding to add each as a data script output
+     * @param {function} [options.utxoSelection=bestUtxoSelection] Algorithm to select utxos. Use the best method by default
+     * @returns {Promise<IDataTx>}
+     */
+    prepareMeltTxData(token: string, authorityMeltInput: IDataInput, address: string, amount: OutputValueType, storage: IStorage, { createAnotherMelt, meltAuthorityAddress, changeAddress, unshiftData, data, utxoSelection, }?: {
+        createAnotherMelt?: boolean;
+        meltAuthorityAddress?: string | null;
+        changeAddress?: string | null;
+        unshiftData?: boolean | null;
+        data?: string[] | null;
+        utxoSelection?: UtxoSelectionAlgorithm;
+    }): Promise<IDataTx>;
+    /**
+     * Prepare transaction data to create a token.
+     *
+     * @param {string} address Address to create the token
+     * @param {string} name Name of the token being created
+     * @param {string} symbol Symbol of the token being created
+     * @param {OutputValueType} mintAmount Amount of tokens to mint
+     * @param {IStorage} storage Storage to get necessary data
+     * @param {Object} [options={}] options to create the token
+     * @param {string|null} [options.changeAddress=null] Address to send the change
+     * @param {boolean} [options.createMint=true] Whether to create a mint output
+     * @param {string} [options.mintAuthorityAddress] the address to send the mint authority created
+     * @param {boolean} [options.createMelt=true] Whether to create a melt output
+     * @param {string} [options.meltAuthorityAddress] the address to send the melt authority created
+     * @param {string[]|null} [options.data=null] list of data strings using utf8 encoding to add each as a data script output
+     * @param {boolean} [options.isCreateNFT=false] if the create token is an NFT creation call
+     * @param {boolean} [options.skipDepositFee=false] if it should skip utxo selection for token deposit fee
+     * @returns {Promise<IDataTx>} The transaction data to create the token
+     */
+    prepareCreateTokenData(address: string, name: string, symbol: string, mintAmount: OutputValueType, storage: IStorage, { changeAddress, createMint, mintAuthorityAddress, createMelt, meltAuthorityAddress, data, isCreateNFT, skipDepositFee, }?: {
+        changeAddress?: string | null;
+        createMint?: boolean;
+        mintAuthorityAddress?: string | null;
+        createMelt?: boolean;
+        meltAuthorityAddress?: string | null;
+        data?: string[] | null;
+        isCreateNFT?: boolean;
+        skipDepositFee?: boolean;
+    }): Promise<IDataTx>;
+    /**
+     * Prepare delegate authority transaction data.
+     *
+     * This method creates the tx data to delegate the authority of `authorityInput` to `address`.
+     * So the we will create an output with the same authorities of the `authorityInput`.
+     * Meaning that we do not yet support creating a mint only authority (authorities=1) from a mint/melt authority (authorities=3).
+     *
+     * @param {string} token Token to delegate authority
+     * @param {IDataInput} authorityInput Utxo to spend
+     * @param {string} address Address to send the authority
+     * @param {IStorage} storage Storage instance of the wallet
+     * @param {boolean} [createAnother=true] If we should create another authority in the current wallet
+     * @returns {Promise<IDataTx>} Transaction data
+     */
+    prepareDelegateAuthorityTxData(token: string, authorityInput: IDataInput, address: string, storage: IStorage, createAnother?: boolean): Promise<IDataTx>;
+    /**
+     * Prepare transaction data to destroy authority utxos
+     *
+     * @param authorityInputs Authority inputs to destroy
+     * @returns {IDataTx} Transaction data
+     */
+    prepareDestroyAuthorityTxData(authorityInputs: IDataInput[]): IDataTx;
+    /**
+     * Get the total HTR to deposit for a mint transaction
+     * including mint deposit and data output fee
+     */
+    getTransactionHTRDeposit(mintAmount: OutputValueType, dataLen: number, storage: IStorage): OutputValueType;
+    /**
+     * Get data output fee for a transaction from the len of data outputs
+     */
+    getDataFee(dataLen: number): OutputValueType;
+    /**
+     * Get the deposit amount for a mint
+     */
+    getMintDeposit(mintAmount: OutputValueType, storage: IStorage): OutputValueType;
+};
+export default tokens;
+//# sourceMappingURL=tokens.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/utils/tokens.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/utils/tokens.d.ts.map
new file mode 100644
index 0000000..23a9928
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/utils/tokens.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"tokens.d.ts","sourceRoot":"","sources":["../../src/utils/tokens.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/utils/tokens.js b/node_modules/@hathor/wallet-lib/oldLib/utils/tokens.js
new file mode 100644
index 0000000..cf856b6
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/utils/tokens.js
@@ -0,0 +1,696 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+var _buffer = _interopRequireDefault(require("buffer"));
+var _constants = require("../constants");
+var _helpers = _interopRequireDefault(require("./helpers"));
+var _address = require("./address");
+var _errors = require("../errors");
+var _utxo = require("./utxo");
+var _wallet = _interopRequireDefault(require("../api/wallet"));
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+function _asyncIterator(r) { var n, t, o, e = 2; for ("undefined" != typeof Symbol && (t = Symbol.asyncIterator, o = Symbol.iterator); e--;) { if (t && null != (n = r[t])) return n.call(r); if (o && null != (n = r[o])) return new AsyncFromSyncIterator(n.call(r)); t = "@@asyncIterator", o = "@@iterator"; } throw new TypeError("Object is not async iterable"); }
+function AsyncFromSyncIterator(r) { function AsyncFromSyncIteratorContinuation(r) { if (Object(r) !== r) return Promise.reject(new TypeError(r + " is not an object.")); var n = r.done; return Promise.resolve(r.value).then(function (r) { return { value: r, done: n }; }); } return AsyncFromSyncIterator = function (r) { this.s = r, this.n = r.next; }, AsyncFromSyncIterator.prototype = { s: null, n: null, next: function () { return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments)); }, return: function (r) { var n = this.s.return; return void 0 === n ? Promise.resolve({ value: r, done: !0 }) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments)); }, throw: function (r) { var n = this.s.return; return void 0 === n ? Promise.reject(r) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments)); } }, new AsyncFromSyncIterator(r); } /**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+const tokens = {
+  /**
+   * Validate the configuration string and if we should register the token in it.
+   *
+   * @param {string} config Configuration string to check
+   * @param {IStorage | undefined} storage To check if we have a similarly named token in storage.
+   * @param {string | undefined} uid Check that the configuration string matches this uid.
+   * @returns {Promise<ITokenData>}
+   */
+  async validateTokenToAddByConfigurationString(config, storage, uid) {
+    const tokenData = this.getTokenFromConfigurationString(config);
+    if (!tokenData) {
+      throw new _errors.TokenValidationError('Invalid configuration string');
+    }
+    if (uid && tokenData.uid !== uid) {
+      throw new _errors.TokenValidationError(`Configuration string uid does not match: ${uid} != ${tokenData.uid}`);
+    }
+    await this.validadateTokenToAddByData(tokenData, storage);
+    return tokenData;
+  },
+  /**
+   * Validate the token data and if we should register the token in it.
+   *
+   * - Check if the token is already registered.
+   * - Check if we have a token in storage with the same name or symbol.
+   * - Check the uid with the fullnode and fail if the name or symbol does not match.
+   *
+   * @param {ITokenData} tokenData Token data to check.
+   * @param {IStorage | undefined} storage to check if we have a similarly named token in storage.
+   * @returns {Promise<void>}
+   */
+  async validadateTokenToAddByData(tokenData, storage) {
+    if (storage) {
+      if (await storage.isTokenRegistered(tokenData.uid)) {
+        throw new _errors.TokenValidationError(`You already have this token: ${tokenData.uid} (${tokenData.name})`);
+      }
+      const isDuplicate = await this.checkDuplicateTokenInfo(tokenData, storage);
+      if (isDuplicate) {
+        throw new _errors.TokenValidationError(`You already have a token with this ${isDuplicate.key}: ${isDuplicate.token.uid} - ${isDuplicate.token.name} (${isDuplicate.token.symbol})`);
+      }
+    }
+
+    // Validate if name and symbol match with the token info in the DAG
+    const response = await new Promise(resolve => {
+      _wallet.default.getGeneralTokenInfo(tokenData.uid, resolve);
+    });
+    if (!response.success) {
+      throw new _errors.TokenValidationError(response.message);
+    }
+    if (response.name !== tokenData.name) {
+      throw new _errors.TokenValidationError(`Token name does not match with the real one. Added: ${tokenData.name}. Real: ${response.name}`);
+    }
+    if (response.symbol !== tokenData.symbol) {
+      throw new _errors.TokenValidationError(`Token symbol does not match with the real one. Added: ${tokenData.symbol}. Real: ${response.symbol}`);
+    }
+  },
+  /**
+   * Check if we have a token with the same name or symbol in the storage.
+   *
+   * @param {IStorage} storage to retrieve the registered tokens.
+   * @param {ITokenData} tokenData token we are searching.
+   * @returns {Promise<null | { token: ITokenData, key: string }>}
+   */
+  async checkDuplicateTokenInfo(tokenData, storage) {
+    const cleanName = _helpers.default.cleanupString(tokenData.name);
+    const cleanSymbol = _helpers.default.cleanupString(tokenData.symbol);
+    var _iteratorAbruptCompletion = false;
+    var _didIteratorError = false;
+    var _iteratorError;
+    try {
+      for (var _iterator = _asyncIterator(storage.getRegisteredTokens()), _step; _iteratorAbruptCompletion = !(_step = await _iterator.next()).done; _iteratorAbruptCompletion = false) {
+        const registeredToken = _step.value;
+        {
+          if (_helpers.default.cleanupString(registeredToken.name) === cleanName) {
+            return {
+              token: registeredToken,
+              key: 'name'
+            };
+          }
+          if (_helpers.default.cleanupString(registeredToken.symbol) === cleanSymbol) {
+            return {
+              token: registeredToken,
+              key: 'symbol'
+            };
+          }
+        }
+      }
+    } catch (err) {
+      _didIteratorError = true;
+      _iteratorError = err;
+    } finally {
+      try {
+        if (_iteratorAbruptCompletion && _iterator.return != null) {
+          await _iterator.return();
+        }
+      } finally {
+        if (_didIteratorError) {
+          throw _iteratorError;
+        }
+      }
+    }
+    return null;
+  },
+  /**
+   * Check if string is a valid configuration token string.
+   *
+   * @param {string} config Token configuration string
+   *
+   * @return {Boolean} If config string is valid
+   *
+   * @memberof Tokens
+   * @inner
+   */
+  isConfigurationStringValid(config) {
+    const tokenData = this.getTokenFromConfigurationString(config);
+    if (tokenData === null) {
+      return false;
+    }
+    return true;
+  },
+  /**
+   * Returns token configuration string
+   *
+   * @param {string} uid Token uid
+   * @param {string} name Token name
+   * @param {string} symbol Token symbol
+   *
+   * @return {string} Configuration string of the token
+   *
+   * @memberof Tokens
+   * @inner
+   *
+   */
+  getConfigurationString(uid, name, symbol) {
+    const partialConfig = `${name}:${symbol}:${uid}`;
+    const checksum = _helpers.default.getChecksum(_buffer.default.Buffer.from(partialConfig));
+    return `[${partialConfig}:${checksum.toString('hex')}]`;
+  },
+  /**
+   * Returns token from configuration string
+   * Configuration string has the following format:
+   * [name:symbol:uid:checksum]
+   *
+   * @param {string} config Configuration string with token data plus a checksum
+   *
+   * @return {Object} token {'uid', 'name', 'symbol'} or null in case config is invalid
+   *
+   * @memberof Tokens
+   * @inner
+   *
+   */
+  getTokenFromConfigurationString(config) {
+    // First we validate that first char is [ and last one is ]
+    if (!config || config[0] !== '[' || config[config.length - 1] !== ']') {
+      return null;
+    }
+    // Then we remove the [] and split the string by :
+    const configArr = config.slice(1, -1).split(':');
+    if (configArr.length < 4) {
+      return null;
+    }
+
+    // Last element is the checksum
+    const checksum = configArr.splice(-1);
+    const configWithoutChecksum = configArr.join(':');
+    const correctChecksum = _helpers.default.getChecksum(_buffer.default.Buffer.from(configWithoutChecksum));
+    if (correctChecksum.toString('hex') !== checksum[0]) {
+      return null;
+    }
+    const uid = configArr.pop();
+    const symbol = configArr.pop();
+    // Assuming that the name might have : on it
+    const name = configArr.join(':');
+    return {
+      uid,
+      name,
+      symbol
+    };
+  },
+  /**
+   * Gets the token index to be added to the tokenData in the output from tx
+   *
+   * @param {Object} tokensArray Array of token configs
+   * @param {Object} uid Token uid to return the index
+   *
+   * @return {number} Index of token to be set as tokenData in output tx
+   *
+   * @memberof Tokens
+   * @inner
+   */
+  getTokenIndex(tokensArray, uid) {
+    // If token is Hathor, index is always 0
+    // Otherwise, it is always the array index + 1
+    if (uid === _constants.NATIVE_TOKEN_UID) {
+      return 0;
+    }
+    const tokensWithoutHathor = tokensArray.filter(token => token.uid !== _constants.NATIVE_TOKEN_UID);
+    const myIndex = tokensWithoutHathor.findIndex(token => token.uid === uid);
+    return myIndex + 1;
+  },
+  /**
+   * Get token index from tokenData in output.
+   * 0 is HTR and any other are mapped to the tx tokens array at index = tokenIndex - 1.
+   * @param {number} tokenData Token data from output
+   * @returns {number} Token index
+   */
+  getTokenIndexFromData(tokenData) {
+    return tokenData & _constants.TOKEN_INDEX_MASK;
+  },
+  /**
+   * Checks if the uid passed is from Hathor token
+   *
+   * @param {string} uid UID to check if is Hathor's
+   *
+   * @return {boolean} true if is Hathor uid, false otherwise
+   *
+   * @memberof Tokens
+   * @inner
+   */
+  isHathorToken(uid) {
+    return uid === _constants.NATIVE_TOKEN_UID;
+  },
+  /**
+   * Calculate deposit value for the given token mint amount
+   *
+   * @param {OutputValueType} mintAmount Amount of tokens being minted
+   * @param {number} [depositPercent=TOKEN_DEPOSIT_PERCENTAGE] token deposit percentage.
+   *
+   * @return {number}
+   * @memberof Tokens
+   * @inner
+   *
+   */
+  getDepositAmount(mintAmount, depositPercent = _constants.TOKEN_DEPOSIT_PERCENTAGE) {
+    // This conversion from mintAmount to Number may cause loss of precision for large amounts,
+    // but this is fully equivalent to the reference Python implementation, which does the same.
+    // It'll never be a problem for mainnet as no values can reach the precision boundary, but
+    // it may happen in custom networks.
+    return BigInt(Math.ceil(depositPercent * Number(mintAmount)));
+  },
+  /**
+   * Get the HTR value of the fee to add a data script output
+   * @returns {OutputValueType} The fee to have a data script output
+   */
+  getDataScriptOutputFee() {
+    return 1n;
+  },
+  /**
+   * Calculate withdraw value for the given token melt amount
+   *
+   * @param {OutputValueType} meltAmount Amount of tokens being melted
+   * @param {number} [depositPercent=TOKEN_DEPOSIT_PERCENTAGE] token deposit percentage.
+   *
+   * @return {number}
+   * @memberof Tokens
+   * @inner
+   *
+   */
+  getWithdrawAmount(meltAmount, depositPercent = _constants.TOKEN_DEPOSIT_PERCENTAGE) {
+    return BigInt(Math.floor(depositPercent * Number(meltAmount)));
+  },
+  /**
+   * Prepare the transaction data for minting tokens or creating tokens.
+   *
+   * @param address Where to send the minted tokens
+   * @param amount Amount of tokens to mint
+   * @param storage Storage instance of the wallet
+   * @param [options={}] Options to mint tokens
+   * @param {string|null} [options.token=null] Token to mint, may be null if we are creating the token
+   * @param {IDataInput|null} [options.mintInput=null] Input to spend, may be null if we are creating the token
+   * @param {boolean} [options.createAnotherMint=true] If a mint authority should be created on the transaction.
+   * @param {string|null} [options.mintAuthorityAddress=null] The address to send the new mint authority created
+   * @param {string|null} [options.changeAddress=null] The address to send any change output.
+   * @param {boolean|null} [options.unshiftData=null] Whether to unshift the data script output.
+   * @param {string[]|null} [options.data=null] list of data strings using utf8 encoding to add each as a data script output
+   * @param {function} [options.utxoSelection=bestUtxoSelection] Algorithm to select utxos. Use the best method by default
+   * @param {boolean} [options.skipDepositFee=false] if it should skip utxo selection for token deposit fee
+   *
+   * @returns {Promise<IDataTx>} The transaction data
+   */
+  async prepareMintTxData(address, amount, storage, {
+    token = null,
+    mintInput = null,
+    createAnotherMint = true,
+    changeAddress = null,
+    unshiftData = null,
+    data = null,
+    mintAuthorityAddress = null,
+    utxoSelection = _utxo.bestUtxoSelection,
+    skipDepositFee = false
+  } = {}) {
+    const inputs = [];
+    const outputs = [];
+    let depositAmount = 0n;
+    // We might have transactions where the nano contract will pay for deposit fees
+    // so we must consider the skipDepositFee flag to skip the utxo selection
+    if (!skipDepositFee) {
+      depositAmount += this.getTransactionHTRDeposit(amount, data?.length ?? 0, storage);
+    }
+    if (depositAmount) {
+      // get HTR deposit inputs
+      const selectedUtxos = await utxoSelection(storage, _constants.NATIVE_TOKEN_UID, depositAmount);
+      const foundAmount = selectedUtxos.amount;
+      for (const utxo of selectedUtxos.utxos) {
+        inputs.push(_helpers.default.getDataInputFromUtxo(utxo));
+      }
+      if (foundAmount < depositAmount) {
+        const availableAmount = selectedUtxos.available ?? 0;
+        throw new _errors.InsufficientFundsError(`Not enough HTR tokens for deposit: ${depositAmount} required, ${availableAmount} available`);
+      }
+
+      // get output change
+      if (foundAmount > depositAmount) {
+        const cAddress = await storage.getChangeAddress({
+          changeAddress
+        });
+        outputs.push({
+          type: (0, _address.getAddressType)(cAddress, storage.config.getNetwork()),
+          address: cAddress,
+          value: foundAmount - depositAmount,
+          timelock: null,
+          token: _constants.NATIVE_TOKEN_UID,
+          authorities: 0n,
+          isChange: true
+        });
+      }
+    }
+    if (mintInput !== null) {
+      // We are spending a mint input to mint more tokens
+      inputs.push(mintInput);
+    }
+
+    // Add output to mint tokens
+    outputs.push({
+      type: 'mint',
+      address,
+      value: amount,
+      timelock: null,
+      authorities: 0n
+    });
+    if (createAnotherMint) {
+      const newAddress = mintAuthorityAddress || (await storage.getCurrentAddress());
+      outputs.push({
+        type: 'mint',
+        address: newAddress,
+        value: _constants.TOKEN_MINT_MASK,
+        timelock: null,
+        authorities: 1n
+      });
+    }
+    if (data !== null) {
+      for (const dataString of data) {
+        const outputData = {
+          type: 'data',
+          data: dataString,
+          value: 1n,
+          token: _constants.NATIVE_TOKEN_UID,
+          authorities: 0n
+        };
+
+        // We currently have an external service that identifies NFT tokens with the first output as the data output
+        // that's why we are keeping like this
+        // However, this will change after a new project is completed to better identify an NFT token
+        // the method that validates the NFT is in src/models/CreateTokenTransaction.validateNft
+        if (unshiftData) {
+          outputs.unshift(outputData);
+        } else {
+          outputs.push(outputData);
+        }
+      }
+    }
+    const tokensArray = token !== null ? [token] : [];
+    return {
+      inputs,
+      outputs,
+      tokens: tokensArray
+    };
+  },
+  /**
+   * Generate melt transaction data
+   *
+   * @param {string} token Token to melt
+   * @param {IDataInput} authorityMeltInput Input with authority to melt
+   * @param {string} address Address to send the melted HTR tokens
+   * @param {OutputValueType} amount The amount of tokens to melt
+   * @param {IStorage} storage The storage object
+   * @param {Object} [options={}] Options to create the melt transaction
+   * @param {boolean} [options.createAnotherMelt=true] If should create another melt authority
+   * @param {string | null} [options.meltAuthorityAddress=null] Address to send the new melt authority created
+   * @param {string | null} [options.changeAddress=null] Address to send the change
+   * @param {boolean|null} [options.unshiftData=null] Whether to unshift the data script output.
+   * @param {string[]|null} [options.data=null] list of data strings using utf8 encoding to add each as a data script output
+   * @param {function} [options.utxoSelection=bestUtxoSelection] Algorithm to select utxos. Use the best method by default
+   * @returns {Promise<IDataTx>}
+   */
+  async prepareMeltTxData(token, authorityMeltInput,
+  // Authority melt
+  address, amount, storage, {
+    createAnotherMelt = true,
+    meltAuthorityAddress = null,
+    changeAddress = null,
+    unshiftData = null,
+    data = null,
+    utxoSelection = _utxo.bestUtxoSelection
+  } = {}) {
+    if (authorityMeltInput.token !== token || authorityMeltInput.authorities !== 2n) {
+      throw new Error('Melt authority input is not valid');
+    }
+    const inputs = [authorityMeltInput];
+    const outputs = [];
+    const tokensArray = [authorityMeltInput.token];
+    const depositPercent = storage.getTokenDepositPercentage();
+    let withdrawAmount = this.getWithdrawAmount(amount, depositPercent);
+    // The deposit amount will be the quantity of data strings in the array
+    // multiplied by the fee or 0 if there are no data outputs
+    let depositAmount = data !== null ? this.getDataScriptOutputFee() * BigInt(data.length) : 0n;
+
+    // We only make these calculations if we are creating data outputs because the transaction needs to deposit the fee
+    if (depositAmount > 0) {
+      // If we are creating data outputs the withdrawal amount may be used to create the data outputs
+      // This may prevent finding HTR inputs to meet the deposit amount if we are creating HTR with the melt.
+      if (withdrawAmount >= depositAmount) {
+        // We can use part of the withdraw tokens as deposit
+        withdrawAmount -= depositAmount;
+        depositAmount = 0n;
+      } else {
+        // Deposit is greater than withdraw, we will use all withdrawn tokens and still need to find utxos to meet deposit
+        depositAmount -= withdrawAmount;
+        withdrawAmount = 0n;
+      }
+    }
+
+    // get inputs that amount to requested melt amount
+    const selectedUtxos = await utxoSelection(storage, token, amount);
+    const foundAmount = selectedUtxos.amount;
+    for (const utxo of selectedUtxos.utxos) {
+      inputs.push(_helpers.default.getDataInputFromUtxo(utxo));
+    }
+    if (foundAmount < amount) {
+      const availableAmount = selectedUtxos.available ?? 0;
+      throw new _errors.InsufficientFundsError(`Not enough tokens to melt: ${amount} requested, ${availableAmount} available`);
+    }
+
+    // get output change
+    if (foundAmount > amount) {
+      const cAddress = await storage.getChangeAddress({
+        changeAddress
+      });
+      outputs.push({
+        type: (0, _address.getAddressType)(cAddress, storage.config.getNetwork()),
+        address: cAddress,
+        value: foundAmount - amount,
+        timelock: null,
+        token,
+        authorities: 0n,
+        isChange: true
+      });
+    }
+    if (depositAmount > 0) {
+      // get HTR deposit inputs
+      const depositSelectedUtxos = await utxoSelection(storage, _constants.NATIVE_TOKEN_UID, depositAmount);
+      const depositFoundAmount = depositSelectedUtxos.amount;
+      for (const utxo of depositSelectedUtxos.utxos) {
+        inputs.push(_helpers.default.getDataInputFromUtxo(utxo));
+      }
+      if (depositFoundAmount < depositAmount) {
+        throw new _errors.InsufficientFundsError(`Not enough HTR tokens for deposit: ${depositAmount} required, ${depositFoundAmount} available`);
+      }
+
+      // get output change
+      if (depositFoundAmount > depositAmount) {
+        const cAddress = await storage.getChangeAddress({
+          changeAddress
+        });
+        outputs.push({
+          type: (0, _address.getAddressType)(cAddress, storage.config.getNetwork()),
+          address: cAddress,
+          value: depositFoundAmount - depositAmount,
+          timelock: null,
+          token: _constants.NATIVE_TOKEN_UID,
+          authorities: 0n,
+          isChange: true
+        });
+      }
+    }
+    if (createAnotherMelt) {
+      const newAddress = meltAuthorityAddress || (await storage.getCurrentAddress());
+      outputs.push({
+        type: (0, _address.getAddressType)(newAddress, storage.config.getNetwork()),
+        address: newAddress,
+        token,
+        authorities: 2n,
+        value: _constants.TOKEN_MELT_MASK,
+        timelock: null
+      });
+    }
+
+    // When melting an amount smaller than 100 (1.00), the withdraw value will be 0, then we don't need to add output for that
+    if (withdrawAmount > 0) {
+      outputs.push({
+        value: withdrawAmount,
+        address,
+        token: _constants.NATIVE_TOKEN_UID,
+        authorities: 0n,
+        timelock: null,
+        type: (0, _address.getAddressType)(address, storage.config.getNetwork())
+      });
+    }
+    if (data !== null) {
+      for (const dataString of data) {
+        const outputData = {
+          type: 'data',
+          data: dataString,
+          value: 1n,
+          token: _constants.NATIVE_TOKEN_UID,
+          authorities: 0n
+        };
+        if (unshiftData) {
+          outputs.unshift(outputData);
+        } else {
+          outputs.push(outputData);
+        }
+      }
+    }
+    return {
+      inputs,
+      outputs,
+      tokens: tokensArray
+    };
+  },
+  /**
+   * Prepare transaction data to create a token.
+   *
+   * @param {string} address Address to create the token
+   * @param {string} name Name of the token being created
+   * @param {string} symbol Symbol of the token being created
+   * @param {OutputValueType} mintAmount Amount of tokens to mint
+   * @param {IStorage} storage Storage to get necessary data
+   * @param {Object} [options={}] options to create the token
+   * @param {string|null} [options.changeAddress=null] Address to send the change
+   * @param {boolean} [options.createMint=true] Whether to create a mint output
+   * @param {string} [options.mintAuthorityAddress] the address to send the mint authority created
+   * @param {boolean} [options.createMelt=true] Whether to create a melt output
+   * @param {string} [options.meltAuthorityAddress] the address to send the melt authority created
+   * @param {string[]|null} [options.data=null] list of data strings using utf8 encoding to add each as a data script output
+   * @param {boolean} [options.isCreateNFT=false] if the create token is an NFT creation call
+   * @param {boolean} [options.skipDepositFee=false] if it should skip utxo selection for token deposit fee
+   * @returns {Promise<IDataTx>} The transaction data to create the token
+   */
+  async prepareCreateTokenData(address, name, symbol, mintAmount, storage, {
+    changeAddress = null,
+    createMint = true,
+    mintAuthorityAddress = null,
+    createMelt = true,
+    meltAuthorityAddress = null,
+    data = null,
+    isCreateNFT = false,
+    skipDepositFee = false
+  } = {}) {
+    const mintOptions = {
+      createAnotherMint: createMint,
+      mintAuthorityAddress,
+      changeAddress,
+      unshiftData: isCreateNFT,
+      data,
+      skipDepositFee
+    };
+    const txData = await this.prepareMintTxData(address, mintAmount, storage, mintOptions);
+    if (createMelt) {
+      const newAddress = meltAuthorityAddress || (await storage.getCurrentAddress());
+      const meltAuthorityOutput = {
+        type: 'melt',
+        address: newAddress,
+        value: _constants.TOKEN_MELT_MASK,
+        timelock: null,
+        authorities: 2n
+      };
+      if (data !== null && data.length !== 0 && !isCreateNFT) {
+        txData.outputs.splice(-data.length, 0, meltAuthorityOutput);
+      } else {
+        txData.outputs.push(meltAuthorityOutput);
+      }
+    }
+
+    // Set create token tx version value
+    txData.version = _constants.CREATE_TOKEN_TX_VERSION;
+    txData.name = name;
+    txData.symbol = symbol;
+    return txData;
+  },
+  /**
+   * Prepare delegate authority transaction data.
+   *
+   * This method creates the tx data to delegate the authority of `authorityInput` to `address`.
+   * So the we will create an output with the same authorities of the `authorityInput`.
+   * Meaning that we do not yet support creating a mint only authority (authorities=1) from a mint/melt authority (authorities=3).
+   *
+   * @param {string} token Token to delegate authority
+   * @param {IDataInput} authorityInput Utxo to spend
+   * @param {string} address Address to send the authority
+   * @param {IStorage} storage Storage instance of the wallet
+   * @param {boolean} [createAnother=true] If we should create another authority in the current wallet
+   * @returns {Promise<IDataTx>} Transaction data
+   */
+  async prepareDelegateAuthorityTxData(token, authorityInput,
+  // Authority input
+  address, storage, createAnother = true) {
+    const outputs = [{
+      type: (0, _address.getAddressType)(address, storage.config.getNetwork()),
+      address,
+      token,
+      authorities: authorityInput.authorities,
+      value: authorityInput.value,
+      timelock: null
+    }];
+    if (createAnother) {
+      const newAddress = await storage.getCurrentAddress();
+      outputs.push({
+        type: (0, _address.getAddressType)(newAddress, storage.config.getNetwork()),
+        address: newAddress,
+        token,
+        authorities: authorityInput.authorities,
+        value: authorityInput.value,
+        timelock: null
+      });
+    }
+    return {
+      outputs,
+      inputs: [authorityInput],
+      tokens: [token]
+    };
+  },
+  /**
+   * Prepare transaction data to destroy authority utxos
+   *
+   * @param authorityInputs Authority inputs to destroy
+   * @returns {IDataTx} Transaction data
+   */
+  prepareDestroyAuthorityTxData(authorityInputs) {
+    return {
+      inputs: authorityInputs,
+      outputs: [],
+      tokens: []
+    };
+  },
+  /**
+   * Get the total HTR to deposit for a mint transaction
+   * including mint deposit and data output fee
+   */
+  getTransactionHTRDeposit(mintAmount, dataLen, storage) {
+    let mintDeposit = this.getMintDeposit(mintAmount, storage);
+    mintDeposit += this.getDataFee(dataLen);
+    return mintDeposit;
+  },
+  /**
+   * Get data output fee for a transaction from the len of data outputs
+   */
+  getDataFee(dataLen) {
+    let fee = 0n;
+    if (dataLen > 0) {
+      // The deposit amount will be the quantity of data strings in the array
+      // multiplied by the fee
+      fee += this.getDataScriptOutputFee() * BigInt(dataLen);
+    }
+    return fee;
+  },
+  /**
+   * Get the deposit amount for a mint
+   */
+  getMintDeposit(mintAmount, storage) {
+    const depositPercent = storage.getTokenDepositPercentage();
+    return this.getDepositAmount(mintAmount, depositPercent);
+  }
+};
+var _default = exports.default = tokens;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/utils/transaction.d.ts b/node_modules/@hathor/wallet-lib/oldLib/utils/transaction.d.ts
new file mode 100644
index 0000000..68f56fd
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/utils/transaction.d.ts
@@ -0,0 +1,257 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/// <reference types="node" />
+import { z } from 'zod';
+import { Utxo } from '../wallet/types';
+import { HistoryTransactionOutput } from '../models/types';
+import Transaction from '../models/transaction';
+import CreateTokenTransaction from '../models/create_token_transaction';
+import Network from '../models/network';
+import { IBalance, IStorage, IHistoryTx, IDataOutput, IDataTx, IHistoryOutput, IUtxoId, ITxSignatureData, OutputValueType } from '../types';
+import Address from '../models/address';
+import { transactionApiSchema } from '../api/schemas/txApi';
+import OnChainBlueprint from '../nano_contracts/on_chain_blueprint';
+declare const transaction: {
+    /**
+     * Return if a tx is a block or not.
+     *
+     * @param {Pick<IHistoryTx, 'version'>} tx - Transaction to check
+     * @returns {boolean}
+     */
+    isBlock(tx: Pick<IHistoryTx, 'version'>): boolean;
+    /**
+     * Check if the output is an authority output
+     *
+     * @param {Pick<HistoryTransactionOutput, 'token_data'>} output An output with the token_data field
+     * @returns {boolean} If the output is an authority output
+     */
+    isAuthorityOutput(output: Pick<HistoryTransactionOutput, 'token_data'>): boolean;
+    /**
+     * Check if the output is a mint authority output
+     *
+     * @param {Pick<HistoryTransactionOutput, 'token_data'|'value'>} output An output with the token_data and value fields
+     * @returns {boolean} If the output is a mint authority output
+     */
+    isMint(output: Pick<HistoryTransactionOutput, 'token_data' | 'value'>): boolean;
+    /**
+     * Check if the output is a melt authority output
+     *
+     * @param {Pick<HistoryTransactionOutput, 'token_data'|'value'>} output An output with the token_data and value fields
+     * @returns {boolean} If the output is a melt authority output
+     */
+    isMelt(output: Pick<HistoryTransactionOutput, 'token_data' | 'value'>): boolean;
+    /**
+     * Check if the utxo is locked
+     *
+     * @param {Pick<HistoryTransactionOutput, 'decoded'>} output The output to check
+     * @param {{refTs: number|undefined}} options Use these values as reference to check if the output is locked
+     * @returns {boolean} Wheather the output is locked or not
+     */
+    isOutputLocked(output: Pick<HistoryTransactionOutput, 'decoded'>, options?: {
+        refTs?: number;
+    }): boolean;
+    /**
+     * Check if an output in the given conditions would be height locked (or under reward lock)
+     *
+     * @param {number|undefined|null} blockHeight The height of the block
+     * @param {number|undefined|null} currentHeight The height of the network
+     * @param {number|undefined|null} rewardLock The reward lock of the network
+     *
+     * @returns {boolean} If the output is heightlocked
+     */
+    isHeightLocked(blockHeight: number | undefined | null, currentHeight: number | undefined | null, rewardLock: number | undefined | null): boolean;
+    /**
+     * Get the signature from the dataToSignHash for a private key
+     *
+     * @param {Buffer} dataToSignHash hash of a transaction's dataToSign.
+     * @param {PrivateKey} privateKey Signing key.
+     *
+     * @returns {Buffer}
+     *
+     * @memberof transaction
+     * @inner
+     */
+    getSignature(dataToSignHash: Buffer, privateKey: PrivateKey): Buffer;
+    /**
+     * Get the signatures for a transaction
+     * @param tx Transaction to sign
+     * @param storage Storage of the wallet
+     * @param pinCode Pin to unlock the mainKey for signatures
+     */
+    getSignatureForTx(tx: Transaction, storage: IStorage, pinCode: string): Promise<ITxSignatureData>;
+    /**
+     * Gets the pubkey of the nano header from a tx.
+     *
+     * Returns null if it's not a nano tx.
+     *
+     * @param tx - The transaction to try to get the nano pubkey from
+     */
+    getNanoContractCaller(tx: Transaction): Address | null;
+    /**
+     * Signs a transaction using the provided storage and pin code.
+     *
+     * Warning: This function will mutate the transaction parameter
+     *
+     * @param tx - The transaction to be signed.
+     * @param storage - The storage of the target wallet.
+     * @param pinCode - The pin code used for retrieving signatures.
+     * @returns The transaction object updated with the signatures.
+     */
+    signTransaction(tx: Transaction, storage: IStorage, pinCode: string): Promise<Transaction>;
+    /**
+     * Select best utxos with the algorithm described below. This method expects the utxos to be sorted by greatest value
+     *
+     * 1. If we have a single utxo capable of handle the full amount requested,
+     * we return the utxo with smaller amount among the ones that have an amount bigger than the requested
+     * 2. Otherwise we reverse sort the utxos by amount and select the utxos in order until the full amount is fulfilled.
+     *
+     * @memberof transaction
+     * @inner
+     */
+    selectUtxos(utxos: Utxo[], totalAmount: OutputValueType): {
+        utxos: Utxo[];
+        changeAmount: OutputValueType;
+    };
+    /**
+     * Convert an output from the history of transactions to an Utxo.
+     *
+     * @param {string} txId The transaction this output belongs to.
+     * @param {number} index The output index on the original transaction.
+     * @param {HistoryTransactionOutput} txout output from the transaction history.
+     * @param {Object} [options]
+     * @param {string} [options.addressPath=''] utxo address bip32 path
+     *
+     * @returns {Utxo}
+     *
+     * @memberof transaction
+     */
+    utxoFromHistoryOutput(txId: string, index: number, txout: HistoryTransactionOutput, { addressPath }: {
+        addressPath?: string;
+    }): Utxo;
+    /**
+     * Calculate the balance of a transaction
+     *
+     * @param tx Transaction to get balance from
+     * @param storage Storage to get metadata from
+     * @returns {Promise<Record<string, IBalance>>} Balance of the transaction
+     */
+    getTxBalance(tx: IHistoryTx, storage: IStorage): Promise<Record<string, IBalance>>;
+    /**
+     * Calculate the token balance of a transaction, including authorities, for a single token.
+     * The balance will contain funds, mint and melt properties.
+     * The funds property will contain the amount of tokens.
+     * The mint and melt properties will contain the amount of mint and melt authorities.
+     *
+     * We will consider the balance from the inputs as negative and the outputs as positive
+     * So that if the balance if positive we have a surplus of the token in the outputs.
+     * If the balance is negative we have a deficit of the token in the outputs.
+     *
+     * Normal txs can be "unbalanced" when minting or melting tokens, but since we are not required to add the minted tokens on the inputs
+     * Or conversely add the melted tokens on the outputs, we will ignore minted/melted funds.
+     *
+     * @param {string} token The token we want to calculate the balance.
+     * @param {IDataTx} tx The transaction we want to calculate the balance.
+     * @returns {Promise<Record<'funds'|'mint'|'melt', number>>} The balance of the given token on the transaction.
+     */
+    calculateTxBalanceToFillTx(token: string, tx: IDataTx): Promise<Record<'funds' | 'mint' | 'melt', OutputValueType>>;
+    /**
+     * Get the token_data for a given output
+     *
+     * @param {IDataOutput} output output data
+     * @param {string[]} tokens List of tokens in the transaction
+     * @returns {number} Calculated TokenData for the output token
+     */
+    getTokenDataFromOutput(output: IDataOutput, tokens: string[]): number;
+    /**
+     * Create output script
+     *
+     * @param {IDataOutput} output Output with data to create the script
+     *
+     * @throws {AddressError} If the address is invalid
+     *
+     * @return {Buffer} Output script
+     */
+    createOutputScript(output: IDataOutput, network: Network): Buffer;
+    /**
+     * Create a Transaction instance from tx data.
+     *
+     * @param {IDataTx} txData Tx data to create the transaction
+     * @param {Network} network network to use
+     * @returns {Transaction|CreateTokenTransaction}
+     */
+    createTransactionFromData(txData: IDataTx, network: Network): Transaction | CreateTokenTransaction;
+    /**
+     * Convert a Transaction instance to the history object.
+     * May call the fullnode transaction api to get information on the tx spent
+     * by the inputs.
+     */
+    convertTransactionToHistoryTx(tx: Transaction | CreateTokenTransaction | OnChainBlueprint, storage: IStorage): Promise<IHistoryTx>;
+    /**
+     * Prepare a Transaction instance from the transaction data and storage
+     *
+     * @param tx tx data to be prepared
+     * @param pinCode pin to unlock the mainKey for signatures
+     * @param storage Storage to get the mainKey
+     * @param {Object} [options]
+     * @param {boolean} [options.signTx=true] sign transaction instance
+     * @returns {Promise<Transaction|CreateTokenTransaction>} Prepared transaction
+     */
+    prepareTransaction(txData: IDataTx, pinCode: string, storage: IStorage, options?: {
+        signTx?: boolean;
+    }): Promise<Transaction | CreateTokenTransaction>;
+    /**
+     * Create P2PKH input data
+     *
+     * @param {Buffer} signature Input signature
+     * @param {Buffer} publicKey Input public key
+     * @returns {Buffer} Input data
+     */
+    createInputData(signature: Buffer, publicKey: Buffer): Buffer;
+    /**
+     * Calculate the authorities data for an output
+     *
+     * @param output History output
+     * @returns {OutputValueType} Authorities from output
+     */
+    authoritiesFromOutput(output: Pick<IHistoryOutput, 'token_data' | 'value'>): OutputValueType;
+    /**
+     * Check if an utxo is available to be spent.
+     *
+     * @param {IUtxoId} utxo Utxo to check if we can use it
+     * @param {IStorage} storage storage that may have the tx
+     * @returns {Promise<boolean>}
+     */
+    canUseUtxo(utxo: IUtxoId, storage: IStorage): Promise<boolean>;
+    /**
+     * Get object type (Transaction or Block)
+     *
+     * @param {Pick<IHistoryTx, 'version'>} tx Object to get the type
+     *
+     * @return {string} Type of the object
+     *
+     * @memberof transaction
+     * @inner
+     */
+    getTxType(tx: Pick<IHistoryTx, 'version'>): string;
+    /**
+     * From a `token_data` and the tokens array we can add the token uid to the input/output.
+     */
+    hydrateIOWithToken<IO extends {
+        token_data: number;
+    }, T extends {
+        uid: string;
+    }>(io: IO, tokens: T[]): IO & {
+        token: string;
+    };
+    /**
+     * Convert the transaction type from the tx api to the IHistoryTx which is
+     * the interface of transactions received via websocket.
+     */
+    convertFullNodeTxToHistoryTx(txResponse: z.infer<typeof transactionApiSchema>): IHistoryTx;
+};
+export default transaction;
+//# sourceMappingURL=transaction.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/utils/transaction.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/utils/transaction.d.ts.map
new file mode 100644
index 0000000..9c53200
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/utils/transaction.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"transaction.d.ts","sourceRoot":"","sources":["../../src/utils/transaction.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/utils/transaction.js b/node_modules/@hathor/wallet-lib/oldLib/utils/transaction.js
new file mode 100644
index 0000000..84eb76a
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/utils/transaction.js
@@ -0,0 +1,876 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+var _bitcoreLib = require("bitcore-lib");
+var _lodash = require("lodash");
+var _errors = require("../errors");
+var _constants = require("../constants");
+var _transaction = _interopRequireDefault(require("../models/transaction"));
+var _create_token_transaction = _interopRequireDefault(require("../models/create_token_transaction"));
+var _input = _interopRequireDefault(require("../models/input"));
+var _output = _interopRequireDefault(require("../models/output"));
+var _types = require("../types");
+var _address = _interopRequireDefault(require("../models/address"));
+var _p2pkh = _interopRequireDefault(require("../models/p2pkh"));
+var _p2sh = _interopRequireDefault(require("../models/p2sh"));
+var _script_data = _interopRequireDefault(require("../models/script_data"));
+var _helpers = _interopRequireDefault(require("./helpers"));
+var _address2 = require("./address");
+var _txApi = _interopRequireDefault(require("../api/txApi"));
+var _tokens = _interopRequireDefault(require("./tokens"));
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+function _asyncIterator(r) { var n, t, o, e = 2; for ("undefined" != typeof Symbol && (t = Symbol.asyncIterator, o = Symbol.iterator); e--;) { if (t && null != (n = r[t])) return n.call(r); if (o && null != (n = r[o])) return new AsyncFromSyncIterator(n.call(r)); t = "@@asyncIterator", o = "@@iterator"; } throw new TypeError("Object is not async iterable"); }
+function AsyncFromSyncIterator(r) { function AsyncFromSyncIteratorContinuation(r) { if (Object(r) !== r) return Promise.reject(new TypeError(r + " is not an object.")); var n = r.done; return Promise.resolve(r.value).then(function (r) { return { value: r, done: n }; }); } return AsyncFromSyncIterator = function (r) { this.s = r, this.n = r.next; }, AsyncFromSyncIterator.prototype = { s: null, n: null, next: function () { return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments)); }, return: function (r) { var n = this.s.return; return void 0 === n ? Promise.resolve({ value: r, done: !0 }) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments)); }, throw: function (r) { var n = this.s.return; return void 0 === n ? Promise.reject(r) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments)); } }, new AsyncFromSyncIterator(r); } /**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+const transaction = {
+  /**
+   * Return if a tx is a block or not.
+   *
+   * @param {Pick<IHistoryTx, 'version'>} tx - Transaction to check
+   * @returns {boolean}
+   */
+  isBlock(tx) {
+    return tx.version === _constants.BLOCK_VERSION || tx.version === _constants.MERGED_MINED_BLOCK_VERSION || tx.version === _constants.POA_BLOCK_VERSION;
+  },
+  /**
+   * Check if the output is an authority output
+   *
+   * @param {Pick<HistoryTransactionOutput, 'token_data'>} output An output with the token_data field
+   * @returns {boolean} If the output is an authority output
+   */
+  isAuthorityOutput(output) {
+    return (output.token_data & _constants.TOKEN_AUTHORITY_MASK) > 0;
+  },
+  /**
+   * Check if the output is a mint authority output
+   *
+   * @param {Pick<HistoryTransactionOutput, 'token_data'|'value'>} output An output with the token_data and value fields
+   * @returns {boolean} If the output is a mint authority output
+   */
+  isMint(output) {
+    return this.isAuthorityOutput(output) && (output.value & _constants.TOKEN_MINT_MASK) > 0;
+  },
+  /**
+   * Check if the output is a melt authority output
+   *
+   * @param {Pick<HistoryTransactionOutput, 'token_data'|'value'>} output An output with the token_data and value fields
+   * @returns {boolean} If the output is a melt authority output
+   */
+  isMelt(output) {
+    return this.isAuthorityOutput(output) && (output.value & _constants.TOKEN_MELT_MASK) > 0;
+  },
+  /**
+   * Check if the utxo is locked
+   *
+   * @param {Pick<HistoryTransactionOutput, 'decoded'>} output The output to check
+   * @param {{refTs: number|undefined}} options Use these values as reference to check if the output is locked
+   * @returns {boolean} Wheather the output is locked or not
+   */
+  isOutputLocked(output, options = {}) {
+    // XXX: check reward lock: requires blockHeight, bestBlockHeight and reward_spend_min_blocks
+    const refTs = options.refTs || Math.floor(Date.now() / 1000);
+    return output.decoded.timelock !== undefined && output.decoded.timelock !== null && refTs < output.decoded.timelock;
+  },
+  /**
+   * Check if an output in the given conditions would be height locked (or under reward lock)
+   *
+   * @param {number|undefined|null} blockHeight The height of the block
+   * @param {number|undefined|null} currentHeight The height of the network
+   * @param {number|undefined|null} rewardLock The reward lock of the network
+   *
+   * @returns {boolean} If the output is heightlocked
+   */
+  isHeightLocked(blockHeight, currentHeight, rewardLock) {
+    if (!(blockHeight && currentHeight && rewardLock)) {
+      // We do not have the details needed to consider this as locked
+      return false;
+    }
+
+    // Heighlocked when current height is lower than block height + reward_spend_min_blocks of the network
+    return currentHeight < blockHeight + rewardLock;
+  },
+  /**
+   * Get the signature from the dataToSignHash for a private key
+   *
+   * @param {Buffer} dataToSignHash hash of a transaction's dataToSign.
+   * @param {PrivateKey} privateKey Signing key.
+   *
+   * @returns {Buffer}
+   *
+   * @memberof transaction
+   * @inner
+   */
+  getSignature(dataToSignHash, privateKey) {
+    const signature = _bitcoreLib.crypto.ECDSA.sign(dataToSignHash, privateKey).set({
+      nhashtype: _bitcoreLib.crypto.Signature.SIGHASH_ALL
+    });
+    return signature.toDER();
+  },
+  /**
+   * Get the signatures for a transaction
+   * @param tx Transaction to sign
+   * @param storage Storage of the wallet
+   * @param pinCode Pin to unlock the mainKey for signatures
+   */
+  async getSignatureForTx(tx, storage, pinCode) {
+    const xprivstr = await storage.getMainXPrivKey(pinCode);
+    const xprivkey = _bitcoreLib.HDPrivateKey.fromString(xprivstr);
+    const dataToSignHash = tx.getDataToSignHash();
+    const signatures = [];
+    let ncCallerSignature = null;
+    var _iteratorAbruptCompletion = false;
+    var _didIteratorError = false;
+    var _iteratorError;
+    try {
+      for (var _iterator = _asyncIterator(storage.getSpentTxs(tx.inputs)), _step; _iteratorAbruptCompletion = !(_step = await _iterator.next()).done; _iteratorAbruptCompletion = false) {
+        const {
+          tx: spentTx,
+          input,
+          index: inputIndex
+        } = _step.value;
+        {
+          if (input.data) {
+            // This input is already signed
+            continue;
+          }
+          const spentOut = spentTx.outputs[input.index];
+          if (!spentOut.decoded.address) {
+            // This is not a wallet output
+            continue;
+          }
+          const addressInfo = await storage.getAddressInfo(spentOut.decoded.address);
+          if (!addressInfo) {
+            // Not a wallet address
+            continue;
+          }
+          const xpriv = xprivkey.deriveNonCompliantChild(addressInfo.bip32AddressIndex);
+          signatures.push({
+            inputIndex,
+            addressIndex: addressInfo.bip32AddressIndex,
+            signature: this.getSignature(dataToSignHash, xpriv.privateKey),
+            pubkey: xpriv.publicKey.toDER()
+          });
+        }
+      }
+    } catch (err) {
+      _didIteratorError = true;
+      _iteratorError = err;
+    } finally {
+      try {
+        if (_iteratorAbruptCompletion && _iterator.return != null) {
+          await _iterator.return();
+        }
+      } finally {
+        if (_didIteratorError) {
+          throw _iteratorError;
+        }
+      }
+    }
+    let address = null;
+    if (tx.isNanoContract()) {
+      address = this.getNanoContractCaller(tx);
+    }
+    if (tx.version === _constants.ON_CHAIN_BLUEPRINTS_VERSION) {
+      // Get pubkey from ocb tx
+      const {
+        pubkey
+      } = tx;
+      address = (0, _address2.getAddressFromPubkey)(pubkey.toString('hex'), storage.config.getNetwork());
+    }
+    if (address) {
+      const addressInfo = await storage.getAddressInfo(address.base58);
+      if (!addressInfo) {
+        // The nano contract address or OCB pubkey are not from our wallet.
+        return {
+          inputSignatures: signatures,
+          ncCallerSignature
+        };
+      }
+      const xpriv = xprivkey.deriveNonCompliantChild(addressInfo.bip32AddressIndex);
+      if (tx.isNanoContract()) {
+        // Nano contract
+        const signature = this.getSignature(dataToSignHash, xpriv.privateKey);
+        ncCallerSignature = this.createInputData(signature, xpriv.publicKey.toDER());
+      } else {
+        // On-chain blueprint
+        ncCallerSignature = this.getSignature(dataToSignHash, xpriv.privateKey);
+      }
+    }
+    return {
+      inputSignatures: signatures,
+      ncCallerSignature
+    };
+  },
+  /**
+   * Gets the pubkey of the nano header from a tx.
+   *
+   * Returns null if it's not a nano tx.
+   *
+   * @param tx - The transaction to try to get the nano pubkey from
+   */
+  getNanoContractCaller(tx) {
+    if (tx.isNanoContract()) {
+      // Get pubkey from nano header
+      const nanoHeader = tx.getNanoHeaders()[0];
+      // XXX this code won't work if we have more than one
+      // nano header for the same tx in the future
+      return nanoHeader.address;
+    }
+    return null;
+  },
+  /**
+   * Signs a transaction using the provided storage and pin code.
+   *
+   * Warning: This function will mutate the transaction parameter
+   *
+   * @param tx - The transaction to be signed.
+   * @param storage - The storage of the target wallet.
+   * @param pinCode - The pin code used for retrieving signatures.
+   * @returns The transaction object updated with the signatures.
+   */
+  async signTransaction(tx, storage, pinCode) {
+    const signatures = await storage.getTxSignatures(tx, pinCode);
+    for (const sigData of signatures.inputSignatures) {
+      const input = tx.inputs[sigData.inputIndex];
+      const inputData = this.createInputData(sigData.signature, sigData.pubkey);
+      input.setData(inputData);
+    }
+    if (tx.isNanoContract()) {
+      // Store signature in nano header
+      const nanoHeaders = tx.getNanoHeaders();
+      for (const nanoHeader of nanoHeaders) {
+        nanoHeader.script = signatures.ncCallerSignature;
+      }
+    }
+    if (tx.version === _constants.ON_CHAIN_BLUEPRINTS_VERSION) {
+      // eslint-disable-next-line no-param-reassign
+      tx.signature = signatures.ncCallerSignature;
+    }
+    return tx;
+  },
+  /**
+   * Select best utxos with the algorithm described below. This method expects the utxos to be sorted by greatest value
+   *
+   * 1. If we have a single utxo capable of handle the full amount requested,
+   * we return the utxo with smaller amount among the ones that have an amount bigger than the requested
+   * 2. Otherwise we reverse sort the utxos by amount and select the utxos in order until the full amount is fulfilled.
+   *
+   * @memberof transaction
+   * @inner
+   */
+  selectUtxos(utxos, totalAmount) {
+    if (totalAmount <= 0) {
+      throw new _errors.UtxoError('Total amount must be a positive integer.');
+    }
+    if (utxos.length === 0) {
+      throw new _errors.UtxoError("Don't have enough utxos to fill total amount.");
+    }
+    let utxosToUse = [];
+    let filledAmount = 0n;
+    for (const utxo of utxos) {
+      if (utxo.value >= totalAmount) {
+        utxosToUse = [utxo];
+        filledAmount = utxo.value;
+      } else {
+        if (filledAmount >= totalAmount) {
+          break;
+        }
+        filledAmount += utxo.value;
+        utxosToUse.push(utxo);
+      }
+    }
+    if (filledAmount < totalAmount) {
+      throw new _errors.UtxoError("Don't have enough utxos to fill total amount.");
+    }
+    return {
+      utxos: utxosToUse,
+      changeAmount: filledAmount - totalAmount
+    };
+  },
+  /**
+   * Convert an output from the history of transactions to an Utxo.
+   *
+   * @param {string} txId The transaction this output belongs to.
+   * @param {number} index The output index on the original transaction.
+   * @param {HistoryTransactionOutput} txout output from the transaction history.
+   * @param {Object} [options]
+   * @param {string} [options.addressPath=''] utxo address bip32 path
+   *
+   * @returns {Utxo}
+   *
+   * @memberof transaction
+   */
+  utxoFromHistoryOutput(txId, index, txout, {
+    addressPath = ''
+  }) {
+    const isAuthority = this.isAuthorityOutput(txout);
+    return {
+      txId,
+      index,
+      addressPath,
+      address: txout.decoded && txout.decoded.address || '',
+      timelock: txout.decoded && txout.decoded.timelock || null,
+      tokenId: txout.token,
+      value: txout.value,
+      authorities: isAuthority ? txout.value : 0n,
+      heightlock: null,
+      // not enough info to determine this.
+      locked: false
+    };
+  },
+  /**
+   * Calculate the balance of a transaction
+   *
+   * @param tx Transaction to get balance from
+   * @param storage Storage to get metadata from
+   * @returns {Promise<Record<string, IBalance>>} Balance of the transaction
+   */
+  async getTxBalance(tx, storage) {
+    const balance = {};
+    const getEmptyBalance = () => ({
+      tokens: {
+        locked: 0n,
+        unlocked: 0n
+      },
+      authorities: {
+        mint: {
+          locked: 0n,
+          unlocked: 0n
+        },
+        melt: {
+          locked: 0n,
+          unlocked: 0n
+        }
+      }
+    });
+    const nowTs = Math.floor(Date.now() / 1000);
+    const nowHeight = await storage.getCurrentHeight();
+    const rewardLock = storage.version?.reward_spend_min_blocks;
+    const isHeightLocked = this.isHeightLocked(tx.height, nowHeight, rewardLock);
+    for (const output of tx.outputs) {
+      const {
+        address
+      } = output.decoded;
+      if (!(address && (await storage.isAddressMine(address)))) {
+        continue;
+      }
+      if (!balance[output.token]) {
+        balance[output.token] = getEmptyBalance();
+      }
+      const isLocked = this.isOutputLocked(output, {
+        refTs: nowTs
+      }) || isHeightLocked;
+      if (this.isAuthorityOutput(output)) {
+        if (this.isMint(output)) {
+          if (isLocked) {
+            balance[output.token].authorities.mint.locked += 1n;
+          } else {
+            balance[output.token].authorities.mint.unlocked += 1n;
+          }
+        }
+        if (this.isMelt(output)) {
+          if (isLocked) {
+            balance[output.token].authorities.melt.locked += 1n;
+          } else {
+            balance[output.token].authorities.melt.unlocked += 1n;
+          }
+        }
+      } else if (isLocked) {
+        balance[output.token].tokens.locked += output.value;
+      } else {
+        balance[output.token].tokens.unlocked += output.value;
+      }
+    }
+    for (const input of tx.inputs) {
+      const {
+        address
+      } = input.decoded;
+      if (!(address && (await storage.isAddressMine(address)))) {
+        continue;
+      }
+      if (!balance[input.token]) {
+        balance[input.token] = getEmptyBalance();
+      }
+      if (this.isAuthorityOutput(input)) {
+        if (this.isMint(input)) {
+          balance[input.token].authorities.mint.unlocked -= 1n;
+        }
+        if (this.isMelt(input)) {
+          balance[input.token].authorities.melt.unlocked -= 1n;
+        }
+      } else {
+        balance[input.token].tokens.unlocked -= input.value;
+      }
+    }
+    return balance;
+  },
+  /**
+   * Calculate the token balance of a transaction, including authorities, for a single token.
+   * The balance will contain funds, mint and melt properties.
+   * The funds property will contain the amount of tokens.
+   * The mint and melt properties will contain the amount of mint and melt authorities.
+   *
+   * We will consider the balance from the inputs as negative and the outputs as positive
+   * So that if the balance if positive we have a surplus of the token in the outputs.
+   * If the balance is negative we have a deficit of the token in the outputs.
+   *
+   * Normal txs can be "unbalanced" when minting or melting tokens, but since we are not required to add the minted tokens on the inputs
+   * Or conversely add the melted tokens on the outputs, we will ignore minted/melted funds.
+   *
+   * @param {string} token The token we want to calculate the balance.
+   * @param {IDataTx} tx The transaction we want to calculate the balance.
+   * @returns {Promise<Record<'funds'|'mint'|'melt', number>>} The balance of the given token on the transaction.
+   */
+  async calculateTxBalanceToFillTx(token, tx) {
+    const balance = {
+      funds: 0n,
+      mint: 0n,
+      melt: 0n
+    };
+    for (const output of tx.outputs) {
+      if ((0, _types.isDataOutputCreateToken)(output)) {
+        // This is a mint output
+        // Since we are creating this token on the transaction we do not need to add inputs to match the balance
+        // So we will skip this output.
+        continue;
+      }
+      if (output.token !== token) continue;
+      if (output.authorities > 0) {
+        // Authority output, add to mint or melt balance
+        // Check for MINT authority
+        if ((output.authorities & 1n) > 0) {
+          balance.mint += 1n;
+        }
+        // Check for MELT authority
+        if ((output.authorities & 2n) > 0) {
+          balance.melt += 1n;
+        }
+      } else {
+        // Fund output, add to the amount balance
+        balance.funds += output.value;
+      }
+    }
+    for (const input of tx.inputs) {
+      if (input.token !== token) continue;
+      if (input.authorities > 0) {
+        // Authority input, remove from mint or melt balance
+        // Check for MINT authority
+        if ((input.authorities & 1n) > 0) {
+          balance.mint -= 1n;
+        }
+        // Check for MELT authority
+        if ((input.authorities & 2n) > 0) {
+          balance.melt -= 1n;
+        }
+      } else {
+        // Fund input, remove from the amount balance
+        balance.funds -= input.value;
+      }
+    }
+    return balance;
+  },
+  /**
+   * Get the token_data for a given output
+   *
+   * @param {IDataOutput} output output data
+   * @param {string[]} tokens List of tokens in the transaction
+   * @returns {number} Calculated TokenData for the output token
+   */
+  getTokenDataFromOutput(output, tokens) {
+    if ((0, _types.isDataOutputCreateToken)(output)) {
+      // This output does not contain the token since it will be creating
+      // But knowing this, we also know the token index of it.
+      if (output.authorities === 0n) {
+        return 1;
+      }
+      return 1 | _constants.TOKEN_AUTHORITY_MASK;
+    }
+
+    // Token index of HTR is 0 and if it is a custom token it is its index on tokensWithoutHathor + 1
+    const tokensWithoutHathor = tokens.filter(token => token !== _constants.NATIVE_TOKEN_UID);
+    const tokenIndex = tokensWithoutHathor.indexOf(output.token) + 1;
+    if (output.authorities === 0n) {
+      return tokenIndex;
+    }
+    return tokenIndex | _constants.TOKEN_AUTHORITY_MASK;
+  },
+  /**
+   * Create output script
+   *
+   * @param {IDataOutput} output Output with data to create the script
+   *
+   * @throws {AddressError} If the address is invalid
+   *
+   * @return {Buffer} Output script
+   */
+  createOutputScript(output, network) {
+    if (output.type === 'data') {
+      // Data script for NFT
+      const scriptData = new _script_data.default(output.data);
+      return scriptData.createScript();
+    }
+    if ((0, _address2.getAddressType)(output.address, network) === 'p2sh') {
+      // P2SH
+      const address = new _address.default(output.address, {
+        network
+      });
+      // This will throw AddressError in case the address is invalid
+      address.validateAddress();
+      const p2sh = new _p2sh.default(address, {
+        timelock: output.timelock
+      });
+      return p2sh.createScript();
+    }
+    if ((0, _address2.getAddressType)(output.address, network) === 'p2pkh') {
+      // P2PKH
+      const address = new _address.default(output.address, {
+        network
+      });
+      // This will throw AddressError in case the address is invalid
+      address.validateAddress();
+      const p2pkh = new _p2pkh.default(address, {
+        timelock: output.timelock
+      });
+      return p2pkh.createScript();
+    }
+    throw new Error('Invalid output for creating script.');
+  },
+  /**
+   * Create a Transaction instance from tx data.
+   *
+   * @param {IDataTx} txData Tx data to create the transaction
+   * @param {Network} network network to use
+   * @returns {Transaction|CreateTokenTransaction}
+   */
+  createTransactionFromData(txData, network) {
+    const inputs = txData.inputs.map(input => {
+      const inputObj = new _input.default(input.txId, input.index);
+      if (input.data) {
+        inputObj.setData(Buffer.from(input.data, 'hex'));
+      }
+      return inputObj;
+    });
+    const outputs = txData.outputs.map(output => {
+      const script = this.createOutputScript(output, network);
+      const tokenData = this.getTokenDataFromOutput(output, txData.tokens);
+      return new _output.default(output.value, script, {
+        tokenData
+      });
+    });
+    const options = {
+      signalBits: txData.signalBits === undefined ? _constants.DEFAULT_SIGNAL_BITS : txData.signalBits,
+      version: txData.version === undefined ? _constants.DEFAULT_TX_VERSION : txData.version,
+      weight: txData.weight || 0,
+      nonce: txData.nonce || 0,
+      timestamp: txData.timestamp || null,
+      parents: txData.parents || [],
+      tokens: txData.tokens || []
+    };
+    if (options.version === _constants.CREATE_TOKEN_TX_VERSION) {
+      return new _create_token_transaction.default(txData.name, txData.symbol, inputs, outputs, options);
+    }
+    if (options.version === _constants.DEFAULT_TX_VERSION) {
+      return new _transaction.default(inputs, outputs, options);
+    }
+    throw new _errors.ParseError('Invalid transaction version.');
+  },
+  /**
+   * Convert a Transaction instance to the history object.
+   * May call the fullnode transaction api to get information on the tx spent
+   * by the inputs.
+   */
+  async convertTransactionToHistoryTx(tx, storage) {
+    if (!tx.hash) {
+      throw new Error('To be a history tx a calculated hash is required');
+    }
+    const inputs = [];
+    const outputs = [];
+    const txCache = {};
+    for (const input of tx.inputs) {
+      let spentTx = await storage.getTx(input.hash);
+      if (!spentTx) {
+        // Try cache first
+        if (txCache[input.hash]) {
+          spentTx = txCache[input.hash];
+        } else {
+          // Get from API
+          spentTx = await new Promise((resolve, reject) => {
+            _txApi.default.getTransaction(input.hash, response => {
+              if (!response.success) {
+                return reject(new Error(response.message ?? ''));
+              }
+              if (input.index >= response.tx.outputs.length) {
+                return reject(new Error('Index outside of tx output array bounds'));
+              }
+              return resolve(this.convertFullNodeTxToHistoryTx(response));
+            }).catch(err => reject(err));
+          });
+          if (!spentTx) {
+            // This should not happen since any errors should be treated already.
+            // This if statement is to ensure typing since spentTx starts as IHistoryTx | null.
+            throw new Error('Could not find the spent transaction');
+          }
+          // Update cache
+          txCache[input.hash] = (0, _lodash.cloneDeep)(spentTx);
+        }
+      }
+      if (input.index >= spentTx.outputs.length) {
+        throw new Error(`Index (${input.index}) outside of transaction output array bounds (${spentTx.outputs.length})`);
+      }
+      const spentOut = spentTx.outputs[input.index];
+      inputs.push({
+        tx_id: input.hash,
+        index: input.index,
+        script: spentOut.script,
+        decoded: spentOut.decoded,
+        token_data: spentOut.token_data,
+        token: spentOut.token,
+        value: spentOut.value
+      });
+    }
+    const tokensArray = tx.version === _constants.CREATE_TOKEN_TX_VERSION ? [{
+      uid: tx.hash
+    }] : tx.tokens.map(tk => ({
+      uid: tk
+    }));
+    for (const output of tx.outputs) {
+      const script = output.parseScript(storage.config.getNetwork());
+      const out = {
+        value: output.value,
+        token_data: output.tokenData,
+        script: output.script.toString('hex'),
+        decoded: script?.toData() ?? {},
+        spent_by: null // Cannot reconstruct this field
+      };
+      outputs.push(this.hydrateIOWithToken(out, tokensArray));
+    }
+    const histTx = {
+      tx_id: tx.hash,
+      signalBits: tx.signalBits,
+      version: tx.version,
+      weight: tx.weight,
+      timestamp: tx.timestamp ?? 0,
+      is_voided: false,
+      nonce: tx.nonce,
+      inputs,
+      outputs,
+      parents: tx.parents,
+      tokens: tx.tokens
+      // The missing fields below are metadata that cannot be inferred from the
+      // Transaction instance.
+      // height, first_block
+    };
+    if (tx.version === _constants.CREATE_TOKEN_TX_VERSION) {
+      histTx.token_name = tx.name;
+      histTx.token_symbol = tx.symbol;
+    }
+    if (tx.version === _constants.ON_CHAIN_BLUEPRINTS_VERSION) {
+      histTx.nc_pubkey = tx.pubkey.toString('hex');
+    }
+    if (tx.isNanoContract()) {
+      const nanoHeader = tx.getNanoHeaders()[0];
+      // XXX this code won't work if we have more than one
+      // nano header for the same tx in the future
+      histTx.nc_id = nanoHeader.id;
+      histTx.nc_method = nanoHeader.method;
+      histTx.nc_args = nanoHeader.args.toString('hex');
+      histTx.nc_address = nanoHeader.address.base58;
+      // XXX: should we build nc_context from nanoHeader information?
+      // Cannot fetch histTx.nc_blueprint_id with the current data
+    }
+    return histTx;
+  },
+  /**
+   * Prepare a Transaction instance from the transaction data and storage
+   *
+   * @param tx tx data to be prepared
+   * @param pinCode pin to unlock the mainKey for signatures
+   * @param storage Storage to get the mainKey
+   * @param {Object} [options]
+   * @param {boolean} [options.signTx=true] sign transaction instance
+   * @returns {Promise<Transaction|CreateTokenTransaction>} Prepared transaction
+   */
+  async prepareTransaction(txData, pinCode, storage, options) {
+    const newOptions = {
+      signTx: true,
+      ...options
+    };
+    const network = storage.config.getNetwork();
+    const tx = this.createTransactionFromData(txData, network);
+    if (newOptions.signTx) {
+      await this.signTransaction(tx, storage, pinCode);
+    }
+    tx.prepareToSend();
+    return tx;
+  },
+  /**
+   * Create P2PKH input data
+   *
+   * @param {Buffer} signature Input signature
+   * @param {Buffer} publicKey Input public key
+   * @returns {Buffer} Input data
+   */
+  createInputData(signature, publicKey) {
+    const arr = [];
+    _helpers.default.pushDataToStack(arr, signature);
+    _helpers.default.pushDataToStack(arr, publicKey);
+    return Buffer.concat(arr);
+  },
+  /**
+   * Calculate the authorities data for an output
+   *
+   * @param output History output
+   * @returns {OutputValueType} Authorities from output
+   */
+  authoritiesFromOutput(output) {
+    let authorities = 0n;
+    if (this.isMint(output)) {
+      authorities |= _constants.TOKEN_MINT_MASK;
+    }
+    if (this.isMelt(output)) {
+      authorities |= _constants.TOKEN_MELT_MASK;
+    }
+    return authorities;
+  },
+  /**
+   * Check if an utxo is available to be spent.
+   *
+   * @param {IUtxoId} utxo Utxo to check if we can use it
+   * @param {IStorage} storage storage that may have the tx
+   * @returns {Promise<boolean>}
+   */
+  async canUseUtxo(utxo, storage) {
+    const currentHeight = await storage.getCurrentHeight();
+    const rewardLock = storage.version?.reward_spend_min_blocks || 0;
+    const nowTs = Math.floor(Date.now() / 1000);
+    const tx = await storage.getTx(utxo.txId);
+    if (tx === null || tx.outputs && tx.outputs.length <= utxo.index) {
+      // This is not our utxo, so we cannot spend it.
+      return false;
+    }
+    const output = tx.outputs[utxo.index];
+    const isTimelocked = this.isOutputLocked(output, {
+      refTs: nowTs
+    });
+    const isHeightLocked = this.isHeightLocked(tx.height, currentHeight, rewardLock);
+    const isSelectedAsInput = await storage.isUtxoSelectedAsInput(utxo);
+
+    // If utxo is selected as input on another tx we cannot use it
+    // If utxo is timelocked we cannot use it
+    // If utxo is height locked we cannot use it
+    return !(isSelectedAsInput || isTimelocked || isHeightLocked);
+  },
+  /**
+   * Get object type (Transaction or Block)
+   *
+   * @param {Pick<IHistoryTx, 'version'>} tx Object to get the type
+   *
+   * @return {string} Type of the object
+   *
+   * @memberof transaction
+   * @inner
+   */
+  getTxType(tx) {
+    if (this.isBlock(tx)) {
+      if (tx.version === _constants.BLOCK_VERSION) {
+        return 'Block';
+      }
+      if (tx.version === _constants.MERGED_MINED_BLOCK_VERSION) {
+        return 'Merged Mining Block';
+      }
+      if (tx.version === _constants.POA_BLOCK_VERSION) {
+        return 'Proof-of-Authority Block';
+      }
+    } else {
+      if (tx.version === _constants.DEFAULT_TX_VERSION) {
+        return 'Transaction';
+      }
+      if (tx.version === _constants.CREATE_TOKEN_TX_VERSION) {
+        return 'Create Token Transaction';
+      }
+      if (tx.version === _constants.ON_CHAIN_BLUEPRINTS_VERSION) {
+        return 'On-Chain Blueprint';
+      }
+    }
+
+    // If there is no match
+    return 'Unknown';
+  },
+  /**
+   * From a `token_data` and the tokens array we can add the token uid to the input/output.
+   */
+  hydrateIOWithToken(io, tokens) {
+    const {
+      token_data
+    } = io;
+    if (token_data === 0) {
+      return {
+        ...io,
+        token: _constants.NATIVE_TOKEN_UID
+      };
+    }
+    const tokenIdx = _tokens.default.getTokenIndexFromData(token_data);
+    const tokenUid = tokens[tokenIdx - 1]?.uid;
+    if (!tokenUid) {
+      throw new Error(`Invalid token_data ${token_data}, token not found in tokens list`);
+    }
+    return {
+      ...io,
+      token: tokenUid
+    };
+  },
+  /**
+   * Convert the transaction type from the tx api to the IHistoryTx which is
+   * the interface of transactions received via websocket.
+   */
+  convertFullNodeTxToHistoryTx(txResponse) {
+    if (txResponse.success === false) {
+      throw new Error(`trying to convert a tx from a failed api request: ${txResponse.message}`);
+    }
+    const {
+      tx,
+      meta
+    } = txResponse;
+    const inputs = tx.inputs.map(i => {
+      const hydratedInput = this.hydrateIOWithToken(i, tx.tokens);
+      return hydratedInput;
+    });
+    const outputs = tx.outputs.map(o => {
+      const hydratedoutput = this.hydrateIOWithToken(o, tx.tokens);
+      return hydratedoutput;
+    });
+    const histTx = {
+      tx_id: tx.hash,
+      signalBits: tx.signal_bits,
+      version: tx.version,
+      weight: tx.weight,
+      timestamp: tx.timestamp,
+      is_voided: meta.voided_by.length > 0,
+      nonce: Number.parseInt(tx.nonce ?? '0', 10),
+      inputs,
+      outputs,
+      parents: tx.parents,
+      token_name: tx.token_name ?? undefined,
+      token_symbol: tx.token_symbol ?? undefined,
+      tokens: tx.tokens.map(token => token.uid),
+      height: meta.height,
+      first_block: meta.first_block
+    };
+    if (tx.nc_id) histTx.nc_id = tx.nc_id;
+    if (tx.nc_blueprint_id) histTx.nc_blueprint_id = tx.nc_blueprint_id;
+    if (tx.nc_method) histTx.nc_method = tx.nc_method;
+    if (tx.nc_args) histTx.nc_args = tx.nc_args;
+    if (tx.nc_address) histTx.nc_address = tx.nc_address;
+    if (tx.nc_context) histTx.nc_context = tx.nc_context;
+    if (tx.nc_pubkey) histTx.nc_pubkey = tx.nc_pubkey;
+    return histTx;
+  }
+};
+var _default = exports.default = transaction;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/utils/utxo.d.ts b/node_modules/@hathor/wallet-lib/oldLib/utils/utxo.d.ts
new file mode 100644
index 0000000..196199f
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/utils/utxo.d.ts
@@ -0,0 +1,50 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+import { IStorage, IUtxo, OutputValueType, UtxoSelectionAlgorithm } from '../types';
+export declare enum UtxoSelection {
+    FAST = "fast",
+    BEST = "best"
+}
+/**
+ * Get the algorithm function from the enum value.
+ *
+ * @param algorithm The algorithm to get
+ * @returns {UtxoSelectionAlgorithm} The algorithm function
+ */
+export declare function getAlgorithmFromEnum(algorithm: UtxoSelection): UtxoSelectionAlgorithm;
+/**
+ * Select utxos to fill the amount required.
+ * This method should be faster since it stops the iteration once the target amount is reached.
+ * Obs: Does not work with authority utxos.
+ *
+ * @param {IStorage} storage The wallet storage to select the utxos
+ * @param {string} token The token uid to select the utxos
+ * @param {OutputValueType} amount The target amount of tokens required
+ * @returns {Promise<{ utxos: IUtxo[], amount: OutputValueType, available?: OutputValueType }>}
+ */
+export declare function fastUtxoSelection(storage: IStorage, token: string, amount: OutputValueType): Promise<{
+    utxos: IUtxo[];
+    amount: OutputValueType;
+    available?: OutputValueType;
+}>;
+/**
+ * Select utxos to fill the amount required.
+ * This method will select the smallest utxos that are bigger than the amount required.
+ * Obs: this will iterate on all available utxos to choose the best suited selection.
+ * Obs: Does not work with authority utxos.
+ *
+ * @param {IStorage} storage The wallet storage to select the utxos
+ * @param {string} token The token uid to select the utxos
+ * @param {OutputValueType} amount The target amount of tokens required
+ * @returns {Promise<{ utxos: IUtxo[], amount: OutputValueType, available?: OutputValueType }>}
+ */
+export declare function bestUtxoSelection(storage: IStorage, token: string, amount: OutputValueType): Promise<{
+    utxos: IUtxo[];
+    amount: OutputValueType;
+    available?: OutputValueType;
+}>;
+//# sourceMappingURL=utxo.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/utils/utxo.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/utils/utxo.d.ts.map
new file mode 100644
index 0000000..74a82ab
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/utils/utxo.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"utxo.d.ts","sourceRoot":"","sources":["../../src/utils/utxo.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;AAEH,OAAO,EACL,QAAQ,EACR,KAAK,EAEL,eAAe,EACf,sBAAsB,EACvB,MAAM,UAAU,CAAC;AAElB,oBAAY,aAAa;IACvB,IAAI,SAAS;IACb,IAAI,SAAS;CACd;AAED;;;;;GAKG;AACH,wBAAgB,oBAAoB,CAAC,SAAS,EAAE,aAAa,GAAG,sBAAsB,CASrF;AAED;;;;;;;;;GASG;AACH,wBAAsB,iBAAiB,CACrC,OAAO,EAAE,QAAQ,EACjB,KAAK,EAAE,MAAM,EACb,MAAM,EAAE,eAAe,GACtB,OAAO,CAAC;IAAE,KAAK,EAAE,KAAK,EAAE,CAAC;IAAC,MAAM,EAAE,eAAe,CAAC;IAAC,SAAS,CAAC,EAAE,eAAe,CAAA;CAAE,CAAC,CA4BnF;AAED;;;;;;;;;;GAUG;AACH,wBAAsB,iBAAiB,CACrC,OAAO,EAAE,QAAQ,EACjB,KAAK,EAAE,MAAM,EACb,MAAM,EAAE,eAAe,GACtB,OAAO,CAAC;IAAE,KAAK,EAAE,KAAK,EAAE,CAAC;IAAC,MAAM,EAAE,eAAe,CAAC;IAAC,SAAS,CAAC,EAAE,eAAe,CAAA;CAAE,CAAC,CAsEnF"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/utils/utxo.js b/node_modules/@hathor/wallet-lib/oldLib/utils/utxo.js
new file mode 100644
index 0000000..464855a
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/utils/utxo.js
@@ -0,0 +1,195 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.UtxoSelection = void 0;
+exports.bestUtxoSelection = bestUtxoSelection;
+exports.fastUtxoSelection = fastUtxoSelection;
+exports.getAlgorithmFromEnum = getAlgorithmFromEnum;
+function _asyncIterator(r) { var n, t, o, e = 2; for ("undefined" != typeof Symbol && (t = Symbol.asyncIterator, o = Symbol.iterator); e--;) { if (t && null != (n = r[t])) return n.call(r); if (o && null != (n = r[o])) return new AsyncFromSyncIterator(n.call(r)); t = "@@asyncIterator", o = "@@iterator"; } throw new TypeError("Object is not async iterable"); }
+function AsyncFromSyncIterator(r) { function AsyncFromSyncIteratorContinuation(r) { if (Object(r) !== r) return Promise.reject(new TypeError(r + " is not an object.")); var n = r.done; return Promise.resolve(r.value).then(function (r) { return { value: r, done: n }; }); } return AsyncFromSyncIterator = function (r) { this.s = r, this.n = r.next; }, AsyncFromSyncIterator.prototype = { s: null, n: null, next: function () { return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments)); }, return: function (r) { var n = this.s.return; return void 0 === n ? Promise.resolve({ value: r, done: !0 }) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments)); }, throw: function (r) { var n = this.s.return; return void 0 === n ? Promise.reject(r) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments)); } }, new AsyncFromSyncIterator(r); } /**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+let UtxoSelection = exports.UtxoSelection = /*#__PURE__*/function (UtxoSelection) {
+  UtxoSelection["FAST"] = "fast";
+  UtxoSelection["BEST"] = "best";
+  return UtxoSelection;
+}({});
+/**
+ * Get the algorithm function from the enum value.
+ *
+ * @param algorithm The algorithm to get
+ * @returns {UtxoSelectionAlgorithm} The algorithm function
+ */
+function getAlgorithmFromEnum(algorithm) {
+  switch (algorithm) {
+    case UtxoSelection.FAST:
+      return fastUtxoSelection;
+    case UtxoSelection.BEST:
+      return bestUtxoSelection;
+    default:
+      throw new Error(`Unknown algorithm ${algorithm}`);
+  }
+}
+
+/**
+ * Select utxos to fill the amount required.
+ * This method should be faster since it stops the iteration once the target amount is reached.
+ * Obs: Does not work with authority utxos.
+ *
+ * @param {IStorage} storage The wallet storage to select the utxos
+ * @param {string} token The token uid to select the utxos
+ * @param {OutputValueType} amount The target amount of tokens required
+ * @returns {Promise<{ utxos: IUtxo[], amount: OutputValueType, available?: OutputValueType }>}
+ */
+async function fastUtxoSelection(storage, token, amount) {
+  const utxos = [];
+  let utxosAmount = 0n;
+  const options = {
+    token,
+    authorities: 0n,
+    target_amount: amount,
+    only_available_utxos: true,
+    order_by_value: 'desc'
+  };
+  var _iteratorAbruptCompletion = false;
+  var _didIteratorError = false;
+  var _iteratorError;
+  try {
+    for (var _iterator = _asyncIterator(storage.selectUtxos(options)), _step; _iteratorAbruptCompletion = !(_step = await _iterator.next()).done; _iteratorAbruptCompletion = false) {
+      const utxo = _step.value;
+      {
+        // We let selectUtxos to filter the utxos for us and stop after target amount is reached
+        utxosAmount += utxo.value;
+        utxos.push(utxo);
+      }
+    }
+  } catch (err) {
+    _didIteratorError = true;
+    _iteratorError = err;
+  } finally {
+    try {
+      if (_iteratorAbruptCompletion && _iterator.return != null) {
+        await _iterator.return();
+      }
+    } finally {
+      if (_didIteratorError) {
+        throw _iteratorError;
+      }
+    }
+  }
+  if (utxosAmount < amount) {
+    // Not enough funds to fill the amount required.
+    return {
+      utxos: [],
+      amount: 0n,
+      available: utxosAmount
+    };
+  }
+  return {
+    utxos,
+    amount: utxosAmount
+  };
+}
+
+/**
+ * Select utxos to fill the amount required.
+ * This method will select the smallest utxos that are bigger than the amount required.
+ * Obs: this will iterate on all available utxos to choose the best suited selection.
+ * Obs: Does not work with authority utxos.
+ *
+ * @param {IStorage} storage The wallet storage to select the utxos
+ * @param {string} token The token uid to select the utxos
+ * @param {OutputValueType} amount The target amount of tokens required
+ * @returns {Promise<{ utxos: IUtxo[], amount: OutputValueType, available?: OutputValueType }>}
+ */
+async function bestUtxoSelection(storage, token, amount) {
+  const utxos = [];
+  let utxosAmount = 0n;
+  let selectedUtxo = null;
+  const options = {
+    token,
+    authorities: 0n,
+    only_available_utxos: true,
+    order_by_value: 'desc'
+  };
+  var _iteratorAbruptCompletion2 = false;
+  var _didIteratorError2 = false;
+  var _iteratorError2;
+  try {
+    for (var _iterator2 = _asyncIterator(storage.selectUtxos(options)), _step2; _iteratorAbruptCompletion2 = !(_step2 = await _iterator2.next()).done; _iteratorAbruptCompletion2 = false) {
+      const utxo = _step2.value;
+      {
+        // storage ensures the utxo can be used
+        if (utxo.value === amount) {
+          return {
+            utxos: [utxo],
+            amount
+          };
+        }
+        utxos.push(utxo);
+        utxosAmount += utxo.value;
+        if (utxo.value > amount) {
+          // We want to select the smallest utxo that is bigger than the amount
+          if (selectedUtxo === null || utxo.value < selectedUtxo.value) {
+            selectedUtxo = utxo;
+          }
+        }
+        if (utxo.value < amount) {
+          if (selectedUtxo !== null) {
+            // We already have an utxo that is bigger than the amount required
+            // with the lowest possible value.
+            // We don't need to iterate more
+            break;
+          }
+          if (utxosAmount >= amount) {
+            // We have enough funds to fill the amount required
+            // We don't need to iterate more
+            break;
+          }
+        }
+      }
+    }
+  } catch (err) {
+    _didIteratorError2 = true;
+    _iteratorError2 = err;
+  } finally {
+    try {
+      if (_iteratorAbruptCompletion2 && _iterator2.return != null) {
+        await _iterator2.return();
+      }
+    } finally {
+      if (_didIteratorError2) {
+        throw _iteratorError2;
+      }
+    }
+  }
+  if (selectedUtxo !== null) {
+    return {
+      utxos: [selectedUtxo],
+      amount: selectedUtxo.value
+    };
+  }
+  if (utxosAmount < amount) {
+    // We don't have enough funds
+    return {
+      utxos: [],
+      amount: 0n,
+      available: utxosAmount
+    };
+  }
+  // We need to ensure we use the smallest number of utxos and avoid hitting the maximum number of inputs
+  // This can be done by ordering the utxos by value and selecting the highest values first until the amount is fulfilled
+  // But since the store ensures the utxos are ordered by value descending
+  // (Which is ensured by options.order_by_value = 'desc' on the selectUtxos method)
+  // And we stop selecting when the amount in the utxos array is greater than or equal to the requested amount
+  // We can just return the utxos selected during the loop above
+  return {
+    utxos,
+    amount: utxosAmount
+  };
+}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/utils/wallet.d.ts b/node_modules/@hathor/wallet-lib/oldLib/utils/wallet.d.ts
new file mode 100644
index 0000000..4d5bcaa
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/utils/wallet.d.ts
@@ -0,0 +1,288 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/// <reference types="node" />
+import { IMultisigData, IWalletAccessData } from '../types';
+declare const wallet: {
+    /**
+     * Get the wallet id given the change path xpubkey
+     *
+     * @param {string} xpub - The change path xpubkey
+     * @returns {string} The walletId
+     *
+     * @memberof Wallet
+     * @inner
+     */
+    getWalletIdFromXPub(xpub: string): string;
+    /**
+     * Verify if words passed to generate wallet are valid. In case of invalid, returns message
+     *
+     * @param {string} words Words (separated by space) to generate the HD Wallet seed
+     *
+     * @return {Object} {'valid': boolean, 'words': string} where 'words' is a cleaned
+     * string with the words separated by a single space
+     * @throws {InvalidWords} In case the words string is invalid. The error object will have
+     * an invalidWords attribute with an array of words that are not valid.
+     *
+     * @memberof Wallet
+     * @inner
+     */
+    wordsValid(words: string): {
+        valid: boolean;
+        words: string;
+    };
+    /**
+     * Generate HD wallet words
+     *
+     * @param {number} entropy Data to generate the HD Wallet seed - entropy (256 - to generate 24 words)
+     *
+     * @return {string} words generated
+     * @memberof Wallet
+     * @inner
+     */
+    generateWalletWords(entropy?: number): string;
+    /**
+     * Get xpub from data
+     *
+     * @param {Buffer} pubkey Compressed public key
+     * @param {Buffer} chainCode HDPublic key chaincode
+     * @param {Buffer} fingerprint parent fingerprint
+     * @param {string} networkName Optional parameter to select the used network (default is mainnet)
+     *
+     * @return {String} Xpub
+     *
+     * @memberof Wallet
+     * @inner
+     */
+    xpubFromData(pubkey: Buffer, chainCode: Buffer, fingerprint: Buffer, networkName?: string): string;
+    /**
+     * Get compressed public key from uncompressed
+     *
+     * @param {Buffer} pubkey Uncompressed public key
+     *
+     * @return {Buffer} Compressed public key
+     * @throws {UncompressedPubKeyError} In case the given public key is invalid
+     *
+     * @memberof Wallet
+     * @inner
+     */
+    toPubkeyCompressed(pubkey: Buffer): Buffer;
+    /**
+     * Get public key for specific key index derivation.
+     * We expect to receive the xpub after the derivation and the index to get the public key
+     * Example: to get the public key of the path m/44'/280/0'/0/{index}
+     * you must send in this method the xpubkey from m/44'/280/0'/0 and the index you want to derive
+     *
+     * @param {String} xpubkey Xpub of the path before the last derivation
+     * @param {number?} index Index of the key to derive, if not present no derivation will be made.
+     *
+     * @return {Object} Public key object
+     * @throws {XPubError} In case the given xpub key is invalid
+     *
+     * @memberof Wallet
+     * @inner
+     */
+    getPublicKeyFromXpub(xpubkey: string, index?: number): PublicKey;
+    /**
+     * Get xpubkey from xpriv
+     *
+     * @param {String} xpriv Private key
+     *
+     * @return {String} Wallet xpubkey
+     * @memberof Wallet
+     * @inner
+     */
+    getXPubKeyFromXPrivKey(xpriv: string): string;
+    /**
+     * Get xpubkey in account derivation path from seed
+     *
+     * @param {String} seed 24 words
+     * @param {Object} options Options with passphrase, networkName and accountDerivationIndex
+     *
+     * @return {String} Wallet xpubkey
+     * @memberof Wallet
+     * @inner
+     */
+    getXPubKeyFromSeed(seed: string, options?: {
+        passphrase?: string;
+        networkName?: string;
+        accountDerivationIndex?: string;
+    }): string;
+    /**
+     * Get root privateKey from seed
+     *
+     * TODO: Change method name as we are not returning a xpriv
+     *
+     * @param {String} seed 24 words
+     * @param {Object} options Options with passphrase, networkName
+     *
+     * @return {HDPrivateKey} Root HDPrivateKey
+     * @memberof Wallet
+     * @inner
+     */
+    getXPrivKeyFromSeed(seed: string, options?: {
+        passphrase?: string;
+        networkName?: string;
+    }): HDPrivateKey;
+    /**
+     * Derive xpriv from root to account derivation path
+     *
+     * TODO: Method name is misleading as we are returning a HDPrivateKey and not a xpriv, we should change it
+     *
+     * @param {string} accountDerivationIndex String with derivation index of account (can be hardened)
+     *
+     * @return {HDPrivateKey} Derived private key
+     * @memberof Wallet
+     * @inner
+     */
+    deriveXpriv(xpriv: HDPrivateKey, accountDerivationIndex: string): HDPrivateKey;
+    /**
+     * Validate an xpubkey.
+     *
+     * @param {string} xpubkey The xpubkey
+     *
+     * @return {boolean} true if it's a valid xpubkey, false otherwise
+     * @memberof Wallet
+     * @inner
+     */
+    isXpubKeyValid(xpubkey: string): boolean;
+    /**
+     * Derive next step of child from xpub
+     *
+     * @param {string} xpubkey The xpubkey
+     * @param {number} derivationIndex Index to derive the xpub
+     *
+     * @return {string} Derived xpub
+     * @throws {XPubError} In case the given xpub key is invalid
+     * @memberof Wallet
+     * @inner
+     */
+    xpubDeriveChild(xpubkey: string, derivationIndex: number): string;
+    /**
+     * Create a P2SH MultiSig redeem script
+     *
+     * @param {string[]} xpubs The list of xpubkeys involved in this MultiSig
+     * @param {number} numSignatures Minimum number of signatures to send a
+     * transaction with this MultiSig
+     * @param {number} index Index to derive the xpubs
+     *
+     * @return {Buffer} A buffer with the redeemScript
+     * @throws {XPubError} In case any of the given xpubs are invalid
+     * @memberof Wallet
+     * @inner
+     */
+    createP2SHRedeemScript(xpubs: string[], numSignatures: number, index: number): Buffer;
+    /**
+     * Create a P2SH MultiSig input data from the signatures and redeemScript
+     *
+     * @param {Buffer[]} signatures The list of signatures collected from participants.
+     * @param {Buffer} redeemScript The redeemScript as a Buffer
+     *
+     * @return {Buffer} A buffer with the input data to send.
+     * @memberof Wallet
+     * @inner
+     */
+    getP2SHInputData(signatures: Buffer[], redeemScript: Buffer): Buffer;
+    /**
+     * Create an HDPublicKey on P2SH MultiSig account path from the root xpriv
+     *
+     * @param {HDPrivateKey} xpriv HD private key used to derive the multisig xpub.
+     *
+     * @return {string} xpubkey at MultiSig account path
+     * @memberof Wallet
+     * @inner
+     */
+    getMultiSigXPubFromXPriv(xpriv: HDPrivateKey): string;
+    /**
+     * Create an HDPublicKey on P2SH MultiSig account path from the seed
+     *
+     * @param {string} seed space separated list of words to use as seed.
+     * @param {Object} options Optionally inform passphrase and network (defaults to no passphrase and mainnet).
+     *
+     * @return {string} xpubkey at MultiSig account path
+     * @memberof Wallet
+     * @inner
+     */
+    getMultiSigXPubFromWords(seed: string, options?: {
+        passphrase?: string;
+        networkName?: string;
+    }): string;
+    /**
+     * Generate access data from xpubkey.
+     * The access data will be used to start a wallet and derive the wallet's addresses.
+     * This method can only generate READONLY wallets since we do not have the private key.
+     *
+     * We can only accept xpubs derived to the account or change path.
+     * Since hdpublickeys cannot derive on hardened paths, the derivation must be done previously with the private key
+     * The last path with hardened derivation defined on bip44 is the account path so we support using an account path xpub.
+     * We can also use the change path xpub since we use it to derive the addresses
+     * but we cannot use the address path xpub since we won't be able to derive all addresses.
+     * And the wallet-lib currently does not support the creation of a wallet with a single address.
+     *
+     * @param {string} xpubkey HDPublicKey in string format.
+     * @param {Object} [options={}] Options to generate the access data.
+     * @param {IMultisigData|undefined} [options.multisig=undefined] MultiSig data of the wallet
+     * @param {boolean} [options.hardware=false] If the wallet is a hardware wallet
+     * @returns {IWalletAccessData}
+     */
+    generateAccessDataFromXpub(xpubkey: string, { multisig, hardware }?: {
+        multisig?: IMultisigData;
+        hardware?: boolean;
+    }): IWalletAccessData;
+    /**
+     * Generate access data from the xprivkey.
+     * We can use either the root xprivkey or the change path xprivkey.
+     * Obs: A multisig wallet cannot be started with a change path xprivkey.
+     *
+     * The seed can be passed so we save it on the storage, even if its not used.
+     * Obs: must also pass password to encrypt the seed.
+     *
+     * @param {string} xprivkey
+     * @param {Object} options
+     * @param {IMultisigData | undefined} [options.multisig=undefined]
+     * @param {string} [options.pin]
+     * @param {string | undefined} [options.seed=undefined]
+     * @param {string | undefined} [options.password=undefined]
+     * @param {string | undefined} [options.authXpriv=undefined]
+     * @returns {IWalletAccessData}
+     */
+    generateAccessDataFromXpriv(xprivkey: string, { multisig, pin, seed, password, authXpriv, }: {
+        multisig?: IMultisigData;
+        pin: string;
+        seed?: string;
+        password?: string;
+        authXpriv?: string;
+    }): IWalletAccessData;
+    generateAccessDataFromSeed(words: string, { multisig, passphrase, pin, password, networkName, }: {
+        multisig?: IMultisigData;
+        pin: string;
+        password: string;
+        passphrase?: string;
+        networkName: string;
+    }): IWalletAccessData;
+    /**
+     * Change the encryption pin on the fields that are encrypted using the pin.
+     * Will not save the access data, only return the new access data.
+     *
+     * @param {IWalletAccessData} accessData The current access data encrypted with `oldPin`.
+     * @param {string} oldPin Used to decrypt the old access data.
+     * @param {string} newPin Encrypt the fields with this pin.
+     * @returns {IWalletAccessData} The access data with fields encrypted with `newPin`.
+     */
+    changeEncryptionPin(accessData: IWalletAccessData, oldPin: string, newPin: string): IWalletAccessData;
+    /**
+     * Change the encryption password on the seed.
+     * Will not save the access data, only return the new access data.
+     *
+     * @param {IWalletAccessData} accessData The current access data encrypted with `oldPassword`.
+     * @param {string} oldPassword Used to decrypt the old access data.
+     * @param {string} newPassword Encrypt the seed with this password.
+     * @returns {IWalletAccessData} The access data with fields encrypted with `newPassword`.
+     */
+    changeEncryptionPassword(accessData: IWalletAccessData, oldPassword: string, newPassword: string): IWalletAccessData;
+};
+export default wallet;
+//# sourceMappingURL=wallet.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/utils/wallet.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/utils/wallet.d.ts.map
new file mode 100644
index 0000000..f68549b
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/utils/wallet.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"wallet.d.ts","sourceRoot":"","sources":["../../src/utils/wallet.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;;AAiBH,OAAO,EAEL,aAAa,EACb,iBAAiB,EAGlB,MAAM,UAAU,CAAC;AAGlB,QAAA,MAAM,MAAM;IACV;;;;;;;;OAQG;8BACuB,MAAM,GAAG,MAAM;IAIzC;;;;;;;;;;;;OAYG;sBACe,MAAM,GAAG;QAAE,KAAK,EAAE,OAAO,CAAC;QAAC,KAAK,EAAE,MAAM,CAAA;KAAE;IAiD5D;;;;;;;;OAQG;kCAC0B,MAAM,GAAuB,MAAM;IAKhE;;;;;;;;;;;;OAYG;yBAEO,MAAM,aACH,MAAM,eACJ,MAAM,gBACN,MAAM,GAClB,MAAM;IAcT;;;;;;;;;;OAUG;+BACwB,MAAM,GAAG,MAAM;IAU1C;;;;;;;;;;;;;;OAcG;kCAC2B,MAAM,UAAU,MAAM;IAkBpD;;;;;;;;OAQG;kCAC2B,MAAM,GAAG,MAAM;IAK7C;;;;;;;;;OASG;6BAEK,MAAM,YACH;QAAE,UAAU,CAAC,EAAE,MAAM,CAAC;QAAC,WAAW,CAAC,EAAE,MAAM,CAAC;QAAC,sBAAsB,CAAC,EAAE,MAAM,CAAA;KAAE,GACtF,MAAM;IAgBT;;;;;;;;;;;OAWG;8BAEK,MAAM,YACH;QAAE,UAAU,CAAC,EAAE,MAAM,CAAC;QAAC,WAAW,CAAC,EAAE,MAAM,CAAA;KAAE;IAUxD;;;;;;;;;;OAUG;6DACsD,MAAM;IAI/D;;;;;;;;OAQG;4BACqB,MAAM,GAAG,OAAO;IAIxC;;;;;;;;;;OAUG;6BACsB,MAAM,mBAAmB,MAAM,GAAG,MAAM;IAgBjE;;;;;;;;;;;;OAYG;kCAC2B,MAAM,EAAE,iBAAiB,MAAM,SAAS,MAAM,GAAG,MAAM;IAoBrF;;;;;;;;;OASG;iCAC0B,MAAM,EAAE,gBAAgB,MAAM,GAAG,MAAM;IAcpE;;;;;;;;OAQG;mDAC4C,MAAM;IAKrD;;;;;;;;;OASG;mCAEK,MAAM,YACH;QAAE,UAAU,CAAC,EAAE,MAAM,CAAC;QAAC,WAAW,CAAC,EAAE,MAAM,CAAA;KAAE,GACrD,MAAM;IAMT;;;;;;;;;;;;;;;;;OAiBG;wCAEQ,MAAM,2BACiB;QAAE,QAAQ,CAAC,EAAE,aAAa,CAAC;QAAC,QAAQ,CAAC,EAAE,OAAO,CAAA;KAAE,GAC/E,iBAAiB;IAyDpB;;;;;;;;;;;;;;;;OAgBG;0CAES,MAAM,iDAOb;QACD,QAAQ,CAAC,EAAE,aAAa,CAAC;QACzB,GAAG,EAAE,MAAM,CAAC;QACZ,IAAI,CAAC,EAAE,MAAM,CAAC;QACd,QAAQ,CAAC,EAAE,MAAM,CAAC;QAClB,SAAS,CAAC,EAAE,MAAM,CAAC;KACpB,GACA,iBAAiB;sCA2EX,MAAM,yDAOV;QACD,QAAQ,CAAC,EAAE,aAAa,CAAC;QACzB,GAAG,EAAE,MAAM,CAAC;QACZ,QAAQ,EAAE,MAAM,CAAC;QACjB,UAAU,CAAC,EAAE,MAAM,CAAC;QACpB,WAAW,EAAE,MAAM,CAAC;KACrB,GACA,iBAAiB;IAkDpB;;;;;;;;OAQG;oCAEW,iBAAiB,UACrB,MAAM,UACN,MAAM,GACb,iBAAiB;IA2BpB;;;;;;;;OAQG;yCAEW,iBAAiB,eAChB,MAAM,eACN,MAAM,GAClB,iBAAiB;CAYrB,CAAC;AAEF,eAAe,MAAM,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/utils/wallet.js b/node_modules/@hathor/wallet-lib/oldLib/utils/wallet.js
new file mode 100644
index 0000000..e4a36e2
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/utils/wallet.js
@@ -0,0 +1,645 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+var _bitcoreLib = require("bitcore-lib");
+var _bitcoreMnemonic = _interopRequireDefault(require("bitcore-mnemonic"));
+var _lodash = _interopRequireDefault(require("lodash"));
+var _constants = require("../constants");
+var _opcodes = require("../opcodes");
+var _errors = require("../errors");
+var _network = _interopRequireDefault(require("../models/network"));
+var _helpers = _interopRequireDefault(require("./helpers"));
+var _types = require("../types");
+var _crypto = require("./crypto");
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+const wallet = {
+  /**
+   * Get the wallet id given the change path xpubkey
+   *
+   * @param {string} xpub - The change path xpubkey
+   * @returns {string} The walletId
+   *
+   * @memberof Wallet
+   * @inner
+   */
+  getWalletIdFromXPub(xpub) {
+    return _bitcoreLib.crypto.Hash.sha256sha256(Buffer.from(xpub)).toString('hex');
+  },
+  /**
+   * Verify if words passed to generate wallet are valid. In case of invalid, returns message
+   *
+   * @param {string} words Words (separated by space) to generate the HD Wallet seed
+   *
+   * @return {Object} {'valid': boolean, 'words': string} where 'words' is a cleaned
+   * string with the words separated by a single space
+   * @throws {InvalidWords} In case the words string is invalid. The error object will have
+   * an invalidWords attribute with an array of words that are not valid.
+   *
+   * @memberof Wallet
+   * @inner
+   */
+  wordsValid(words) {
+    if (!_lodash.default.isString(words)) {
+      // Must be string
+      throw new _errors.InvalidWords('Words must be a string.');
+    }
+    let newWordsString = '';
+    // 1. Replace all non ascii chars by a single space
+    // 2. Remove one or more spaces (or line breaks) before and after the 24 words
+    // 3. Set text to lower case
+    newWordsString = words.replace(/[^A-Za-z0-9]/g, ' ').replace(/\s+/g, ' ').trim().toLowerCase();
+    const wordsArray = newWordsString.split(' ');
+    const getInvalidWords = paramWords => {
+      const wordlist = _bitcoreMnemonic.default.Words.ENGLISH;
+      const errorList = [];
+      for (const word of paramWords) {
+        if (wordlist.indexOf(word) < 0) {
+          errorList.push(word);
+        }
+      }
+      return errorList;
+    };
+    if (wordsArray.length !== 24) {
+      // Must have 24 words
+      const err = new _errors.InvalidWords('Must have 24 words.');
+      err.invalidWords = getInvalidWords(wordsArray);
+      throw err;
+    } else if (!_bitcoreMnemonic.default.isValid(newWordsString)) {
+      // Check if there is a word that does not belong to the list of possible words
+      const errorList = getInvalidWords(wordsArray);
+      if (errorList.length > 0) {
+        const err = new _errors.InvalidWords('Invalid words.');
+        err.invalidWords = errorList;
+        throw err;
+      } else {
+        // Invalid sequence of words
+        throw new _errors.InvalidWords('Invalid sequence of words.');
+      }
+    }
+    return {
+      valid: true,
+      words: newWordsString
+    };
+  },
+  /**
+   * Generate HD wallet words
+   *
+   * @param {number} entropy Data to generate the HD Wallet seed - entropy (256 - to generate 24 words)
+   *
+   * @return {string} words generated
+   * @memberof Wallet
+   * @inner
+   */
+  generateWalletWords(entropy = _constants.HD_WALLET_ENTROPY) {
+    const code = new _bitcoreMnemonic.default(entropy);
+    return code.phrase;
+  },
+  /**
+   * Get xpub from data
+   *
+   * @param {Buffer} pubkey Compressed public key
+   * @param {Buffer} chainCode HDPublic key chaincode
+   * @param {Buffer} fingerprint parent fingerprint
+   * @param {string} networkName Optional parameter to select the used network (default is mainnet)
+   *
+   * @return {String} Xpub
+   *
+   * @memberof Wallet
+   * @inner
+   */
+  xpubFromData(pubkey, chainCode, fingerprint, networkName = 'mainnet') {
+    const network = new _network.default(networkName);
+    const hdpubkey = new _bitcoreLib.HDPublicKey({
+      network: network.bitcoreNetwork,
+      depth: 4,
+      parentFingerPrint: fingerprint,
+      childIndex: 0,
+      chainCode,
+      publicKey: pubkey
+    });
+    return hdpubkey.xpubkey;
+  },
+  /**
+   * Get compressed public key from uncompressed
+   *
+   * @param {Buffer} pubkey Uncompressed public key
+   *
+   * @return {Buffer} Compressed public key
+   * @throws {UncompressedPubKeyError} In case the given public key is invalid
+   *
+   * @memberof Wallet
+   * @inner
+   */
+  toPubkeyCompressed(pubkey) {
+    if (pubkey.length !== 65) {
+      throw new _errors.UncompressedPubKeyError('Invalid uncompressed public key size.');
+    }
+    const x = pubkey.slice(1, 33);
+    const y = pubkey.slice(33, 65);
+    const point = new _bitcoreLib.crypto.Point(x, y);
+    return _bitcoreLib.crypto.Point.pointToCompressed(point);
+  },
+  /**
+   * Get public key for specific key index derivation.
+   * We expect to receive the xpub after the derivation and the index to get the public key
+   * Example: to get the public key of the path m/44'/280/0'/0/{index}
+   * you must send in this method the xpubkey from m/44'/280/0'/0 and the index you want to derive
+   *
+   * @param {String} xpubkey Xpub of the path before the last derivation
+   * @param {number?} index Index of the key to derive, if not present no derivation will be made.
+   *
+   * @return {Object} Public key object
+   * @throws {XPubError} In case the given xpub key is invalid
+   *
+   * @memberof Wallet
+   * @inner
+   */
+  getPublicKeyFromXpub(xpubkey, index) {
+    let xpub;
+    try {
+      xpub = (0, _bitcoreLib.HDPublicKey)(xpubkey);
+    } catch (error) {
+      if (error instanceof Error) {
+        throw new _errors.XPubError(error.message);
+      } else {
+        throw new _errors.XPubError(error);
+      }
+    }
+    if (index === undefined) {
+      return xpub.publicKey;
+    }
+    const key = xpub.deriveChild(index);
+    return key.publicKey;
+  },
+  /**
+   * Get xpubkey from xpriv
+   *
+   * @param {String} xpriv Private key
+   *
+   * @return {String} Wallet xpubkey
+   * @memberof Wallet
+   * @inner
+   */
+  getXPubKeyFromXPrivKey(xpriv) {
+    const privateKey = (0, _bitcoreLib.HDPrivateKey)(xpriv);
+    return privateKey.xpubkey;
+  },
+  /**
+   * Get xpubkey in account derivation path from seed
+   *
+   * @param {String} seed 24 words
+   * @param {Object} options Options with passphrase, networkName and accountDerivationIndex
+   *
+   * @return {String} Wallet xpubkey
+   * @memberof Wallet
+   * @inner
+   */
+  getXPubKeyFromSeed(seed, options = {}) {
+    const methodOptions = {
+      passphrase: '',
+      networkName: 'mainnet',
+      accountDerivationIndex: "0'",
+      ...options
+    };
+    const {
+      accountDerivationIndex
+    } = methodOptions;
+    const xpriv = this.getXPrivKeyFromSeed(seed, methodOptions);
+    // We have a fixed derivation until the coin index
+    // after that we can receive a different account index, which the default is 0'
+    const privkey = this.deriveXpriv(xpriv, accountDerivationIndex);
+    return privkey.xpubkey;
+  },
+  /**
+   * Get root privateKey from seed
+   *
+   * TODO: Change method name as we are not returning a xpriv
+   *
+   * @param {String} seed 24 words
+   * @param {Object} options Options with passphrase, networkName
+   *
+   * @return {HDPrivateKey} Root HDPrivateKey
+   * @memberof Wallet
+   * @inner
+   */
+  getXPrivKeyFromSeed(seed, options = {}) {
+    const methodOptions = {
+      passphrase: '',
+      networkName: 'mainnet',
+      ...options
+    };
+    const {
+      passphrase,
+      networkName
+    } = methodOptions;
+    const network = new _network.default(networkName);
+    const code = new _bitcoreMnemonic.default(seed);
+    return code.toHDPrivateKey(passphrase, network.bitcoreNetwork);
+  },
+  /**
+   * Derive xpriv from root to account derivation path
+   *
+   * TODO: Method name is misleading as we are returning a HDPrivateKey and not a xpriv, we should change it
+   *
+   * @param {string} accountDerivationIndex String with derivation index of account (can be hardened)
+   *
+   * @return {HDPrivateKey} Derived private key
+   * @memberof Wallet
+   * @inner
+   */
+  deriveXpriv(xpriv, accountDerivationIndex) {
+    return xpriv.deriveNonCompliantChild(`m/44'/${_constants.HATHOR_BIP44_CODE}'/${accountDerivationIndex}`);
+  },
+  /**
+   * Validate an xpubkey.
+   *
+   * @param {string} xpubkey The xpubkey
+   *
+   * @return {boolean} true if it's a valid xpubkey, false otherwise
+   * @memberof Wallet
+   * @inner
+   */
+  isXpubKeyValid(xpubkey) {
+    return _bitcoreLib.HDPublicKey.isValidSerialized(xpubkey);
+  },
+  /**
+   * Derive next step of child from xpub
+   *
+   * @param {string} xpubkey The xpubkey
+   * @param {number} derivationIndex Index to derive the xpub
+   *
+   * @return {string} Derived xpub
+   * @throws {XPubError} In case the given xpub key is invalid
+   * @memberof Wallet
+   * @inner
+   */
+  xpubDeriveChild(xpubkey, derivationIndex) {
+    let xpub;
+    try {
+      xpub = (0, _bitcoreLib.HDPublicKey)(xpubkey);
+    } catch (error) {
+      if (error instanceof Error) {
+        throw new _errors.XPubError(error.message);
+      } else {
+        throw new _errors.XPubError(error);
+      }
+    }
+    const derivedXpub = xpub.deriveChild(derivationIndex);
+    return derivedXpub.xpubkey;
+  },
+  /**
+   * Create a P2SH MultiSig redeem script
+   *
+   * @param {string[]} xpubs The list of xpubkeys involved in this MultiSig
+   * @param {number} numSignatures Minimum number of signatures to send a
+   * transaction with this MultiSig
+   * @param {number} index Index to derive the xpubs
+   *
+   * @return {Buffer} A buffer with the redeemScript
+   * @throws {XPubError} In case any of the given xpubs are invalid
+   * @memberof Wallet
+   * @inner
+   */
+  createP2SHRedeemScript(xpubs, numSignatures, index) {
+    const sortedXpubs = _lodash.default.sortBy(xpubs.map(xp => new _bitcoreLib.HDPublicKey(xp)), xpub => {
+      return xpub.publicKey.toString('hex');
+    });
+
+    // xpub comes derived to m/45'/280'/0'
+    // Derive to m/45'/280'/0'/0/index
+    const pubkeys = sortedXpubs.map(xpub => xpub.deriveChild(0).deriveChild(index).publicKey);
+
+    // bitcore-lib sorts the public keys by default before building the script
+    // noSorting prevents that and keeps our order
+    const redeemScript = _bitcoreLib.Script.buildMultisigOut(pubkeys, numSignatures, {
+      noSorting: true
+    });
+    return redeemScript.toBuffer();
+  },
+  /**
+   * Create a P2SH MultiSig input data from the signatures and redeemScript
+   *
+   * @param {Buffer[]} signatures The list of signatures collected from participants.
+   * @param {Buffer} redeemScript The redeemScript as a Buffer
+   *
+   * @return {Buffer} A buffer with the input data to send.
+   * @memberof Wallet
+   * @inner
+   */
+  getP2SHInputData(signatures, redeemScript) {
+    // numSignatures is the first opcode
+    const numSignatures = redeemScript.readUInt8(0) - _opcodes.OP_0.readUInt8(0);
+    if (signatures.length !== numSignatures) {
+      throw new Error('Signatures are incompatible with redeemScript');
+    }
+    const arr = [];
+    for (const sig of signatures) {
+      _helpers.default.pushDataToStack(arr, sig);
+    }
+    _helpers.default.pushDataToStack(arr, redeemScript);
+    return _bitcoreLib.util.buffer.concat(arr);
+  },
+  /**
+   * Create an HDPublicKey on P2SH MultiSig account path from the root xpriv
+   *
+   * @param {HDPrivateKey} xpriv HD private key used to derive the multisig xpub.
+   *
+   * @return {string} xpubkey at MultiSig account path
+   * @memberof Wallet
+   * @inner
+   */
+  getMultiSigXPubFromXPriv(xpriv) {
+    const derived = xpriv.deriveNonCompliantChild(_constants.P2SH_ACCT_PATH);
+    return derived.xpubkey;
+  },
+  /**
+   * Create an HDPublicKey on P2SH MultiSig account path from the seed
+   *
+   * @param {string} seed space separated list of words to use as seed.
+   * @param {Object} options Optionally inform passphrase and network (defaults to no passphrase and mainnet).
+   *
+   * @return {string} xpubkey at MultiSig account path
+   * @memberof Wallet
+   * @inner
+   */
+  getMultiSigXPubFromWords(seed, options = {}) {
+    const methodOptions = {
+      passphrase: '',
+      networkName: 'mainnet',
+      ...options
+    };
+    const xpriv = this.getXPrivKeyFromSeed(seed, methodOptions);
+    return this.getMultiSigXPubFromXPriv(xpriv);
+  },
+  /**
+   * Generate access data from xpubkey.
+   * The access data will be used to start a wallet and derive the wallet's addresses.
+   * This method can only generate READONLY wallets since we do not have the private key.
+   *
+   * We can only accept xpubs derived to the account or change path.
+   * Since hdpublickeys cannot derive on hardened paths, the derivation must be done previously with the private key
+   * The last path with hardened derivation defined on bip44 is the account path so we support using an account path xpub.
+   * We can also use the change path xpub since we use it to derive the addresses
+   * but we cannot use the address path xpub since we won't be able to derive all addresses.
+   * And the wallet-lib currently does not support the creation of a wallet with a single address.
+   *
+   * @param {string} xpubkey HDPublicKey in string format.
+   * @param {Object} [options={}] Options to generate the access data.
+   * @param {IMultisigData|undefined} [options.multisig=undefined] MultiSig data of the wallet
+   * @param {boolean} [options.hardware=false] If the wallet is a hardware wallet
+   * @returns {IWalletAccessData}
+   */
+  generateAccessDataFromXpub(xpubkey, {
+    multisig,
+    hardware = false
+  } = {}) {
+    let walletFlags = 0 | _types.WALLET_FLAGS.READONLY;
+    if (hardware) {
+      walletFlags |= _types.WALLET_FLAGS.HARDWARE;
+    }
+    let walletType;
+    if (multisig === undefined) {
+      walletType = _types.WalletType.P2PKH;
+    } else {
+      walletType = _types.WalletType.MULTISIG;
+    }
+    // HDPublicKeys cannot derive on hardened paths, so the derivation must be done previously with the xprivkey.
+    // So we assume the user sent an xpub derived to the account level.
+
+    const argXpub = new _bitcoreLib.HDPublicKey(xpubkey);
+    let multisigData;
+    let xpub;
+    if (argXpub.depth === 3) {
+      // This is an account path xpub which we expect was derived to the path m/45'/280'/0'
+      xpub = argXpub.derive(0);
+      if (multisig) {
+        // A multisig wallet requires the account path publickey to determine which participant this wallet is.
+        // Since we have the account path xpub we can initialize the readonly multisig wallet.
+        multisigData = {
+          ...multisig,
+          pubkey: argXpub.publicKey.toString('hex')
+        };
+      } else {
+        multisigData = undefined;
+      }
+    } else if (argXpub.depth === 4) {
+      // This is a change path xpub which we expect was derived to the path m/45'/280'/0'/0
+      xpub = argXpub;
+      if (multisig) {
+        // A multisig wallet requires the account path publickey to determine which participant this wallet is.
+        // Since we cannot get the account path publickey we must stop the wallet creation.
+        throw new Error('Cannot create a multisig wallet with a change path xpub');
+      }
+    } else {
+      // We currently only support account path and change path xpubs.
+      throw new Error('Invalid xpub');
+    }
+    return {
+      // Change path hdpublickey in string format
+      xpubkey: xpub.xpubkey,
+      walletType,
+      multisigData,
+      // We force the readonly flag because we are starting a wallet without the private key
+      walletFlags
+    };
+  },
+  /**
+   * Generate access data from the xprivkey.
+   * We can use either the root xprivkey or the change path xprivkey.
+   * Obs: A multisig wallet cannot be started with a change path xprivkey.
+   *
+   * The seed can be passed so we save it on the storage, even if its not used.
+   * Obs: must also pass password to encrypt the seed.
+   *
+   * @param {string} xprivkey
+   * @param {Object} options
+   * @param {IMultisigData | undefined} [options.multisig=undefined]
+   * @param {string} [options.pin]
+   * @param {string | undefined} [options.seed=undefined]
+   * @param {string | undefined} [options.password=undefined]
+   * @param {string | undefined} [options.authXpriv=undefined]
+   * @returns {IWalletAccessData}
+   */
+  generateAccessDataFromXpriv(xprivkey, {
+    multisig,
+    pin,
+    seed,
+    password,
+    authXpriv
+  }) {
+    let walletType;
+    if (multisig === undefined) {
+      walletType = _types.WalletType.P2PKH;
+    } else {
+      walletType = _types.WalletType.MULTISIG;
+    }
+    const argXpriv = new _bitcoreLib.HDPrivateKey(xprivkey);
+    let xpriv;
+    let acctXpriv = null;
+    let derivedAuthKey = null;
+    if (argXpriv.depth === 0) {
+      derivedAuthKey = argXpriv.deriveNonCompliantChild(_constants.WALLET_SERVICE_AUTH_DERIVATION_PATH);
+      if (walletType === _types.WalletType.MULTISIG) {
+        acctXpriv = argXpriv.deriveNonCompliantChild(_constants.P2SH_ACCT_PATH);
+        xpriv = acctXpriv.deriveNonCompliantChild(0);
+      } else {
+        acctXpriv = argXpriv.deriveNonCompliantChild(_constants.P2PKH_ACCT_PATH);
+        xpriv = acctXpriv.deriveNonCompliantChild(0);
+      }
+    } else {
+      if (walletType === _types.WalletType.MULTISIG) {
+        throw new Error('Cannot start a multisig wallet with a derived xpriv');
+      }
+      xpriv = argXpriv;
+    }
+    const encryptedMainKey = (0, _crypto.encryptData)(xpriv.xprivkey, pin);
+    let multisigData;
+    if (multisig === undefined) {
+      multisigData = undefined;
+    } else {
+      // For multisig wallets we need to save the pubkey of the account path
+      const derivedXpriv = argXpriv.deriveNonCompliantChild(_constants.P2SH_ACCT_PATH);
+      multisigData = {
+        pubkey: derivedXpriv.publicKey.toString('hex'),
+        ...multisig
+      };
+    }
+    const accessData = {
+      walletType,
+      multisigData,
+      mainKey: encryptedMainKey,
+      xpubkey: xpriv.xpubkey,
+      walletFlags: 0
+    };
+    if (acctXpriv !== null) {
+      // Account path key will only be available if the provided key is a root key
+      const encryptedAcctPathKey = (0, _crypto.encryptData)(acctXpriv.xprivkey, pin);
+      accessData.acctPathKey = encryptedAcctPathKey;
+    }
+    if (authXpriv || derivedAuthKey) {
+      let authKey;
+      if (authXpriv) {
+        authKey = (0, _crypto.encryptData)(authXpriv, pin);
+      } else {
+        authKey = (0, _crypto.encryptData)(derivedAuthKey.xprivkey, pin);
+      }
+      accessData.authKey = authKey;
+    }
+    if (seed && password) {
+      const encryptedWords = (0, _crypto.encryptData)(seed, password);
+      accessData.words = encryptedWords;
+    }
+    return accessData;
+  },
+  generateAccessDataFromSeed(words, {
+    multisig,
+    passphrase = '',
+    pin,
+    password,
+    networkName
+  }) {
+    let walletType;
+    if (multisig === undefined) {
+      walletType = _types.WalletType.P2PKH;
+    } else {
+      walletType = _types.WalletType.MULTISIG;
+    }
+    const code = new _bitcoreMnemonic.default(words);
+    const rootXpriv = code.toHDPrivateKey(passphrase, new _network.default(networkName));
+    const authXpriv = rootXpriv.deriveNonCompliantChild(_constants.WALLET_SERVICE_AUTH_DERIVATION_PATH);
+    let accXpriv;
+    let xpriv;
+    if (walletType === _types.WalletType.MULTISIG) {
+      accXpriv = rootXpriv.deriveNonCompliantChild(_constants.P2SH_ACCT_PATH);
+      xpriv = accXpriv.deriveNonCompliantChild(0);
+    } else {
+      accXpriv = rootXpriv.deriveNonCompliantChild(_constants.P2PKH_ACCT_PATH);
+      xpriv = accXpriv.deriveNonCompliantChild(0);
+    }
+    const encryptedMainKey = (0, _crypto.encryptData)(xpriv.xprivkey, pin);
+    const encryptedAcctPathKey = (0, _crypto.encryptData)(accXpriv.xprivkey, pin);
+    const encryptedAuthPathKey = (0, _crypto.encryptData)(authXpriv.xprivkey, pin);
+    const encryptedWords = (0, _crypto.encryptData)(words, password);
+    let multisigData;
+    if (multisig === undefined) {
+      multisigData = undefined;
+    } else {
+      // For multisig wallets we need to save the pubkey of the account path
+      multisigData = {
+        pubkey: accXpriv.publicKey.toString('hex'),
+        ...multisig
+      };
+    }
+    return {
+      walletType,
+      multisigData,
+      xpubkey: xpriv.xpubkey,
+      mainKey: encryptedMainKey,
+      acctPathKey: encryptedAcctPathKey,
+      authKey: encryptedAuthPathKey,
+      words: encryptedWords,
+      walletFlags: 0
+    };
+  },
+  /**
+   * Change the encryption pin on the fields that are encrypted using the pin.
+   * Will not save the access data, only return the new access data.
+   *
+   * @param {IWalletAccessData} accessData The current access data encrypted with `oldPin`.
+   * @param {string} oldPin Used to decrypt the old access data.
+   * @param {string} newPin Encrypt the fields with this pin.
+   * @returns {IWalletAccessData} The access data with fields encrypted with `newPin`.
+   */
+  changeEncryptionPin(accessData, oldPin, newPin) {
+    const data = _lodash.default.cloneDeep(accessData);
+    if (!(data.mainKey || data.authKey || data.acctPathKey)) {
+      throw new Error('No data to change');
+    }
+    if (data.mainKey) {
+      const mainKey = (0, _crypto.decryptData)(data.mainKey, oldPin);
+      const newEncryptedMainKey = (0, _crypto.encryptData)(mainKey, newPin);
+      data.mainKey = newEncryptedMainKey;
+    }
+    if (data.authKey) {
+      const authKey = (0, _crypto.decryptData)(data.authKey, oldPin);
+      const newEncryptedAuthKey = (0, _crypto.encryptData)(authKey, newPin);
+      data.authKey = newEncryptedAuthKey;
+    }
+    if (data.acctPathKey) {
+      const acctPathKey = (0, _crypto.decryptData)(data.acctPathKey, oldPin);
+      const newEncryptedAcctPathKey = (0, _crypto.encryptData)(acctPathKey, newPin);
+      data.acctPathKey = newEncryptedAcctPathKey;
+    }
+    return data;
+  },
+  /**
+   * Change the encryption password on the seed.
+   * Will not save the access data, only return the new access data.
+   *
+   * @param {IWalletAccessData} accessData The current access data encrypted with `oldPassword`.
+   * @param {string} oldPassword Used to decrypt the old access data.
+   * @param {string} newPassword Encrypt the seed with this password.
+   * @returns {IWalletAccessData} The access data with fields encrypted with `newPassword`.
+   */
+  changeEncryptionPassword(accessData, oldPassword, newPassword) {
+    const data = _lodash.default.cloneDeep(accessData);
+    if (!data.words) {
+      throw new Error('No data to change');
+    }
+    const words = (0, _crypto.decryptData)(data.words, oldPassword);
+    const newEncryptedWords = (0, _crypto.encryptData)(words, newPassword);
+    data.words = newEncryptedWords;
+    return data;
+  }
+};
+var _default = exports.default = wallet;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/wallet/api/schemas/walletApi.d.ts b/node_modules/@hathor/wallet-lib/oldLib/wallet/api/schemas/walletApi.d.ts
new file mode 100644
index 0000000..ad07877
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/wallet/api/schemas/walletApi.d.ts
@@ -0,0 +1,3595 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+import { z } from 'zod';
+/**
+ * Schema for validating Hathor addresses.
+ * Addresses are base58 encoded and must be 34-35 characters long.
+ * They can only contain characters from the base58 alphabet.
+ */
+export declare const AddressSchema: z.ZodString;
+/**
+ * Schema for validating BIP44 derivation paths.
+ * Must start with 'm' followed by zero or more segments.
+ * Each segment starts with '/' followed by numbers and may end with a single quote (').
+ * Example: m/44'/280'/0'/0/0
+ */
+export declare const AddressPathSchema: z.ZodString;
+/**
+ * Schema for individual address information.
+ * Represents a single address in the wallet with its derivation index and transaction count.
+ */
+export declare const getAddressesObjectSchema: z.ZodObject<{
+    address: z.ZodString;
+    index: z.ZodNumber;
+    transactions: z.ZodNumber;
+}, "strip", z.ZodTypeAny, {
+    index: number;
+    address: string;
+    transactions: number;
+}, {
+    index: number;
+    address: string;
+    transactions: number;
+}>;
+/**
+ * Response schema for getting all addresses in the wallet.
+ */
+export declare const addressesResponseSchema: z.ZodObject<z.objectUtil.extendShape<{
+    success: z.ZodBoolean;
+}, {
+    addresses: z.ZodArray<z.ZodObject<{
+        address: z.ZodString;
+        index: z.ZodNumber;
+        transactions: z.ZodNumber;
+    }, "strip", z.ZodTypeAny, {
+        index: number;
+        address: string;
+        transactions: number;
+    }, {
+        index: number;
+        address: string;
+        transactions: number;
+    }>, "many">;
+}>, "strip", z.ZodTypeAny, {
+    success: boolean;
+    addresses: {
+        index: number;
+        address: string;
+        transactions: number;
+    }[];
+}, {
+    success: boolean;
+    addresses: {
+        index: number;
+        address: string;
+        transactions: number;
+    }[];
+}>;
+/**
+ * Response schema for checking if addresses belong to the wallet.
+ * Maps addresses to boolean values indicating ownership.
+ */
+export declare const checkAddressesMineResponseSchema: z.ZodObject<z.objectUtil.extendShape<{
+    success: z.ZodBoolean;
+}, {
+    addresses: z.ZodRecord<z.ZodString, z.ZodBoolean>;
+}>, "strip", z.ZodTypeAny, {
+    success: boolean;
+    addresses: Record<string, boolean>;
+}, {
+    success: boolean;
+    addresses: Record<string, boolean>;
+}>;
+/**
+ * Schema for address information used in new address generation.
+ */
+export declare const addressInfoObjectSchema: z.ZodObject<{
+    address: z.ZodString;
+    index: z.ZodNumber;
+    addressPath: z.ZodString;
+    info: z.ZodOptional<z.ZodString>;
+}, "strict", z.ZodTypeAny, {
+    index: number;
+    address: string;
+    addressPath: string;
+    info?: string | undefined;
+}, {
+    index: number;
+    address: string;
+    addressPath: string;
+    info?: string | undefined;
+}>;
+/**
+ * Response schema for generating new addresses.
+ */
+export declare const newAddressesResponseSchema: z.ZodObject<z.objectUtil.extendShape<{
+    success: z.ZodBoolean;
+}, {
+    addresses: z.ZodArray<z.ZodObject<{
+        address: z.ZodString;
+        index: z.ZodNumber;
+        addressPath: z.ZodString;
+        info: z.ZodOptional<z.ZodString>;
+    }, "strict", z.ZodTypeAny, {
+        index: number;
+        address: string;
+        addressPath: string;
+        info?: string | undefined;
+    }, {
+        index: number;
+        address: string;
+        addressPath: string;
+        info?: string | undefined;
+    }>, "many">;
+}>, "strip", z.ZodTypeAny, {
+    success: boolean;
+    addresses: {
+        index: number;
+        address: string;
+        addressPath: string;
+        info?: string | undefined;
+    }[];
+}, {
+    success: boolean;
+    addresses: {
+        index: number;
+        address: string;
+        addressPath: string;
+        info?: string | undefined;
+    }[];
+}>;
+/**
+ * TokenId schema
+ */
+export declare const tokenIdSchema: z.ZodUnion<[z.ZodString, z.ZodLiteral<string>]>;
+/**
+ * Schema for token information.
+ */
+export declare const tokenInfoSchema: z.ZodObject<{
+    id: z.ZodUnion<[z.ZodString, z.ZodLiteral<string>]>;
+    name: z.ZodString;
+    symbol: z.ZodString;
+}, "strip", z.ZodTypeAny, {
+    symbol: string;
+    id: string;
+    name: string;
+}, {
+    symbol: string;
+    id: string;
+    name: string;
+}>;
+/**
+ * Response schema for token details.
+ * Contains information about a token's name, symbol, total supply, and authorities.
+ */
+export declare const tokenDetailsResponseSchema: z.ZodObject<z.objectUtil.extendShape<{
+    success: z.ZodBoolean;
+}, {
+    details: z.ZodObject<{
+        tokenInfo: z.ZodObject<{
+            id: z.ZodUnion<[z.ZodString, z.ZodLiteral<string>]>;
+            name: z.ZodString;
+            symbol: z.ZodString;
+        }, "strip", z.ZodTypeAny, {
+            symbol: string;
+            id: string;
+            name: string;
+        }, {
+            symbol: string;
+            id: string;
+            name: string;
+        }>;
+        totalSupply: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+        totalTransactions: z.ZodNumber;
+        authorities: z.ZodObject<{
+            mint: z.ZodBoolean;
+            melt: z.ZodBoolean;
+        }, "strip", z.ZodTypeAny, {
+            mint: boolean;
+            melt: boolean;
+        }, {
+            mint: boolean;
+            melt: boolean;
+        }>;
+    }, "strip", z.ZodTypeAny, {
+        authorities: {
+            mint: boolean;
+            melt: boolean;
+        };
+        tokenInfo: {
+            symbol: string;
+            id: string;
+            name: string;
+        };
+        totalSupply: bigint;
+        totalTransactions: number;
+    }, {
+        authorities: {
+            mint: boolean;
+            melt: boolean;
+        };
+        tokenInfo: {
+            symbol: string;
+            id: string;
+            name: string;
+        };
+        totalSupply: string | number | bigint;
+        totalTransactions: number;
+    }>;
+}>, "strip", z.ZodTypeAny, {
+    details: {
+        authorities: {
+            mint: boolean;
+            melt: boolean;
+        };
+        tokenInfo: {
+            symbol: string;
+            id: string;
+            name: string;
+        };
+        totalSupply: bigint;
+        totalTransactions: number;
+    };
+    success: boolean;
+}, {
+    details: {
+        authorities: {
+            mint: boolean;
+            melt: boolean;
+        };
+        tokenInfo: {
+            symbol: string;
+            id: string;
+            name: string;
+        };
+        totalSupply: string | number | bigint;
+        totalTransactions: number;
+    };
+    success: boolean;
+}>;
+/**
+ * Schema for token balance information.
+ * Represents both unlocked and locked balances for a token.
+ */
+export declare const balanceSchema: z.ZodObject<{
+    unlocked: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+    locked: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+}, "strip", z.ZodTypeAny, {
+    locked: bigint;
+    unlocked: bigint;
+}, {
+    locked: string | number | bigint;
+    unlocked: string | number | bigint;
+}>;
+/**
+ * Schema for token authority balances.
+ * Represents mint and melt authority balances in both unlocked and locked states.
+ */
+export declare const authorityBalanceSchema: z.ZodObject<{
+    unlocked: z.ZodObject<{
+        mint: z.ZodBoolean;
+        melt: z.ZodBoolean;
+    }, "strip", z.ZodTypeAny, {
+        mint: boolean;
+        melt: boolean;
+    }, {
+        mint: boolean;
+        melt: boolean;
+    }>;
+    locked: z.ZodObject<{
+        mint: z.ZodBoolean;
+        melt: z.ZodBoolean;
+    }, "strip", z.ZodTypeAny, {
+        mint: boolean;
+        melt: boolean;
+    }, {
+        mint: boolean;
+        melt: boolean;
+    }>;
+}, "strip", z.ZodTypeAny, {
+    locked: {
+        mint: boolean;
+        melt: boolean;
+    };
+    unlocked: {
+        mint: boolean;
+        melt: boolean;
+    };
+}, {
+    locked: {
+        mint: boolean;
+        melt: boolean;
+    };
+    unlocked: {
+        mint: boolean;
+        melt: boolean;
+    };
+}>;
+/**
+ * Schema for balance object.
+ * Contains token info, balance, authorities, and transaction count.
+ */
+export declare const getBalanceObjectSchema: z.ZodObject<{
+    token: z.ZodObject<{
+        id: z.ZodUnion<[z.ZodString, z.ZodLiteral<string>]>;
+        name: z.ZodString;
+        symbol: z.ZodString;
+    }, "strip", z.ZodTypeAny, {
+        symbol: string;
+        id: string;
+        name: string;
+    }, {
+        symbol: string;
+        id: string;
+        name: string;
+    }>;
+    balance: z.ZodObject<{
+        unlocked: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+        locked: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+    }, "strip", z.ZodTypeAny, {
+        locked: bigint;
+        unlocked: bigint;
+    }, {
+        locked: string | number | bigint;
+        unlocked: string | number | bigint;
+    }>;
+    tokenAuthorities: z.ZodObject<{
+        unlocked: z.ZodObject<{
+            mint: z.ZodBoolean;
+            melt: z.ZodBoolean;
+        }, "strip", z.ZodTypeAny, {
+            mint: boolean;
+            melt: boolean;
+        }, {
+            mint: boolean;
+            melt: boolean;
+        }>;
+        locked: z.ZodObject<{
+            mint: z.ZodBoolean;
+            melt: z.ZodBoolean;
+        }, "strip", z.ZodTypeAny, {
+            mint: boolean;
+            melt: boolean;
+        }, {
+            mint: boolean;
+            melt: boolean;
+        }>;
+    }, "strip", z.ZodTypeAny, {
+        locked: {
+            mint: boolean;
+            melt: boolean;
+        };
+        unlocked: {
+            mint: boolean;
+            melt: boolean;
+        };
+    }, {
+        locked: {
+            mint: boolean;
+            melt: boolean;
+        };
+        unlocked: {
+            mint: boolean;
+            melt: boolean;
+        };
+    }>;
+    transactions: z.ZodNumber;
+    lockExpires: z.ZodNullable<z.ZodNumber>;
+}, "strip", z.ZodTypeAny, {
+    balance: {
+        locked: bigint;
+        unlocked: bigint;
+    };
+    token: {
+        symbol: string;
+        id: string;
+        name: string;
+    };
+    transactions: number;
+    tokenAuthorities: {
+        locked: {
+            mint: boolean;
+            melt: boolean;
+        };
+        unlocked: {
+            mint: boolean;
+            melt: boolean;
+        };
+    };
+    lockExpires: number | null;
+}, {
+    balance: {
+        locked: string | number | bigint;
+        unlocked: string | number | bigint;
+    };
+    token: {
+        symbol: string;
+        id: string;
+        name: string;
+    };
+    transactions: number;
+    tokenAuthorities: {
+        locked: {
+            mint: boolean;
+            melt: boolean;
+        };
+        unlocked: {
+            mint: boolean;
+            melt: boolean;
+        };
+    };
+    lockExpires: number | null;
+}>;
+/**
+ * Response schema for token balances.
+ * Contains an array of balance objects for each token.
+ */
+export declare const balanceResponseSchema: z.ZodObject<z.objectUtil.extendShape<{
+    success: z.ZodBoolean;
+}, {
+    balances: z.ZodArray<z.ZodObject<{
+        token: z.ZodObject<{
+            id: z.ZodUnion<[z.ZodString, z.ZodLiteral<string>]>;
+            name: z.ZodString;
+            symbol: z.ZodString;
+        }, "strip", z.ZodTypeAny, {
+            symbol: string;
+            id: string;
+            name: string;
+        }, {
+            symbol: string;
+            id: string;
+            name: string;
+        }>;
+        balance: z.ZodObject<{
+            unlocked: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            locked: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+        }, "strip", z.ZodTypeAny, {
+            locked: bigint;
+            unlocked: bigint;
+        }, {
+            locked: string | number | bigint;
+            unlocked: string | number | bigint;
+        }>;
+        tokenAuthorities: z.ZodObject<{
+            unlocked: z.ZodObject<{
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }, "strip", z.ZodTypeAny, {
+                mint: boolean;
+                melt: boolean;
+            }, {
+                mint: boolean;
+                melt: boolean;
+            }>;
+            locked: z.ZodObject<{
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }, "strip", z.ZodTypeAny, {
+                mint: boolean;
+                melt: boolean;
+            }, {
+                mint: boolean;
+                melt: boolean;
+            }>;
+        }, "strip", z.ZodTypeAny, {
+            locked: {
+                mint: boolean;
+                melt: boolean;
+            };
+            unlocked: {
+                mint: boolean;
+                melt: boolean;
+            };
+        }, {
+            locked: {
+                mint: boolean;
+                melt: boolean;
+            };
+            unlocked: {
+                mint: boolean;
+                melt: boolean;
+            };
+        }>;
+        transactions: z.ZodNumber;
+        lockExpires: z.ZodNullable<z.ZodNumber>;
+    }, "strip", z.ZodTypeAny, {
+        balance: {
+            locked: bigint;
+            unlocked: bigint;
+        };
+        token: {
+            symbol: string;
+            id: string;
+            name: string;
+        };
+        transactions: number;
+        tokenAuthorities: {
+            locked: {
+                mint: boolean;
+                melt: boolean;
+            };
+            unlocked: {
+                mint: boolean;
+                melt: boolean;
+            };
+        };
+        lockExpires: number | null;
+    }, {
+        balance: {
+            locked: string | number | bigint;
+            unlocked: string | number | bigint;
+        };
+        token: {
+            symbol: string;
+            id: string;
+            name: string;
+        };
+        transactions: number;
+        tokenAuthorities: {
+            locked: {
+                mint: boolean;
+                melt: boolean;
+            };
+            unlocked: {
+                mint: boolean;
+                melt: boolean;
+            };
+        };
+        lockExpires: number | null;
+    }>, "many">;
+}>, "strip", z.ZodTypeAny, {
+    success: boolean;
+    balances: {
+        balance: {
+            locked: bigint;
+            unlocked: bigint;
+        };
+        token: {
+            symbol: string;
+            id: string;
+            name: string;
+        };
+        transactions: number;
+        tokenAuthorities: {
+            locked: {
+                mint: boolean;
+                melt: boolean;
+            };
+            unlocked: {
+                mint: boolean;
+                melt: boolean;
+            };
+        };
+        lockExpires: number | null;
+    }[];
+}, {
+    success: boolean;
+    balances: {
+        balance: {
+            locked: string | number | bigint;
+            unlocked: string | number | bigint;
+        };
+        token: {
+            symbol: string;
+            id: string;
+            name: string;
+        };
+        transactions: number;
+        tokenAuthorities: {
+            locked: {
+                mint: boolean;
+                melt: boolean;
+            };
+            unlocked: {
+                mint: boolean;
+                melt: boolean;
+            };
+        };
+        lockExpires: number | null;
+    }[];
+}>;
+/**
+ * Schema for transaction proposal inputs.
+ * Represents the inputs that will be used in a transaction.
+ */
+export declare const txProposalInputsSchema: z.ZodObject<{
+    txId: z.ZodString;
+    index: z.ZodNumber;
+    addressPath: z.ZodString;
+}, "strip", z.ZodTypeAny, {
+    index: number;
+    txId: string;
+    addressPath: string;
+}, {
+    index: number;
+    txId: string;
+    addressPath: string;
+}>;
+/**
+ * Schema for transaction proposal outputs.
+ * Represents the outputs that will be created in a transaction.
+ */
+export declare const txProposalOutputsSchema: z.ZodObject<{
+    address: z.ZodString;
+    value: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+    token: z.ZodUnion<[z.ZodString, z.ZodLiteral<string>]>;
+    timelock: z.ZodNullable<z.ZodNumber>;
+}, "strip", z.ZodTypeAny, {
+    address: string;
+    value: bigint;
+    timelock: number | null;
+    token: string;
+}, {
+    address: string;
+    value: string | number | bigint;
+    timelock: number | null;
+    token: string;
+}>;
+/**
+ * Response schema for creating a transaction proposal.
+ * Contains the proposal ID and the transaction details.
+ */
+export declare const txProposalCreateResponseSchema: z.ZodObject<z.objectUtil.extendShape<{
+    success: z.ZodBoolean;
+}, {
+    txProposalId: z.ZodString;
+    inputs: z.ZodArray<z.ZodObject<{
+        txId: z.ZodString;
+        index: z.ZodNumber;
+        addressPath: z.ZodString;
+    }, "strip", z.ZodTypeAny, {
+        index: number;
+        txId: string;
+        addressPath: string;
+    }, {
+        index: number;
+        txId: string;
+        addressPath: string;
+    }>, "many">;
+}>, "strip", z.ZodTypeAny, {
+    success: boolean;
+    inputs: {
+        index: number;
+        txId: string;
+        addressPath: string;
+    }[];
+    txProposalId: string;
+}, {
+    success: boolean;
+    inputs: {
+        index: number;
+        txId: string;
+        addressPath: string;
+    }[];
+    txProposalId: string;
+}>;
+/**
+ * Response schema for updating a transaction proposal.
+ * Contains the proposal ID and the transaction hex.
+ */
+export declare const txProposalUpdateResponseSchema: z.ZodObject<z.objectUtil.extendShape<{
+    success: z.ZodBoolean;
+}, {
+    txProposalId: z.ZodString;
+    txHex: z.ZodString;
+}>, "strip", z.ZodTypeAny, {
+    success: boolean;
+    txProposalId: string;
+    txHex: string;
+}, {
+    success: boolean;
+    txProposalId: string;
+    txHex: string;
+}>;
+/**
+ * Schema for full node version data.
+ * Contains network parameters and configuration values.
+ * Uses passthrough() to allow additional fields in the response without breaking validation,
+ * as the full node may add new fields in future versions without changing the API version.
+ */
+export declare const fullNodeVersionDataSchema: z.ZodObject<{
+    timestamp: z.ZodNumber;
+    version: z.ZodString;
+    network: z.ZodString;
+    minWeight: z.ZodNumber;
+    minTxWeight: z.ZodNumber;
+    minTxWeightCoefficient: z.ZodNumber;
+    minTxWeightK: z.ZodNumber;
+    tokenDepositPercentage: z.ZodNumber;
+    rewardSpendMinBlocks: z.ZodNumber;
+    maxNumberInputs: z.ZodNumber;
+    maxNumberOutputs: z.ZodNumber;
+    decimalPlaces: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+    genesisBlockHash: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+    genesisTx1Hash: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+    genesisTx2Hash: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+}, "passthrough", z.ZodTypeAny, z.objectOutputType<{
+    timestamp: z.ZodNumber;
+    version: z.ZodString;
+    network: z.ZodString;
+    minWeight: z.ZodNumber;
+    minTxWeight: z.ZodNumber;
+    minTxWeightCoefficient: z.ZodNumber;
+    minTxWeightK: z.ZodNumber;
+    tokenDepositPercentage: z.ZodNumber;
+    rewardSpendMinBlocks: z.ZodNumber;
+    maxNumberInputs: z.ZodNumber;
+    maxNumberOutputs: z.ZodNumber;
+    decimalPlaces: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+    genesisBlockHash: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+    genesisTx1Hash: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+    genesisTx2Hash: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+}, z.ZodTypeAny, "passthrough">, z.objectInputType<{
+    timestamp: z.ZodNumber;
+    version: z.ZodString;
+    network: z.ZodString;
+    minWeight: z.ZodNumber;
+    minTxWeight: z.ZodNumber;
+    minTxWeightCoefficient: z.ZodNumber;
+    minTxWeightK: z.ZodNumber;
+    tokenDepositPercentage: z.ZodNumber;
+    rewardSpendMinBlocks: z.ZodNumber;
+    maxNumberInputs: z.ZodNumber;
+    maxNumberOutputs: z.ZodNumber;
+    decimalPlaces: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+    genesisBlockHash: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+    genesisTx1Hash: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+    genesisTx2Hash: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+}, z.ZodTypeAny, "passthrough">>;
+/**
+ * Schema for full node transaction inputs.
+ * Represents the inputs of a transaction as seen by the full node.
+ */
+export declare const fullNodeInputSchema: z.ZodObject<{
+    value: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+    token_data: z.ZodNumber;
+    script: z.ZodString;
+    decoded: z.ZodObject<{
+        type: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+        address: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+        timelock: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+        value: z.ZodOptional<z.ZodNullable<z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>>>;
+        token_data: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+    }, "strip", z.ZodTypeAny, {
+        type?: string | null | undefined;
+        address?: string | null | undefined;
+        value?: bigint | null | undefined;
+        timelock?: number | null | undefined;
+        token_data?: number | null | undefined;
+    }, {
+        type?: string | null | undefined;
+        address?: string | null | undefined;
+        value?: string | number | bigint | null | undefined;
+        timelock?: number | null | undefined;
+        token_data?: number | null | undefined;
+    }>;
+    tx_id: z.ZodString;
+    index: z.ZodNumber;
+    token: z.ZodOptional<z.ZodNullable<z.ZodUnion<[z.ZodString, z.ZodLiteral<string>]>>>;
+    spent_by: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+}, "strip", z.ZodTypeAny, {
+    index: number;
+    value: bigint;
+    script: string;
+    token_data: number;
+    decoded: {
+        type?: string | null | undefined;
+        address?: string | null | undefined;
+        value?: bigint | null | undefined;
+        timelock?: number | null | undefined;
+        token_data?: number | null | undefined;
+    };
+    tx_id: string;
+    token?: string | null | undefined;
+    spent_by?: string | null | undefined;
+}, {
+    index: number;
+    value: string | number | bigint;
+    script: string;
+    token_data: number;
+    decoded: {
+        type?: string | null | undefined;
+        address?: string | null | undefined;
+        value?: string | number | bigint | null | undefined;
+        timelock?: number | null | undefined;
+        token_data?: number | null | undefined;
+    };
+    tx_id: string;
+    token?: string | null | undefined;
+    spent_by?: string | null | undefined;
+}>;
+/**
+ * Schema for full node transaction outputs.
+ * Represents the outputs of a transaction as seen by the full node.
+ */
+export declare const fullNodeOutputSchema: z.ZodObject<{
+    value: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+    token_data: z.ZodNumber;
+    script: z.ZodString;
+    decoded: z.ZodObject<{
+        type: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+        address: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+        timelock: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+        value: z.ZodOptional<z.ZodNullable<z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>>>;
+        token_data: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+    }, "strip", z.ZodTypeAny, {
+        type?: string | null | undefined;
+        address?: string | null | undefined;
+        value?: bigint | null | undefined;
+        timelock?: number | null | undefined;
+        token_data?: number | null | undefined;
+    }, {
+        type?: string | null | undefined;
+        address?: string | null | undefined;
+        value?: string | number | bigint | null | undefined;
+        timelock?: number | null | undefined;
+        token_data?: number | null | undefined;
+    }>;
+    address: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+    token: z.ZodOptional<z.ZodNullable<z.ZodUnion<[z.ZodString, z.ZodLiteral<string>]>>>;
+    authorities: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+    timelock: z.ZodNullable<z.ZodNumber>;
+}, "strip", z.ZodTypeAny, {
+    value: bigint;
+    script: string;
+    timelock: number | null;
+    authorities: bigint;
+    token_data: number;
+    decoded: {
+        type?: string | null | undefined;
+        address?: string | null | undefined;
+        value?: bigint | null | undefined;
+        timelock?: number | null | undefined;
+        token_data?: number | null | undefined;
+    };
+    address?: string | null | undefined;
+    token?: string | null | undefined;
+}, {
+    value: string | number | bigint;
+    script: string;
+    timelock: number | null;
+    authorities: string | number | bigint;
+    token_data: number;
+    decoded: {
+        type?: string | null | undefined;
+        address?: string | null | undefined;
+        value?: string | number | bigint | null | undefined;
+        timelock?: number | null | undefined;
+        token_data?: number | null | undefined;
+    };
+    address?: string | null | undefined;
+    token?: string | null | undefined;
+}>;
+/**
+ * Schema for full node token information.
+ * Represents token details as seen by the full node.
+ */
+export declare const fullNodeTokenSchema: z.ZodObject<{
+    uid: z.ZodString;
+    name: z.ZodString;
+    symbol: z.ZodString;
+    amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+}, "strip", z.ZodTypeAny, {
+    symbol: string;
+    name: string;
+    amount: bigint;
+    uid: string;
+}, {
+    symbol: string;
+    name: string;
+    amount: string | number | bigint;
+    uid: string;
+}>;
+/**
+ * Schema for full node transaction data.
+ * Contains all information about a transaction as seen by the full node.
+ */
+export declare const fullNodeTxSchema: z.ZodObject<{
+    hash: z.ZodString;
+    nonce: z.ZodString;
+    timestamp: z.ZodNumber;
+    version: z.ZodNumber;
+    weight: z.ZodNumber;
+    parents: z.ZodArray<z.ZodString, "many">;
+    inputs: z.ZodArray<z.ZodObject<{
+        value: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+        token_data: z.ZodNumber;
+        script: z.ZodString;
+        decoded: z.ZodObject<{
+            type: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+            address: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+            timelock: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+            value: z.ZodOptional<z.ZodNullable<z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>>>;
+            token_data: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+        }, "strip", z.ZodTypeAny, {
+            type?: string | null | undefined;
+            address?: string | null | undefined;
+            value?: bigint | null | undefined;
+            timelock?: number | null | undefined;
+            token_data?: number | null | undefined;
+        }, {
+            type?: string | null | undefined;
+            address?: string | null | undefined;
+            value?: string | number | bigint | null | undefined;
+            timelock?: number | null | undefined;
+            token_data?: number | null | undefined;
+        }>;
+        tx_id: z.ZodString;
+        index: z.ZodNumber;
+        token: z.ZodOptional<z.ZodNullable<z.ZodUnion<[z.ZodString, z.ZodLiteral<string>]>>>;
+        spent_by: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+    }, "strip", z.ZodTypeAny, {
+        index: number;
+        value: bigint;
+        script: string;
+        token_data: number;
+        decoded: {
+            type?: string | null | undefined;
+            address?: string | null | undefined;
+            value?: bigint | null | undefined;
+            timelock?: number | null | undefined;
+            token_data?: number | null | undefined;
+        };
+        tx_id: string;
+        token?: string | null | undefined;
+        spent_by?: string | null | undefined;
+    }, {
+        index: number;
+        value: string | number | bigint;
+        script: string;
+        token_data: number;
+        decoded: {
+            type?: string | null | undefined;
+            address?: string | null | undefined;
+            value?: string | number | bigint | null | undefined;
+            timelock?: number | null | undefined;
+            token_data?: number | null | undefined;
+        };
+        tx_id: string;
+        token?: string | null | undefined;
+        spent_by?: string | null | undefined;
+    }>, "many">;
+    outputs: z.ZodArray<z.ZodObject<{
+        value: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+        token_data: z.ZodNumber;
+        script: z.ZodString;
+        decoded: z.ZodObject<{
+            type: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+            address: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+            timelock: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+            value: z.ZodOptional<z.ZodNullable<z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>>>;
+            token_data: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+        }, "strip", z.ZodTypeAny, {
+            type?: string | null | undefined;
+            address?: string | null | undefined;
+            value?: bigint | null | undefined;
+            timelock?: number | null | undefined;
+            token_data?: number | null | undefined;
+        }, {
+            type?: string | null | undefined;
+            address?: string | null | undefined;
+            value?: string | number | bigint | null | undefined;
+            timelock?: number | null | undefined;
+            token_data?: number | null | undefined;
+        }>;
+        address: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+        token: z.ZodOptional<z.ZodNullable<z.ZodUnion<[z.ZodString, z.ZodLiteral<string>]>>>;
+        authorities: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+        timelock: z.ZodNullable<z.ZodNumber>;
+    }, "strip", z.ZodTypeAny, {
+        value: bigint;
+        script: string;
+        timelock: number | null;
+        authorities: bigint;
+        token_data: number;
+        decoded: {
+            type?: string | null | undefined;
+            address?: string | null | undefined;
+            value?: bigint | null | undefined;
+            timelock?: number | null | undefined;
+            token_data?: number | null | undefined;
+        };
+        address?: string | null | undefined;
+        token?: string | null | undefined;
+    }, {
+        value: string | number | bigint;
+        script: string;
+        timelock: number | null;
+        authorities: string | number | bigint;
+        token_data: number;
+        decoded: {
+            type?: string | null | undefined;
+            address?: string | null | undefined;
+            value?: string | number | bigint | null | undefined;
+            timelock?: number | null | undefined;
+            token_data?: number | null | undefined;
+        };
+        address?: string | null | undefined;
+        token?: string | null | undefined;
+    }>, "many">;
+    tokens: z.ZodArray<z.ZodObject<{
+        uid: z.ZodString;
+        name: z.ZodString;
+        symbol: z.ZodString;
+        amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+    }, "strip", z.ZodTypeAny, {
+        symbol: string;
+        name: string;
+        amount: bigint;
+        uid: string;
+    }, {
+        symbol: string;
+        name: string;
+        amount: string | number | bigint;
+        uid: string;
+    }>, "many">;
+    token_name: z.ZodNullable<z.ZodString>;
+    token_symbol: z.ZodNullable<z.ZodString>;
+    raw: z.ZodString;
+}, "strip", z.ZodTypeAny, {
+    raw: string;
+    nonce: string;
+    hash: string;
+    tokens: {
+        symbol: string;
+        name: string;
+        amount: bigint;
+        uid: string;
+    }[];
+    timestamp: number;
+    version: number;
+    weight: number;
+    inputs: {
+        index: number;
+        value: bigint;
+        script: string;
+        token_data: number;
+        decoded: {
+            type?: string | null | undefined;
+            address?: string | null | undefined;
+            value?: bigint | null | undefined;
+            timelock?: number | null | undefined;
+            token_data?: number | null | undefined;
+        };
+        tx_id: string;
+        token?: string | null | undefined;
+        spent_by?: string | null | undefined;
+    }[];
+    outputs: {
+        value: bigint;
+        script: string;
+        timelock: number | null;
+        authorities: bigint;
+        token_data: number;
+        decoded: {
+            type?: string | null | undefined;
+            address?: string | null | undefined;
+            value?: bigint | null | undefined;
+            timelock?: number | null | undefined;
+            token_data?: number | null | undefined;
+        };
+        address?: string | null | undefined;
+        token?: string | null | undefined;
+    }[];
+    parents: string[];
+    token_name: string | null;
+    token_symbol: string | null;
+}, {
+    raw: string;
+    nonce: string;
+    hash: string;
+    tokens: {
+        symbol: string;
+        name: string;
+        amount: string | number | bigint;
+        uid: string;
+    }[];
+    timestamp: number;
+    version: number;
+    weight: number;
+    inputs: {
+        index: number;
+        value: string | number | bigint;
+        script: string;
+        token_data: number;
+        decoded: {
+            type?: string | null | undefined;
+            address?: string | null | undefined;
+            value?: string | number | bigint | null | undefined;
+            timelock?: number | null | undefined;
+            token_data?: number | null | undefined;
+        };
+        tx_id: string;
+        token?: string | null | undefined;
+        spent_by?: string | null | undefined;
+    }[];
+    outputs: {
+        value: string | number | bigint;
+        script: string;
+        timelock: number | null;
+        authorities: string | number | bigint;
+        token_data: number;
+        decoded: {
+            type?: string | null | undefined;
+            address?: string | null | undefined;
+            value?: string | number | bigint | null | undefined;
+            timelock?: number | null | undefined;
+            token_data?: number | null | undefined;
+        };
+        address?: string | null | undefined;
+        token?: string | null | undefined;
+    }[];
+    parents: string[];
+    token_name: string | null;
+    token_symbol: string | null;
+}>;
+/**
+ * Schema for full node transaction metadata.
+ * Contains additional information about a transaction's status and relationships.
+ */
+export declare const fullNodeMetaSchema: z.ZodObject<{
+    hash: z.ZodString;
+    received_by: z.ZodArray<z.ZodString, "many">;
+    children: z.ZodArray<z.ZodString, "many">;
+    conflict_with: z.ZodArray<z.ZodString, "many">;
+    first_block: z.ZodNullable<z.ZodString>;
+    height: z.ZodNumber;
+    voided_by: z.ZodArray<z.ZodString, "many">;
+    spent_outputs: z.ZodArray<z.ZodTuple<[z.ZodNumber, z.ZodArray<z.ZodString, "many">], null>, "many">;
+    received_timestamp: z.ZodNullable<z.ZodNumber>;
+    is_voided: z.ZodBoolean;
+    verification_status: z.ZodString;
+    twins: z.ZodArray<z.ZodString, "many">;
+    accumulated_weight: z.ZodNumber;
+    score: z.ZodNumber;
+}, "strip", z.ZodTypeAny, {
+    height: number;
+    children: string[];
+    hash: string;
+    is_voided: boolean;
+    first_block: string | null;
+    spent_outputs: [number, string[]][];
+    received_by: string[];
+    conflict_with: string[];
+    voided_by: string[];
+    twins: string[];
+    accumulated_weight: number;
+    score: number;
+    received_timestamp: number | null;
+    verification_status: string;
+}, {
+    height: number;
+    children: string[];
+    hash: string;
+    is_voided: boolean;
+    first_block: string | null;
+    spent_outputs: [number, string[]][];
+    received_by: string[];
+    conflict_with: string[];
+    voided_by: string[];
+    twins: string[];
+    accumulated_weight: number;
+    score: number;
+    received_timestamp: number | null;
+    verification_status: string;
+}>;
+/**
+ * Response schema for full node transaction data.
+ * Contains the transaction details, metadata, and optional message.
+ */
+export declare const fullNodeTxResponseSchema: z.ZodObject<z.objectUtil.extendShape<{
+    success: z.ZodBoolean;
+}, {
+    tx: z.ZodObject<{
+        hash: z.ZodString;
+        nonce: z.ZodString;
+        timestamp: z.ZodNumber;
+        version: z.ZodNumber;
+        weight: z.ZodNumber;
+        parents: z.ZodArray<z.ZodString, "many">;
+        inputs: z.ZodArray<z.ZodObject<{
+            value: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            token_data: z.ZodNumber;
+            script: z.ZodString;
+            decoded: z.ZodObject<{
+                type: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+                address: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+                timelock: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+                value: z.ZodOptional<z.ZodNullable<z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>>>;
+                token_data: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+            }, "strip", z.ZodTypeAny, {
+                type?: string | null | undefined;
+                address?: string | null | undefined;
+                value?: bigint | null | undefined;
+                timelock?: number | null | undefined;
+                token_data?: number | null | undefined;
+            }, {
+                type?: string | null | undefined;
+                address?: string | null | undefined;
+                value?: string | number | bigint | null | undefined;
+                timelock?: number | null | undefined;
+                token_data?: number | null | undefined;
+            }>;
+            tx_id: z.ZodString;
+            index: z.ZodNumber;
+            token: z.ZodOptional<z.ZodNullable<z.ZodUnion<[z.ZodString, z.ZodLiteral<string>]>>>;
+            spent_by: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+        }, "strip", z.ZodTypeAny, {
+            index: number;
+            value: bigint;
+            script: string;
+            token_data: number;
+            decoded: {
+                type?: string | null | undefined;
+                address?: string | null | undefined;
+                value?: bigint | null | undefined;
+                timelock?: number | null | undefined;
+                token_data?: number | null | undefined;
+            };
+            tx_id: string;
+            token?: string | null | undefined;
+            spent_by?: string | null | undefined;
+        }, {
+            index: number;
+            value: string | number | bigint;
+            script: string;
+            token_data: number;
+            decoded: {
+                type?: string | null | undefined;
+                address?: string | null | undefined;
+                value?: string | number | bigint | null | undefined;
+                timelock?: number | null | undefined;
+                token_data?: number | null | undefined;
+            };
+            tx_id: string;
+            token?: string | null | undefined;
+            spent_by?: string | null | undefined;
+        }>, "many">;
+        outputs: z.ZodArray<z.ZodObject<{
+            value: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            token_data: z.ZodNumber;
+            script: z.ZodString;
+            decoded: z.ZodObject<{
+                type: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+                address: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+                timelock: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+                value: z.ZodOptional<z.ZodNullable<z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>>>;
+                token_data: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+            }, "strip", z.ZodTypeAny, {
+                type?: string | null | undefined;
+                address?: string | null | undefined;
+                value?: bigint | null | undefined;
+                timelock?: number | null | undefined;
+                token_data?: number | null | undefined;
+            }, {
+                type?: string | null | undefined;
+                address?: string | null | undefined;
+                value?: string | number | bigint | null | undefined;
+                timelock?: number | null | undefined;
+                token_data?: number | null | undefined;
+            }>;
+            address: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+            token: z.ZodOptional<z.ZodNullable<z.ZodUnion<[z.ZodString, z.ZodLiteral<string>]>>>;
+            authorities: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            timelock: z.ZodNullable<z.ZodNumber>;
+        }, "strip", z.ZodTypeAny, {
+            value: bigint;
+            script: string;
+            timelock: number | null;
+            authorities: bigint;
+            token_data: number;
+            decoded: {
+                type?: string | null | undefined;
+                address?: string | null | undefined;
+                value?: bigint | null | undefined;
+                timelock?: number | null | undefined;
+                token_data?: number | null | undefined;
+            };
+            address?: string | null | undefined;
+            token?: string | null | undefined;
+        }, {
+            value: string | number | bigint;
+            script: string;
+            timelock: number | null;
+            authorities: string | number | bigint;
+            token_data: number;
+            decoded: {
+                type?: string | null | undefined;
+                address?: string | null | undefined;
+                value?: string | number | bigint | null | undefined;
+                timelock?: number | null | undefined;
+                token_data?: number | null | undefined;
+            };
+            address?: string | null | undefined;
+            token?: string | null | undefined;
+        }>, "many">;
+        tokens: z.ZodArray<z.ZodObject<{
+            uid: z.ZodString;
+            name: z.ZodString;
+            symbol: z.ZodString;
+            amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+        }, "strip", z.ZodTypeAny, {
+            symbol: string;
+            name: string;
+            amount: bigint;
+            uid: string;
+        }, {
+            symbol: string;
+            name: string;
+            amount: string | number | bigint;
+            uid: string;
+        }>, "many">;
+        token_name: z.ZodNullable<z.ZodString>;
+        token_symbol: z.ZodNullable<z.ZodString>;
+        raw: z.ZodString;
+    }, "strip", z.ZodTypeAny, {
+        raw: string;
+        nonce: string;
+        hash: string;
+        tokens: {
+            symbol: string;
+            name: string;
+            amount: bigint;
+            uid: string;
+        }[];
+        timestamp: number;
+        version: number;
+        weight: number;
+        inputs: {
+            index: number;
+            value: bigint;
+            script: string;
+            token_data: number;
+            decoded: {
+                type?: string | null | undefined;
+                address?: string | null | undefined;
+                value?: bigint | null | undefined;
+                timelock?: number | null | undefined;
+                token_data?: number | null | undefined;
+            };
+            tx_id: string;
+            token?: string | null | undefined;
+            spent_by?: string | null | undefined;
+        }[];
+        outputs: {
+            value: bigint;
+            script: string;
+            timelock: number | null;
+            authorities: bigint;
+            token_data: number;
+            decoded: {
+                type?: string | null | undefined;
+                address?: string | null | undefined;
+                value?: bigint | null | undefined;
+                timelock?: number | null | undefined;
+                token_data?: number | null | undefined;
+            };
+            address?: string | null | undefined;
+            token?: string | null | undefined;
+        }[];
+        parents: string[];
+        token_name: string | null;
+        token_symbol: string | null;
+    }, {
+        raw: string;
+        nonce: string;
+        hash: string;
+        tokens: {
+            symbol: string;
+            name: string;
+            amount: string | number | bigint;
+            uid: string;
+        }[];
+        timestamp: number;
+        version: number;
+        weight: number;
+        inputs: {
+            index: number;
+            value: string | number | bigint;
+            script: string;
+            token_data: number;
+            decoded: {
+                type?: string | null | undefined;
+                address?: string | null | undefined;
+                value?: string | number | bigint | null | undefined;
+                timelock?: number | null | undefined;
+                token_data?: number | null | undefined;
+            };
+            tx_id: string;
+            token?: string | null | undefined;
+            spent_by?: string | null | undefined;
+        }[];
+        outputs: {
+            value: string | number | bigint;
+            script: string;
+            timelock: number | null;
+            authorities: string | number | bigint;
+            token_data: number;
+            decoded: {
+                type?: string | null | undefined;
+                address?: string | null | undefined;
+                value?: string | number | bigint | null | undefined;
+                timelock?: number | null | undefined;
+                token_data?: number | null | undefined;
+            };
+            address?: string | null | undefined;
+            token?: string | null | undefined;
+        }[];
+        parents: string[];
+        token_name: string | null;
+        token_symbol: string | null;
+    }>;
+    meta: z.ZodObject<{
+        hash: z.ZodString;
+        received_by: z.ZodArray<z.ZodString, "many">;
+        children: z.ZodArray<z.ZodString, "many">;
+        conflict_with: z.ZodArray<z.ZodString, "many">;
+        first_block: z.ZodNullable<z.ZodString>;
+        height: z.ZodNumber;
+        voided_by: z.ZodArray<z.ZodString, "many">;
+        spent_outputs: z.ZodArray<z.ZodTuple<[z.ZodNumber, z.ZodArray<z.ZodString, "many">], null>, "many">;
+        received_timestamp: z.ZodNullable<z.ZodNumber>;
+        is_voided: z.ZodBoolean;
+        verification_status: z.ZodString;
+        twins: z.ZodArray<z.ZodString, "many">;
+        accumulated_weight: z.ZodNumber;
+        score: z.ZodNumber;
+    }, "strip", z.ZodTypeAny, {
+        height: number;
+        children: string[];
+        hash: string;
+        is_voided: boolean;
+        first_block: string | null;
+        spent_outputs: [number, string[]][];
+        received_by: string[];
+        conflict_with: string[];
+        voided_by: string[];
+        twins: string[];
+        accumulated_weight: number;
+        score: number;
+        received_timestamp: number | null;
+        verification_status: string;
+    }, {
+        height: number;
+        children: string[];
+        hash: string;
+        is_voided: boolean;
+        first_block: string | null;
+        spent_outputs: [number, string[]][];
+        received_by: string[];
+        conflict_with: string[];
+        voided_by: string[];
+        twins: string[];
+        accumulated_weight: number;
+        score: number;
+        received_timestamp: number | null;
+        verification_status: string;
+    }>;
+    message: z.ZodOptional<z.ZodString>;
+    spent_outputs: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodString>>;
+}>, "strip", z.ZodTypeAny, {
+    meta: {
+        height: number;
+        children: string[];
+        hash: string;
+        is_voided: boolean;
+        first_block: string | null;
+        spent_outputs: [number, string[]][];
+        received_by: string[];
+        conflict_with: string[];
+        voided_by: string[];
+        twins: string[];
+        accumulated_weight: number;
+        score: number;
+        received_timestamp: number | null;
+        verification_status: string;
+    };
+    success: boolean;
+    tx: {
+        raw: string;
+        nonce: string;
+        hash: string;
+        tokens: {
+            symbol: string;
+            name: string;
+            amount: bigint;
+            uid: string;
+        }[];
+        timestamp: number;
+        version: number;
+        weight: number;
+        inputs: {
+            index: number;
+            value: bigint;
+            script: string;
+            token_data: number;
+            decoded: {
+                type?: string | null | undefined;
+                address?: string | null | undefined;
+                value?: bigint | null | undefined;
+                timelock?: number | null | undefined;
+                token_data?: number | null | undefined;
+            };
+            tx_id: string;
+            token?: string | null | undefined;
+            spent_by?: string | null | undefined;
+        }[];
+        outputs: {
+            value: bigint;
+            script: string;
+            timelock: number | null;
+            authorities: bigint;
+            token_data: number;
+            decoded: {
+                type?: string | null | undefined;
+                address?: string | null | undefined;
+                value?: bigint | null | undefined;
+                timelock?: number | null | undefined;
+                token_data?: number | null | undefined;
+            };
+            address?: string | null | undefined;
+            token?: string | null | undefined;
+        }[];
+        parents: string[];
+        token_name: string | null;
+        token_symbol: string | null;
+    };
+    message?: string | undefined;
+    spent_outputs?: Record<string, string> | undefined;
+}, {
+    meta: {
+        height: number;
+        children: string[];
+        hash: string;
+        is_voided: boolean;
+        first_block: string | null;
+        spent_outputs: [number, string[]][];
+        received_by: string[];
+        conflict_with: string[];
+        voided_by: string[];
+        twins: string[];
+        accumulated_weight: number;
+        score: number;
+        received_timestamp: number | null;
+        verification_status: string;
+    };
+    success: boolean;
+    tx: {
+        raw: string;
+        nonce: string;
+        hash: string;
+        tokens: {
+            symbol: string;
+            name: string;
+            amount: string | number | bigint;
+            uid: string;
+        }[];
+        timestamp: number;
+        version: number;
+        weight: number;
+        inputs: {
+            index: number;
+            value: string | number | bigint;
+            script: string;
+            token_data: number;
+            decoded: {
+                type?: string | null | undefined;
+                address?: string | null | undefined;
+                value?: string | number | bigint | null | undefined;
+                timelock?: number | null | undefined;
+                token_data?: number | null | undefined;
+            };
+            tx_id: string;
+            token?: string | null | undefined;
+            spent_by?: string | null | undefined;
+        }[];
+        outputs: {
+            value: string | number | bigint;
+            script: string;
+            timelock: number | null;
+            authorities: string | number | bigint;
+            token_data: number;
+            decoded: {
+                type?: string | null | undefined;
+                address?: string | null | undefined;
+                value?: string | number | bigint | null | undefined;
+                timelock?: number | null | undefined;
+                token_data?: number | null | undefined;
+            };
+            address?: string | null | undefined;
+            token?: string | null | undefined;
+        }[];
+        parents: string[];
+        token_name: string | null;
+        token_symbol: string | null;
+    };
+    message?: string | undefined;
+    spent_outputs?: Record<string, string> | undefined;
+}>;
+/**
+ * Response schema for transaction confirmation data.
+ * Contains information about the transaction's confirmation status and weight.
+ */
+export declare const fullNodeTxConfirmationDataResponseSchema: z.ZodObject<z.objectUtil.extendShape<{
+    success: z.ZodBoolean;
+}, {
+    accumulated_weight: z.ZodNumber;
+    accumulated_bigger: z.ZodBoolean;
+    stop_value: z.ZodNumber;
+    confirmation_level: z.ZodNumber;
+}>, "strip", z.ZodTypeAny, {
+    success: boolean;
+    accumulated_weight: number;
+    accumulated_bigger: boolean;
+    stop_value: number;
+    confirmation_level: number;
+}, {
+    success: boolean;
+    accumulated_weight: number;
+    accumulated_bigger: boolean;
+    stop_value: number;
+    confirmation_level: number;
+}>;
+/**
+ * Response schema for wallet status.
+ * Contains information about the wallet's current state.
+ */
+export declare const walletStatusResponseSchema: z.ZodObject<z.objectUtil.extendShape<{
+    success: z.ZodBoolean;
+}, {
+    status: z.ZodObject<{
+        walletId: z.ZodString;
+        xpubkey: z.ZodString;
+        status: z.ZodString;
+        maxGap: z.ZodNumber;
+        createdAt: z.ZodNumber;
+        readyAt: z.ZodNullable<z.ZodNumber>;
+    }, "strip", z.ZodTypeAny, {
+        status: string;
+        xpubkey: string;
+        walletId: string;
+        maxGap: number;
+        createdAt: number;
+        readyAt: number | null;
+    }, {
+        status: string;
+        xpubkey: string;
+        walletId: string;
+        maxGap: number;
+        createdAt: number;
+        readyAt: number | null;
+    }>;
+    error: z.ZodOptional<z.ZodString>;
+}>, "strip", z.ZodTypeAny, {
+    success: boolean;
+    status: {
+        status: string;
+        xpubkey: string;
+        walletId: string;
+        maxGap: number;
+        createdAt: number;
+        readyAt: number | null;
+    };
+    error?: string | undefined;
+}, {
+    success: boolean;
+    status: {
+        status: string;
+        xpubkey: string;
+        walletId: string;
+        maxGap: number;
+        createdAt: number;
+        readyAt: number | null;
+    };
+    error?: string | undefined;
+}>;
+/**
+ * Response schema for token list.
+ * Contains an array of token information.
+ */
+export declare const tokensResponseSchema: z.ZodObject<z.objectUtil.extendShape<{
+    success: z.ZodBoolean;
+}, {
+    tokens: z.ZodArray<z.ZodString, "many">;
+}>, "strip", z.ZodTypeAny, {
+    success: boolean;
+    tokens: string[];
+}, {
+    success: boolean;
+    tokens: string[];
+}>;
+/**
+ * Response schema for transaction history.
+ * Contains an array of transaction information.
+ */
+export declare const historyResponseSchema: z.ZodObject<z.objectUtil.extendShape<{
+    success: z.ZodBoolean;
+}, {
+    history: z.ZodArray<z.ZodObject<{
+        txId: z.ZodString;
+        balance: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+        timestamp: z.ZodNumber;
+        voided: z.ZodEffects<z.ZodNumber, boolean, number>;
+        version: z.ZodNumber;
+    }, "strip", z.ZodTypeAny, {
+        balance: bigint;
+        timestamp: number;
+        version: number;
+        txId: string;
+        voided: boolean;
+    }, {
+        balance: string | number | bigint;
+        timestamp: number;
+        version: number;
+        txId: string;
+        voided: number;
+    }>, "many">;
+}>, "strip", z.ZodTypeAny, {
+    success: boolean;
+    history: {
+        balance: bigint;
+        timestamp: number;
+        version: number;
+        txId: string;
+        voided: boolean;
+    }[];
+}, {
+    success: boolean;
+    history: {
+        balance: string | number | bigint;
+        timestamp: number;
+        version: number;
+        txId: string;
+        voided: number;
+    }[];
+}>;
+/**
+ * Response schema for transaction outputs.
+ * Contains an array of unspent transaction outputs.
+ */
+export declare const txOutputResponseSchema: z.ZodObject<z.objectUtil.extendShape<{
+    success: z.ZodBoolean;
+}, {
+    txOutputs: z.ZodArray<z.ZodObject<{
+        txId: z.ZodString;
+        index: z.ZodNumber;
+        tokenId: z.ZodString;
+        address: z.ZodString;
+        value: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+        authorities: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+        timelock: z.ZodNullable<z.ZodNumber>;
+        heightlock: z.ZodNullable<z.ZodNumber>;
+        locked: z.ZodBoolean;
+        addressPath: z.ZodString;
+    }, "strip", z.ZodTypeAny, {
+        index: number;
+        address: string;
+        value: bigint;
+        timelock: number | null;
+        locked: boolean;
+        authorities: bigint;
+        txId: string;
+        addressPath: string;
+        tokenId: string;
+        heightlock: number | null;
+    }, {
+        index: number;
+        address: string;
+        value: string | number | bigint;
+        timelock: number | null;
+        locked: boolean;
+        authorities: string | number | bigint;
+        txId: string;
+        addressPath: string;
+        tokenId: string;
+        heightlock: number | null;
+    }>, "many">;
+}>, "strip", z.ZodTypeAny, {
+    success: boolean;
+    txOutputs: {
+        index: number;
+        address: string;
+        value: bigint;
+        timelock: number | null;
+        locked: boolean;
+        authorities: bigint;
+        txId: string;
+        addressPath: string;
+        tokenId: string;
+        heightlock: number | null;
+    }[];
+}, {
+    success: boolean;
+    txOutputs: {
+        index: number;
+        address: string;
+        value: string | number | bigint;
+        timelock: number | null;
+        locked: boolean;
+        authorities: string | number | bigint;
+        txId: string;
+        addressPath: string;
+        tokenId: string;
+        heightlock: number | null;
+    }[];
+}>;
+/**
+ * Response schema for authentication token.
+ * Contains the authentication token.
+ */
+export declare const authTokenResponseSchema: z.ZodObject<z.objectUtil.extendShape<{
+    success: z.ZodBoolean;
+}, {
+    token: z.ZodString;
+}>, "strip", z.ZodTypeAny, {
+    success: boolean;
+    token: string;
+}, {
+    success: boolean;
+    token: string;
+}>;
+/**
+ * Schema for transaction by ID response.
+ * Contains detailed information about a specific transaction.
+ */
+export declare const txByIdResponseSchema: z.ZodObject<z.objectUtil.extendShape<{
+    success: z.ZodBoolean;
+}, {
+    txTokens: z.ZodArray<z.ZodObject<{
+        txId: z.ZodString;
+        timestamp: z.ZodNumber;
+        version: z.ZodNumber;
+        voided: z.ZodBoolean;
+        height: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+        weight: z.ZodNumber;
+        balance: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+        tokenId: z.ZodString;
+        tokenName: z.ZodString;
+        tokenSymbol: z.ZodString;
+    }, "strip", z.ZodTypeAny, {
+        balance: bigint;
+        timestamp: number;
+        version: number;
+        weight: number;
+        txId: string;
+        voided: boolean;
+        tokenId: string;
+        tokenName: string;
+        tokenSymbol: string;
+        height?: number | null | undefined;
+    }, {
+        balance: string | number | bigint;
+        timestamp: number;
+        version: number;
+        weight: number;
+        txId: string;
+        voided: boolean;
+        tokenId: string;
+        tokenName: string;
+        tokenSymbol: string;
+        height?: number | null | undefined;
+    }>, "many">;
+}>, "strip", z.ZodTypeAny, {
+    success: boolean;
+    txTokens: {
+        balance: bigint;
+        timestamp: number;
+        version: number;
+        weight: number;
+        txId: string;
+        voided: boolean;
+        tokenId: string;
+        tokenName: string;
+        tokenSymbol: string;
+        height?: number | null | undefined;
+    }[];
+}, {
+    success: boolean;
+    txTokens: {
+        balance: string | number | bigint;
+        timestamp: number;
+        version: number;
+        weight: number;
+        txId: string;
+        voided: boolean;
+        tokenId: string;
+        tokenName: string;
+        tokenSymbol: string;
+        height?: number | null | undefined;
+    }[];
+}>;
+/**
+ * Schema for transaction input.
+ * Represents a transaction input with its decoded data.
+ */
+export declare const txInputSchema: z.ZodObject<{
+    tx_id: z.ZodString;
+    index: z.ZodNumber;
+    value: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+    token_data: z.ZodNumber;
+    script: z.ZodString;
+    decoded: z.ZodObject<{
+        type: z.ZodString;
+        address: z.ZodString;
+        timelock: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+        value: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+        token_data: z.ZodNumber;
+    }, "strip", z.ZodTypeAny, {
+        type: string;
+        address: string;
+        value: bigint;
+        token_data: number;
+        timelock?: number | null | undefined;
+    }, {
+        type: string;
+        address: string;
+        value: string | number | bigint;
+        token_data: number;
+        timelock?: number | null | undefined;
+    }>;
+}, "strip", z.ZodTypeAny, {
+    index: number;
+    value: bigint;
+    script: string;
+    token_data: number;
+    decoded: {
+        type: string;
+        address: string;
+        value: bigint;
+        token_data: number;
+        timelock?: number | null | undefined;
+    };
+    tx_id: string;
+}, {
+    index: number;
+    value: string | number | bigint;
+    script: string;
+    token_data: number;
+    decoded: {
+        type: string;
+        address: string;
+        value: string | number | bigint;
+        token_data: number;
+        timelock?: number | null | undefined;
+    };
+    tx_id: string;
+}>;
+/**
+ * Schema for transaction output.
+ * Represents a transaction output with its decoded data.
+ */
+export declare const txOutputSchema: z.ZodObject<{
+    index: z.ZodNumber;
+    value: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+    token_data: z.ZodNumber;
+    script: z.ZodString;
+    decoded: z.ZodObject<{
+        type: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+        address: z.ZodOptional<z.ZodString>;
+        timelock: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+        value: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+        token_data: z.ZodOptional<z.ZodNumber>;
+    }, "strip", z.ZodTypeAny, {
+        value: bigint;
+        type?: string | null | undefined;
+        address?: string | undefined;
+        timelock?: number | null | undefined;
+        token_data?: number | undefined;
+    }, {
+        value: string | number | bigint;
+        type?: string | null | undefined;
+        address?: string | undefined;
+        timelock?: number | null | undefined;
+        token_data?: number | undefined;
+    }>;
+}, "strip", z.ZodTypeAny, {
+    index: number;
+    value: bigint;
+    script: string;
+    token_data: number;
+    decoded: {
+        value: bigint;
+        type?: string | null | undefined;
+        address?: string | undefined;
+        timelock?: number | null | undefined;
+        token_data?: number | undefined;
+    };
+}, {
+    index: number;
+    value: string | number | bigint;
+    script: string;
+    token_data: number;
+    decoded: {
+        value: string | number | bigint;
+        type?: string | null | undefined;
+        address?: string | undefined;
+        timelock?: number | null | undefined;
+        token_data?: number | undefined;
+    };
+}>;
+/**
+ * Schema for websocket transaction events.
+ * Represents the structure of transactions received via websocket.
+ */
+export declare const wsTransactionSchema: z.ZodObject<{
+    tx_id: z.ZodString;
+    nonce: z.ZodNumber;
+    timestamp: z.ZodNumber;
+    version: z.ZodNumber;
+    voided: z.ZodBoolean;
+    weight: z.ZodNumber;
+    parents: z.ZodArray<z.ZodString, "many">;
+    inputs: z.ZodArray<z.ZodObject<{
+        tx_id: z.ZodString;
+        index: z.ZodNumber;
+        value: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+        token_data: z.ZodNumber;
+        script: z.ZodObject<{
+            type: z.ZodLiteral<"Buffer">;
+            data: z.ZodArray<z.ZodNumber, "many">;
+        }, "strip", z.ZodTypeAny, {
+            type: "Buffer";
+            data: number[];
+        }, {
+            type: "Buffer";
+            data: number[];
+        }>;
+        token: z.ZodUnion<[z.ZodString, z.ZodLiteral<string>]>;
+        decoded: z.ZodObject<{
+            type: z.ZodString;
+            address: z.ZodString;
+            timelock: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+        }, "strip", z.ZodTypeAny, {
+            type: string;
+            address: string;
+            timelock?: number | null | undefined;
+        }, {
+            type: string;
+            address: string;
+            timelock?: number | null | undefined;
+        }>;
+    }, "strip", z.ZodTypeAny, {
+        index: number;
+        value: bigint;
+        script: {
+            type: "Buffer";
+            data: number[];
+        };
+        token_data: number;
+        decoded: {
+            type: string;
+            address: string;
+            timelock?: number | null | undefined;
+        };
+        token: string;
+        tx_id: string;
+    }, {
+        index: number;
+        value: string | number | bigint;
+        script: {
+            type: "Buffer";
+            data: number[];
+        };
+        token_data: number;
+        decoded: {
+            type: string;
+            address: string;
+            timelock?: number | null | undefined;
+        };
+        token: string;
+        tx_id: string;
+    }>, "many">;
+    outputs: z.ZodArray<z.ZodObject<{
+        value: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+        token_data: z.ZodNumber;
+        script: z.ZodObject<{
+            type: z.ZodLiteral<"Buffer">;
+            data: z.ZodArray<z.ZodNumber, "many">;
+        }, "strip", z.ZodTypeAny, {
+            type: "Buffer";
+            data: number[];
+        }, {
+            type: "Buffer";
+            data: number[];
+        }>;
+        decodedScript: z.ZodOptional<z.ZodNullable<z.ZodAny>>;
+        token: z.ZodUnion<[z.ZodString, z.ZodLiteral<string>]>;
+        locked: z.ZodBoolean;
+        index: z.ZodNumber;
+        decoded: z.ZodObject<{
+            type: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+            address: z.ZodOptional<z.ZodString>;
+            timelock: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+        }, "strip", z.ZodTypeAny, {
+            type?: string | null | undefined;
+            address?: string | undefined;
+            timelock?: number | null | undefined;
+        }, {
+            type?: string | null | undefined;
+            address?: string | undefined;
+            timelock?: number | null | undefined;
+        }>;
+    }, "strip", z.ZodTypeAny, {
+        index: number;
+        value: bigint;
+        script: {
+            type: "Buffer";
+            data: number[];
+        };
+        locked: boolean;
+        token_data: number;
+        decoded: {
+            type?: string | null | undefined;
+            address?: string | undefined;
+            timelock?: number | null | undefined;
+        };
+        token: string;
+        decodedScript?: any;
+    }, {
+        index: number;
+        value: string | number | bigint;
+        script: {
+            type: "Buffer";
+            data: number[];
+        };
+        locked: boolean;
+        token_data: number;
+        decoded: {
+            type?: string | null | undefined;
+            address?: string | undefined;
+            timelock?: number | null | undefined;
+        };
+        token: string;
+        decodedScript?: any;
+    }>, "many">;
+    height: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+    token_name: z.ZodNullable<z.ZodString>;
+    token_symbol: z.ZodNullable<z.ZodString>;
+    signal_bits: z.ZodNumber;
+}, "strip", z.ZodTypeAny, {
+    nonce: number;
+    tx_id: string;
+    timestamp: number;
+    version: number;
+    weight: number;
+    inputs: {
+        index: number;
+        value: bigint;
+        script: {
+            type: "Buffer";
+            data: number[];
+        };
+        token_data: number;
+        decoded: {
+            type: string;
+            address: string;
+            timelock?: number | null | undefined;
+        };
+        token: string;
+        tx_id: string;
+    }[];
+    outputs: {
+        index: number;
+        value: bigint;
+        script: {
+            type: "Buffer";
+            data: number[];
+        };
+        locked: boolean;
+        token_data: number;
+        decoded: {
+            type?: string | null | undefined;
+            address?: string | undefined;
+            timelock?: number | null | undefined;
+        };
+        token: string;
+        decodedScript?: any;
+    }[];
+    parents: string[];
+    token_name: string | null;
+    token_symbol: string | null;
+    signal_bits: number;
+    voided: boolean;
+    height?: number | null | undefined;
+}, {
+    nonce: number;
+    tx_id: string;
+    timestamp: number;
+    version: number;
+    weight: number;
+    inputs: {
+        index: number;
+        value: string | number | bigint;
+        script: {
+            type: "Buffer";
+            data: number[];
+        };
+        token_data: number;
+        decoded: {
+            type: string;
+            address: string;
+            timelock?: number | null | undefined;
+        };
+        token: string;
+        tx_id: string;
+    }[];
+    outputs: {
+        index: number;
+        value: string | number | bigint;
+        script: {
+            type: "Buffer";
+            data: number[];
+        };
+        locked: boolean;
+        token_data: number;
+        decoded: {
+            type?: string | null | undefined;
+            address?: string | undefined;
+            timelock?: number | null | undefined;
+        };
+        token: string;
+        decodedScript?: any;
+    }[];
+    parents: string[];
+    token_name: string | null;
+    token_symbol: string | null;
+    signal_bits: number;
+    voided: boolean;
+    height?: number | null | undefined;
+}>;
+/**
+ * Collection of all wallet API schemas.
+ * Used for type validation and documentation of the wallet API.
+ */
+export declare const walletApiSchemas: {
+    addressesResponse: z.ZodObject<z.objectUtil.extendShape<{
+        success: z.ZodBoolean;
+    }, {
+        addresses: z.ZodArray<z.ZodObject<{
+            address: z.ZodString;
+            index: z.ZodNumber;
+            transactions: z.ZodNumber;
+        }, "strip", z.ZodTypeAny, {
+            index: number;
+            address: string;
+            transactions: number;
+        }, {
+            index: number;
+            address: string;
+            transactions: number;
+        }>, "many">;
+    }>, "strip", z.ZodTypeAny, {
+        success: boolean;
+        addresses: {
+            index: number;
+            address: string;
+            transactions: number;
+        }[];
+    }, {
+        success: boolean;
+        addresses: {
+            index: number;
+            address: string;
+            transactions: number;
+        }[];
+    }>;
+    checkAddressesMineResponse: z.ZodObject<z.objectUtil.extendShape<{
+        success: z.ZodBoolean;
+    }, {
+        addresses: z.ZodRecord<z.ZodString, z.ZodBoolean>;
+    }>, "strip", z.ZodTypeAny, {
+        success: boolean;
+        addresses: Record<string, boolean>;
+    }, {
+        success: boolean;
+        addresses: Record<string, boolean>;
+    }>;
+    newAddressesResponse: z.ZodObject<z.objectUtil.extendShape<{
+        success: z.ZodBoolean;
+    }, {
+        addresses: z.ZodArray<z.ZodObject<{
+            address: z.ZodString;
+            index: z.ZodNumber;
+            addressPath: z.ZodString;
+            info: z.ZodOptional<z.ZodString>;
+        }, "strict", z.ZodTypeAny, {
+            index: number;
+            address: string;
+            addressPath: string;
+            info?: string | undefined;
+        }, {
+            index: number;
+            address: string;
+            addressPath: string;
+            info?: string | undefined;
+        }>, "many">;
+    }>, "strip", z.ZodTypeAny, {
+        success: boolean;
+        addresses: {
+            index: number;
+            address: string;
+            addressPath: string;
+            info?: string | undefined;
+        }[];
+    }, {
+        success: boolean;
+        addresses: {
+            index: number;
+            address: string;
+            addressPath: string;
+            info?: string | undefined;
+        }[];
+    }>;
+    tokenDetailsResponse: z.ZodObject<z.objectUtil.extendShape<{
+        success: z.ZodBoolean;
+    }, {
+        details: z.ZodObject<{
+            tokenInfo: z.ZodObject<{
+                id: z.ZodUnion<[z.ZodString, z.ZodLiteral<string>]>;
+                name: z.ZodString;
+                symbol: z.ZodString;
+            }, "strip", z.ZodTypeAny, {
+                symbol: string;
+                id: string;
+                name: string;
+            }, {
+                symbol: string;
+                id: string;
+                name: string;
+            }>;
+            totalSupply: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            totalTransactions: z.ZodNumber;
+            authorities: z.ZodObject<{
+                mint: z.ZodBoolean;
+                melt: z.ZodBoolean;
+            }, "strip", z.ZodTypeAny, {
+                mint: boolean;
+                melt: boolean;
+            }, {
+                mint: boolean;
+                melt: boolean;
+            }>;
+        }, "strip", z.ZodTypeAny, {
+            authorities: {
+                mint: boolean;
+                melt: boolean;
+            };
+            tokenInfo: {
+                symbol: string;
+                id: string;
+                name: string;
+            };
+            totalSupply: bigint;
+            totalTransactions: number;
+        }, {
+            authorities: {
+                mint: boolean;
+                melt: boolean;
+            };
+            tokenInfo: {
+                symbol: string;
+                id: string;
+                name: string;
+            };
+            totalSupply: string | number | bigint;
+            totalTransactions: number;
+        }>;
+    }>, "strip", z.ZodTypeAny, {
+        details: {
+            authorities: {
+                mint: boolean;
+                melt: boolean;
+            };
+            tokenInfo: {
+                symbol: string;
+                id: string;
+                name: string;
+            };
+            totalSupply: bigint;
+            totalTransactions: number;
+        };
+        success: boolean;
+    }, {
+        details: {
+            authorities: {
+                mint: boolean;
+                melt: boolean;
+            };
+            tokenInfo: {
+                symbol: string;
+                id: string;
+                name: string;
+            };
+            totalSupply: string | number | bigint;
+            totalTransactions: number;
+        };
+        success: boolean;
+    }>;
+    balanceResponse: z.ZodObject<z.objectUtil.extendShape<{
+        success: z.ZodBoolean;
+    }, {
+        balances: z.ZodArray<z.ZodObject<{
+            token: z.ZodObject<{
+                id: z.ZodUnion<[z.ZodString, z.ZodLiteral<string>]>;
+                name: z.ZodString;
+                symbol: z.ZodString;
+            }, "strip", z.ZodTypeAny, {
+                symbol: string;
+                id: string;
+                name: string;
+            }, {
+                symbol: string;
+                id: string;
+                name: string;
+            }>;
+            balance: z.ZodObject<{
+                unlocked: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+                locked: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }, "strip", z.ZodTypeAny, {
+                locked: bigint;
+                unlocked: bigint;
+            }, {
+                locked: string | number | bigint;
+                unlocked: string | number | bigint;
+            }>;
+            tokenAuthorities: z.ZodObject<{
+                unlocked: z.ZodObject<{
+                    mint: z.ZodBoolean;
+                    melt: z.ZodBoolean;
+                }, "strip", z.ZodTypeAny, {
+                    mint: boolean;
+                    melt: boolean;
+                }, {
+                    mint: boolean;
+                    melt: boolean;
+                }>;
+                locked: z.ZodObject<{
+                    mint: z.ZodBoolean;
+                    melt: z.ZodBoolean;
+                }, "strip", z.ZodTypeAny, {
+                    mint: boolean;
+                    melt: boolean;
+                }, {
+                    mint: boolean;
+                    melt: boolean;
+                }>;
+            }, "strip", z.ZodTypeAny, {
+                locked: {
+                    mint: boolean;
+                    melt: boolean;
+                };
+                unlocked: {
+                    mint: boolean;
+                    melt: boolean;
+                };
+            }, {
+                locked: {
+                    mint: boolean;
+                    melt: boolean;
+                };
+                unlocked: {
+                    mint: boolean;
+                    melt: boolean;
+                };
+            }>;
+            transactions: z.ZodNumber;
+            lockExpires: z.ZodNullable<z.ZodNumber>;
+        }, "strip", z.ZodTypeAny, {
+            balance: {
+                locked: bigint;
+                unlocked: bigint;
+            };
+            token: {
+                symbol: string;
+                id: string;
+                name: string;
+            };
+            transactions: number;
+            tokenAuthorities: {
+                locked: {
+                    mint: boolean;
+                    melt: boolean;
+                };
+                unlocked: {
+                    mint: boolean;
+                    melt: boolean;
+                };
+            };
+            lockExpires: number | null;
+        }, {
+            balance: {
+                locked: string | number | bigint;
+                unlocked: string | number | bigint;
+            };
+            token: {
+                symbol: string;
+                id: string;
+                name: string;
+            };
+            transactions: number;
+            tokenAuthorities: {
+                locked: {
+                    mint: boolean;
+                    melt: boolean;
+                };
+                unlocked: {
+                    mint: boolean;
+                    melt: boolean;
+                };
+            };
+            lockExpires: number | null;
+        }>, "many">;
+    }>, "strip", z.ZodTypeAny, {
+        success: boolean;
+        balances: {
+            balance: {
+                locked: bigint;
+                unlocked: bigint;
+            };
+            token: {
+                symbol: string;
+                id: string;
+                name: string;
+            };
+            transactions: number;
+            tokenAuthorities: {
+                locked: {
+                    mint: boolean;
+                    melt: boolean;
+                };
+                unlocked: {
+                    mint: boolean;
+                    melt: boolean;
+                };
+            };
+            lockExpires: number | null;
+        }[];
+    }, {
+        success: boolean;
+        balances: {
+            balance: {
+                locked: string | number | bigint;
+                unlocked: string | number | bigint;
+            };
+            token: {
+                symbol: string;
+                id: string;
+                name: string;
+            };
+            transactions: number;
+            tokenAuthorities: {
+                locked: {
+                    mint: boolean;
+                    melt: boolean;
+                };
+                unlocked: {
+                    mint: boolean;
+                    melt: boolean;
+                };
+            };
+            lockExpires: number | null;
+        }[];
+    }>;
+    txProposalCreateResponse: z.ZodObject<z.objectUtil.extendShape<{
+        success: z.ZodBoolean;
+    }, {
+        txProposalId: z.ZodString;
+        inputs: z.ZodArray<z.ZodObject<{
+            txId: z.ZodString;
+            index: z.ZodNumber;
+            addressPath: z.ZodString;
+        }, "strip", z.ZodTypeAny, {
+            index: number;
+            txId: string;
+            addressPath: string;
+        }, {
+            index: number;
+            txId: string;
+            addressPath: string;
+        }>, "many">;
+    }>, "strip", z.ZodTypeAny, {
+        success: boolean;
+        inputs: {
+            index: number;
+            txId: string;
+            addressPath: string;
+        }[];
+        txProposalId: string;
+    }, {
+        success: boolean;
+        inputs: {
+            index: number;
+            txId: string;
+            addressPath: string;
+        }[];
+        txProposalId: string;
+    }>;
+    txProposalUpdateResponse: z.ZodObject<z.objectUtil.extendShape<{
+        success: z.ZodBoolean;
+    }, {
+        txProposalId: z.ZodString;
+        txHex: z.ZodString;
+    }>, "strip", z.ZodTypeAny, {
+        success: boolean;
+        txProposalId: string;
+        txHex: string;
+    }, {
+        success: boolean;
+        txProposalId: string;
+        txHex: string;
+    }>;
+    fullNodeVersionData: z.ZodObject<{
+        timestamp: z.ZodNumber;
+        version: z.ZodString;
+        network: z.ZodString;
+        minWeight: z.ZodNumber;
+        minTxWeight: z.ZodNumber;
+        minTxWeightCoefficient: z.ZodNumber;
+        minTxWeightK: z.ZodNumber;
+        tokenDepositPercentage: z.ZodNumber;
+        rewardSpendMinBlocks: z.ZodNumber;
+        maxNumberInputs: z.ZodNumber;
+        maxNumberOutputs: z.ZodNumber;
+        decimalPlaces: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+        genesisBlockHash: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+        genesisTx1Hash: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+        genesisTx2Hash: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+    }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
+        timestamp: z.ZodNumber;
+        version: z.ZodString;
+        network: z.ZodString;
+        minWeight: z.ZodNumber;
+        minTxWeight: z.ZodNumber;
+        minTxWeightCoefficient: z.ZodNumber;
+        minTxWeightK: z.ZodNumber;
+        tokenDepositPercentage: z.ZodNumber;
+        rewardSpendMinBlocks: z.ZodNumber;
+        maxNumberInputs: z.ZodNumber;
+        maxNumberOutputs: z.ZodNumber;
+        decimalPlaces: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+        genesisBlockHash: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+        genesisTx1Hash: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+        genesisTx2Hash: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+    }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
+        timestamp: z.ZodNumber;
+        version: z.ZodString;
+        network: z.ZodString;
+        minWeight: z.ZodNumber;
+        minTxWeight: z.ZodNumber;
+        minTxWeightCoefficient: z.ZodNumber;
+        minTxWeightK: z.ZodNumber;
+        tokenDepositPercentage: z.ZodNumber;
+        rewardSpendMinBlocks: z.ZodNumber;
+        maxNumberInputs: z.ZodNumber;
+        maxNumberOutputs: z.ZodNumber;
+        decimalPlaces: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+        genesisBlockHash: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+        genesisTx1Hash: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+        genesisTx2Hash: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+    }, z.ZodTypeAny, "passthrough">>;
+    fullNodeTxResponse: z.ZodObject<z.objectUtil.extendShape<{
+        success: z.ZodBoolean;
+    }, {
+        tx: z.ZodObject<{
+            hash: z.ZodString;
+            nonce: z.ZodString;
+            timestamp: z.ZodNumber;
+            version: z.ZodNumber;
+            weight: z.ZodNumber;
+            parents: z.ZodArray<z.ZodString, "many">;
+            inputs: z.ZodArray<z.ZodObject<{
+                value: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+                token_data: z.ZodNumber;
+                script: z.ZodString;
+                decoded: z.ZodObject<{
+                    type: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+                    address: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+                    timelock: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+                    value: z.ZodOptional<z.ZodNullable<z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>>>;
+                    token_data: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+                }, "strip", z.ZodTypeAny, {
+                    type?: string | null | undefined;
+                    address?: string | null | undefined;
+                    value?: bigint | null | undefined;
+                    timelock?: number | null | undefined;
+                    token_data?: number | null | undefined;
+                }, {
+                    type?: string | null | undefined;
+                    address?: string | null | undefined;
+                    value?: string | number | bigint | null | undefined;
+                    timelock?: number | null | undefined;
+                    token_data?: number | null | undefined;
+                }>;
+                tx_id: z.ZodString;
+                index: z.ZodNumber;
+                token: z.ZodOptional<z.ZodNullable<z.ZodUnion<[z.ZodString, z.ZodLiteral<string>]>>>;
+                spent_by: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+            }, "strip", z.ZodTypeAny, {
+                index: number;
+                value: bigint;
+                script: string;
+                token_data: number;
+                decoded: {
+                    type?: string | null | undefined;
+                    address?: string | null | undefined;
+                    value?: bigint | null | undefined;
+                    timelock?: number | null | undefined;
+                    token_data?: number | null | undefined;
+                };
+                tx_id: string;
+                token?: string | null | undefined;
+                spent_by?: string | null | undefined;
+            }, {
+                index: number;
+                value: string | number | bigint;
+                script: string;
+                token_data: number;
+                decoded: {
+                    type?: string | null | undefined;
+                    address?: string | null | undefined;
+                    value?: string | number | bigint | null | undefined;
+                    timelock?: number | null | undefined;
+                    token_data?: number | null | undefined;
+                };
+                tx_id: string;
+                token?: string | null | undefined;
+                spent_by?: string | null | undefined;
+            }>, "many">;
+            outputs: z.ZodArray<z.ZodObject<{
+                value: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+                token_data: z.ZodNumber;
+                script: z.ZodString;
+                decoded: z.ZodObject<{
+                    type: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+                    address: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+                    timelock: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+                    value: z.ZodOptional<z.ZodNullable<z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>>>;
+                    token_data: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+                }, "strip", z.ZodTypeAny, {
+                    type?: string | null | undefined;
+                    address?: string | null | undefined;
+                    value?: bigint | null | undefined;
+                    timelock?: number | null | undefined;
+                    token_data?: number | null | undefined;
+                }, {
+                    type?: string | null | undefined;
+                    address?: string | null | undefined;
+                    value?: string | number | bigint | null | undefined;
+                    timelock?: number | null | undefined;
+                    token_data?: number | null | undefined;
+                }>;
+                address: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+                token: z.ZodOptional<z.ZodNullable<z.ZodUnion<[z.ZodString, z.ZodLiteral<string>]>>>;
+                authorities: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+                timelock: z.ZodNullable<z.ZodNumber>;
+            }, "strip", z.ZodTypeAny, {
+                value: bigint;
+                script: string;
+                timelock: number | null;
+                authorities: bigint;
+                token_data: number;
+                decoded: {
+                    type?: string | null | undefined;
+                    address?: string | null | undefined;
+                    value?: bigint | null | undefined;
+                    timelock?: number | null | undefined;
+                    token_data?: number | null | undefined;
+                };
+                address?: string | null | undefined;
+                token?: string | null | undefined;
+            }, {
+                value: string | number | bigint;
+                script: string;
+                timelock: number | null;
+                authorities: string | number | bigint;
+                token_data: number;
+                decoded: {
+                    type?: string | null | undefined;
+                    address?: string | null | undefined;
+                    value?: string | number | bigint | null | undefined;
+                    timelock?: number | null | undefined;
+                    token_data?: number | null | undefined;
+                };
+                address?: string | null | undefined;
+                token?: string | null | undefined;
+            }>, "many">;
+            tokens: z.ZodArray<z.ZodObject<{
+                uid: z.ZodString;
+                name: z.ZodString;
+                symbol: z.ZodString;
+                amount: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            }, "strip", z.ZodTypeAny, {
+                symbol: string;
+                name: string;
+                amount: bigint;
+                uid: string;
+            }, {
+                symbol: string;
+                name: string;
+                amount: string | number | bigint;
+                uid: string;
+            }>, "many">;
+            token_name: z.ZodNullable<z.ZodString>;
+            token_symbol: z.ZodNullable<z.ZodString>;
+            raw: z.ZodString;
+        }, "strip", z.ZodTypeAny, {
+            raw: string;
+            nonce: string;
+            hash: string;
+            tokens: {
+                symbol: string;
+                name: string;
+                amount: bigint;
+                uid: string;
+            }[];
+            timestamp: number;
+            version: number;
+            weight: number;
+            inputs: {
+                index: number;
+                value: bigint;
+                script: string;
+                token_data: number;
+                decoded: {
+                    type?: string | null | undefined;
+                    address?: string | null | undefined;
+                    value?: bigint | null | undefined;
+                    timelock?: number | null | undefined;
+                    token_data?: number | null | undefined;
+                };
+                tx_id: string;
+                token?: string | null | undefined;
+                spent_by?: string | null | undefined;
+            }[];
+            outputs: {
+                value: bigint;
+                script: string;
+                timelock: number | null;
+                authorities: bigint;
+                token_data: number;
+                decoded: {
+                    type?: string | null | undefined;
+                    address?: string | null | undefined;
+                    value?: bigint | null | undefined;
+                    timelock?: number | null | undefined;
+                    token_data?: number | null | undefined;
+                };
+                address?: string | null | undefined;
+                token?: string | null | undefined;
+            }[];
+            parents: string[];
+            token_name: string | null;
+            token_symbol: string | null;
+        }, {
+            raw: string;
+            nonce: string;
+            hash: string;
+            tokens: {
+                symbol: string;
+                name: string;
+                amount: string | number | bigint;
+                uid: string;
+            }[];
+            timestamp: number;
+            version: number;
+            weight: number;
+            inputs: {
+                index: number;
+                value: string | number | bigint;
+                script: string;
+                token_data: number;
+                decoded: {
+                    type?: string | null | undefined;
+                    address?: string | null | undefined;
+                    value?: string | number | bigint | null | undefined;
+                    timelock?: number | null | undefined;
+                    token_data?: number | null | undefined;
+                };
+                tx_id: string;
+                token?: string | null | undefined;
+                spent_by?: string | null | undefined;
+            }[];
+            outputs: {
+                value: string | number | bigint;
+                script: string;
+                timelock: number | null;
+                authorities: string | number | bigint;
+                token_data: number;
+                decoded: {
+                    type?: string | null | undefined;
+                    address?: string | null | undefined;
+                    value?: string | number | bigint | null | undefined;
+                    timelock?: number | null | undefined;
+                    token_data?: number | null | undefined;
+                };
+                address?: string | null | undefined;
+                token?: string | null | undefined;
+            }[];
+            parents: string[];
+            token_name: string | null;
+            token_symbol: string | null;
+        }>;
+        meta: z.ZodObject<{
+            hash: z.ZodString;
+            received_by: z.ZodArray<z.ZodString, "many">;
+            children: z.ZodArray<z.ZodString, "many">;
+            conflict_with: z.ZodArray<z.ZodString, "many">;
+            first_block: z.ZodNullable<z.ZodString>;
+            height: z.ZodNumber;
+            voided_by: z.ZodArray<z.ZodString, "many">;
+            spent_outputs: z.ZodArray<z.ZodTuple<[z.ZodNumber, z.ZodArray<z.ZodString, "many">], null>, "many">;
+            received_timestamp: z.ZodNullable<z.ZodNumber>;
+            is_voided: z.ZodBoolean;
+            verification_status: z.ZodString;
+            twins: z.ZodArray<z.ZodString, "many">;
+            accumulated_weight: z.ZodNumber;
+            score: z.ZodNumber;
+        }, "strip", z.ZodTypeAny, {
+            height: number;
+            children: string[];
+            hash: string;
+            is_voided: boolean;
+            first_block: string | null;
+            spent_outputs: [number, string[]][];
+            received_by: string[];
+            conflict_with: string[];
+            voided_by: string[];
+            twins: string[];
+            accumulated_weight: number;
+            score: number;
+            received_timestamp: number | null;
+            verification_status: string;
+        }, {
+            height: number;
+            children: string[];
+            hash: string;
+            is_voided: boolean;
+            first_block: string | null;
+            spent_outputs: [number, string[]][];
+            received_by: string[];
+            conflict_with: string[];
+            voided_by: string[];
+            twins: string[];
+            accumulated_weight: number;
+            score: number;
+            received_timestamp: number | null;
+            verification_status: string;
+        }>;
+        message: z.ZodOptional<z.ZodString>;
+        spent_outputs: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodString>>;
+    }>, "strip", z.ZodTypeAny, {
+        meta: {
+            height: number;
+            children: string[];
+            hash: string;
+            is_voided: boolean;
+            first_block: string | null;
+            spent_outputs: [number, string[]][];
+            received_by: string[];
+            conflict_with: string[];
+            voided_by: string[];
+            twins: string[];
+            accumulated_weight: number;
+            score: number;
+            received_timestamp: number | null;
+            verification_status: string;
+        };
+        success: boolean;
+        tx: {
+            raw: string;
+            nonce: string;
+            hash: string;
+            tokens: {
+                symbol: string;
+                name: string;
+                amount: bigint;
+                uid: string;
+            }[];
+            timestamp: number;
+            version: number;
+            weight: number;
+            inputs: {
+                index: number;
+                value: bigint;
+                script: string;
+                token_data: number;
+                decoded: {
+                    type?: string | null | undefined;
+                    address?: string | null | undefined;
+                    value?: bigint | null | undefined;
+                    timelock?: number | null | undefined;
+                    token_data?: number | null | undefined;
+                };
+                tx_id: string;
+                token?: string | null | undefined;
+                spent_by?: string | null | undefined;
+            }[];
+            outputs: {
+                value: bigint;
+                script: string;
+                timelock: number | null;
+                authorities: bigint;
+                token_data: number;
+                decoded: {
+                    type?: string | null | undefined;
+                    address?: string | null | undefined;
+                    value?: bigint | null | undefined;
+                    timelock?: number | null | undefined;
+                    token_data?: number | null | undefined;
+                };
+                address?: string | null | undefined;
+                token?: string | null | undefined;
+            }[];
+            parents: string[];
+            token_name: string | null;
+            token_symbol: string | null;
+        };
+        message?: string | undefined;
+        spent_outputs?: Record<string, string> | undefined;
+    }, {
+        meta: {
+            height: number;
+            children: string[];
+            hash: string;
+            is_voided: boolean;
+            first_block: string | null;
+            spent_outputs: [number, string[]][];
+            received_by: string[];
+            conflict_with: string[];
+            voided_by: string[];
+            twins: string[];
+            accumulated_weight: number;
+            score: number;
+            received_timestamp: number | null;
+            verification_status: string;
+        };
+        success: boolean;
+        tx: {
+            raw: string;
+            nonce: string;
+            hash: string;
+            tokens: {
+                symbol: string;
+                name: string;
+                amount: string | number | bigint;
+                uid: string;
+            }[];
+            timestamp: number;
+            version: number;
+            weight: number;
+            inputs: {
+                index: number;
+                value: string | number | bigint;
+                script: string;
+                token_data: number;
+                decoded: {
+                    type?: string | null | undefined;
+                    address?: string | null | undefined;
+                    value?: string | number | bigint | null | undefined;
+                    timelock?: number | null | undefined;
+                    token_data?: number | null | undefined;
+                };
+                tx_id: string;
+                token?: string | null | undefined;
+                spent_by?: string | null | undefined;
+            }[];
+            outputs: {
+                value: string | number | bigint;
+                script: string;
+                timelock: number | null;
+                authorities: string | number | bigint;
+                token_data: number;
+                decoded: {
+                    type?: string | null | undefined;
+                    address?: string | null | undefined;
+                    value?: string | number | bigint | null | undefined;
+                    timelock?: number | null | undefined;
+                    token_data?: number | null | undefined;
+                };
+                address?: string | null | undefined;
+                token?: string | null | undefined;
+            }[];
+            parents: string[];
+            token_name: string | null;
+            token_symbol: string | null;
+        };
+        message?: string | undefined;
+        spent_outputs?: Record<string, string> | undefined;
+    }>;
+    fullNodeTxConfirmationDataResponse: z.ZodObject<z.objectUtil.extendShape<{
+        success: z.ZodBoolean;
+    }, {
+        accumulated_weight: z.ZodNumber;
+        accumulated_bigger: z.ZodBoolean;
+        stop_value: z.ZodNumber;
+        confirmation_level: z.ZodNumber;
+    }>, "strip", z.ZodTypeAny, {
+        success: boolean;
+        accumulated_weight: number;
+        accumulated_bigger: boolean;
+        stop_value: number;
+        confirmation_level: number;
+    }, {
+        success: boolean;
+        accumulated_weight: number;
+        accumulated_bigger: boolean;
+        stop_value: number;
+        confirmation_level: number;
+    }>;
+    walletStatusResponse: z.ZodObject<z.objectUtil.extendShape<{
+        success: z.ZodBoolean;
+    }, {
+        status: z.ZodObject<{
+            walletId: z.ZodString;
+            xpubkey: z.ZodString;
+            status: z.ZodString;
+            maxGap: z.ZodNumber;
+            createdAt: z.ZodNumber;
+            readyAt: z.ZodNullable<z.ZodNumber>;
+        }, "strip", z.ZodTypeAny, {
+            status: string;
+            xpubkey: string;
+            walletId: string;
+            maxGap: number;
+            createdAt: number;
+            readyAt: number | null;
+        }, {
+            status: string;
+            xpubkey: string;
+            walletId: string;
+            maxGap: number;
+            createdAt: number;
+            readyAt: number | null;
+        }>;
+        error: z.ZodOptional<z.ZodString>;
+    }>, "strip", z.ZodTypeAny, {
+        success: boolean;
+        status: {
+            status: string;
+            xpubkey: string;
+            walletId: string;
+            maxGap: number;
+            createdAt: number;
+            readyAt: number | null;
+        };
+        error?: string | undefined;
+    }, {
+        success: boolean;
+        status: {
+            status: string;
+            xpubkey: string;
+            walletId: string;
+            maxGap: number;
+            createdAt: number;
+            readyAt: number | null;
+        };
+        error?: string | undefined;
+    }>;
+    tokensResponse: z.ZodObject<z.objectUtil.extendShape<{
+        success: z.ZodBoolean;
+    }, {
+        tokens: z.ZodArray<z.ZodString, "many">;
+    }>, "strip", z.ZodTypeAny, {
+        success: boolean;
+        tokens: string[];
+    }, {
+        success: boolean;
+        tokens: string[];
+    }>;
+    historyResponse: z.ZodObject<z.objectUtil.extendShape<{
+        success: z.ZodBoolean;
+    }, {
+        history: z.ZodArray<z.ZodObject<{
+            txId: z.ZodString;
+            balance: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            timestamp: z.ZodNumber;
+            voided: z.ZodEffects<z.ZodNumber, boolean, number>;
+            version: z.ZodNumber;
+        }, "strip", z.ZodTypeAny, {
+            balance: bigint;
+            timestamp: number;
+            version: number;
+            txId: string;
+            voided: boolean;
+        }, {
+            balance: string | number | bigint;
+            timestamp: number;
+            version: number;
+            txId: string;
+            voided: number;
+        }>, "many">;
+    }>, "strip", z.ZodTypeAny, {
+        success: boolean;
+        history: {
+            balance: bigint;
+            timestamp: number;
+            version: number;
+            txId: string;
+            voided: boolean;
+        }[];
+    }, {
+        success: boolean;
+        history: {
+            balance: string | number | bigint;
+            timestamp: number;
+            version: number;
+            txId: string;
+            voided: number;
+        }[];
+    }>;
+    txOutputResponse: z.ZodObject<z.objectUtil.extendShape<{
+        success: z.ZodBoolean;
+    }, {
+        txOutputs: z.ZodArray<z.ZodObject<{
+            txId: z.ZodString;
+            index: z.ZodNumber;
+            tokenId: z.ZodString;
+            address: z.ZodString;
+            value: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            authorities: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            timelock: z.ZodNullable<z.ZodNumber>;
+            heightlock: z.ZodNullable<z.ZodNumber>;
+            locked: z.ZodBoolean;
+            addressPath: z.ZodString;
+        }, "strip", z.ZodTypeAny, {
+            index: number;
+            address: string;
+            value: bigint;
+            timelock: number | null;
+            locked: boolean;
+            authorities: bigint;
+            txId: string;
+            addressPath: string;
+            tokenId: string;
+            heightlock: number | null;
+        }, {
+            index: number;
+            address: string;
+            value: string | number | bigint;
+            timelock: number | null;
+            locked: boolean;
+            authorities: string | number | bigint;
+            txId: string;
+            addressPath: string;
+            tokenId: string;
+            heightlock: number | null;
+        }>, "many">;
+    }>, "strip", z.ZodTypeAny, {
+        success: boolean;
+        txOutputs: {
+            index: number;
+            address: string;
+            value: bigint;
+            timelock: number | null;
+            locked: boolean;
+            authorities: bigint;
+            txId: string;
+            addressPath: string;
+            tokenId: string;
+            heightlock: number | null;
+        }[];
+    }, {
+        success: boolean;
+        txOutputs: {
+            index: number;
+            address: string;
+            value: string | number | bigint;
+            timelock: number | null;
+            locked: boolean;
+            authorities: string | number | bigint;
+            txId: string;
+            addressPath: string;
+            tokenId: string;
+            heightlock: number | null;
+        }[];
+    }>;
+    authTokenResponse: z.ZodObject<z.objectUtil.extendShape<{
+        success: z.ZodBoolean;
+    }, {
+        token: z.ZodString;
+    }>, "strip", z.ZodTypeAny, {
+        success: boolean;
+        token: string;
+    }, {
+        success: boolean;
+        token: string;
+    }>;
+    txByIdResponse: z.ZodObject<z.objectUtil.extendShape<{
+        success: z.ZodBoolean;
+    }, {
+        txTokens: z.ZodArray<z.ZodObject<{
+            txId: z.ZodString;
+            timestamp: z.ZodNumber;
+            version: z.ZodNumber;
+            voided: z.ZodBoolean;
+            height: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+            weight: z.ZodNumber;
+            balance: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            tokenId: z.ZodString;
+            tokenName: z.ZodString;
+            tokenSymbol: z.ZodString;
+        }, "strip", z.ZodTypeAny, {
+            balance: bigint;
+            timestamp: number;
+            version: number;
+            weight: number;
+            txId: string;
+            voided: boolean;
+            tokenId: string;
+            tokenName: string;
+            tokenSymbol: string;
+            height?: number | null | undefined;
+        }, {
+            balance: string | number | bigint;
+            timestamp: number;
+            version: number;
+            weight: number;
+            txId: string;
+            voided: boolean;
+            tokenId: string;
+            tokenName: string;
+            tokenSymbol: string;
+            height?: number | null | undefined;
+        }>, "many">;
+    }>, "strip", z.ZodTypeAny, {
+        success: boolean;
+        txTokens: {
+            balance: bigint;
+            timestamp: number;
+            version: number;
+            weight: number;
+            txId: string;
+            voided: boolean;
+            tokenId: string;
+            tokenName: string;
+            tokenSymbol: string;
+            height?: number | null | undefined;
+        }[];
+    }, {
+        success: boolean;
+        txTokens: {
+            balance: string | number | bigint;
+            timestamp: number;
+            version: number;
+            weight: number;
+            txId: string;
+            voided: boolean;
+            tokenId: string;
+            tokenName: string;
+            tokenSymbol: string;
+            height?: number | null | undefined;
+        }[];
+    }>;
+    wsTransaction: z.ZodObject<{
+        tx_id: z.ZodString;
+        nonce: z.ZodNumber;
+        timestamp: z.ZodNumber;
+        version: z.ZodNumber;
+        voided: z.ZodBoolean;
+        weight: z.ZodNumber;
+        parents: z.ZodArray<z.ZodString, "many">;
+        inputs: z.ZodArray<z.ZodObject<{
+            tx_id: z.ZodString;
+            index: z.ZodNumber;
+            value: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            token_data: z.ZodNumber;
+            script: z.ZodObject<{
+                type: z.ZodLiteral<"Buffer">;
+                data: z.ZodArray<z.ZodNumber, "many">;
+            }, "strip", z.ZodTypeAny, {
+                type: "Buffer";
+                data: number[];
+            }, {
+                type: "Buffer";
+                data: number[];
+            }>;
+            token: z.ZodUnion<[z.ZodString, z.ZodLiteral<string>]>;
+            decoded: z.ZodObject<{
+                type: z.ZodString;
+                address: z.ZodString;
+                timelock: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+            }, "strip", z.ZodTypeAny, {
+                type: string;
+                address: string;
+                timelock?: number | null | undefined;
+            }, {
+                type: string;
+                address: string;
+                timelock?: number | null | undefined;
+            }>;
+        }, "strip", z.ZodTypeAny, {
+            index: number;
+            value: bigint;
+            script: {
+                type: "Buffer";
+                data: number[];
+            };
+            token_data: number;
+            decoded: {
+                type: string;
+                address: string;
+                timelock?: number | null | undefined;
+            };
+            token: string;
+            tx_id: string;
+        }, {
+            index: number;
+            value: string | number | bigint;
+            script: {
+                type: "Buffer";
+                data: number[];
+            };
+            token_data: number;
+            decoded: {
+                type: string;
+                address: string;
+                timelock?: number | null | undefined;
+            };
+            token: string;
+            tx_id: string;
+        }>, "many">;
+        outputs: z.ZodArray<z.ZodObject<{
+            value: z.ZodPipeline<z.ZodUnion<[z.ZodUnion<[z.ZodBigInt, z.ZodNumber]>, z.ZodString]>, z.ZodBigInt>;
+            token_data: z.ZodNumber;
+            script: z.ZodObject<{
+                type: z.ZodLiteral<"Buffer">;
+                data: z.ZodArray<z.ZodNumber, "many">;
+            }, "strip", z.ZodTypeAny, {
+                type: "Buffer";
+                data: number[];
+            }, {
+                type: "Buffer";
+                data: number[];
+            }>;
+            decodedScript: z.ZodOptional<z.ZodNullable<z.ZodAny>>;
+            token: z.ZodUnion<[z.ZodString, z.ZodLiteral<string>]>;
+            locked: z.ZodBoolean;
+            index: z.ZodNumber;
+            decoded: z.ZodObject<{
+                type: z.ZodOptional<z.ZodNullable<z.ZodString>>;
+                address: z.ZodOptional<z.ZodString>;
+                timelock: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+            }, "strip", z.ZodTypeAny, {
+                type?: string | null | undefined;
+                address?: string | undefined;
+                timelock?: number | null | undefined;
+            }, {
+                type?: string | null | undefined;
+                address?: string | undefined;
+                timelock?: number | null | undefined;
+            }>;
+        }, "strip", z.ZodTypeAny, {
+            index: number;
+            value: bigint;
+            script: {
+                type: "Buffer";
+                data: number[];
+            };
+            locked: boolean;
+            token_data: number;
+            decoded: {
+                type?: string | null | undefined;
+                address?: string | undefined;
+                timelock?: number | null | undefined;
+            };
+            token: string;
+            decodedScript?: any;
+        }, {
+            index: number;
+            value: string | number | bigint;
+            script: {
+                type: "Buffer";
+                data: number[];
+            };
+            locked: boolean;
+            token_data: number;
+            decoded: {
+                type?: string | null | undefined;
+                address?: string | undefined;
+                timelock?: number | null | undefined;
+            };
+            token: string;
+            decodedScript?: any;
+        }>, "many">;
+        height: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
+        token_name: z.ZodNullable<z.ZodString>;
+        token_symbol: z.ZodNullable<z.ZodString>;
+        signal_bits: z.ZodNumber;
+    }, "strip", z.ZodTypeAny, {
+        nonce: number;
+        tx_id: string;
+        timestamp: number;
+        version: number;
+        weight: number;
+        inputs: {
+            index: number;
+            value: bigint;
+            script: {
+                type: "Buffer";
+                data: number[];
+            };
+            token_data: number;
+            decoded: {
+                type: string;
+                address: string;
+                timelock?: number | null | undefined;
+            };
+            token: string;
+            tx_id: string;
+        }[];
+        outputs: {
+            index: number;
+            value: bigint;
+            script: {
+                type: "Buffer";
+                data: number[];
+            };
+            locked: boolean;
+            token_data: number;
+            decoded: {
+                type?: string | null | undefined;
+                address?: string | undefined;
+                timelock?: number | null | undefined;
+            };
+            token: string;
+            decodedScript?: any;
+        }[];
+        parents: string[];
+        token_name: string | null;
+        token_symbol: string | null;
+        signal_bits: number;
+        voided: boolean;
+        height?: number | null | undefined;
+    }, {
+        nonce: number;
+        tx_id: string;
+        timestamp: number;
+        version: number;
+        weight: number;
+        inputs: {
+            index: number;
+            value: string | number | bigint;
+            script: {
+                type: "Buffer";
+                data: number[];
+            };
+            token_data: number;
+            decoded: {
+                type: string;
+                address: string;
+                timelock?: number | null | undefined;
+            };
+            token: string;
+            tx_id: string;
+        }[];
+        outputs: {
+            index: number;
+            value: string | number | bigint;
+            script: {
+                type: "Buffer";
+                data: number[];
+            };
+            locked: boolean;
+            token_data: number;
+            decoded: {
+                type?: string | null | undefined;
+                address?: string | undefined;
+                timelock?: number | null | undefined;
+            };
+            token: string;
+            decodedScript?: any;
+        }[];
+        parents: string[];
+        token_name: string | null;
+        token_symbol: string | null;
+        signal_bits: number;
+        voided: boolean;
+        height?: number | null | undefined;
+    }>;
+};
+//# sourceMappingURL=walletApi.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/wallet/api/schemas/walletApi.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/wallet/api/schemas/walletApi.d.ts.map
new file mode 100644
index 0000000..8c81252
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/wallet/api/schemas/walletApi.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"walletApi.d.ts","sourceRoot":"","sources":["../../../../src/wallet/api/schemas/walletApi.ts"],"names":[],"mappings":"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;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAc9B,CAAC;AAEH;;;GAGG;AACH,eAAO,MAAM,gBAAgB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAkB5B,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/wallet/api/schemas/walletApi.js b/node_modules/@hathor/wallet-lib/oldLib/wallet/api/schemas/walletApi.js
new file mode 100644
index 0000000..118bcb0
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/wallet/api/schemas/walletApi.js
@@ -0,0 +1,543 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.wsTransactionSchema = exports.walletStatusResponseSchema = exports.walletApiSchemas = exports.txProposalUpdateResponseSchema = exports.txProposalOutputsSchema = exports.txProposalInputsSchema = exports.txProposalCreateResponseSchema = exports.txOutputSchema = exports.txOutputResponseSchema = exports.txInputSchema = exports.txByIdResponseSchema = exports.tokensResponseSchema = exports.tokenInfoSchema = exports.tokenIdSchema = exports.tokenDetailsResponseSchema = exports.newAddressesResponseSchema = exports.historyResponseSchema = exports.getBalanceObjectSchema = exports.getAddressesObjectSchema = exports.fullNodeVersionDataSchema = exports.fullNodeTxSchema = exports.fullNodeTxResponseSchema = exports.fullNodeTxConfirmationDataResponseSchema = exports.fullNodeTokenSchema = exports.fullNodeOutputSchema = exports.fullNodeMetaSchema = exports.fullNodeInputSchema = exports.checkAddressesMineResponseSchema = exports.balanceSchema = exports.balanceResponseSchema = exports.authorityBalanceSchema = exports.authTokenResponseSchema = exports.addressesResponseSchema = exports.addressInfoObjectSchema = exports.AddressSchema = exports.AddressPathSchema = void 0;
+var _zod = require("zod");
+var _constants = require("../../../constants");
+var _schemas = require("../../../schemas");
+var _bigint = require("../../../utils/bigint");
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+/**
+ * Schema for validating Hathor addresses.
+ * Addresses are base58 encoded and must be 34-35 characters long.
+ * They can only contain characters from the base58 alphabet.
+ */
+const AddressSchema = exports.AddressSchema = _zod.z.string().regex(/^[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{34,35}$/);
+
+/**
+ * Schema for validating BIP44 derivation paths.
+ * Must start with 'm' followed by zero or more segments.
+ * Each segment starts with '/' followed by numbers and may end with a single quote (').
+ * Example: m/44'/280'/0'/0/0
+ */
+const AddressPathSchema = exports.AddressPathSchema = _zod.z.string().regex(/^m(\/\d+'?)*$/, 'Invalid BIP44 derivation path format');
+
+/**
+ * Base response schema that all API responses extend from.
+ * Contains a success flag indicating if the operation was successful.
+ */
+const baseResponseSchema = _zod.z.object({
+  success: _zod.z.boolean()
+});
+
+/**
+ * Schema for individual address information.
+ * Represents a single address in the wallet with its derivation index and transaction count.
+ */
+const getAddressesObjectSchema = exports.getAddressesObjectSchema = _zod.z.object({
+  address: AddressSchema,
+  // Address in base58
+  index: _zod.z.number(),
+  // derivation index of the address
+  transactions: _zod.z.number() // quantity of transactions
+});
+
+/**
+ * Response schema for getting all addresses in the wallet.
+ */
+const addressesResponseSchema = exports.addressesResponseSchema = baseResponseSchema.extend({
+  addresses: _zod.z.array(getAddressesObjectSchema)
+});
+
+/**
+ * Response schema for checking if addresses belong to the wallet.
+ * Maps addresses to boolean values indicating ownership.
+ */
+const checkAddressesMineResponseSchema = exports.checkAddressesMineResponseSchema = baseResponseSchema.extend({
+  addresses: _zod.z.record(AddressSchema, _zod.z.boolean()) // WalletAddressMap with validated address keys
+});
+
+/**
+ * Schema for address information used in new address generation.
+ */
+const addressInfoObjectSchema = exports.addressInfoObjectSchema = _zod.z.object({
+  address: AddressSchema,
+  index: _zod.z.number(),
+  addressPath: AddressPathSchema,
+  info: _zod.z.string().optional()
+}).strict();
+
+/**
+ * Response schema for generating new addresses.
+ */
+const newAddressesResponseSchema = exports.newAddressesResponseSchema = baseResponseSchema.extend({
+  addresses: _zod.z.array(addressInfoObjectSchema)
+});
+
+/**
+ * TokenId schema
+ */
+const tokenIdSchema = exports.tokenIdSchema = _zod.z.union([_schemas.txIdSchema, _zod.z.literal(_constants.NATIVE_TOKEN_UID)]);
+
+/**
+ * Schema for token information.
+ */
+const tokenInfoSchema = exports.tokenInfoSchema = _zod.z.object({
+  id: tokenIdSchema,
+  name: _zod.z.string(),
+  symbol: _zod.z.string()
+});
+
+/**
+ * Response schema for token details.
+ * Contains information about a token's name, symbol, total supply, and authorities.
+ */
+const tokenDetailsResponseSchema = exports.tokenDetailsResponseSchema = baseResponseSchema.extend({
+  details: _zod.z.object({
+    tokenInfo: tokenInfoSchema,
+    totalSupply: _bigint.bigIntCoercibleSchema,
+    totalTransactions: _zod.z.number(),
+    authorities: _zod.z.object({
+      mint: _zod.z.boolean(),
+      melt: _zod.z.boolean()
+    })
+  })
+});
+
+/**
+ * Schema for token balance information.
+ * Represents both unlocked and locked balances for a token.
+ */
+const balanceSchema = exports.balanceSchema = _zod.z.object({
+  unlocked: _bigint.bigIntCoercibleSchema,
+  locked: _bigint.bigIntCoercibleSchema
+});
+
+/**
+ * Schema for token authority balances.
+ * Represents mint and melt authority balances in both unlocked and locked states.
+ */
+const authorityBalanceSchema = exports.authorityBalanceSchema = _zod.z.object({
+  unlocked: _zod.z.object({
+    mint: _zod.z.boolean(),
+    melt: _zod.z.boolean()
+  }),
+  locked: _zod.z.object({
+    mint: _zod.z.boolean(),
+    melt: _zod.z.boolean()
+  })
+});
+
+/**
+ * Schema for balance object.
+ * Contains token info, balance, authorities, and transaction count.
+ */
+const getBalanceObjectSchema = exports.getBalanceObjectSchema = _zod.z.object({
+  token: tokenInfoSchema,
+  balance: balanceSchema,
+  tokenAuthorities: authorityBalanceSchema,
+  transactions: _zod.z.number(),
+  lockExpires: _zod.z.number().nullable()
+});
+
+/**
+ * Response schema for token balances.
+ * Contains an array of balance objects for each token.
+ */
+const balanceResponseSchema = exports.balanceResponseSchema = baseResponseSchema.extend({
+  balances: _zod.z.array(getBalanceObjectSchema)
+});
+
+/**
+ * Schema for transaction proposal inputs.
+ * Represents the inputs that will be used in a transaction.
+ */
+const txProposalInputsSchema = exports.txProposalInputsSchema = _zod.z.object({
+  txId: _zod.z.string(),
+  index: _zod.z.number(),
+  addressPath: AddressPathSchema
+});
+
+/**
+ * Schema for transaction proposal outputs.
+ * Represents the outputs that will be created in a transaction.
+ */
+const txProposalOutputsSchema = exports.txProposalOutputsSchema = _zod.z.object({
+  address: AddressSchema,
+  value: _bigint.bigIntCoercibleSchema,
+  token: tokenIdSchema,
+  timelock: _zod.z.number().nullable()
+});
+
+/**
+ * Response schema for creating a transaction proposal.
+ * Contains the proposal ID and the transaction details.
+ */
+const txProposalCreateResponseSchema = exports.txProposalCreateResponseSchema = baseResponseSchema.extend({
+  txProposalId: _zod.z.string(),
+  inputs: _zod.z.array(txProposalInputsSchema)
+});
+
+/**
+ * Response schema for updating a transaction proposal.
+ * Contains the proposal ID and the transaction hex.
+ */
+const txProposalUpdateResponseSchema = exports.txProposalUpdateResponseSchema = baseResponseSchema.extend({
+  txProposalId: _zod.z.string(),
+  txHex: _zod.z.string()
+});
+
+/**
+ * Schema for full node version data.
+ * Contains network parameters and configuration values.
+ * Uses passthrough() to allow additional fields in the response without breaking validation,
+ * as the full node may add new fields in future versions without changing the API version.
+ */
+const fullNodeVersionDataSchema = exports.fullNodeVersionDataSchema = _zod.z.object({
+  timestamp: _zod.z.number(),
+  version: _zod.z.string(),
+  network: _zod.z.string(),
+  minWeight: _zod.z.number(),
+  minTxWeight: _zod.z.number(),
+  minTxWeightCoefficient: _zod.z.number(),
+  minTxWeightK: _zod.z.number(),
+  tokenDepositPercentage: _zod.z.number(),
+  rewardSpendMinBlocks: _zod.z.number(),
+  maxNumberInputs: _zod.z.number(),
+  maxNumberOutputs: _zod.z.number(),
+  decimalPlaces: _zod.z.number().nullable().optional(),
+  genesisBlockHash: _zod.z.string().nullable().optional(),
+  genesisTx1Hash: _zod.z.string().nullable().optional(),
+  genesisTx2Hash: _zod.z.string().nullable().optional()
+}).passthrough();
+
+/**
+ * Schema for full node transaction inputs.
+ * Represents the inputs of a transaction as seen by the full node.
+ */
+const fullNodeInputSchema = exports.fullNodeInputSchema = _zod.z.object({
+  value: _bigint.bigIntCoercibleSchema,
+  token_data: _zod.z.number(),
+  script: _zod.z.string(),
+  decoded: _zod.z.object({
+    type: _zod.z.string().nullable().optional(),
+    address: AddressSchema.nullable().optional(),
+    timelock: _zod.z.number().nullable().optional(),
+    value: _bigint.bigIntCoercibleSchema.nullable().optional(),
+    token_data: _zod.z.number().nullable().optional()
+  }),
+  tx_id: _schemas.txIdSchema,
+  index: _zod.z.number(),
+  token: tokenIdSchema.nullable().optional(),
+  spent_by: _zod.z.string().nullable().optional()
+});
+
+/**
+ * Schema for full node transaction outputs.
+ * Represents the outputs of a transaction as seen by the full node.
+ */
+const fullNodeOutputSchema = exports.fullNodeOutputSchema = _zod.z.object({
+  value: _bigint.bigIntCoercibleSchema,
+  token_data: _zod.z.number(),
+  script: _zod.z.string(),
+  decoded: _zod.z.object({
+    type: _zod.z.string().nullable().optional(),
+    address: AddressSchema.nullable().optional(),
+    timelock: _zod.z.number().nullable().optional(),
+    value: _bigint.bigIntCoercibleSchema.nullable().optional(),
+    token_data: _zod.z.number().nullable().optional()
+  }),
+  address: AddressSchema.nullable().optional(),
+  token: tokenIdSchema.nullable().optional(),
+  authorities: _bigint.bigIntCoercibleSchema,
+  timelock: _zod.z.number().nullable()
+});
+
+/**
+ * Schema for full node token information.
+ * Represents token details as seen by the full node.
+ */
+const fullNodeTokenSchema = exports.fullNodeTokenSchema = _zod.z.object({
+  uid: _zod.z.string(),
+  name: _zod.z.string(),
+  symbol: _zod.z.string(),
+  amount: _bigint.bigIntCoercibleSchema
+});
+
+/**
+ * Schema for full node transaction data.
+ * Contains all information about a transaction as seen by the full node.
+ */
+const fullNodeTxSchema = exports.fullNodeTxSchema = _zod.z.object({
+  hash: _zod.z.string(),
+  nonce: _zod.z.string(),
+  timestamp: _zod.z.number(),
+  version: _zod.z.number(),
+  weight: _zod.z.number(),
+  parents: _zod.z.array(_zod.z.string()),
+  inputs: _zod.z.array(fullNodeInputSchema),
+  outputs: _zod.z.array(fullNodeOutputSchema),
+  tokens: _zod.z.array(fullNodeTokenSchema),
+  token_name: _zod.z.string().nullable(),
+  token_symbol: _zod.z.string().nullable(),
+  raw: _zod.z.string()
+});
+
+/**
+ * Schema for full node transaction metadata.
+ * Contains additional information about a transaction's status and relationships.
+ */
+const fullNodeMetaSchema = exports.fullNodeMetaSchema = _zod.z.object({
+  hash: _zod.z.string(),
+  received_by: _zod.z.array(_zod.z.string()),
+  children: _zod.z.array(_zod.z.string()),
+  conflict_with: _zod.z.array(_zod.z.string()),
+  first_block: _zod.z.string().nullable(),
+  height: _zod.z.number(),
+  voided_by: _zod.z.array(_zod.z.string()),
+  spent_outputs: _zod.z.array(_zod.z.tuple([_zod.z.number(), _zod.z.array(_zod.z.string())])),
+  received_timestamp: _zod.z.number().nullable(),
+  is_voided: _zod.z.boolean(),
+  verification_status: _zod.z.string(),
+  twins: _zod.z.array(_zod.z.string()),
+  accumulated_weight: _zod.z.number(),
+  score: _zod.z.number()
+});
+
+/**
+ * Response schema for full node transaction data.
+ * Contains the transaction details, metadata, and optional message.
+ */
+const fullNodeTxResponseSchema = exports.fullNodeTxResponseSchema = baseResponseSchema.extend({
+  tx: fullNodeTxSchema,
+  meta: fullNodeMetaSchema,
+  message: _zod.z.string().optional(),
+  spent_outputs: _zod.z.record(_zod.z.string()).optional()
+});
+
+/**
+ * Response schema for transaction confirmation data.
+ * Contains information about the transaction's confirmation status and weight.
+ */
+const fullNodeTxConfirmationDataResponseSchema = exports.fullNodeTxConfirmationDataResponseSchema = baseResponseSchema.extend({
+  accumulated_weight: _zod.z.number(),
+  accumulated_bigger: _zod.z.boolean(),
+  stop_value: _zod.z.number(),
+  confirmation_level: _zod.z.number()
+});
+
+/**
+ * Response schema for wallet status.
+ * Contains information about the wallet's current state.
+ */
+const walletStatusResponseSchema = exports.walletStatusResponseSchema = baseResponseSchema.extend({
+  status: _zod.z.object({
+    walletId: _zod.z.string(),
+    xpubkey: _zod.z.string(),
+    status: _zod.z.string(),
+    maxGap: _zod.z.number(),
+    createdAt: _zod.z.number(),
+    readyAt: _zod.z.number().nullable()
+  }),
+  error: _zod.z.string().optional()
+});
+
+/**
+ * Response schema for token list.
+ * Contains an array of token information.
+ */
+const tokensResponseSchema = exports.tokensResponseSchema = baseResponseSchema.extend({
+  tokens: _zod.z.array(_zod.z.string())
+});
+
+/**
+ * Response schema for transaction history.
+ * Contains an array of transaction information.
+ */
+const historyResponseSchema = exports.historyResponseSchema = baseResponseSchema.extend({
+  history: _zod.z.array(_zod.z.object({
+    txId: _zod.z.string(),
+    balance: _bigint.bigIntCoercibleSchema,
+    timestamp: _zod.z.number(),
+    voided: _zod.z.number().transform(val => val === 1),
+    version: _zod.z.number()
+  }))
+});
+
+/**
+ * Response schema for transaction outputs.
+ * Contains an array of unspent transaction outputs.
+ */
+const txOutputResponseSchema = exports.txOutputResponseSchema = baseResponseSchema.extend({
+  txOutputs: _zod.z.array(_zod.z.object({
+    txId: _zod.z.string(),
+    index: _zod.z.number(),
+    tokenId: _zod.z.string(),
+    address: AddressSchema,
+    value: _bigint.bigIntCoercibleSchema,
+    authorities: _bigint.bigIntCoercibleSchema,
+    timelock: _zod.z.number().nullable(),
+    heightlock: _zod.z.number().nullable(),
+    locked: _zod.z.boolean(),
+    addressPath: AddressPathSchema
+  }))
+});
+
+/**
+ * Response schema for authentication token.
+ * Contains the authentication token.
+ */
+const authTokenResponseSchema = exports.authTokenResponseSchema = baseResponseSchema.extend({
+  token: _zod.z.string().regex(/^[A-Za-z0-9-_=]+\.[A-Za-z0-9-_=]+\.[A-Za-z0-9-_=]+$/, 'Invalid JWT token format')
+});
+
+/**
+ * Schema for transaction by ID response.
+ * Contains detailed information about a specific transaction.
+ */
+const txByIdResponseSchema = exports.txByIdResponseSchema = baseResponseSchema.extend({
+  txTokens: _zod.z.array(_zod.z.object({
+    txId: _zod.z.string(),
+    timestamp: _zod.z.number(),
+    version: _zod.z.number(),
+    voided: _zod.z.boolean(),
+    height: _zod.z.number().nullable().optional(),
+    weight: _zod.z.number(),
+    balance: _bigint.bigIntCoercibleSchema,
+    tokenId: _zod.z.string(),
+    tokenName: _zod.z.string(),
+    tokenSymbol: _zod.z.string()
+  }))
+});
+
+/**
+ * Schema for transaction input.
+ * Represents a transaction input with its decoded data.
+ */
+const txInputSchema = exports.txInputSchema = _zod.z.object({
+  tx_id: _schemas.txIdSchema,
+  index: _zod.z.number(),
+  value: _bigint.bigIntCoercibleSchema,
+  token_data: _zod.z.number(),
+  script: _zod.z.string(),
+  decoded: _zod.z.object({
+    type: _zod.z.string(),
+    address: AddressSchema,
+    timelock: _zod.z.number().nullable().optional(),
+    value: _bigint.bigIntCoercibleSchema,
+    token_data: _zod.z.number()
+  })
+});
+
+/**
+ * Schema for transaction output.
+ * Represents a transaction output with its decoded data.
+ */
+const txOutputSchema = exports.txOutputSchema = _zod.z.object({
+  index: _zod.z.number(),
+  value: _bigint.bigIntCoercibleSchema,
+  token_data: _zod.z.number(),
+  script: _zod.z.string(),
+  decoded: _zod.z.object({
+    type: _zod.z.string().nullable().optional(),
+    address: AddressSchema.optional(),
+    timelock: _zod.z.number().nullable().optional(),
+    value: _bigint.bigIntCoercibleSchema,
+    token_data: _zod.z.number().optional()
+  })
+});
+
+/**
+ * Schema for Buffer-like scripts
+ */
+const bufferScriptSchema = _zod.z.object({
+  type: _zod.z.literal('Buffer'),
+  data: _zod.z.array(_zod.z.number())
+});
+
+/**
+ * Schema for websocket transaction input.
+ */
+const wsTxInputSchema = _zod.z.object({
+  tx_id: _schemas.txIdSchema,
+  index: _zod.z.number(),
+  value: _bigint.bigIntCoercibleSchema,
+  token_data: _zod.z.number(),
+  script: bufferScriptSchema,
+  token: tokenIdSchema,
+  decoded: _zod.z.object({
+    type: _zod.z.string(),
+    address: AddressSchema,
+    timelock: _zod.z.number().nullable().optional()
+  })
+});
+
+/**
+ * Schema for websocket transaction output.
+ */
+const wsTxOutputSchema = _zod.z.object({
+  value: _bigint.bigIntCoercibleSchema,
+  token_data: _zod.z.number(),
+  script: bufferScriptSchema,
+  decodedScript: _zod.z.any().nullable().optional(),
+  token: tokenIdSchema,
+  locked: _zod.z.boolean(),
+  index: _zod.z.number(),
+  decoded: _zod.z.object({
+    type: _zod.z.string().nullable().optional(),
+    address: AddressSchema.optional(),
+    timelock: _zod.z.number().nullable().optional()
+  })
+});
+
+/**
+ * Schema for websocket transaction events.
+ * Represents the structure of transactions received via websocket.
+ */
+const wsTransactionSchema = exports.wsTransactionSchema = _zod.z.object({
+  tx_id: _schemas.txIdSchema,
+  nonce: _zod.z.number(),
+  timestamp: _zod.z.number(),
+  version: _zod.z.number(),
+  voided: _zod.z.boolean(),
+  weight: _zod.z.number(),
+  parents: _zod.z.array(_zod.z.string()),
+  inputs: _zod.z.array(wsTxInputSchema),
+  outputs: _zod.z.array(wsTxOutputSchema),
+  height: _zod.z.number().nullable().optional(),
+  token_name: _zod.z.string().nullable(),
+  token_symbol: _zod.z.string().nullable(),
+  signal_bits: _zod.z.number()
+});
+
+/**
+ * Collection of all wallet API schemas.
+ * Used for type validation and documentation of the wallet API.
+ */
+const walletApiSchemas = exports.walletApiSchemas = {
+  addressesResponse: addressesResponseSchema,
+  checkAddressesMineResponse: checkAddressesMineResponseSchema,
+  newAddressesResponse: newAddressesResponseSchema,
+  tokenDetailsResponse: tokenDetailsResponseSchema,
+  balanceResponse: balanceResponseSchema,
+  txProposalCreateResponse: txProposalCreateResponseSchema,
+  txProposalUpdateResponse: txProposalUpdateResponseSchema,
+  fullNodeVersionData: fullNodeVersionDataSchema,
+  fullNodeTxResponse: fullNodeTxResponseSchema,
+  fullNodeTxConfirmationDataResponse: fullNodeTxConfirmationDataResponseSchema,
+  walletStatusResponse: walletStatusResponseSchema,
+  tokensResponse: tokensResponseSchema,
+  historyResponse: historyResponseSchema,
+  txOutputResponse: txOutputResponseSchema,
+  authTokenResponse: authTokenResponseSchema,
+  txByIdResponse: txByIdResponseSchema,
+  wsTransaction: wsTransactionSchema
+};
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/wallet/api/swapService.d.ts b/node_modules/@hathor/wallet-lib/oldLib/wallet/api/swapService.d.ts
new file mode 100644
index 0000000..c659616
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/wallet/api/swapService.d.ts
@@ -0,0 +1,64 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+import { AtomicSwapProposal } from '../../models/types';
+/**
+ * Encrypts a string ( PartialTx or Signatures ) before sending it to the backend
+ * @param serialized
+ * @param password
+ */
+export declare function encryptString(serialized: string, password: string): string;
+/**
+ * Decrypts a string ( PartialTx or Signatures ) from the backend
+ * @param serialized
+ * @param password
+ */
+export declare function decryptString(serialized: string, password: string): string;
+/**
+ * Hashes the password to use it as an authentication on the backend
+ * @param {string} password
+ * @returns {string} hashed password
+ */
+export declare function hashPassword(password: any): string;
+/**
+ * Calls the Atomic Swap Service requesting the creation of a new proposal identifier for the informed partialTx.
+ * @param serializedPartialTx
+ * @param password
+ * @return Promise<{ success: boolean, id: string }>
+ * @throws {Error} When the swap service network is not configured
+ * @example
+ * const results = await create('PartialTx|0001000000000000000000000063f78c0e0000000000||', 'pass123')
+ */
+export declare const create: (serializedPartialTx: string, password: string) => Promise<{
+    success: boolean;
+    id: string;
+}>;
+/**
+ * Fetches from the Atomic Swap Service the most up-to-date version of the proposal by the given id
+ * and decrypts it locally
+ * @throws {Error} When the swap service network is not configured
+ * @throws {Error} When the password is incorrect and the proposal cannot be decoded
+ * @param proposalId
+ * @param password
+ * @example
+ * const results = await get('b4a5b077-c599-41e8-a791-85e08efcb1da', 'pass123')
+ */
+export declare const get: (proposalId: string, password: string) => Promise<AtomicSwapProposal>;
+interface SwapUpdateParams {
+    proposalId: string;
+    password: string;
+    partialTx: string;
+    version: number;
+    signatures?: string;
+}
+/**
+ * Updates the proposal on the Atomic Swap Service with the parameters informed
+ */
+export declare const update: (params: SwapUpdateParams) => Promise<{
+    success: boolean;
+}>;
+export {};
+//# sourceMappingURL=swapService.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/wallet/api/swapService.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/wallet/api/swapService.d.ts.map
new file mode 100644
index 0000000..f6b272f
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/wallet/api/swapService.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"swapService.d.ts","sourceRoot":"","sources":["../../../src/wallet/api/swapService.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;AAOH,OAAO,EAAE,kBAAkB,EAAE,MAAM,oBAAoB,CAAC;AAkBxD;;;;GAIG;AACH,wBAAgB,aAAa,CAAC,UAAU,EAAE,MAAM,EAAE,QAAQ,EAAE,MAAM,GAAG,MAAM,CAY1E;AAED;;;;GAIG;AACH,wBAAgB,aAAa,CAAC,UAAU,EAAE,MAAM,EAAE,QAAQ,EAAE,MAAM,GAAG,MAAM,CAS1E;AAED;;;;GAIG;AACH,wBAAgB,YAAY,CAAC,QAAQ,KAAA,GAAG,MAAM,CAE7C;AAqBD;;;;;;;;GAQG;AACH,eAAO,MAAM,MAAM,wBAA+B,MAAM,YAAY,MAAM;aAcvB,OAAO;QAAM,MAAM;EAErE,CAAC;AAEF;;;;;;;;;GASG;AACH,eAAO,MAAM,GAAG,eAAsB,MAAM,YAAY,MAAM,KAAG,QAAQ,kBAAkB,CAiD1F,CAAC;AAEF,UAAU,gBAAgB;IACxB,UAAU,EAAE,MAAM,CAAC;IACnB,QAAQ,EAAE,MAAM,CAAC;IACjB,SAAS,EAAE,MAAM,CAAC;IAClB,OAAO,EAAE,MAAM,CAAC;IAChB,UAAU,CAAC,EAAE,MAAM,CAAC;CACrB;AAED;;GAEG;AACH,eAAO,MAAM,MAAM,WAAkB,gBAAgB,KAAG,QAAQ;IAAE,OAAO,EAAE,OAAO,CAAA;CAAE,CA2DnF,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/wallet/api/swapService.js b/node_modules/@hathor/wallet-lib/oldLib/wallet/api/swapService.js
new file mode 100644
index 0000000..5aff800
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/wallet/api/swapService.js
@@ -0,0 +1,256 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.create = void 0;
+exports.decryptString = decryptString;
+exports.encryptString = encryptString;
+exports.get = void 0;
+exports.hashPassword = hashPassword;
+exports.update = void 0;
+var _axios = _interopRequireDefault(require("axios"));
+var _sha = _interopRequireDefault(require("crypto-js/sha256"));
+var _aes = _interopRequireDefault(require("crypto-js/aes"));
+var _cryptoJs = _interopRequireDefault(require("crypto-js"));
+var _lodash = require("lodash");
+var _partial_tx = require("../../models/partial_tx");
+var _constants = require("../../constants");
+var _config = _interopRequireDefault(require("../../config"));
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+/**
+ * This interface represents the type returned on the HTTP response, with its untreated and encrypted data.
+ * The results should be translated to an `AtomicSwapProposal` interface before being sent out of this service.
+ */
+
+/**
+ * Encrypts a string ( PartialTx or Signatures ) before sending it to the backend
+ * @param serialized
+ * @param password
+ */
+function encryptString(serialized, password) {
+  if (!serialized) {
+    throw new Error('Missing encrypted string');
+  }
+  if (!password) {
+    throw new Error('Missing password');
+  }
+  const aesEncryptedObject = _aes.default.encrypt(serialized, password);
+
+  // Serializing the cipher output in Base64 to avoid loss of encryption parameter data
+  const baseEncryptedObj = _cryptoJs.default.enc.Base64.parse(aesEncryptedObject.toString());
+  return _cryptoJs.default.enc.Base64.stringify(baseEncryptedObj);
+}
+
+/**
+ * Decrypts a string ( PartialTx or Signatures ) from the backend
+ * @param serialized
+ * @param password
+ */
+function decryptString(serialized, password) {
+  if (!serialized) {
+    throw new Error('Missing encrypted string');
+  }
+  if (!password) {
+    throw new Error('Missing password');
+  }
+  const aesDecryptedObject = _aes.default.decrypt(serialized, password);
+  return aesDecryptedObject.toString(_cryptoJs.default.enc.Utf8);
+}
+
+/**
+ * Hashes the password to use it as an authentication on the backend
+ * @param {string} password
+ * @returns {string} hashed password
+ */
+function hashPassword(password) {
+  return (0, _sha.default)(password).toString();
+}
+
+/**
+ * Returns an axios instance pre-configured for interacting with the Atomic Swap Service
+ * @param [timeout] Optional timeout, defaults to the lib's timeout constant
+ * @param [network] Optional network. If not present, defaults connection to the lib's configured baseUrl
+ */
+// eslint-disable-next-line default-param-last -- XXX: This method should be refactored
+const axiosInstance = async (timeout = _constants.TIMEOUT, network) => {
+  const swapServiceBaseUrl = _config.default.getSwapServiceBaseUrl(network);
+  const defaultOptions = {
+    baseURL: swapServiceBaseUrl,
+    timeout,
+    headers: {
+      'Content-Type': 'application/json'
+    }
+  };
+  return _axios.default.create(defaultOptions);
+};
+
+/**
+ * Calls the Atomic Swap Service requesting the creation of a new proposal identifier for the informed partialTx.
+ * @param serializedPartialTx
+ * @param password
+ * @return Promise<{ success: boolean, id: string }>
+ * @throws {Error} When the swap service network is not configured
+ * @example
+ * const results = await create('PartialTx|0001000000000000000000000063f78c0e0000000000||', 'pass123')
+ */
+const create = async (serializedPartialTx, password) => {
+  if (!serializedPartialTx) {
+    throw new Error('Missing serializedPartialTx');
+  }
+  if (!password) {
+    throw new Error('Missing password');
+  }
+  const swapAxios = await axiosInstance();
+  const payload = {
+    partialTx: encryptString(serializedPartialTx, password),
+    authPassword: hashPassword(password)
+  };
+  const {
+    data
+  } = await swapAxios.post('/', payload);
+  return data;
+};
+
+/**
+ * Fetches from the Atomic Swap Service the most up-to-date version of the proposal by the given id
+ * and decrypts it locally
+ * @throws {Error} When the swap service network is not configured
+ * @throws {Error} When the password is incorrect and the proposal cannot be decoded
+ * @param proposalId
+ * @param password
+ * @example
+ * const results = await get('b4a5b077-c599-41e8-a791-85e08efcb1da', 'pass123')
+ */
+exports.create = create;
+const get = async (proposalId, password) => {
+  if (!proposalId) {
+    throw new Error('Missing proposalId');
+  }
+  if (!password) {
+    throw new Error('Missing password');
+  }
+  const swapAxios = await axiosInstance();
+  const options = {
+    headers: {
+      'X-Auth-Password': hashPassword(password)
+    }
+  };
+  const {
+    data
+  } = await swapAxios.get(`/${proposalId}`, options);
+
+  // Decrypting the backend contents and handling its possible failures
+  try {
+    const decryptedData = {
+      proposalId: data.id,
+      version: data.version,
+      timestamp: data.timestamp,
+      partialTx: decryptString(data.partialTx, password),
+      signatures: data.signatures ? decryptString(data.signatures, password) : null,
+      history: data.history.map(r => ({
+        partialTx: decryptString(r.partialTx, password),
+        timestamp: r.timestamp
+      }))
+    };
+
+    // If the PartialTx does not have the correct prefix, it was not correctly decoded: incorrect password
+    if (!decryptedData.partialTx.startsWith(_partial_tx.PartialTxPrefix)) {
+      throw new Error('Incorrect password: could not decode the proposal');
+    }
+
+    // Decoding was successful, return the data
+    return decryptedData;
+  } catch (err) {
+    if (!(err instanceof Error)) {
+      // If the error is not an Error, rethrow it
+      throw err;
+    }
+    // If the failure was specifically on the decoding, our password was incorrect.
+    if (err.message === 'Malformed UTF-8 data') {
+      throw new Error('Incorrect password: could not decode the proposal');
+    }
+
+    // Rethrow any other errors that may happen
+    throw err;
+  }
+};
+exports.get = get;
+/**
+ * Updates the proposal on the Atomic Swap Service with the parameters informed
+ */
+const update = async params => {
+  // Validates the input parameters and throws in case of errors
+  validateParameters();
+  const {
+    proposalId,
+    password,
+    partialTx,
+    version,
+    signatures
+  } = params;
+  const swapAxios = await axiosInstance();
+  const options = {
+    headers: {
+      'X-Auth-Password': hashPassword(password)
+    }
+  };
+  const payload = {
+    partialTx: encryptString(partialTx, password),
+    version,
+    signatures: signatures ? encryptString(signatures, password) : null
+  };
+  const {
+    data
+  } = await swapAxios.put(`/${proposalId}`, payload, options);
+  return {
+    success: data?.success
+  };
+
+  /**
+   * Validates the many mandatory parameters for the `update` method
+   * @throws {Error} if any mandatory parameter is missing
+   * @throws {Error} if any version parameter is invalid
+   */
+  function validateParameters() {
+    if (!params) {
+      throw new Error(`Missing mandatory parameters.`);
+    }
+    const {
+      proposalId: paramProposalId,
+      password: paramPassword,
+      partialTx: paramPartialTx,
+      version: paramVersion
+    } = params;
+    // Checking for missing parameters
+    const missingParameters = [];
+    if (!paramProposalId) {
+      missingParameters.push('proposalId');
+    }
+    if (!paramPassword) {
+      missingParameters.push('password');
+    }
+    if (!paramPartialTx) {
+      missingParameters.push('partialTx');
+    }
+    if (paramVersion === undefined || paramVersion === null) {
+      missingParameters.push('version');
+    }
+    if (missingParameters.length > 0) {
+      throw new Error(`Missing mandatory parameters: ${missingParameters.join(', ')}`);
+    }
+
+    // Checking for invalid parameters
+    if (!(0, _lodash.isNumber)(paramVersion) || paramVersion < 0) {
+      throw new Error('Invalid version number');
+    }
+  }
+};
+exports.update = update;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/wallet/api/walletApi.d.ts b/node_modules/@hathor/wallet-lib/oldLib/wallet/api/walletApi.d.ts
new file mode 100644
index 0000000..a2bbadb
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/wallet/api/walletApi.d.ts
@@ -0,0 +1,37 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+import { CheckAddressesMineResponseData, WalletStatusResponseData, AddressesResponseData, NewAddressesResponseData, BalanceResponseData, HistoryResponseData, TokensResponseData, TxProposalCreateResponseData, TxProposalUpdateResponseData, TokenDetailsResponseData, TxOutputResponseData, AuthTokenResponseData, FullNodeVersionData, TxByIdTokensResponseData, FullNodeTxResponse, FullNodeTxConfirmationDataResponse } from '../types';
+import HathorWalletServiceWallet from '../wallet';
+/**
+ * Api calls for wallet
+ *
+ * @namespace ApiWallet
+ */
+declare const walletApi: {
+    getWalletStatus(wallet: HathorWalletServiceWallet): Promise<WalletStatusResponseData>;
+    getVersionData(wallet: HathorWalletServiceWallet): Promise<FullNodeVersionData>;
+    createWallet(wallet: HathorWalletServiceWallet, xpubkey: string, xpubkeySignature: string, authXpubkey: string, authXpubkeySignature: string, timestamp: number, firstAddress?: string | null): Promise<WalletStatusResponseData>;
+    getAddresses(wallet: HathorWalletServiceWallet, index?: number): Promise<AddressesResponseData>;
+    checkAddressesMine(wallet: HathorWalletServiceWallet, addresses: string[]): Promise<CheckAddressesMineResponseData>;
+    getNewAddresses(wallet: HathorWalletServiceWallet): Promise<NewAddressesResponseData>;
+    getTokenDetails(wallet: HathorWalletServiceWallet, tokenId: string): Promise<TokenDetailsResponseData>;
+    getBalances(wallet: HathorWalletServiceWallet, token?: string | null): Promise<BalanceResponseData>;
+    getTokens(wallet: HathorWalletServiceWallet): Promise<TokensResponseData>;
+    getHistory(wallet: HathorWalletServiceWallet, options?: {}): Promise<HistoryResponseData>;
+    getTxOutputs(wallet: HathorWalletServiceWallet, options?: {}): Promise<TxOutputResponseData>;
+    createTxProposal(wallet: HathorWalletServiceWallet, txHex: string): Promise<TxProposalCreateResponseData>;
+    updateTxProposal(wallet: HathorWalletServiceWallet, id: string, txHex: string): Promise<TxProposalUpdateResponseData>;
+    deleteTxProposal(wallet: HathorWalletServiceWallet, id: string): Promise<TxProposalUpdateResponseData>;
+    createAuthToken(wallet: HathorWalletServiceWallet, timestamp: number, xpub: string, sign: string): Promise<AuthTokenResponseData>;
+    getTxById(wallet: HathorWalletServiceWallet, txId: string): Promise<TxByIdTokensResponseData>;
+    _txNotFoundGuard(data: unknown): void;
+    getFullTxById(wallet: HathorWalletServiceWallet, txId: string): Promise<FullNodeTxResponse>;
+    getTxConfirmationData(wallet: HathorWalletServiceWallet, txId: string): Promise<FullNodeTxConfirmationDataResponse>;
+    graphvizNeighborsQuery(wallet: HathorWalletServiceWallet, txId: string, graphType: string, maxLevel: number): Promise<string>;
+};
+export default walletApi;
+//# sourceMappingURL=walletApi.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/wallet/api/walletApi.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/wallet/api/walletApi.d.ts.map
new file mode 100644
index 0000000..b367a50
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/wallet/api/walletApi.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"walletApi.d.ts","sourceRoot":"","sources":["../../../src/wallet/api/walletApi.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;AAIH,OAAO,EACL,8BAA8B,EAC9B,wBAAwB,EACxB,qBAAqB,EACrB,wBAAwB,EACxB,mBAAmB,EACnB,mBAAmB,EACnB,kBAAkB,EAClB,4BAA4B,EAC5B,4BAA4B,EAC5B,wBAAwB,EACxB,oBAAoB,EACpB,qBAAqB,EACrB,mBAAmB,EACnB,wBAAwB,EACxB,kBAAkB,EAClB,kCAAkC,EACnC,MAAM,UAAU,CAAC;AAClB,OAAO,yBAAyB,MAAM,WAAW,CAAC;AAsBlD;;;;GAIG;AAEH,QAAA,MAAM,SAAS;4BACiB,yBAAyB,GAAG,QAAQ,wBAAwB,CAAC;2BAU9D,yBAAyB,GAAG,QAAQ,mBAAmB,CAAC;yBAY3E,yBAAyB,WACxB,MAAM,oBACG,MAAM,eACX,MAAM,wBACG,MAAM,aACjB,MAAM,iBACH,MAAM,GAAG,IAAI,GAC1B,QAAQ,wBAAwB,CAAC;yBAgC1B,yBAAyB,UACzB,MAAM,GACb,QAAQ,qBAAqB,CAAC;+BAcvB,yBAAyB,aACtB,MAAM,EAAE,GAClB,QAAQ,8BAA8B,CAAC;4BAUZ,yBAAyB,GAAG,QAAQ,wBAAwB,CAAC;4BAUjF,yBAAyB,WACxB,MAAM,GACd,QAAQ,wBAAwB,CAAC;wBAW1B,yBAAyB,UAC1B,MAAM,GAAG,IAAI,GACnB,QAAQ,mBAAmB,CAAC;sBAaP,yBAAyB,GAAG,QAAQ,kBAAkB,CAAC;uBAStD,yBAAyB,iBAAiB,QAAQ,mBAAmB,CAAC;yBAWrF,yBAAyB,iBAEhC,QAAQ,oBAAoB,CAAC;6BAWtB,yBAAyB,SAC1B,MAAM,GACZ,QAAQ,4BAA4B,CAAC;6BAW9B,yBAAyB,MAC7B,MAAM,SACH,MAAM,GACZ,QAAQ,4BAA4B,CAAC;6BAW9B,yBAAyB,MAC7B,MAAM,GACT,QAAQ,4BAA4B,CAAC;4BAU9B,yBAAyB,aACtB,MAAM,QACX,MAAM,QACN,MAAM,GACX,QAAQ,qBAAqB,CAAC;sBAiBvB,yBAAyB,QAC3B,MAAM,GACX,QAAQ,wBAAwB,CAAC;2BAkBb,OAAO;0BASpB,yBAAyB,QAC3B,MAAM,GACX,QAAQ,kBAAkB,CAAC;kCAepB,yBAAyB,QAC3B,MAAM,GACX,QAAQ,kCAAkC,CAAC;mCAkBpC,yBAAyB,QAC3B,MAAM,aACD,MAAM,YACP,MAAM,GACf,QAAQ,MAAM,CAAC;CAgCnB,CAAC;AAEF,eAAe,SAAS,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/wallet/api/walletApi.js b/node_modules/@hathor/wallet-lib/oldLib/wallet/api/walletApi.js
new file mode 100644
index 0000000..4641f46
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/wallet/api/walletApi.js
@@ -0,0 +1,260 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+var _lodash = require("lodash");
+var _walletServiceAxios = require("./walletServiceAxios");
+var _errors = require("../../errors");
+var _bigint = require("../../utils/bigint");
+var _walletApi = require("./schemas/walletApi");
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+/**
+ * Api calls for wallet
+ *
+ * @namespace ApiWallet
+ */
+
+const walletApi = {
+  async getWalletStatus(wallet) {
+    const axios = await (0, _walletServiceAxios.axiosInstance)(wallet, true);
+    const response = await axios.get('wallet/status');
+    const {
+      data
+    } = response;
+    if (response.status === 200 && data.success) {
+      return (0, _bigint.parseSchema)(data, _walletApi.walletStatusResponseSchema);
+    }
+    throw new _errors.WalletRequestError('Error getting wallet status.');
+  },
+  async getVersionData(wallet) {
+    const axios = await (0, _walletServiceAxios.axiosInstance)(wallet, false);
+    const response = await axios.get('version');
+    const {
+      data
+    } = response;
+    if (response.status === 200 && data.success) {
+      return (0, _bigint.parseSchema)(data.data, _walletApi.fullNodeVersionDataSchema);
+    }
+    throw new _errors.WalletRequestError('Error getting fullnode data.');
+  },
+  async createWallet(wallet, xpubkey, xpubkeySignature, authXpubkey, authXpubkeySignature, timestamp, firstAddress = null) {
+    const data = {
+      xpubkey,
+      xpubkeySignature,
+      authXpubkey,
+      authXpubkeySignature,
+      timestamp
+    };
+    if (firstAddress) {
+      data.firstAddress = firstAddress;
+    }
+    const axios = await (0, _walletServiceAxios.axiosInstance)(wallet, false);
+    const response = await axios.post('wallet/init', data);
+    if (response.status === 200 && response.data.success) {
+      return (0, _bigint.parseSchema)(response.data, _walletApi.walletStatusResponseSchema);
+    }
+    if (response.status === 400 && response.data.error === 'wallet-already-loaded') {
+      // If it was already loaded, we have to check if it's ready
+      return (0, _bigint.parseSchema)(response.data, _walletApi.walletStatusResponseSchema);
+    }
+    throw new _errors.WalletRequestError('Error creating wallet.');
+  },
+  async getAddresses(wallet, index) {
+    const axios = await (0, _walletServiceAxios.axiosInstance)(wallet, true);
+    const path = (0, _lodash.isNumber)(index) ? `?index=${index}` : '';
+    const url = `wallet/addresses${path}`;
+    const response = await axios.get(url);
+    if (response.status === 200 && response.data.success === true) {
+      return (0, _bigint.parseSchema)(response.data, _walletApi.addressesResponseSchema);
+    }
+    throw new _errors.WalletRequestError('Error getting wallet addresses.');
+  },
+  async checkAddressesMine(wallet, addresses) {
+    const axios = await (0, _walletServiceAxios.axiosInstance)(wallet, true);
+    const response = await axios.post('wallet/addresses/check_mine', {
+      addresses
+    });
+    if (response.status === 200 && response.data.success === true) {
+      return (0, _bigint.parseSchema)(response.data, _walletApi.checkAddressesMineResponseSchema);
+    }
+    throw new _errors.WalletRequestError('Error checking wallet addresses.');
+  },
+  async getNewAddresses(wallet) {
+    const axios = await (0, _walletServiceAxios.axiosInstance)(wallet, true);
+    const response = await axios.get('wallet/addresses/new');
+    if (response.status === 200 && response.data.success === true) {
+      return (0, _bigint.parseSchema)(response.data, _walletApi.newAddressesResponseSchema);
+    }
+    throw new _errors.WalletRequestError('Error getting wallet addresses to use.');
+  },
+  async getTokenDetails(wallet, tokenId) {
+    const axios = await (0, _walletServiceAxios.axiosInstance)(wallet, true);
+    const response = await axios.get(`wallet/tokens/${tokenId}/details`);
+    if (response.status === 200 && response.data.success === true) {
+      return (0, _bigint.parseSchema)(response.data, _walletApi.tokenDetailsResponseSchema);
+    }
+    throw new _errors.WalletRequestError('Error getting token details.');
+  },
+  async getBalances(wallet, token = null) {
+    const data = {
+      params: {}
+    };
+    if (token) {
+      data.params.token_id = token;
+    }
+    const axios = await (0, _walletServiceAxios.axiosInstance)(wallet, true);
+    const response = await axios.get('wallet/balances', data);
+    if (response.status === 200 && response.data.success === true) {
+      return (0, _bigint.parseSchema)(response.data, _walletApi.balanceResponseSchema);
+    }
+    throw new _errors.WalletRequestError('Error getting wallet balance.');
+  },
+  async getTokens(wallet) {
+    const axios = await (0, _walletServiceAxios.axiosInstance)(wallet, true);
+    const response = await axios.get('wallet/tokens');
+    if (response.status === 200 && response.data.success === true) {
+      return (0, _bigint.parseSchema)(response.data, _walletApi.tokensResponseSchema);
+    }
+    throw new _errors.WalletRequestError('Error getting list of tokens.');
+  },
+  async getHistory(wallet, options = {}) {
+    const data = {
+      params: options
+    };
+    const axios = await (0, _walletServiceAxios.axiosInstance)(wallet, true);
+    const response = await axios.get('wallet/history', data);
+    if (response.status === 200 && response.data.success === true) {
+      return (0, _bigint.parseSchema)(response.data, _walletApi.historyResponseSchema);
+    }
+    throw new _errors.WalletRequestError('Error getting wallet history.');
+  },
+  async getTxOutputs(wallet, options = {}) {
+    const data = {
+      params: options
+    };
+    const axios = await (0, _walletServiceAxios.axiosInstance)(wallet, true);
+    const response = await axios.get('wallet/tx_outputs', data);
+    if (response.status === 200 && response.data.success === true) {
+      return (0, _bigint.parseSchema)(response.data, _walletApi.txOutputResponseSchema);
+    }
+    throw new _errors.WalletRequestError('Error requesting utxo.');
+  },
+  async createTxProposal(wallet, txHex) {
+    const data = {
+      txHex
+    };
+    const axios = await (0, _walletServiceAxios.axiosInstance)(wallet, true);
+    const response = await axios.post('tx/proposal', data);
+    if (response.status === 201) {
+      return (0, _bigint.parseSchema)(response.data, _walletApi.txProposalCreateResponseSchema);
+    }
+    throw new _errors.WalletRequestError('Error creating tx proposal.');
+  },
+  async updateTxProposal(wallet, id, txHex) {
+    const data = {
+      txHex
+    };
+    const axios = await (0, _walletServiceAxios.axiosInstance)(wallet, true);
+    const response = await axios.put(`tx/proposal/${id}`, data);
+    if (response.status === 200) {
+      return (0, _bigint.parseSchema)(response.data, _walletApi.txProposalUpdateResponseSchema);
+    }
+    throw new _errors.WalletRequestError('Error sending tx proposal.');
+  },
+  async deleteTxProposal(wallet, id) {
+    const axios = await (0, _walletServiceAxios.axiosInstance)(wallet, true);
+    const response = await axios.delete(`tx/proposal/${id}`);
+    if (response.status === 200) {
+      return (0, _bigint.parseSchema)(response.data, _walletApi.txProposalUpdateResponseSchema);
+    }
+    throw new _errors.WalletRequestError('Error deleting tx proposal.');
+  },
+  async createAuthToken(wallet, timestamp, xpub, sign) {
+    const data = {
+      ts: timestamp,
+      xpub,
+      sign,
+      walletId: wallet.walletId
+    };
+    const axios = await (0, _walletServiceAxios.axiosInstance)(wallet, false);
+    const response = await axios.post('auth/token', data);
+    if (response.status === 200 && response.data.success === true) {
+      return (0, _bigint.parseSchema)(response.data, _walletApi.authTokenResponseSchema);
+    }
+    throw new _errors.WalletRequestError('Error requesting auth token.');
+  },
+  async getTxById(wallet, txId) {
+    const axios = await (0, _walletServiceAxios.axiosInstance)(wallet, true);
+    const response = await axios.get(`wallet/transactions/${txId}`);
+    if (response.status === 200 && response.data) {
+      if (!response.data.success) {
+        walletApi._txNotFoundGuard(response.data);
+        throw new _errors.WalletRequestError('Error getting transaction by its id.', {
+          cause: response.data
+        });
+      }
+      return (0, _bigint.parseSchema)(response.data, _walletApi.txByIdResponseSchema);
+    }
+    throw new _errors.WalletRequestError('Error getting transaction by its id.', {
+      cause: response.data
+    });
+  },
+  _txNotFoundGuard(data) {
+    const message = (0, _lodash.get)(data, 'message', '');
+    if (message === 'Transaction not found') {
+      throw new _errors.TxNotFoundError();
+    }
+  },
+  async getFullTxById(wallet, txId) {
+    const axios = await (0, _walletServiceAxios.axiosInstance)(wallet, true);
+    const response = await axios.get(`wallet/proxy/transactions/${txId}`);
+    if (response.status === 200 && response.data.success) {
+      return (0, _bigint.parseSchema)(response.data, _walletApi.fullNodeTxResponseSchema);
+    }
+    walletApi._txNotFoundGuard(response.data);
+    throw new _errors.WalletRequestError('Error getting transaction by its id from the proxied fullnode.', {
+      cause: response.data
+    });
+  },
+  async getTxConfirmationData(wallet, txId) {
+    const axios = await (0, _walletServiceAxios.axiosInstance)(wallet, true);
+    const response = await axios.get(`wallet/proxy/transactions/${txId}/confirmation_data`);
+    if (response.status === 200 && response.data.success) {
+      return (0, _bigint.parseSchema)(response.data, _walletApi.fullNodeTxConfirmationDataResponseSchema);
+    }
+    walletApi._txNotFoundGuard(response.data);
+    throw new _errors.WalletRequestError('Error getting transaction confirmation data by its id from the proxied fullnode.', {
+      cause: response.data
+    });
+  },
+  async graphvizNeighborsQuery(wallet, txId, graphType, maxLevel) {
+    const axios = await (0, _walletServiceAxios.axiosInstance)(wallet, true);
+    const response = await axios.get(`wallet/proxy/graphviz/neighbours?txId=${txId}&graphType=${graphType}&maxLevel=${maxLevel}`);
+    if (response.status === 200) {
+      // The service might answer a status code 200 but output an error message like
+      // { success: false, message: '...' }, we need to handle it.
+      //
+      // We also need to check if `success` is a key to the object since this API will return
+      // a string on success.
+      if (Object.hasOwnProperty.call(response.data, 'success') && !response.data.success) {
+        walletApi._txNotFoundGuard(response.data);
+        throw new _errors.WalletRequestError(`Error getting neighbors data for ${txId} from the proxied fullnode.`, {
+          cause: response.data.message
+        });
+      }
+      return response.data;
+    }
+    throw new _errors.WalletRequestError(`Error getting neighbors data for ${txId} from the proxied fullnode.`, {
+      cause: response.data
+    });
+  }
+};
+var _default = exports.default = walletApi;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/wallet/api/walletServiceAxios.d.ts b/node_modules/@hathor/wallet-lib/oldLib/wallet/api/walletServiceAxios.d.ts
new file mode 100644
index 0000000..6d3b2d3
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/wallet/api/walletServiceAxios.d.ts
@@ -0,0 +1,20 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+import HathorWalletServiceWallet from '../wallet';
+/**
+ * Method that creates an axios instance
+ *
+ * @module Axios
+ */
+/**
+ * Create an axios instance to be used when sending requests
+ *
+ * @param {number} timeout Timeout in milliseconds for the request
+ */
+export declare const axiosInstance: (wallet: HathorWalletServiceWallet, needsAuth: boolean, timeout?: number) => Promise<import("axios").AxiosInstance>;
+export default axiosInstance;
+//# sourceMappingURL=walletServiceAxios.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/wallet/api/walletServiceAxios.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/wallet/api/walletServiceAxios.d.ts.map
new file mode 100644
index 0000000..a330316
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/wallet/api/walletServiceAxios.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"walletServiceAxios.d.ts","sourceRoot":"","sources":["../../../src/wallet/api/walletServiceAxios.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;AAIH,OAAO,yBAAyB,MAAM,WAAW,CAAC;AAGlD;;;;GAIG;AAEH;;;;GAIG;AACH,eAAO,MAAM,aAAa,WAChB,yBAAyB,aACtB,OAAO,YACT,MAAM,2CAgChB,CAAC;AAEF,eAAe,aAAa,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/wallet/api/walletServiceAxios.js b/node_modules/@hathor/wallet-lib/oldLib/wallet/api/walletServiceAxios.js
new file mode 100644
index 0000000..266c2bf
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/wallet/api/walletServiceAxios.js
@@ -0,0 +1,52 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = exports.axiosInstance = void 0;
+var _axios = _interopRequireDefault(require("axios"));
+var _constants = require("../../constants");
+var _config = _interopRequireDefault(require("../../config"));
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+/**
+ * Method that creates an axios instance
+ *
+ * @module Axios
+ */
+
+/**
+ * Create an axios instance to be used when sending requests
+ *
+ * @param {number} timeout Timeout in milliseconds for the request
+ */
+const axiosInstance = async (wallet, needsAuth, timeout = _constants.TIMEOUT) => {
+  // TODO How to allow 'Retry' request?
+  const defaultOptions = {
+    baseURL: _config.default.getWalletServiceBaseUrl(),
+    timeout,
+    // `validateStatus` defines whether to resolve or reject the promise for a given
+    // HTTP response status code. If `validateStatus` returns `true` (or is set to `null`
+    // or `undefined`), the promise will be resolved; otherwise, the promise will be
+    // rejected. The default behaviour of axios is to reject anything different than 2xx
+    // We need to handle some 400 manually (e.g. create wallet might already be loaded)
+    validateStatus: status => status >= 200 && status < 500,
+    headers: {
+      'Content-Type': 'application/json'
+    }
+  };
+  if (needsAuth) {
+    // Then we need the auth token
+    await wallet.validateAndRenewAuthToken();
+    defaultOptions.headers.Authorization = `Bearer ${wallet.getAuthToken()}`;
+  }
+  return _axios.default.create(defaultOptions);
+};
+exports.axiosInstance = axiosInstance;
+var _default = exports.default = axiosInstance;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/wallet/connection.d.ts b/node_modules/@hathor/wallet-lib/oldLib/wallet/connection.d.ts
new file mode 100644
index 0000000..ee90395
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/wallet/connection.d.ts
@@ -0,0 +1,40 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+import BaseConnection, { ConnectionParams } from '../connection';
+export interface WalletServiceConnectionParams extends ConnectionParams {
+    walletId: string;
+}
+/**
+ * This is a Connection that may be shared by one or more wallets.
+ *
+ * It has the following states:
+ * - CLOSED: When it is disconnected from the server.
+ * - CONNECTING: When it is connecting to the server.
+ * - CONNECTED: When it is connected.
+ *
+ * You can subscribe for the following events:
+ * - state: Fired when the state of the Wallet changes.
+ * - wallet-update: Fired when a new wallet message arrive from the websocket.
+ * */
+export default class WalletServiceConnection extends BaseConnection {
+    private connectionTimeout?;
+    private walletId?;
+    constructor(options?: WalletServiceConnectionParams);
+    /**
+     * Sets the walletId for the current connection instance
+     * */
+    setWalletId(walletId: string): void;
+    /**
+     * Handle received websocket messages, validating their schemas
+     * */
+    onWsMessage(type: string, payload: any): void;
+    /**
+     * Connect to the server and start emitting events.
+     * */
+    start(): void;
+}
+//# sourceMappingURL=connection.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/wallet/connection.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/wallet/connection.d.ts.map
new file mode 100644
index 0000000..c9ed5e7
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/wallet/connection.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"connection.d.ts","sourceRoot":"","sources":["../../src/wallet/connection.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;AAKH,OAAO,cAAc,EAAE,EAAkB,gBAAgB,EAAE,MAAM,eAAe,CAAC;AAKjF,MAAM,WAAW,6BAA8B,SAAQ,gBAAgB;IACrE,QAAQ,EAAE,MAAM,CAAC;CAClB;AAED;;;;;;;;;;;KAWK;AACL,MAAM,CAAC,OAAO,OAAO,uBAAwB,SAAQ,cAAc;IACjE,OAAO,CAAC,iBAAiB,CAAC,CAAS;IAEnC,OAAO,CAAC,QAAQ,CAAC,CAAS;gBAEd,OAAO,CAAC,EAAE,6BAA6B;IAiBnD;;SAEK;IACL,WAAW,CAAC,QAAQ,EAAE,MAAM;IAI5B;;SAEK;IACL,WAAW,CAAC,IAAI,EAAE,MAAM,EAAE,OAAO,KAAA;IAajC;;SAEK;IACL,KAAK;CAoBN"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/wallet/connection.js b/node_modules/@hathor/wallet-lib/oldLib/wallet/connection.js
new file mode 100644
index 0000000..dc1c095
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/wallet/connection.js
@@ -0,0 +1,104 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+var _types = require("../types");
+var _websocket = _interopRequireDefault(require("./websocket"));
+var _config = _interopRequireDefault(require("../config"));
+var _connection = _interopRequireWildcard(require("../connection"));
+var _types2 = require("./types");
+var _bigint = require("../utils/bigint");
+var _walletApi = require("./api/schemas/walletApi");
+function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
+function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
+function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
+function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/**
+ * This is a Connection that may be shared by one or more wallets.
+ *
+ * It has the following states:
+ * - CLOSED: When it is disconnected from the server.
+ * - CONNECTING: When it is connecting to the server.
+ * - CONNECTED: When it is connected.
+ *
+ * You can subscribe for the following events:
+ * - state: Fired when the state of the Wallet changes.
+ * - wallet-update: Fired when a new wallet message arrive from the websocket.
+ * */
+class WalletServiceConnection extends _connection.default {
+  constructor(options) {
+    const {
+      network,
+      servers,
+      logger,
+      walletId,
+      connectionTimeout
+    } = {
+      ..._connection.DEFAULT_PARAMS,
+      ...options
+    };
+    super({
+      network,
+      servers,
+      logger,
+      connectionTimeout
+    });
+    _defineProperty(this, "connectionTimeout", void 0);
+    _defineProperty(this, "walletId", void 0);
+    this.connectionTimeout = connectionTimeout;
+    this.walletId = walletId;
+  }
+
+  /**
+   * Sets the walletId for the current connection instance
+   * */
+  setWalletId(walletId) {
+    this.walletId = walletId;
+  }
+
+  /**
+   * Handle received websocket messages, validating their schemas
+   * */
+  onWsMessage(type, payload) {
+    const logger = (0, _types.getDefaultLogger)();
+    try {
+      const validatedTx = (0, _bigint.parseSchema)(payload.data, _walletApi.wsTransactionSchema);
+      this.emit(type, validatedTx);
+    } catch (e) {
+      // parseSchema already logs the validation error, so no need to log it
+      // again here.
+      logger.error(`Received a new websocket message (${type}) but schema validation failed.`);
+    }
+  }
+
+  /**
+   * Connect to the server and start emitting events.
+   * */
+  start() {
+    if (!this.walletId) {
+      throw new Error('Wallet id should be set before connection start.');
+    }
+    const wsOptions = {
+      wsURL: _config.default.getWalletServiceBaseWsUrl(),
+      walletId: this.walletId,
+      connectionTimeout: this.connectionTimeout,
+      logger: this.logger
+    };
+    this.websocket = new _websocket.default(wsOptions);
+    this.websocket.on('is_online', online => this.onConnectionChange(online));
+    this.websocket.on('new-tx', payload => this.onWsMessage('new-tx', payload));
+    this.websocket.on('update-tx', payload => this.onWsMessage('update-tx', payload));
+    this.setState(_types2.ConnectionState.CONNECTING);
+    this.websocket.setup();
+  }
+}
+exports.default = WalletServiceConnection;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/wallet/mineTransaction.d.ts b/node_modules/@hathor/wallet-lib/oldLib/wallet/mineTransaction.d.ts
new file mode 100644
index 0000000..e18dff9
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/wallet/mineTransaction.d.ts
@@ -0,0 +1,58 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/// <reference types="node" />
+import { EventEmitter } from 'events';
+import Transaction from '../models/transaction';
+import { MineTxSuccessData } from './types';
+/**
+ * This is transaction mining class responsible for:
+ *
+ * - Submit a job to be mined;
+ * - Update mining time estimation from time to time;
+ * - Get back mining response;
+ *
+ * It emits the following events:
+ * 'job-submitted': after job was submitted;
+ * 'estimation-updated': after getting the job status;
+ * 'job-done': after job is finished;
+ * 'error': if an error happens;
+ * 'unexpected-error': if an unexpected error happens;
+ * */
+declare class MineTransaction extends EventEmitter {
+    transaction: Transaction;
+    promise: Promise<MineTxSuccessData>;
+    private estimation;
+    private jobID;
+    private countTxMiningAttempts;
+    private maxTxMiningRetries;
+    constructor(transaction: Transaction, options?: {
+        maxTxMiningRetries: number;
+    });
+    /**
+     * Used to handle errors in requests to the tx mining API
+     *
+     * @param error The error that was received from the axiosInstance
+     */
+    handleRequestError(error: any): void;
+    /**
+     * Submit job to be mined, update object variables of jobID and estimation, and start method to get job status
+     * Emits 'job-submitted' after submit.
+     */
+    submitJob(): void;
+    /**
+     * Schedule job status request
+     * If the job is done, emits 'job-done' event, complete and send the tx
+     * Otherwise, schedule again the job status request and emits 'estimation-updated' event.
+     */
+    handleJobStatus(): void;
+    /**
+     * Start object (submit job)
+     */
+    start(): void;
+}
+export default MineTransaction;
+//# sourceMappingURL=mineTransaction.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/wallet/mineTransaction.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/wallet/mineTransaction.d.ts.map
new file mode 100644
index 0000000..1a99b35
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/wallet/mineTransaction.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"mineTransaction.d.ts","sourceRoot":"","sources":["../../src/wallet/mineTransaction.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;;AAEH,OAAO,EAAE,YAAY,EAAE,MAAM,QAAQ,CAAC;AAGtC,OAAO,WAAW,MAAM,uBAAuB,CAAC;AAEhD,OAAO,EAAE,iBAAiB,EAAE,MAAM,SAAS,CAAC;AAgB5C;;;;;;;;;;;;;KAaK;AACL,cAAM,eAAgB,SAAQ,YAAY;IAExC,WAAW,EAAE,WAAW,CAAC;IAGzB,OAAO,EAAE,OAAO,CAAC,iBAAiB,CAAC,CAAC;IAGpC,OAAO,CAAC,UAAU,CAAgB;IAGlC,OAAO,CAAC,KAAK,CAAgB;IAG7B,OAAO,CAAC,qBAAqB,CAAS;IAGtC,OAAO,CAAC,kBAAkB,CAAS;gBAEvB,WAAW,EAAE,WAAW,EAAE,OAAO;;KAA4B;IAoCzE;;;;OAIG;IAEH,kBAAkB,CAAC,KAAK,EAAE,GAAG;IAU7B;;;OAGG;IACH,SAAS;IAsBT;;;;OAIG;IACH,eAAe;IAwCf;;OAEG;IACH,KAAK;CAIN;AAED,eAAe,eAAe,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/wallet/mineTransaction.js b/node_modules/@hathor/wallet-lib/oldLib/wallet/mineTransaction.js
new file mode 100644
index 0000000..df76bb9
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/wallet/mineTransaction.js
@@ -0,0 +1,189 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+var _events = require("events");
+var _constants = require("../constants");
+var _errors = require("../errors");
+var _txMining = _interopRequireDefault(require("../api/txMining"));
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
+function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
+function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+// Error to be shown in case of no miners connected
+const noMinersError = 'There are no miners to resolve the proof of work of this transaction.';
+
+// Error to be shown in case of an unexpected error
+const unexpectedError = 'An unexpected error happened. Please try to send your transaction again.';
+
+// Error to be shown in case of a timeout
+const timeoutError = "Timeout solving transaction's proof-of-work.\n\nAll transactions need to solve a proof-of-work as an anti spam mechanism. Currently, Hathor Labs provides this service for free, but their servers may be fully loaded right now.";
+
+// Error to be shown in case of rate limit exceeded
+const rateLimitExceededError = 'Too many transactions sent in a short time-span.\n\nAll transactions need to solve a proof-of-work as an anti spam mechanism. Currently, Hathor Labs provides a tx mining service for free, but there are limits to the number of transactions someone can mine using it to avoid abuse.\n\nPlease try again in a few seconds.';
+
+/**
+ * This is transaction mining class responsible for:
+ *
+ * - Submit a job to be mined;
+ * - Update mining time estimation from time to time;
+ * - Get back mining response;
+ *
+ * It emits the following events:
+ * 'job-submitted': after job was submitted;
+ * 'estimation-updated': after getting the job status;
+ * 'job-done': after job is finished;
+ * 'error': if an error happens;
+ * 'unexpected-error': if an unexpected error happens;
+ * */
+class MineTransaction extends _events.EventEmitter {
+  constructor(transaction, options = {
+    maxTxMiningRetries: 3
+  }) {
+    super();
+    // Transaction to be mined
+    _defineProperty(this, "transaction", void 0);
+    // Promise that will resolve when the mining is over or reject when an error is found
+    _defineProperty(this, "promise", void 0);
+    // Mining time estimation
+    _defineProperty(this, "estimation", void 0);
+    // Mining job ID
+    _defineProperty(this, "jobID", void 0);
+    // Current mining attempt
+    _defineProperty(this, "countTxMiningAttempts", void 0);
+    // Maximum number of mining retries
+    _defineProperty(this, "maxTxMiningRetries", void 0);
+    this.transaction = transaction;
+    // Job estimation
+    this.estimation = null;
+    // Job ID
+    this.jobID = null;
+
+    // Counter of number of attempts to mine the transaction.
+    this.countTxMiningAttempts = 0;
+    // Maximum number of retries if mining timeouts.
+    this.maxTxMiningRetries = options.maxTxMiningRetries;
+
+    // Promise that resolves when push tx finishes with success
+    // or rejects in case of an error
+    // TODO: If this promise is not handled properly we crash the client application with a
+    //       misleading error message. This should be refactored to a more stable solution with
+    //       better user experience
+    this.promise = new Promise((resolve, reject) => {
+      this.on('success', data => {
+        resolve(data);
+      });
+      this.on('error', message => {
+        const err = new _errors.MineTxError(message);
+        reject(err);
+      });
+      this.on('unexpected-error', message => {
+        const err = new _errors.MineTxError(message);
+        reject(err);
+      });
+    });
+  }
+
+  /**
+   * Used to handle errors in requests to the tx mining API
+   *
+   * @param error The error that was received from the axiosInstance
+   */
+  // eslint-disable-next-line @typescript-eslint/no-explicit-any -- To fix this would require changing tests
+  handleRequestError(error) {
+    if (error.response && error.response.status === 429) {
+      this.emit('error', rateLimitExceededError);
+    } else {
+      // eslint-disable-next-line no-console
+      console.error(error);
+      this.emit('unexpected-error', unexpectedError);
+    }
+  }
+
+  /**
+   * Submit job to be mined, update object variables of jobID and estimation, and start method to get job status
+   * Emits 'job-submitted' after submit.
+   */
+  submitJob() {
+    // Get tx hex without parents and nonce
+    const txHex = this.transaction.toHex();
+    this.countTxMiningAttempts++;
+    // Send to be mined in tx mining API
+    _txMining.default.submitJob(txHex, false, true, null, response => {
+      if (response.expected_total_time === -1) {
+        // Error: there are no miners online
+        this.emit('error', noMinersError);
+      } else {
+        this.estimation = response.expected_total_time;
+        this.jobID = response.job_id;
+        this.emit('job-submitted', {
+          estimation: this.estimation,
+          jobID: this.jobID
+        });
+        this.handleJobStatus();
+      }
+    }).catch(e => {
+      this.handleRequestError(e);
+    });
+  }
+
+  /**
+   * Schedule job status request
+   * If the job is done, emits 'job-done' event, complete and send the tx
+   * Otherwise, schedule again the job status request and emits 'estimation-updated' event.
+   */
+  handleJobStatus() {
+    // this.estimation and MIN_POLLING_INTERVAL are in seconds
+    const poll_time = Math.max(this.estimation / 2, _constants.MIN_POLLING_INTERVAL) * 1000;
+    setTimeout(() => {
+      _txMining.default.getJobStatus(this.jobID, response => {
+        if (response.status === 'done') {
+          this.emit('job-done', {
+            jobID: this.jobID
+          });
+          this.emit('success', {
+            nonce: parseInt(response.tx.nonce, 16),
+            parents: response.tx.parents,
+            timestamp: response.tx.timestamp,
+            weight: response.tx.weight
+          });
+        } else if (response.status === 'timeout') {
+          // Error: Timeout resolving pow
+          if (this.countTxMiningAttempts < this.maxTxMiningRetries) {
+            this.submitJob();
+          } else {
+            this.emit('error', timeoutError);
+          }
+        } else if (response.expected_total_time === -1) {
+          // Error: there are no miners online
+          this.emit('error', noMinersError);
+        } else {
+          this.estimation = response.expected_total_time;
+          this.emit('estimation-updated', {
+            jobID: this.jobID,
+            estimation: response.expected_total_time
+          });
+          this.handleJobStatus();
+        }
+      }).catch(e => {
+        this.handleRequestError(e);
+      });
+    }, poll_time);
+  }
+
+  /**
+   * Start object (submit job)
+   */
+  start() {
+    this.emit('mining-started');
+    this.submitJob();
+  }
+}
+var _default = exports.default = MineTransaction;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/wallet/partialTxProposal.d.ts b/node_modules/@hathor/wallet-lib/oldLib/wallet/partialTxProposal.d.ts
new file mode 100644
index 0000000..cab8526
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/wallet/partialTxProposal.d.ts
@@ -0,0 +1,147 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+import { PartialTx, PartialTxInputData } from '../models/partial_tx';
+import Transaction from '../models/transaction';
+import { Utxo } from './types';
+import { Balance } from '../models/types';
+import { IStorage, OutputValueType } from '../types';
+declare class PartialTxProposal {
+    partialTx: PartialTx;
+    signatures: PartialTxInputData | null;
+    transaction: Transaction | null;
+    storage: IStorage;
+    /**
+     * @param {Network} network
+     */
+    constructor(storage: IStorage);
+    /**
+     * Create a PartialTxProposal instance from the serialized string.
+     *
+     * @param {string} serialized Serialized PartialTx data
+     * @param {Network} network network
+     *
+     * @throws {SyntaxError} serialized argument should be a valid PartialTx.
+     * @throws {UnsupportedScriptError} All outputs should be P2SH or P2PKH
+     *
+     * @returns {PartialTxProposal}
+     */
+    static fromPartialTx(serialized: string, storage: IStorage): PartialTxProposal;
+    /**
+     * Add inputs sending the amount of tokens specified, may add a change output.
+     *
+     * @param {string} token UID of token that is being sent
+     * @param {OutputValueType} value Quantity of tokens being sent
+     * @param {Object} [options]
+     * @param {Utxo[]|null} [options.utxos=[]] utxos to add to the partial transaction.
+     * @param {string|null} [options.changeAddress=null] If we add change, use this address instead of getting a new one from the wallet.
+     * @param {boolean} [options.markAsSelected=true] Mark the utxo with `selected_as_input`.
+     */
+    addSend(token: string, value: OutputValueType, { utxos, changeAddress, markAsSelected, }?: {
+        utxos?: Utxo[] | null;
+        changeAddress?: string | null;
+        markAsSelected?: boolean;
+    }): Promise<void>;
+    /**
+     * Add outputs receiving the amount of tokens specified.
+     *
+     * @param {string} token UID of token that is being sent
+     * @param {OutputValueType} value Quantity of tokens being sent
+     * @param {Object} [options]
+     * @param {number|null} [options.timelock=null] UNIX timestamp of the timelock.
+     * @param {string|null} [options.address=null] Output address to receive the tokens.
+     *
+     */
+    addReceive(token: string, value: OutputValueType, { timelock, address }?: {
+        timelock?: number | null;
+        address?: string | null;
+    }): Promise<void>;
+    /**
+     * Add an UTXO as input on the partial data.
+     *
+     * @param {string} hash Transaction hash
+     * @param {number} index UTXO index on the outputs of the transaction.
+     * @param {OutputValueType} value UTXO value.
+     * @param {Object} [options]
+     * @param {string} [options.token='00'] Token UID in hex format.
+     * @param {OutputValueType} [options.authorities=0] Authority information of the UTXO.
+     * @param {string|null} [options.address=null] Address that owns the UTXO.
+     * @param {boolean} [options.markAsSelected=true] Mark the utxo with `selected_as_input`.
+     */
+    addInput(hash: string, index: number, value: OutputValueType, address: string, { token, authorities, markAsSelected, }?: {
+        token?: string;
+        authorities?: OutputValueType;
+        markAsSelected?: boolean;
+    }): void;
+    /**
+     * Add an output to the partial data.
+     *
+     * @param {string} token UID of token that is being sent.
+     * @param {OutputValueType} value Quantity of tokens being sent.
+     * @param {string} address Create the output script for this address.
+     * @param {Object} [options]
+     * @param {number|null} [options.timelock=null] UNIX timestamp of the timelock.
+     * @param {boolean} [options.isChange=false] If the output should be considered as change.
+     * @param {OutputValueType} [options.authorities=0] Authority information of the Output.
+     *
+     * @throws AddressError
+     */
+    addOutput(token: string, value: OutputValueType, address: string, { timelock, isChange, authorities, }?: {
+        timelock?: number | null;
+        isChange?: boolean;
+        authorities?: OutputValueType;
+    }): void;
+    /**
+     * Calculate the token balance of the partial tx for a specific wallet.
+     *
+     * @returns {Record<string, Balance>}
+     */
+    calculateBalance(): Promise<Record<string, Balance>>;
+    /**
+     * Reset any data calculated from the partial tx.
+     */
+    resetSignatures(): void;
+    /**
+     * Unmark all inputs currently on the partial tx as not `selected_as_input`.
+     *
+     * @param {HathorWallet} wallet Wallet of the UTXOs.
+     */
+    unmarkAsSelected(): void;
+    /**
+     * Returns true if the transaction funds are balanced and the signatures match all inputs.
+     *
+     * @returns {boolean}
+     */
+    isComplete(): boolean;
+    /**
+     * Create the data to sign from the current transaction signing the loaded wallet inputs.
+     *
+     * @param {string} pin The loaded wallet's pin to sign the transaction.
+     * @param {boolean} validate If we should validate the data with the fullnode before signing.
+     *
+     * @throws {InvalidPartialTxError} Inputs and outputs balance should match before signing.
+     * @throws {UnsupportedScriptError} When we have an unsupported output script.
+     * @throws {IndexOOBError} input index should be inside the inputs array.
+     */
+    signData(pin: string, validate?: boolean): Promise<void>;
+    /**
+     * Overwrites the proposal's signatures with the serialized contents in the parameters
+     * @param serializedSignatures
+     *
+     * @throws {InvalidPartialTxError} Inputs and outputs balance should match before the signatures can be added.
+     */
+    setSignatures(serializedSignatures: string): void;
+    /**
+     * Create and return the Transaction instance if we have all signatures.
+     *
+     * @throws InvalidPartialTxError
+     *
+     * @returns {Transaction}
+     */
+    prepareTx(): Transaction;
+}
+export default PartialTxProposal;
+//# sourceMappingURL=partialTxProposal.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/wallet/partialTxProposal.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/wallet/partialTxProposal.d.ts.map
new file mode 100644
index 0000000..0a92034
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/wallet/partialTxProposal.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"partialTxProposal.d.ts","sourceRoot":"","sources":["../../src/wallet/partialTxProposal.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;AAEH,OAAO,EAAE,SAAS,EAAE,kBAAkB,EAAE,MAAM,sBAAsB,CAAC;AAKrE,OAAO,WAAW,MAAM,uBAAuB,CAAC;AAOhD,OAAO,EAAc,IAAI,EAAE,MAAM,SAAS,CAAC;AAC3C,OAAO,EAAE,OAAO,EAAE,MAAM,iBAAiB,CAAC;AAC1C,OAAO,EAAE,QAAQ,EAAE,eAAe,EAAE,MAAM,UAAU,CAAC;AAErD,cAAM,iBAAiB;IACd,SAAS,EAAE,SAAS,CAAC;IAErB,UAAU,EAAE,kBAAkB,GAAG,IAAI,CAAC;IAEtC,WAAW,EAAE,WAAW,GAAG,IAAI,CAAC;IAEhC,OAAO,EAAE,QAAQ,CAAC;IAEzB;;OAEG;gBACS,OAAO,EAAE,QAAQ;IAO7B;;;;;;;;;;OAUG;IACH,MAAM,CAAC,aAAa,CAAC,UAAU,EAAE,MAAM,EAAE,OAAO,EAAE,QAAQ,GAAG,iBAAiB;IAQ9E;;;;;;;;;OASG;IACG,OAAO,CACX,KAAK,EAAE,MAAM,EACb,KAAK,EAAE,eAAe,EACtB,EACE,KAAU,EACV,aAAoB,EACpB,cAAqB,GACtB,GAAE;QAAE,KAAK,CAAC,EAAE,IAAI,EAAE,GAAG,IAAI,CAAC;QAAC,aAAa,CAAC,EAAE,MAAM,GAAG,IAAI,CAAC;QAAC,cAAc,CAAC,EAAE,OAAO,CAAA;KAAO;IAiD5F;;;;;;;;;OASG;IACG,UAAU,CACd,KAAK,EAAE,MAAM,EACb,KAAK,EAAE,eAAe,EACtB,EAAE,QAAe,EAAE,OAAc,EAAE,GAAE;QAAE,QAAQ,CAAC,EAAE,MAAM,GAAG,IAAI,CAAC;QAAC,OAAO,CAAC,EAAE,MAAM,GAAG,IAAI,CAAA;KAAO;IASjG;;;;;;;;;;;OAWG;IACH,QAAQ,CACN,IAAI,EAAE,MAAM,EACZ,KAAK,EAAE,MAAM,EACb,KAAK,EAAE,eAAe,EACtB,OAAO,EAAE,MAAM,EACf,EACE,KAAwB,EACxB,WAAgB,EAChB,cAAqB,GACtB,GAAE;QACD,KAAK,CAAC,EAAE,MAAM,CAAC;QACf,WAAW,CAAC,EAAE,eAAe,CAAC;QAC9B,cAAc,CAAC,EAAE,OAAO,CAAC;KACrB;IAWR;;;;;;;;;;;;OAYG;IACH,SAAS,CACP,KAAK,EAAE,MAAM,EACb,KAAK,EAAE,eAAe,EACtB,OAAO,EAAE,MAAM,EACf,EACE,QAAe,EACf,QAAgB,EAChB,WAAgB,GACjB,GAAE;QAAE,QAAQ,CAAC,EAAE,MAAM,GAAG,IAAI,CAAC;QAAC,QAAQ,CAAC,EAAE,OAAO,CAAC;QAAC,WAAW,CAAC,EAAE,eAAe,CAAA;KAAO;IAmBzF;;;;OAIG;IACG,gBAAgB,IAAI,OAAO,CAAC,MAAM,CAAC,MAAM,EAAE,OAAO,CAAC,CAAC;IA2E1D;;OAEG;IACH,eAAe;IAKf;;;;OAIG;IACH,gBAAgB;IAMhB;;;;OAIG;IACH,UAAU,IAAI,OAAO;IAIrB;;;;;;;;;OASG;IACG,QAAQ,CAAC,GAAG,EAAE,MAAM,EAAE,QAAQ,GAAE,OAAc;IA4BpD;;;;;OAKG;IACH,aAAa,CAAC,oBAAoB,EAAE,MAAM,GAAG,IAAI;IAoBjD;;;;;;OAMG;IACH,SAAS,IAAI,WAAW;CAoBzB;AAED,eAAe,iBAAiB,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/wallet/partialTxProposal.js b/node_modules/@hathor/wallet-lib/oldLib/wallet/partialTxProposal.js
new file mode 100644
index 0000000..72ed48b
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/wallet/partialTxProposal.js
@@ -0,0 +1,435 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+var _partial_tx = require("../models/partial_tx");
+var _address = _interopRequireDefault(require("../models/address"));
+var _p2sh = _interopRequireDefault(require("../models/p2sh"));
+var _p2pkh = _interopRequireDefault(require("../models/p2pkh"));
+var _script_data = _interopRequireDefault(require("../models/script_data"));
+var _errors = require("../errors");
+var _constants = require("../constants");
+var _transaction = _interopRequireDefault(require("../utils/transaction"));
+var _date = _interopRequireDefault(require("../utils/date"));
+var _types = require("./types");
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
+function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
+function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
+function _asyncIterator(r) { var n, t, o, e = 2; for ("undefined" != typeof Symbol && (t = Symbol.asyncIterator, o = Symbol.iterator); e--;) { if (t && null != (n = r[t])) return n.call(r); if (o && null != (n = r[o])) return new AsyncFromSyncIterator(n.call(r)); t = "@@asyncIterator", o = "@@iterator"; } throw new TypeError("Object is not async iterable"); }
+function AsyncFromSyncIterator(r) { function AsyncFromSyncIteratorContinuation(r) { if (Object(r) !== r) return Promise.reject(new TypeError(r + " is not an object.")); var n = r.done; return Promise.resolve(r.value).then(function (r) { return { value: r, done: n }; }); } return AsyncFromSyncIterator = function (r) { this.s = r, this.n = r.next; }, AsyncFromSyncIterator.prototype = { s: null, n: null, next: function () { return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments)); }, return: function (r) { var n = this.s.return; return void 0 === n ? Promise.resolve({ value: r, done: !0 }) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments)); }, throw: function (r) { var n = this.s.return; return void 0 === n ? Promise.reject(r) : AsyncFromSyncIteratorContinuation(n.apply(this.s, arguments)); } }, new AsyncFromSyncIterator(r); } /**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+class PartialTxProposal {
+  /**
+   * @param {Network} network
+   */
+  constructor(storage) {
+    _defineProperty(this, "partialTx", void 0);
+    _defineProperty(this, "signatures", void 0);
+    _defineProperty(this, "transaction", void 0);
+    _defineProperty(this, "storage", void 0);
+    this.storage = storage;
+    this.partialTx = new _partial_tx.PartialTx(storage.config.getNetwork());
+    this.signatures = null;
+    this.transaction = null;
+  }
+
+  /**
+   * Create a PartialTxProposal instance from the serialized string.
+   *
+   * @param {string} serialized Serialized PartialTx data
+   * @param {Network} network network
+   *
+   * @throws {SyntaxError} serialized argument should be a valid PartialTx.
+   * @throws {UnsupportedScriptError} All outputs should be P2SH or P2PKH
+   *
+   * @returns {PartialTxProposal}
+   */
+  static fromPartialTx(serialized, storage) {
+    const network = storage.config.getNetwork();
+    const partialTx = _partial_tx.PartialTx.deserialize(serialized, network);
+    const proposal = new PartialTxProposal(storage);
+    proposal.partialTx = partialTx;
+    return proposal;
+  }
+
+  /**
+   * Add inputs sending the amount of tokens specified, may add a change output.
+   *
+   * @param {string} token UID of token that is being sent
+   * @param {OutputValueType} value Quantity of tokens being sent
+   * @param {Object} [options]
+   * @param {Utxo[]|null} [options.utxos=[]] utxos to add to the partial transaction.
+   * @param {string|null} [options.changeAddress=null] If we add change, use this address instead of getting a new one from the wallet.
+   * @param {boolean} [options.markAsSelected=true] Mark the utxo with `selected_as_input`.
+   */
+  async addSend(token, value, {
+    utxos = [],
+    changeAddress = null,
+    markAsSelected = true
+  } = {}) {
+    this.resetSignatures();
+
+    // Use the pool of utxos or all wallet utxos.
+    let allUtxos;
+    if (utxos && utxos.length > 0) {
+      allUtxos = utxos;
+    } else {
+      allUtxos = [];
+      var _iteratorAbruptCompletion = false;
+      var _didIteratorError = false;
+      var _iteratorError;
+      try {
+        for (var _iterator = _asyncIterator(this.storage.selectUtxos({
+            token,
+            authorities: 0n
+          })), _step; _iteratorAbruptCompletion = !(_step = await _iterator.next()).done; _iteratorAbruptCompletion = false) {
+          const utxo = _step.value;
+          {
+            allUtxos.push({
+              txId: utxo.txId,
+              index: utxo.index,
+              value: utxo.value,
+              tokenId: utxo.token,
+              address: utxo.address,
+              authorities: 0n,
+              timelock: utxo.timelock,
+              heightlock: null,
+              locked: false,
+              addressPath: ''
+            });
+          }
+        }
+      } catch (err) {
+        _didIteratorError = true;
+        _iteratorError = err;
+      } finally {
+        try {
+          if (_iteratorAbruptCompletion && _iterator.return != null) {
+            await _iterator.return();
+          }
+        } finally {
+          if (_didIteratorError) {
+            throw _iteratorError;
+          }
+        }
+      }
+    }
+
+    // Filter pool of utxos for only utxos from the token and not already in the partial tx
+    const currentUtxos = this.partialTx.inputs.map(input => `${input.hash}-${input.index}`);
+    const utxosToUse = allUtxos.filter(utxo => utxo.tokenId === token && !currentUtxos.includes(`${utxo.txId}-${utxo.index}`));
+    const utxosDetails = _transaction.default.selectUtxos(utxosToUse, value);
+    for (const utxo of utxosDetails.utxos) {
+      this.addInput(utxo.txId, utxo.index, utxo.value, utxo.address, {
+        token: utxo.tokenId,
+        authorities: utxo.authorities,
+        markAsSelected
+      });
+    }
+
+    // add change output if needed
+    if (utxosDetails.changeAmount > 0) {
+      const address = changeAddress || (await this.storage.getCurrentAddress());
+      this.addOutput(token, utxosDetails.changeAmount, address, {
+        isChange: true
+      });
+    }
+  }
+
+  /**
+   * Add outputs receiving the amount of tokens specified.
+   *
+   * @param {string} token UID of token that is being sent
+   * @param {OutputValueType} value Quantity of tokens being sent
+   * @param {Object} [options]
+   * @param {number|null} [options.timelock=null] UNIX timestamp of the timelock.
+   * @param {string|null} [options.address=null] Output address to receive the tokens.
+   *
+   */
+  async addReceive(token, value, {
+    timelock = null,
+    address = null
+  } = {}) {
+    this.resetSignatures();
+
+    // get an address of our wallet and add the output
+    const addr = address || (await this.storage.getCurrentAddress());
+    this.addOutput(token, value, addr, {
+      timelock
+    });
+  }
+
+  /**
+   * Add an UTXO as input on the partial data.
+   *
+   * @param {string} hash Transaction hash
+   * @param {number} index UTXO index on the outputs of the transaction.
+   * @param {OutputValueType} value UTXO value.
+   * @param {Object} [options]
+   * @param {string} [options.token='00'] Token UID in hex format.
+   * @param {OutputValueType} [options.authorities=0] Authority information of the UTXO.
+   * @param {string|null} [options.address=null] Address that owns the UTXO.
+   * @param {boolean} [options.markAsSelected=true] Mark the utxo with `selected_as_input`.
+   */
+  addInput(hash, index, value, address, {
+    token = _constants.NATIVE_TOKEN_UID,
+    authorities = 0n,
+    markAsSelected = true
+  } = {}) {
+    this.resetSignatures();
+    if (markAsSelected) {
+      this.storage.utxoSelectAsInput({
+        txId: hash,
+        index
+      }, true);
+    }
+    this.partialTx.addInput(hash, index, value, address, {
+      token,
+      authorities
+    });
+  }
+
+  /**
+   * Add an output to the partial data.
+   *
+   * @param {string} token UID of token that is being sent.
+   * @param {OutputValueType} value Quantity of tokens being sent.
+   * @param {string} address Create the output script for this address.
+   * @param {Object} [options]
+   * @param {number|null} [options.timelock=null] UNIX timestamp of the timelock.
+   * @param {boolean} [options.isChange=false] If the output should be considered as change.
+   * @param {OutputValueType} [options.authorities=0] Authority information of the Output.
+   *
+   * @throws AddressError
+   */
+  addOutput(token, value, address, {
+    timelock = null,
+    isChange = false,
+    authorities = 0n
+  } = {}) {
+    this.resetSignatures();
+    const addr = new _address.default(address, {
+      network: this.storage.config.getNetwork()
+    });
+    let script;
+    switch (addr.getType()) {
+      case _types.OutputType.P2SH:
+        script = new _p2sh.default(addr, {
+          timelock
+        });
+        break;
+      case _types.OutputType.P2PKH:
+        script = new _p2pkh.default(addr, {
+          timelock
+        });
+        break;
+      default:
+        throw new _errors.AddressError('Unsupported address type');
+    }
+    this.partialTx.addOutput(value, script.createScript(), {
+      token,
+      authorities,
+      isChange
+    });
+  }
+
+  /**
+   * Calculate the token balance of the partial tx for a specific wallet.
+   *
+   * @returns {Record<string, Balance>}
+   */
+  async calculateBalance() {
+    const currentTimestamp = _date.default.dateToTimestamp(new Date());
+    const isTimelocked = timelock => currentTimestamp < timelock;
+    const getEmptyBalance = () => ({
+      balance: {
+        unlocked: 0n,
+        locked: 0n
+      },
+      authority: {
+        unlocked: {
+          mint: 0n,
+          melt: 0n
+        },
+        locked: {
+          mint: 0n,
+          melt: 0n
+        }
+      }
+    });
+    const tokenBalance = {};
+    for (const input of this.partialTx.inputs) {
+      if (!(await this.storage.isAddressMine(input.address))) continue;
+      if (!tokenBalance[input.token]) {
+        tokenBalance[input.token] = getEmptyBalance();
+      }
+      if (input.isAuthority()) {
+        // calculate authority balance
+        tokenBalance[input.token].authority.unlocked.mint -= (input.value & _constants.TOKEN_MINT_MASK) > 0n ? 1n : 0n;
+        tokenBalance[input.token].authority.unlocked.melt -= (input.value & _constants.TOKEN_MELT_MASK) > 0n ? 1n : 0n;
+      } else {
+        // calculate token balance
+        tokenBalance[input.token].balance.unlocked -= input.value;
+      }
+    }
+    for (const output of this.partialTx.outputs) {
+      const decodedScript = output.decodedScript || output.parseScript(this.storage.config.getNetwork());
+
+      // Catch data output and non-standard scripts cases
+      if (decodedScript instanceof _script_data.default || !decodedScript) continue;
+      if (!(await this.storage.isAddressMine(decodedScript.address.base58))) continue;
+      if (!tokenBalance[output.token]) {
+        tokenBalance[output.token] = getEmptyBalance();
+      }
+      if (output.isAuthority()) {
+        /**
+         * Calculate authorities
+         */
+        if (isTimelocked(decodedScript.timelock)) {
+          // Locked output
+          tokenBalance[output.token].authority.locked.mint += (output.value & _constants.TOKEN_MINT_MASK) > 0n ? 1n : 0n;
+          tokenBalance[output.token].authority.locked.melt += (output.value & _constants.TOKEN_MELT_MASK) > 0n ? 1n : 0n;
+        } else {
+          // Unlocked output
+          tokenBalance[output.token].authority.unlocked.mint += (output.value & _constants.TOKEN_MINT_MASK) > 0n ? 1n : 0n;
+          tokenBalance[output.token].authority.unlocked.melt += (output.value & _constants.TOKEN_MELT_MASK) > 0n ? 1n : 0n;
+        }
+      } else if (isTimelocked(decodedScript.timelock)) {
+        /**
+         * Calculate token balances
+         */
+        // Locked output
+        tokenBalance[output.token].balance.locked += output.value;
+      } else {
+        // Unlocked output
+        tokenBalance[output.token].balance.unlocked += output.value;
+      }
+    }
+    return tokenBalance;
+  }
+
+  /**
+   * Reset any data calculated from the partial tx.
+   */
+  resetSignatures() {
+    this.signatures = null;
+    this.transaction = null;
+  }
+
+  /**
+   * Unmark all inputs currently on the partial tx as not `selected_as_input`.
+   *
+   * @param {HathorWallet} wallet Wallet of the UTXOs.
+   */
+  unmarkAsSelected() {
+    for (const input of this.partialTx.inputs) {
+      this.storage.utxoSelectAsInput({
+        txId: input.hash,
+        index: input.index
+      }, false);
+    }
+  }
+
+  /**
+   * Returns true if the transaction funds are balanced and the signatures match all inputs.
+   *
+   * @returns {boolean}
+   */
+  isComplete() {
+    return !!this.signatures && this.partialTx.isComplete() && this.signatures.isComplete();
+  }
+
+  /**
+   * Create the data to sign from the current transaction signing the loaded wallet inputs.
+   *
+   * @param {string} pin The loaded wallet's pin to sign the transaction.
+   * @param {boolean} validate If we should validate the data with the fullnode before signing.
+   *
+   * @throws {InvalidPartialTxError} Inputs and outputs balance should match before signing.
+   * @throws {UnsupportedScriptError} When we have an unsupported output script.
+   * @throws {IndexOOBError} input index should be inside the inputs array.
+   */
+  async signData(pin, validate = true) {
+    if (!this.partialTx.isComplete()) {
+      // partialTx is not complete, we cannot sign it.
+      throw new _errors.InvalidPartialTxError('Cannot sign incomplete data');
+    }
+    const tx = this.partialTx.getTx();
+    this.signatures = new _partial_tx.PartialTxInputData(tx.getDataToSign().toString('hex'), tx.inputs.length);
+    if (validate) {
+      // The validation method populates the addresses
+      const valid = await this.partialTx.validate();
+      if (!valid) {
+        throw new _errors.InvalidPartialTxError('Transaction data inconsistent with fullnode');
+      }
+    }
+
+    // sign inputs from the loaded wallet and save input data
+    await _transaction.default.signTransaction(tx, this.storage, pin);
+    for (const [index, input] of tx.inputs.entries()) {
+      if (input.data) {
+        // add all signatures we know of this tx
+        this.signatures.addData(index, input.data);
+      }
+    }
+  }
+
+  /**
+   * Overwrites the proposal's signatures with the serialized contents in the parameters
+   * @param serializedSignatures
+   *
+   * @throws {InvalidPartialTxError} Inputs and outputs balance should match before the signatures can be added.
+   */
+  setSignatures(serializedSignatures) {
+    if (!this.partialTx.isComplete()) {
+      // partialTx is not complete, we cannot sign it.
+      throw new _errors.InvalidPartialTxError('Cannot sign incomplete data');
+    }
+    const tx = this.partialTx.getTx();
+
+    // Validating signatures hash before setting them
+    const arr = serializedSignatures.split('|');
+    if (arr[1] !== tx.hash) {
+      throw new _errors.InvalidPartialTxError('Signatures do not match tx hash');
+    }
+
+    // Creating an empty signatures object
+    this.signatures = new _partial_tx.PartialTxInputData(tx.getDataToSign().toString('hex'), tx.inputs.length);
+
+    // Setting the signatures data from the parameters
+    this.signatures.addSignatures(serializedSignatures);
+  }
+
+  /**
+   * Create and return the Transaction instance if we have all signatures.
+   *
+   * @throws InvalidPartialTxError
+   *
+   * @returns {Transaction}
+   */
+  prepareTx() {
+    if (!this.partialTx.isComplete()) {
+      throw new _errors.InvalidPartialTxError('Incomplete data');
+    }
+    if (this.signatures === null || !this.signatures.isComplete()) {
+      throw new _errors.InvalidPartialTxError('Incomplete signatures');
+    }
+    if (this.transaction !== null) {
+      return this.transaction;
+    }
+    for (const [index, inputData] of Object.entries(this.signatures.data)) {
+      this.partialTx.inputs[index].setData(inputData);
+    }
+    this.transaction = this.partialTx.getTx();
+    this.transaction.prepareToSend();
+    return this.transaction;
+  }
+}
+var _default = exports.default = PartialTxProposal;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/wallet/sendTransactionWalletService.d.ts b/node_modules/@hathor/wallet-lib/oldLib/wallet/sendTransactionWalletService.d.ts
new file mode 100644
index 0000000..59ab7f8
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/wallet/sendTransactionWalletService.d.ts
@@ -0,0 +1,117 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/// <reference types="node" />
+import { EventEmitter } from 'events';
+import HathorWalletServiceWallet from './wallet';
+import Transaction from '../models/transaction';
+import Output from '../models/output';
+import Input from '../models/input';
+import { OutputSendTransaction, InputRequestObj, TokenAmountMap, ISendTransaction, MineTxSuccessData } from './types';
+type optionsType = {
+    outputs?: OutputSendTransaction[];
+    inputs?: InputRequestObj[];
+    changeAddress?: string | null;
+    transaction?: Transaction | null;
+    pin?: string | null;
+};
+declare class SendTransactionWalletService extends EventEmitter implements ISendTransaction {
+    private wallet;
+    private outputs;
+    private inputs;
+    private changeAddress;
+    private transaction;
+    private mineTransaction;
+    private pin;
+    constructor(wallet: HathorWalletServiceWallet, options?: optionsType);
+    /**
+     * Prepare transaction data to send
+     * Get utxos from wallet service, creates change outpus and returns a Transaction object
+     *
+     * @memberof SendTransactionWalletService
+     * @inner
+     */
+    prepareTx(): Promise<{
+        transaction: Transaction;
+        utxosAddressPath: string[];
+    }>;
+    /**
+     * Map input data to an input object
+     *
+     * @memberof SendTransactionWalletService
+     * @inner
+     */
+    inputDataToModel(input: InputRequestObj): Input;
+    /**
+     * Map output data to an output object
+     *
+     * @memberof SendTransactionWalletService
+     * @inner
+     */
+    outputDataToModel(output: OutputSendTransaction, tokens: string[]): Output;
+    /**
+     * Check if the utxos selected are valid and the sum is enough to
+     * fill the outputs. If needed, create change output
+     *
+     * @memberof SendTransactionWalletService
+     * @inner
+     */
+    validateUtxos(tokenAmountMap: TokenAmountMap): Promise<string[]>;
+    /**
+     * Select utxos to be used in the transaction
+     * Get utxos from wallet service and creates change output if needed
+     *
+     * @memberof SendTransactionWalletService
+     * @inner
+     */
+    selectUtxosToUse(tokenAmountMap: TokenAmountMap): Promise<string[]>;
+    /**
+     * Signs the inputs of a transaction
+     *
+     * @memberof SendTransactionWalletService
+     * @inner
+     */
+    signTx(utxosAddressPath: string[]): Promise<void>;
+    /**
+     * Mine the transaction
+     * Expects this.transaction to be prepared and signed
+     * Emits MineTransaction events while the process is ongoing
+     *
+     * @memberof SendTransactionWalletService
+     * @inner
+     */
+    mineTx(options?: {}): Promise<MineTxSuccessData>;
+    /**
+     * Create and send a tx proposal to wallet service
+     * Expects this.transaction to be prepared, signed and mined
+     *
+     * @memberof SendTransactionWalletService
+     * @inner
+     */
+    handleSendTxProposal(): Promise<Transaction>;
+    /**
+     * Run sendTransaction from mining, i.e. expects this.transaction to be prepared and signed
+     * then it will mine and handle tx proposal
+     *
+     * 'until' parameter can be 'mine-tx', in order to only mine the transaction without propagating
+     *
+     * @memberof SendTransactionWalletService
+     * @inner
+     */
+    runFromMining(until?: string | null): Promise<Transaction>;
+    /**
+     * Run sendTransaction from preparing, i.e. prepare, sign, mine and send the tx
+     *
+     * 'until' parameter can be 'prepare-tx' (it will stop before signing the tx), 'sign-tx' (it will stop before mining the tx),
+     * or 'mine-tx' (it will stop before send tx proposal, i.e. propagating the tx)
+     *
+     * @memberof SendTransactionWalletService
+     * @inner
+     */
+    run(until?: string | null): Promise<Transaction>;
+}
+export default SendTransactionWalletService;
+//# sourceMappingURL=sendTransactionWalletService.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/wallet/sendTransactionWalletService.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/wallet/sendTransactionWalletService.d.ts.map
new file mode 100644
index 0000000..259dc9f
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/wallet/sendTransactionWalletService.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"sendTransactionWalletService.d.ts","sourceRoot":"","sources":["../../src/wallet/sendTransactionWalletService.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;;AAEH,OAAO,EAAE,YAAY,EAAE,MAAM,QAAQ,CAAC;AAItC,OAAO,yBAAyB,MAAM,UAAU,CAAC;AAGjD,OAAO,WAAW,MAAM,uBAAuB,CAAC;AAChD,OAAO,MAAM,MAAM,kBAAkB,CAAC;AACtC,OAAO,KAAK,MAAM,iBAAiB,CAAC;AAIpC,OAAO,EACL,qBAAqB,EACrB,eAAe,EACf,cAAc,EACd,gBAAgB,EAChB,iBAAiB,EAElB,MAAM,SAAS,CAAC;AAEjB,KAAK,WAAW,GAAG;IACjB,OAAO,CAAC,EAAE,qBAAqB,EAAE,CAAC;IAClC,MAAM,CAAC,EAAE,eAAe,EAAE,CAAC;IAC3B,aAAa,CAAC,EAAE,MAAM,GAAG,IAAI,CAAC;IAC9B,WAAW,CAAC,EAAE,WAAW,GAAG,IAAI,CAAC;IACjC,GAAG,CAAC,EAAE,MAAM,GAAG,IAAI,CAAC;CACrB,CAAC;AAEF,cAAM,4BAA6B,SAAQ,YAAa,YAAW,gBAAgB;IAEjF,OAAO,CAAC,MAAM,CAA4B;IAG1C,OAAO,CAAC,OAAO,CAA0B;IAGzC,OAAO,CAAC,MAAM,CAAoB;IAGlC,OAAO,CAAC,aAAa,CAAgB;IAGrC,OAAO,CAAC,WAAW,CAAqB;IAGxC,OAAO,CAAC,eAAe,CAAyB;IAGhD,OAAO,CAAC,GAAG,CAAgB;gBAEf,MAAM,EAAE,yBAAyB,EAAE,OAAO,GAAE,WAAgB;IAoBxE;;;;;;OAMG;IACG,SAAS,IAAI,OAAO,CAAC;QAAE,WAAW,EAAE,WAAW,CAAC;QAAC,gBAAgB,EAAE,MAAM,EAAE,CAAA;KAAE,CAAC;IA2DpF;;;;;OAKG;IAEH,gBAAgB,CAAC,KAAK,EAAE,eAAe,GAAG,KAAK;IAI/C;;;;;OAKG;IACH,iBAAiB,CAAC,MAAM,EAAE,qBAAqB,EAAE,MAAM,EAAE,MAAM,EAAE,GAAG,MAAM;IAgB1E;;;;;;OAMG;IACG,aAAa,CAAC,cAAc,EAAE,cAAc,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC;IAyDtE;;;;;;OAMG;IACG,gBAAgB,CAAC,cAAc,EAAE,cAAc,GAAG,OAAO,CAAC,MAAM,EAAE,CAAC;IAmCzE;;;;;OAKG;IACG,MAAM,CAAC,gBAAgB,EAAE,MAAM,EAAE;IAyBvC;;;;;;;OAOG;IACH,MAAM,CAAC,OAAO,KAAK,GAAG,OAAO,CAAC,iBAAiB,CAAC;IAqDhD;;;;;;OAMG;IACG,oBAAoB;IAyB1B;;;;;;;;OAQG;IACG,aAAa,CAAC,KAAK,GAAE,MAAM,GAAG,IAAW,GAAG,OAAO,CAAC,WAAW,CAAC;IAyBtE;;;;;;;;OAQG;IACG,GAAG,CAAC,KAAK,GAAE,MAAM,GAAG,IAAW,GAAG,OAAO,CAAC,WAAW,CAAC;CAqB7D;AAED,eAAe,4BAA4B,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/wallet/sendTransactionWalletService.js b/node_modules/@hathor/wallet-lib/oldLib/wallet/sendTransactionWalletService.js
new file mode 100644
index 0000000..85dd130
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/wallet/sendTransactionWalletService.js
@@ -0,0 +1,430 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+var _events = require("events");
+var _lodash = require("lodash");
+var _walletApi = _interopRequireDefault(require("./api/walletApi"));
+var _mineTransaction = _interopRequireDefault(require("./mineTransaction"));
+var _wallet = _interopRequireDefault(require("./wallet"));
+var _helpers = _interopRequireDefault(require("../utils/helpers"));
+var _p2pkh = _interopRequireDefault(require("../models/p2pkh"));
+var _transaction = _interopRequireDefault(require("../models/transaction"));
+var _output = _interopRequireDefault(require("../models/output"));
+var _input = _interopRequireDefault(require("../models/input"));
+var _address = _interopRequireDefault(require("../models/address"));
+var _constants = require("../constants");
+var _errors = require("../errors");
+var _types = require("./types");
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
+function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
+function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+class SendTransactionWalletService extends _events.EventEmitter {
+  constructor(wallet, options = {}) {
+    super();
+    // Wallet that is sending the transaction
+    _defineProperty(this, "wallet", void 0);
+    // Outputs to prepare the transaction
+    _defineProperty(this, "outputs", void 0);
+    // Optional inputs to prepare the transaction
+    _defineProperty(this, "inputs", void 0);
+    // Optional change address to prepare the transaction
+    _defineProperty(this, "changeAddress", void 0);
+    // Transaction object to be used after it's already prepared
+    _defineProperty(this, "transaction", void 0);
+    // MineTransaction object
+    _defineProperty(this, "mineTransaction", void 0);
+    // PIN to load the seed from memory
+    _defineProperty(this, "pin", void 0);
+    const newOptions = {
+      outputs: [],
+      inputs: [],
+      changeAddress: null,
+      transaction: null,
+      ...options
+    };
+    this.wallet = wallet;
+    this.outputs = newOptions.outputs;
+    this.inputs = newOptions.inputs;
+    this.changeAddress = newOptions.changeAddress;
+    this.transaction = newOptions.transaction;
+    this.mineTransaction = null;
+    this.pin = newOptions.pin;
+  }
+
+  /**
+   * Prepare transaction data to send
+   * Get utxos from wallet service, creates change outpus and returns a Transaction object
+   *
+   * @memberof SendTransactionWalletService
+   * @inner
+   */
+  async prepareTx() {
+    if (this.outputs.length === 0) {
+      throw new _errors.WalletError("Can't prepare transactions with no outputs.");
+    }
+    this.emit('prepare-tx-start');
+    // We get the full outputs amount for each token
+    // This is useful for (i) getting the utxos for each one
+    // in case it's not sent and (ii) create the token array of the tx
+    const tokenAmountMap = {};
+    for (const output of this.outputs) {
+      if (output.token in tokenAmountMap) {
+        tokenAmountMap[output.token] += output.value;
+      } else {
+        tokenAmountMap[output.token] = output.value;
+      }
+    }
+
+    // We need this array to get the addressPath for each input used and be able to sign the input data
+    let utxosAddressPath;
+    if (this.inputs.length === 0) {
+      // Need to get utxos
+      // We already know the full amount for each token
+      // Now we can get the utxos and (if needed) change amount for each token
+      utxosAddressPath = await this.selectUtxosToUse(tokenAmountMap);
+    } else {
+      // If the user selected the inputs, we must validate that
+      // all utxos are valid and the sum is enought to fill the outputs
+      utxosAddressPath = await this.validateUtxos(tokenAmountMap);
+    }
+
+    // Create tokens array, in order to calculate each output tokenData
+    // if HTR appears in the array, we must remove it
+    // because we don't add HTR to the transaction tokens array
+    const tokens = Object.keys(tokenAmountMap);
+    const htrIndex = tokens.indexOf(_constants.NATIVE_TOKEN_UID);
+    if (htrIndex > -1) {
+      tokens.splice(htrIndex, 1);
+    }
+
+    // Transform input data in Input model object
+    const inputsObj = [];
+    for (const i of this.inputs) {
+      inputsObj.push(this.inputDataToModel(i));
+    }
+
+    // Transform output data in Output model object
+    const outputsObj = [];
+    for (const o of this.outputs) {
+      outputsObj.push(this.outputDataToModel(o, tokens));
+    }
+
+    // Create the transaction object, add weight and timestamp
+    this.transaction = new _transaction.default(inputsObj, outputsObj);
+    this.transaction.tokens = tokens;
+    this.emit('prepare-tx-end', this.transaction);
+    return {
+      transaction: this.transaction,
+      utxosAddressPath
+    };
+  }
+
+  /**
+   * Map input data to an input object
+   *
+   * @memberof SendTransactionWalletService
+   * @inner
+   */
+  // eslint-disable-next-line class-methods-use-this -- XXX: This method should be made static
+  inputDataToModel(input) {
+    return new _input.default(input.txId, input.index);
+  }
+
+  /**
+   * Map output data to an output object
+   *
+   * @memberof SendTransactionWalletService
+   * @inner
+   */
+  outputDataToModel(output, tokens) {
+    if (output.type === _types.OutputType.DATA) {
+      return _helpers.default.createDataScriptOutput(output.data);
+    }
+    const address = new _address.default(output.address, {
+      network: this.wallet.network
+    });
+    if (!address.isValid()) {
+      throw new _errors.SendTxError(`Address ${output.address} is not valid.`);
+    }
+    const tokenData = tokens.indexOf(output.token) > -1 ? tokens.indexOf(output.token) + 1 : 0;
+    const outputOptions = {
+      tokenData
+    };
+    const p2pkh = new _p2pkh.default(address, {
+      timelock: output.timelock || null
+    });
+    const p2pkhScript = p2pkh.createScript();
+    return new _output.default(output.value, p2pkhScript, outputOptions);
+  }
+
+  /**
+   * Check if the utxos selected are valid and the sum is enough to
+   * fill the outputs. If needed, create change output
+   *
+   * @memberof SendTransactionWalletService
+   * @inner
+   */
+  async validateUtxos(tokenAmountMap) {
+    const amountInputMap = {};
+    const utxosAddressPath = [];
+    for (const input of this.inputs) {
+      const utxo = await this.wallet.getUtxoFromId(input.txId, input.index);
+      if (utxo === null) {
+        throw new _errors.UtxoError(`Invalid input selection. Input ${input.txId} at index ${input.index}.`);
+      }
+      if (!(utxo.tokenId in tokenAmountMap)) {
+        throw new _errors.SendTxError(`Invalid input selection. Input ${input.txId} at index ${input.index} has token ${utxo.tokenId} that is not on the outputs.`);
+      }
+      utxosAddressPath.push(utxo.addressPath);
+      if (utxo.tokenId in amountInputMap) {
+        amountInputMap[utxo.tokenId] += utxo.value;
+      } else {
+        amountInputMap[utxo.tokenId] = utxo.value;
+      }
+    }
+    for (const t in tokenAmountMap) {
+      if (!(t in amountInputMap)) {
+        throw new _errors.SendTxError(`Invalid input selection. Token ${t} is in the outputs but there are no inputs for it.`);
+      }
+      if (amountInputMap[t] < tokenAmountMap[t]) {
+        throw new _errors.SendTxError(`Invalid input selection. Sum of inputs for token ${t} is smaller than the sum of outputs.`);
+      }
+      if (amountInputMap[t] > tokenAmountMap[t]) {
+        const changeAmount = amountInputMap[t] - tokenAmountMap[t];
+        const changeAddress = this.changeAddress || this.wallet.getCurrentAddress({
+          markAsUsed: true
+        }).address;
+        this.outputs.push({
+          address: changeAddress,
+          value: changeAmount,
+          token: t,
+          type: _helpers.default.getOutputTypeFromAddress(changeAddress, this.wallet.network)
+        });
+        // If we add a change output, then we must shuffle it
+        this.outputs = (0, _lodash.shuffle)(this.outputs);
+      }
+    }
+    return utxosAddressPath;
+  }
+
+  /**
+   * Select utxos to be used in the transaction
+   * Get utxos from wallet service and creates change output if needed
+   *
+   * @memberof SendTransactionWalletService
+   * @inner
+   */
+  async selectUtxosToUse(tokenAmountMap) {
+    const utxosAddressPath = [];
+    for (const token in tokenAmountMap) {
+      const {
+        utxos,
+        changeAmount
+      } = await this.wallet.getUtxos({
+        tokenId: token,
+        totalAmount: tokenAmountMap[token]
+      });
+      if (utxos.length === 0) {
+        throw new _errors.UtxoError(`No utxos available to fill the request. Token: ${token} - Amount: ${tokenAmountMap[token]}.`);
+      }
+      for (const utxo of utxos) {
+        this.inputs.push({
+          txId: utxo.txId,
+          index: utxo.index
+        });
+        utxosAddressPath.push(utxo.addressPath);
+      }
+      if (changeAmount) {
+        const changeAddress = this.changeAddress || this.wallet.getCurrentAddress({
+          markAsUsed: true
+        }).address;
+        this.outputs.push({
+          address: changeAddress,
+          value: changeAmount,
+          token,
+          type: _helpers.default.getOutputTypeFromAddress(changeAddress, this.wallet.network)
+        });
+        // If we add a change output, then we must shuffle it
+        this.outputs = (0, _lodash.shuffle)(this.outputs);
+      }
+    }
+    return utxosAddressPath;
+  }
+
+  /**
+   * Signs the inputs of a transaction
+   *
+   * @memberof SendTransactionWalletService
+   * @inner
+   */
+  async signTx(utxosAddressPath) {
+    if (this.transaction === null) {
+      throw new _errors.WalletError("Can't sign transaction if it's null.");
+    }
+    this.emit('sign-tx-start');
+    const dataToSignHash = this.transaction.getDataToSignHash();
+    const xprivkey = await this.wallet.storage.getMainXPrivKey(this.pin || '');
+    for (const [idx, inputObj] of this.transaction.inputs.entries()) {
+      const inputData = this.wallet.getInputData(xprivkey, dataToSignHash,
+      // the wallet service returns the full BIP44 path, but we only need the address path:
+      _wallet.default.getAddressIndexFromFullPath(utxosAddressPath[idx]));
+      inputObj.setData(inputData);
+    }
+
+    // Now that the tx is completed with the data of the input
+    // we can add the timestamp and calculate the weight
+    this.transaction.prepareToSend();
+    this.emit('sign-tx-end', this.transaction);
+  }
+
+  /**
+   * Mine the transaction
+   * Expects this.transaction to be prepared and signed
+   * Emits MineTransaction events while the process is ongoing
+   *
+   * @memberof SendTransactionWalletService
+   * @inner
+   */
+  mineTx(options = {}) {
+    if (this.transaction === null) {
+      throw new _errors.WalletError("Can't mine transaction if it's null.");
+    }
+    const newOptions = {
+      startMiningTx: true,
+      maxTxMiningRetries: 3,
+      ...options
+    };
+    this.mineTransaction = new _mineTransaction.default(this.transaction, {
+      maxTxMiningRetries: newOptions.maxTxMiningRetries
+    });
+    this.mineTransaction.on('mining-started', () => {
+      this.emit('mine-tx-started');
+    });
+    this.mineTransaction.on('estimation-updated', data => {
+      this.emit('estimation-updated', data);
+    });
+    this.mineTransaction.on('job-submitted', data => {
+      this.emit('job-submitted', data);
+    });
+    this.mineTransaction.on('job-done', data => {
+      this.emit('job-done', data);
+    });
+    this.mineTransaction.on('error', message => {
+      this.emit('send-error', message);
+    });
+    this.mineTransaction.on('unexpected-error', message => {
+      this.emit('send-error', message);
+    });
+    this.mineTransaction.on('success', data => {
+      this.emit('mine-tx-ended', data);
+    });
+    if (newOptions.startMiningTx) {
+      this.mineTransaction.start();
+    }
+    return this.mineTransaction.promise;
+  }
+
+  /**
+   * Create and send a tx proposal to wallet service
+   * Expects this.transaction to be prepared, signed and mined
+   *
+   * @memberof SendTransactionWalletService
+   * @inner
+   */
+  async handleSendTxProposal() {
+    if (this.transaction === null) {
+      throw new _errors.WalletError("Can't push transaction if it's null.");
+    }
+    this.emit('send-tx-start', this.transaction);
+    const txHex = this.transaction.toHex();
+    try {
+      const responseData = await _walletApi.default.createTxProposal(this.wallet, txHex);
+      const {
+        txProposalId
+      } = responseData;
+      await _walletApi.default.updateTxProposal(this.wallet, txProposalId, txHex);
+      this.transaction.updateHash();
+      this.emit('send-tx-success', this.transaction);
+      return this.transaction;
+    } catch (err) {
+      if (err instanceof _errors.WalletRequestError) {
+        const errMessage = 'Error sending tx proposal.';
+        this.emit('send-error', errMessage);
+        throw new _errors.SendTxError(errMessage);
+      } else {
+        throw err;
+      }
+    }
+  }
+
+  /**
+   * Run sendTransaction from mining, i.e. expects this.transaction to be prepared and signed
+   * then it will mine and handle tx proposal
+   *
+   * 'until' parameter can be 'mine-tx', in order to only mine the transaction without propagating
+   *
+   * @memberof SendTransactionWalletService
+   * @inner
+   */
+  async runFromMining(until = null) {
+    try {
+      // This will await until mine tx is fully completed
+      // mineTx method returns a promise that resolves when
+      // mining succeeds or rejects when there is an error
+      const mineData = await this.mineTx();
+      this.transaction.parents = mineData.parents;
+      this.transaction.timestamp = mineData.timestamp;
+      this.transaction.nonce = mineData.nonce;
+      this.transaction.weight = mineData.weight;
+      if (until === 'mine-tx') {
+        return this.transaction;
+      }
+      const tx = await this.handleSendTxProposal();
+      return tx;
+    } catch (err) {
+      if (err instanceof _errors.WalletError) {
+        this.emit('send-error', err.message);
+      }
+      throw err;
+    }
+  }
+
+  /**
+   * Run sendTransaction from preparing, i.e. prepare, sign, mine and send the tx
+   *
+   * 'until' parameter can be 'prepare-tx' (it will stop before signing the tx), 'sign-tx' (it will stop before mining the tx),
+   * or 'mine-tx' (it will stop before send tx proposal, i.e. propagating the tx)
+   *
+   * @memberof SendTransactionWalletService
+   * @inner
+   */
+  async run(until = null) {
+    try {
+      const preparedData = await this.prepareTx();
+      if (until === 'prepare-tx') {
+        return this.transaction;
+      }
+      await this.signTx(preparedData.utxosAddressPath);
+      if (until === 'sign-tx') {
+        return this.transaction;
+      }
+      const tx = await this.runFromMining(until);
+      return tx;
+    } catch (err) {
+      if (err instanceof _errors.WalletError) {
+        this.emit('send-error', err.message);
+      }
+      throw err;
+    }
+  }
+}
+var _default = exports.default = SendTransactionWalletService;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/wallet/types.d.ts b/node_modules/@hathor/wallet-lib/oldLib/wallet/types.d.ts
new file mode 100644
index 0000000..85aea88
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/wallet/types.d.ts
@@ -0,0 +1,510 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+import bitcore from 'bitcore-lib';
+import Transaction from '../models/transaction';
+import CreateTokenTransaction from '../models/create_token_transaction';
+import SendTransactionWalletService from './sendTransactionWalletService';
+import Input from '../models/input';
+import Output from '../models/output';
+import { OutputValueType, IHistoryTx } from '../types';
+export interface GetAddressesObject {
+    address: string;
+    index: number;
+    transactions: number;
+}
+export interface GetBalanceObject {
+    token: TokenInfo;
+    balance: Balance;
+    tokenAuthorities: AuthoritiesBalance;
+    transactions: number;
+    lockExpires: number | null;
+}
+export interface TokenInfo {
+    id: string;
+    name: string;
+    symbol: string;
+}
+export interface Balance {
+    unlocked: OutputValueType;
+    locked: OutputValueType;
+}
+export interface AuthoritiesBalance {
+    unlocked: Authority;
+    locked: Authority;
+}
+export interface Authority {
+    mint: boolean;
+    melt: boolean;
+}
+export interface GetHistoryObject {
+    txId: string;
+    balance: OutputValueType;
+    timestamp: number;
+    voided: boolean;
+    version: number;
+}
+export interface AddressInfoObject {
+    address: string;
+    index: number;
+    addressPath: string;
+    info?: string | undefined;
+}
+export interface WalletStatusResponseData {
+    success: boolean;
+    status: WalletStatus;
+    error?: string | undefined;
+}
+export interface WalletStatus {
+    walletId: string;
+    xpubkey: string;
+    status: string;
+    maxGap: number;
+    createdAt: number;
+    readyAt: number | null;
+}
+export interface AddressesResponseData {
+    success: boolean;
+    addresses: GetAddressesObject[];
+}
+export interface CheckAddressesMineResponseData {
+    success: boolean;
+    addresses: WalletAddressMap;
+}
+export interface NewAddressesResponseData {
+    success: boolean;
+    addresses: AddressInfoObject[];
+}
+export interface BalanceResponseData {
+    success: boolean;
+    balances: GetBalanceObject[];
+}
+export interface TokenDetailsResponseData {
+    success: boolean;
+    details: TokenDetailsObject;
+}
+export interface TokenDetailsAuthoritiesObject {
+    mint: boolean;
+    melt: boolean;
+}
+export interface TokenDetailsObject {
+    tokenInfo: TokenInfo;
+    totalSupply: OutputValueType;
+    totalTransactions: number;
+    authorities: TokenDetailsAuthoritiesObject;
+}
+export interface HistoryResponseData {
+    success: boolean;
+    history: GetHistoryObject[];
+}
+export interface TxProposalCreateResponseData {
+    success: boolean;
+    txProposalId: string;
+    inputs: TxProposalInputs[];
+}
+export interface TxProposalInputs {
+    txId: string;
+    index: number;
+    addressPath: string;
+}
+export interface TxProposalOutputs {
+    address: string;
+    value: OutputValueType;
+    token: string;
+    timelock: number | null;
+}
+export interface TxProposalUpdateResponseData {
+    success: boolean;
+    txProposalId: string;
+    txHex: string;
+}
+export interface RequestError {
+    success: boolean;
+    error: string;
+}
+export interface InputRequestObject {
+    txId: string;
+    index: number;
+}
+export interface SendManyTxOptionsParam {
+    inputs: InputRequestObject[] | undefined;
+    changeAddress: string | undefined;
+}
+export interface SendTxOptionsParam {
+    token: string | undefined;
+    changeAddress: string | undefined;
+}
+export interface TxOutputResponseData {
+    success: boolean;
+    txOutputs: Utxo[];
+}
+export interface Utxo {
+    txId: string;
+    index: number;
+    tokenId: string;
+    address: string;
+    value: OutputValueType;
+    authorities: OutputValueType;
+    timelock: number | null;
+    heightlock: number | null;
+    locked: boolean;
+    addressPath: string;
+}
+export interface AuthorityTxOutput {
+    txId: string;
+    index: number;
+    address: string;
+    authorities: OutputValueType;
+}
+export interface AuthTokenResponseData {
+    success: boolean;
+    token: string;
+}
+export interface OutputRequestObj {
+    address: string;
+    value: OutputValueType;
+    token: string;
+    timelock?: number | null;
+}
+export interface DataScriptOutputRequestObj {
+    type: 'data';
+    data: string;
+}
+export interface OutputSendTransaction {
+    type: string;
+    value: OutputValueType;
+    token: string;
+    address?: string;
+    timelock?: number | null;
+    data?: string;
+}
+export interface InputRequestObj {
+    txId: string;
+    index: number;
+}
+export interface TokensResponseData {
+    success: boolean;
+    tokens: string[];
+}
+export interface SendTransactionEvents {
+    success: boolean;
+    sendTransaction: SendTransactionWalletService;
+}
+export interface SendTransactionResponse {
+    success: boolean;
+    transaction: Transaction;
+}
+export interface WalletAddressMap {
+    [address: string]: boolean;
+}
+export interface TokenAmountMap {
+    [token: string]: OutputValueType;
+}
+export interface TransactionFullObject {
+    tx_id: string;
+    version: number;
+    timestamp: number;
+    is_voided: boolean;
+    inputs: Input[];
+    outputs: Output[];
+    parents: string[];
+}
+export interface IStopWalletParams {
+    cleanStorage?: boolean;
+    cleanAddresses?: boolean;
+}
+export interface DelegateAuthorityOptions {
+    anotherAuthorityAddress: string | null;
+    createAnother: boolean;
+    pinCode: string | null;
+}
+export interface DestroyAuthorityOptions {
+    pinCode: string | null;
+}
+export interface IHathorWallet {
+    start(options: {
+        pinCode: string;
+        password: string;
+    }): Promise<void>;
+    getAllAddresses(): AsyncGenerator<GetAddressesObject>;
+    getBalance(token: string | null): Promise<GetBalanceObject[]>;
+    getTokens(): Promise<string[]>;
+    getTxHistory(options: {
+        token_id?: string;
+        count?: number;
+        skip?: number;
+    }): Promise<GetHistoryObject[]>;
+    sendManyOutputsTransaction(outputs: OutputRequestObj[], options: {
+        inputs?: InputRequestObj[];
+        changeAddress?: string;
+    }): Promise<Transaction>;
+    sendTransaction(address: string, value: OutputValueType, options: {
+        token?: string;
+        changeAddress?: string;
+    }): Promise<Transaction>;
+    stop(params?: IStopWalletParams): void;
+    getAddressAtIndex(index: number): Promise<string>;
+    getCurrentAddress(options: {
+        markAsUsed: boolean;
+    }): AddressInfoObject;
+    getNextAddress(): AddressInfoObject;
+    getAddressPrivKey(pinCode: string, addressIndex: number): Promise<bitcore.PrivateKey>;
+    signMessageWithAddress(message: string, index: number, pinCode: string): Promise<string>;
+    prepareCreateNewToken(name: string, symbol: string, amount: OutputValueType, options: any): Promise<CreateTokenTransaction>;
+    createNewToken(name: string, symbol: string, amount: OutputValueType, options: any): Promise<Transaction>;
+    createNFT(name: string, symbol: string, amount: OutputValueType, data: string, options: any): Promise<Transaction>;
+    prepareMintTokensData(token: string, amount: OutputValueType, options: any): Promise<Transaction>;
+    mintTokens(token: string, amount: OutputValueType, options: any): Promise<Transaction>;
+    prepareMeltTokensData(token: string, amount: OutputValueType, options: any): Promise<Transaction>;
+    meltTokens(token: string, amount: OutputValueType, options: any): Promise<Transaction>;
+    prepareDelegateAuthorityData(token: string, type: string, address: string, options: DelegateAuthorityOptions): Promise<Transaction>;
+    delegateAuthority(token: string, type: string, address: string, options: DelegateAuthorityOptions): Promise<Transaction>;
+    prepareDestroyAuthorityData(token: string, type: string, count: number, options: DestroyAuthorityOptions): Promise<Transaction>;
+    destroyAuthority(token: string, type: string, count: number, options: DestroyAuthorityOptions): Promise<Transaction>;
+    getFullHistory(): TransactionFullObject[];
+    getTxBalance(tx: IHistoryTx, optionsParams: any): Promise<{
+        [tokenId: string]: OutputValueType;
+    }>;
+    onConnectionChangedState(newState: ConnectionState): void;
+    getTokenDetails(tokenId: string): Promise<TokenDetailsObject>;
+    getVersionData(): Promise<FullNodeVersionData>;
+    checkAddressesMine(addresses: string[]): Promise<WalletAddressMap>;
+    getFullTxById(txId: string): Promise<FullNodeTxResponse>;
+    getTxConfirmationData(txId: string): Promise<FullNodeTxConfirmationDataResponse>;
+    graphvizNeighborsQuery(txId: string, graphType: string, maxLevel: number): Promise<string>;
+    checkPin(pin: string): Promise<boolean>;
+    checkPassword(password: string): Promise<boolean>;
+    checkPinAndPassword(pin: string, password: string): Promise<boolean>;
+}
+export interface ISendTransaction {
+    run(until: string | null): Promise<Transaction>;
+    runFromMining(until: string | null): Promise<Transaction>;
+}
+export interface MineTxSuccessData {
+    nonce: number;
+    weight: number;
+    timestamp: number;
+    parents: string[];
+}
+export interface DecodedOutput {
+    type: string;
+    address: string;
+    timelock: number | null;
+}
+export interface TxOutput {
+    value: OutputValueType;
+    script: string;
+    token: string;
+    decoded: DecodedOutput;
+    token_data: number;
+    locked: boolean;
+    index: number;
+    tokenData: number;
+    decodedScript: null;
+}
+export interface TxInput {
+    tx_id: string;
+    index: number;
+    value: OutputValueType;
+    token_data: number;
+    token: string;
+    decoded: DecodedOutput;
+}
+/**
+ * Represents the Buffer-like script object in websocket transactions.
+ */
+export type WsBufferScript = {
+    type: 'Buffer';
+    data: number[];
+};
+/**
+ * Represents the decoded part of a websocket transaction input.
+ */
+export type WsTxInputDecoded = {
+    type: string;
+    address: string;
+    timelock?: number | null;
+};
+/**
+ * Represents a websocket transaction input.
+ */
+export type WsTxInput = {
+    tx_id: string;
+    index: number;
+    value: bigint;
+    token_data: number;
+    script: WsBufferScript;
+    token: string;
+    decoded: WsTxInputDecoded;
+};
+/**
+ * Represents the decoded part of a websocket transaction output.
+ */
+export type WsTxOutputDecoded = {
+    type?: string | null;
+    address?: string;
+    timelock?: number | null;
+};
+/**
+ * Represents a websocket transaction output.
+ */
+export type WsTxOutput = {
+    value: bigint;
+    token_data: number;
+    script: WsBufferScript;
+    decodedScript?: unknown | null;
+    token: string;
+    locked: boolean;
+    index: number;
+    decoded: WsTxOutputDecoded;
+};
+export interface WsTransaction {
+    tx_id: string;
+    nonce: number;
+    timestamp: number;
+    signal_bits: number;
+    version: number;
+    weight: number;
+    parents: string[];
+    inputs: WsTxInput[];
+    outputs: WsTxOutput[];
+    height?: number | null;
+    token_name?: string | null;
+    token_symbol?: string | null;
+}
+export interface CreateWalletAuthData {
+    xpub: bitcore.HDPublicKey;
+    xpubkeySignature: string;
+    authXpub: string;
+    authXpubkeySignature: string;
+    timestampNow: number;
+    firstAddress: string;
+    authDerivedPrivKey: bitcore.HDPrivateKey;
+}
+export interface FullNodeVersionData {
+    timestamp: number;
+    version: string;
+    network: string;
+    minWeight: number;
+    minTxWeight: number;
+    minTxWeightCoefficient: number;
+    minTxWeightK: number;
+    tokenDepositPercentage: number;
+    rewardSpendMinBlocks: number;
+    maxNumberInputs: number;
+    maxNumberOutputs: number;
+}
+export interface TxByIdTokenData {
+    txId: string;
+    timestamp: number;
+    version: number;
+    voided: boolean;
+    height?: number | null;
+    weight: number;
+    balance: bigint;
+    tokenId: string;
+    tokenName: string;
+    tokenSymbol: string;
+}
+export interface TxByIdTokensResponseData {
+    success: boolean;
+    txTokens: TxByIdTokenData[];
+}
+export interface WalletServiceServerUrls {
+    walletServiceBaseUrl: string;
+    walletServiceWsUrl: string;
+}
+export declare enum ConnectionState {
+    CLOSED = 0,
+    CONNECTING = 1,
+    CONNECTED = 2
+}
+export declare enum OutputType {
+    P2PKH = "p2pkh",
+    P2SH = "p2sh",
+    DATA = "data"
+}
+export interface FullNodeToken {
+    uid: string;
+    name: string | null;
+    symbol: string | null;
+}
+export interface FullNodeDecodedInput {
+    type?: string | null;
+    address?: string | null;
+    timelock?: number | null;
+    value?: OutputValueType | null;
+    token_data?: number | null;
+}
+export interface FullNodeDecodedOutput {
+    type?: string | null;
+    address?: string | null;
+    timelock?: number | null;
+    value?: OutputValueType | null;
+    token_data?: number | null;
+}
+export interface FullNodeInput {
+    value: OutputValueType;
+    token_data: number;
+    script: string;
+    decoded: FullNodeDecodedInput;
+    tx_id: string;
+    index: number;
+    token?: string | null;
+    spent_by?: string | null;
+}
+export interface FullNodeOutput {
+    value: OutputValueType;
+    token_data: number;
+    script: string;
+    decoded: FullNodeDecodedOutput;
+    token?: string | null;
+    spent_by?: string | null;
+}
+export interface FullNodeTx {
+    hash: string;
+    nonce: string;
+    timestamp: number;
+    version: number;
+    weight: number;
+    parents: string[];
+    inputs: FullNodeInput[];
+    outputs: FullNodeOutput[];
+    tokens: FullNodeToken[];
+    token_name?: string | null;
+    token_symbol?: string | null;
+    raw: string;
+}
+export interface FullNodeMeta {
+    hash: string;
+    spent_outputs: Array<[number, Array<string>]>;
+    received_by: string[];
+    children: string[];
+    conflict_with: string[];
+    voided_by: string[];
+    twins: string[];
+    accumulated_weight: number;
+    score: number;
+    height: number;
+    validation?: string;
+    first_block?: string | null;
+    first_block_height?: number | null;
+}
+export interface FullNodeTxResponse {
+    tx: FullNodeTx;
+    meta: FullNodeMeta;
+    success: boolean;
+    message?: string;
+    spent_outputs?: Record<string, string>;
+}
+export interface FullNodeTxConfirmationDataResponse {
+    success: boolean;
+    accumulated_weight: number;
+    accumulated_bigger: boolean;
+    stop_value: number;
+    confirmation_level: number;
+}
+//# sourceMappingURL=types.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/wallet/types.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/wallet/types.d.ts.map
new file mode 100644
index 0000000..7755eb7
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/wallet/types.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"types.d.ts","sourceRoot":"","sources":["../../src/wallet/types.ts"],"names":[],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/wallet/types.js b/node_modules/@hathor/wallet-lib/oldLib/wallet/types.js
new file mode 100644
index 0000000..541ac7e
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/wallet/types.js
@@ -0,0 +1,40 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.OutputType = exports.ConnectionState = void 0;
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+// This is the output object to be used in the SendTransactionWalletService class
+/**
+ * Represents the Buffer-like script object in websocket transactions.
+ */
+/**
+ * Represents the decoded part of a websocket transaction input.
+ */
+/**
+ * Represents a websocket transaction input.
+ */
+/**
+ * Represents the decoded part of a websocket transaction output.
+ */
+/**
+ * Represents a websocket transaction output.
+ */
+let ConnectionState = exports.ConnectionState = /*#__PURE__*/function (ConnectionState) {
+  ConnectionState[ConnectionState["CLOSED"] = 0] = "CLOSED";
+  ConnectionState[ConnectionState["CONNECTING"] = 1] = "CONNECTING";
+  ConnectionState[ConnectionState["CONNECTED"] = 2] = "CONNECTED";
+  return ConnectionState;
+}({});
+let OutputType = exports.OutputType = /*#__PURE__*/function (OutputType) {
+  OutputType["P2PKH"] = "p2pkh";
+  OutputType["P2SH"] = "p2sh";
+  OutputType["DATA"] = "data";
+  return OutputType;
+}({});
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/wallet/wallet.d.ts b/node_modules/@hathor/wallet-lib/oldLib/wallet/wallet.d.ts
new file mode 100644
index 0000000..ad52833
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/wallet/wallet.d.ts
@@ -0,0 +1,602 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/// <reference types="node" />
+/// <reference types="node" />
+import { EventEmitter } from 'events';
+import bitcore from 'bitcore-lib';
+import Transaction from '../models/transaction';
+import CreateTokenTransaction from '../models/create_token_transaction';
+import Network from '../models/network';
+import { AddressInfoObject, GetBalanceObject, GetAddressesObject, GetHistoryObject, Utxo, OutputRequestObj, DataScriptOutputRequestObj, InputRequestObj, TransactionFullObject, IHathorWallet, WsTransaction, CreateWalletAuthData, ConnectionState, TokenDetailsObject, AuthorityTxOutput, WalletServiceServerUrls, FullNodeVersionData, WalletAddressMap, TxByIdTokensResponseData, DelegateAuthorityOptions, DestroyAuthorityOptions, FullNodeTxResponse, FullNodeTxConfirmationDataResponse } from './types';
+import { IStorage, OutputValueType, IHistoryTx } from '../types';
+declare class HathorWalletServiceWallet extends EventEmitter implements IHathorWallet {
+    passphrase: string;
+    walletId: string | null;
+    network: Network;
+    private requestPassword;
+    private seed;
+    private xpub;
+    private xpriv;
+    private authPrivKey;
+    private state;
+    private isSendingTx;
+    private txProposalId;
+    private authToken;
+    private newAddresses;
+    private indexToUse;
+    private conn;
+    private firstConnection;
+    private readonly _isWsEnabled;
+    storage: IStorage;
+    constructor({ requestPassword, seed, xpriv, authxpriv, xpub, network, passphrase, enableWs, storage, }: {
+        requestPassword: () => Promise<string>;
+        seed?: string | null;
+        xpriv?: string | null;
+        authxpriv?: string | null;
+        xpub?: string | null;
+        network: Network;
+        passphrase?: string;
+        enableWs?: boolean;
+        storage?: IStorage | null;
+    });
+    /**
+     * Sets the server to connect on config singleton and storage
+     *
+     * @param {String} newServer - The new server to set the config and storage to
+     *
+     * @memberof HathorWalletServiceWallet
+     * @inner
+     */
+    changeServer(newServer: string): Promise<void>;
+    /**
+     * Sets the websocket server to connect on config singleton and storage
+     *
+     * @param {String} newServer - The new websocket server to set the config and storage to
+     *
+     * @memberof HathorWalletServiceWallet
+     * @inner
+     */
+    changeWsServer(newServer: string): Promise<void>;
+    /**
+     * Gets the stored websocket and base server urls
+     *
+     * @memberof HathorWalletServiceWallet
+     * @inner
+     */
+    getServerUrlsFromStorage(): Promise<WalletServiceServerUrls>;
+    /**
+     * Remove sensitive data from memory
+     *
+     * NOTICE: This won't remove data from memory immediately, we have to wait until javascript
+     * garbage collect it. JavaScript currently does not provide a standard way to trigger
+     * garbage collection
+     * */
+    clearSensitiveData(): void;
+    /**
+     * Get auth xpubkey from seed
+     *
+     * @param {String} seed 24 words
+     * @param {Object} options Options with passphrase and networkName
+     *
+     * @return {String} auth xpubkey
+     * @memberof HathorWalletServiceWallet
+     * @inner
+     */
+    static getAuthXPubKeyFromSeed(seed: string, options?: {
+        passphrase?: string;
+        networkName?: string;
+    }): string;
+    /**
+     * Derive private key from root to the auth specific purpose derivation path
+     *
+     * @param {HDPrivateKey} xpriv The wallet's root xpriv
+     *
+     * @return {HDPrivateKey} Derived private key at the auth derivation path
+     * @memberof HathorWalletServiceWallet
+     * @inner
+     */
+    static deriveAuthPrivateKey(xpriv: bitcore.HDPrivateKey): bitcore.HDPrivateKey;
+    /**
+     * getWalletIdFromXPub: Get the wallet id given the xpubkey
+     *
+     * @param xpub - The xpubkey
+     * @returns The wallet id
+     *
+     * @memberof HathorWalletServiceWallet
+     * @inner
+     */
+    static getWalletIdFromXPub(xpub: string): string;
+    /**
+     * Start wallet: load the wallet data, update state and start polling wallet status until it's ready
+     *
+     * @param {Object} optionsParams Options parameters
+     *  {
+     *   'pinCode': PIN to encrypt the auth xpriv on storage
+     *   'password': Password to decrypt xpriv information
+     *  }
+     *
+     * @memberof HathorWalletServiceWallet
+     * @inner
+     */
+    start({ pinCode, password }?: {
+        pinCode?: string;
+        password?: string;
+    }): Promise<void>;
+    /**
+     * Returns version data from the connected fullnode
+     * */
+    getVersionData(): Promise<FullNodeVersionData>;
+    /**
+     * Detects if we are loading from the seed or the account path and returns the
+     * required information for authentication
+     *
+     * @param pinCode The pincode to be used to encrypt the auth xprivkey
+     *
+     * @memberof HathorWalletServiceWallet
+     * @inner
+     */
+    generateCreateWalletAuthData(pinCode: string): Promise<CreateWalletAuthData>;
+    /**
+     * onUpdateTx: Event called when a transaction is updated
+     *
+     * @memberof HathorWalletServiceWallet
+     * @inner
+     */
+    onUpdateTx(updatedTx: any): void;
+    /**
+     * onNewTx: Event called when a new transaction is received on the websocket feed
+     *
+     * @memberof HathorWalletServiceWallet
+     * @inner
+     */
+    onNewTx(newTx: WsTransaction): Promise<void>;
+    /**
+     * Return wallet auth token
+     *
+     * @memberof HathorWalletServiceWallet
+     * @inner
+     */
+    getAuthToken(): string | null;
+    /**
+     * Returns the balance for each token in tx, if the input/output belongs to this wallet
+     *
+     * This method is meant to keep compatibility with the old facade
+     *
+     * @param {Object} tx Transaction data with array of inputs and outputs
+     *
+     * @return {Object} Object with each token and it's balance in this tx for this wallet
+     * */
+    getTxBalance(tx: IHistoryTx, optionsParam?: {}): Promise<{
+        [tokenId: string]: OutputValueType;
+    }>;
+    /**
+     * When the wallet starts, it might take some seconds for the wallet service to completely load all addresses
+     * This method is responsible for polling the wallet status until it's ready
+     *
+     * @memberof HathorWalletServiceWallet
+     * @inner
+     */
+    pollForWalletStatus(): Promise<void>;
+    /**
+     * Check if wallet is ready and throw error if not ready
+     *
+     * @memberof HathorWalletServiceWallet
+     * @public
+     */
+    failIfWalletNotReady(): void;
+    /**
+     * Method executed when wallet is ready
+     *
+     * @memberof HathorWalletServiceWallet
+     * @inner
+     */
+    private onWalletReady;
+    setupConnection(): void;
+    /**
+     * Called when the connection to the websocket changes.
+     * It is also called if the network is down.
+     *
+     * Since the wallet service facade holds no data (as opposed to
+     * the old facade, where the wallet facade receives a storage object),
+     * the client needs to handle the data reload, so we just emit an event
+     * to indicate that a reload is necessary.
+     *
+     * @param {Number} newState Enum of new state after change
+     * */
+    onConnectionChangedState(newState: ConnectionState): void;
+    /**
+     * Get all addresses of the wallet
+     *
+     * @memberof HathorWalletServiceWallet
+     * @inner
+     */
+    getAllAddresses(): AsyncGenerator<GetAddressesObject>;
+    /**
+     * Get the new addresses to be used by this wallet, i.e. the last GAP LIMIT unused addresses
+     * Then it updates this.newAddresses and this.indexToUse that handle the addresses to use
+     *
+     * @param ignoreWalletReady Will download new addresses even if the wallet is not set to ready
+     *
+     * @memberof HathorWalletServiceWallet
+     * @inner
+     */
+    private getNewAddresses;
+    /**
+     * Get the balance of the wallet for a specific token
+     *
+     * @memberof HathorWalletServiceWallet
+     * @inner
+     */
+    getBalance(token?: string | null): Promise<GetBalanceObject[]>;
+    getTokens(): Promise<string[]>;
+    /**
+     * Get the history of the wallet for a specific token
+     *
+     * @memberof HathorWalletServiceWallet
+     * @inner
+     */
+    getTxHistory(options?: {
+        token_id?: string;
+        count?: number;
+        skip?: number;
+    }): Promise<GetHistoryObject[]>;
+    /**
+     * Get utxo from tx id and index
+     *
+     * @memberof HathorWalletServiceWallet
+     * @inner
+     */
+    getUtxoFromId(txId: string, index: number): Promise<Utxo | null>;
+    /**
+     * Get utxos for filling a transaction
+     *
+     * @memberof HathorWalletServiceWallet
+     * @inner
+     */
+    getUtxos(options?: {
+        tokenId?: string;
+        authority?: OutputValueType;
+        addresses?: string[];
+        totalAmount?: OutputValueType;
+        count?: number;
+    }): Promise<{
+        utxos: Utxo[];
+        changeAmount: OutputValueType;
+    }>;
+    /**
+     * Signs a message using xpriv derivation path m/44'/280'/0'
+     *
+     * @memberof HathorWalletServiceWallet
+     * @inner
+     */
+    signMessage(hdPrivKey: bitcore.HDPrivateKey, timestamp: number, walletId: string): string;
+    /**
+     * Validate that the wallet auth token is valid
+     * If it's not valid, requests a new one and update
+     *
+     * @param {string} usePassword Accepts the password as a parameter so we don't have to ask
+     * the client for it if we already have it in memory
+     *
+     * @memberof HathorWalletServiceWallet
+     * @inner
+     */
+    validateAndRenewAuthToken(usePassword?: string): Promise<void>;
+    /**
+     * Renew the auth token on the wallet service
+     *
+     * @param {HDPrivateKey} privKey - private key to sign the auth message
+     * @param {number} timestamp - Current timestamp to assemble the signature
+     *
+     * @memberof HathorWalletServiceWallet
+     * @inner
+     */
+    renewAuthToken(privKey: bitcore.HDPrivateKey, timestamp: number): Promise<void>;
+    /**
+     * Creates and send a transaction from an array of inputs and outputs
+     *
+     * @memberof HathorWalletServiceWallet
+     * @inner
+     */
+    sendManyOutputsTransaction(outputs: Array<OutputRequestObj | DataScriptOutputRequestObj>, options?: {
+        inputs?: InputRequestObj[];
+        changeAddress?: string;
+        pinCode?: string;
+    }): Promise<Transaction>;
+    /**
+     * Creates and send a simple transaction with one output
+     *
+     * @memberof HathorWalletServiceWallet
+     * @inner
+     */
+    sendTransaction(address: string, value: OutputValueType, options?: {
+        token?: string;
+        changeAddress?: string;
+        pinCode?: string;
+    }): Promise<Transaction>;
+    /**
+     * Calculate input data from dataToSign and addressPath
+     * Get the private key corresponding to the addressPath,
+     * calculate the signature and add the public key
+     *
+     * @memberof HathorWalletServiceWallet
+     * @inner
+     */
+    getInputData(xprivkey: string, dataToSignHash: Buffer, addressPath: number): Buffer;
+    /**
+     * Return if wallet is ready to be used
+     *
+     * @memberof HathorWalletServiceWallet
+     * @inner
+     */
+    isReady(): boolean;
+    /**
+     * Update wallet state and emit 'state' event
+     *
+     * @param {string} state New wallet state
+     *
+     * @memberof HathorWalletServiceWallet
+     * @inner
+     */
+    setState(state: string): void;
+    /**
+     * Stop the wallet
+     *
+     * @memberof HathorWalletServiceWallet
+     * @inner
+     */
+    stop({ cleanStorage }?: {
+        cleanStorage?: boolean | undefined;
+    }): Promise<void>;
+    /**
+     * Get address at specific index
+     *
+     * @memberof HathorWalletServiceWallet
+     * @inner
+     */
+    getAddressAtIndex(index: number): Promise<string>;
+    /**
+     * Returns an address' privateKey given an index and the encryption password
+     *
+     * @param {string} pinCode - The PIN used to encrypt data in accessData
+     * @param {number} addressIndex - The address' index to fetch
+     *
+     * @memberof HathorWalletServiceWallet
+     * @inner
+     */
+    getAddressPrivKey(pinCode: string, addressIndex: number): Promise<bitcore.HDPrivateKey>;
+    /**
+     * Gets the network model object
+     *
+     * @memberof HathorWalletServiceWallet
+     * @inner
+     */
+    getNetworkObject(): Network;
+    /**
+     * Get the current address to be used
+     *
+     * @memberof HathorWalletServiceWallet
+     * @inner
+     */
+    getCurrentAddress({ markAsUsed }?: {
+        markAsUsed?: boolean | undefined;
+    }): AddressInfoObject;
+    /**
+     * Returns a base64 encoded signed message with an address' private key given an
+     * address index
+     *
+     * @memberof HathorWalletServiceWallet
+     * @inner
+     */
+    signMessageWithAddress(message: string, index: number, pinCode: string): Promise<string>;
+    /**
+     * Get the next address after the current available
+     *
+     * @memberof HathorWalletServiceWallet
+     * @inner
+     */
+    getNextAddress(): AddressInfoObject;
+    getAddressIndex(address: string): void;
+    isAddressMine(address: string): void;
+    getTx(id: string): void;
+    getAddressInfo(address: string, options?: {}): void;
+    consolidateUtxos(destinationAddress: string, options?: {}): void;
+    getFullHistory(): TransactionFullObject[];
+    /**
+     * Checks if the given array of addresses belongs to the caller wallet
+     *
+     * @memberof HathorWalletServiceWallet
+     * @inner
+     */
+    checkAddressesMine(addresses: string[]): Promise<WalletAddressMap>;
+    /**
+     * Create SendTransaction object and run from mining
+     * Returns a promise that resolves when the send succeeds
+     *
+     * @memberof HathorWalletServiceWallet
+     * @inner
+     */
+    handleSendPreparedTransaction(transactionObj: Transaction): Promise<Transaction>;
+    /**
+     * Prepare create new token data, sign the inputs and returns an object ready to be mined
+     *
+     * @memberof HathorWalletServiceWallet
+     * @inner
+     */
+    prepareCreateNewToken(name: string, symbol: string, amount: OutputValueType, options?: {}): Promise<CreateTokenTransaction>;
+    /**
+     * Expects a BIP44 path at the address level and returns the address index
+     *
+     * @param {string} fullPath - The full BIP44 path for the address index
+     *
+     * @memberof HathorWalletServiceWallet
+     * @inner
+     */
+    static getAddressIndexFromFullPath(fullPath: string): number;
+    /**
+     * Helper method to get authority tx_outputs
+     * Uses the getTxOutputs API method to return one or many authorities
+     */
+    _getAuthorityTxOutput(options: {
+        tokenId: string;
+        authority: OutputValueType;
+        skipSpent: boolean;
+        maxOutputs?: number;
+    }): Promise<AuthorityTxOutput[]>;
+    /**
+     * Get mint authorities
+     * Uses the getTxOutputs API method to return one or many mint authorities
+     *
+     * @param tokenId of the token to select the authority utxo
+     * @param options Object with custom options.
+     *  {
+     *    'many': if should return many utxos or just one (default false),
+     *    'skipSpent': if should not include spent utxos (default true)
+     *  }
+     *
+     * @return Promise that resolves with an Array of objects with {txId, index, address, authorities} of the authority output.
+     * Returns an empty array in case there are no tx outputs for this type
+     * */
+    getMintAuthority(tokenId: string, options?: {
+        many?: boolean;
+        skipSpent?: boolean;
+    }): Promise<AuthorityTxOutput[]>;
+    /**
+     * Get melt authorities
+     * Uses the getTxOutputs API method to return one or many melt authorities
+     *
+     * @param tokenId of the token to select the authority utxo
+     * @param options Object with custom options.
+     *  {
+     *    'many': if should return many utxos or just one (default false),
+     *    'skipSpent': if should not include spent utxos (default true)
+     *  }
+     *
+     * @return Promise that resolves with an Array of objects with {txId, index, address, authorities} of the authority output.
+     * Returns an empty array in case there are no tx outputs for this type
+     * */
+    getMeltAuthority(tokenId: string, options?: {
+        many?: boolean;
+        skipSpent?: boolean;
+    }): Promise<AuthorityTxOutput[]>;
+    /**
+     * Create a new custom token in the network
+     *
+     * @memberof HathorWalletServiceWallet
+     * @inner
+     */
+    createNewToken(name: string, symbol: string, amount: OutputValueType, options?: {}): Promise<Transaction>;
+    /**
+     * Prepare mint token data, sign the inputs and returns an object ready to be mined
+     *
+     * @memberof HathorWalletServiceWallet
+     * @inner
+     */
+    prepareMintTokensData(token: string, amount: OutputValueType, options?: {}): Promise<Transaction>;
+    /**
+     * Mint new token units
+     *
+     * @memberof HathorWalletServiceWallet
+     * @inner
+     */
+    mintTokens(token: string, amount: OutputValueType, options?: {}): Promise<Transaction>;
+    /**
+     * Call get token details API
+     *
+     * @param tokenId Token uid to get the token details
+     *
+     * @memberof HathorWalletServiceWallet
+     * @inner
+     */
+    getTokenDetails(tokenId: string): Promise<TokenDetailsObject>;
+    /**
+     * Prepare melt token data, sign the inputs and returns an object ready to be mined
+     *
+     * @memberof HathorWalletServiceWallet
+     * @inner
+     */
+    prepareMeltTokensData(token: string, amount: OutputValueType, options?: {}): Promise<Transaction>;
+    /**
+     * Melt custom token units
+     *
+     * @memberof HathorWalletServiceWallet
+     * @inner
+     */
+    meltTokens(token: string, amount: OutputValueType, options?: {}): Promise<Transaction>;
+    /**
+     * Prepare delegate authority data, sign the inputs and returns an object ready to be mined
+     *
+     * @memberof HathorWalletServiceWallet
+     * @inner
+     */
+    prepareDelegateAuthorityData(token: string, type: string, address: string, { anotherAuthorityAddress, createAnother, pinCode, }: DelegateAuthorityOptions): Promise<Transaction>;
+    /**
+     * Transfer (delegate) authority outputs to another address
+     *
+     * @memberof HathorWalletServiceWallet
+     * @inner
+     */
+    delegateAuthority(token: string, type: string, address: string, options: DelegateAuthorityOptions): Promise<Transaction>;
+    /**
+     * Destroy authority outputs
+     *
+     * @memberof HathorWalletServiceWallet
+     * @inner
+     */
+    prepareDestroyAuthorityData(token: string, type: string, count: number, { pinCode }: DestroyAuthorityOptions): Promise<Transaction>;
+    /**
+     * Destroy authority outputs
+     *
+     * @memberof HathorWalletServiceWallet
+     * @inner
+     */
+    destroyAuthority(token: string, type: string, count: number, options: DestroyAuthorityOptions): Promise<Transaction>;
+    /**
+     * Create an NFT in the network
+     *
+     * @memberof HathorWalletServiceWallet
+     * @inner
+     */
+    createNFT(name: string, symbol: string, amount: OutputValueType, data: string, options?: {}): Promise<Transaction>;
+    getTxById(txId: string): Promise<TxByIdTokensResponseData>;
+    getFullTxById(txId: string): Promise<FullNodeTxResponse>;
+    getTxConfirmationData(txId: string): Promise<FullNodeTxConfirmationDataResponse>;
+    graphvizNeighborsQuery(txId: string, graphType: string, maxLevel: number): Promise<string>;
+    /**
+     * Check if websocket connection is enabled
+     *
+     * @memberof HathorWalletServiceWallet
+     * @inner
+     *
+     * @returns {boolean} If wallet has websocket connection enabled
+     */
+    isWsEnabled(): boolean;
+    /**
+     * Check if the pin used to encrypt the main key is valid.
+     * @param {string} pin
+     * @returns {Promise<boolean>}
+     */
+    checkPin(pin: string): Promise<boolean>;
+    /**
+     * Check if the password used to encrypt the seed is valid.
+     * @param {string} password
+     * @returns {Promise<boolean>}
+     */
+    checkPassword(password: string): Promise<boolean>;
+    /**
+     * @param {string} pin
+     * @param {string} password
+     * @returns {Promise<boolean>}
+     */
+    checkPinAndPassword(pin: string, password: string): Promise<boolean>;
+    /**
+     * Check if the wallet is a hardware wallet.
+     * @returns {Promise<boolean>}
+     */
+    isHardwareWallet(): Promise<boolean>;
+}
+export default HathorWalletServiceWallet;
+//# sourceMappingURL=wallet.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/wallet/wallet.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/wallet/wallet.d.ts.map
new file mode 100644
index 0000000..c854ff7
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/wallet/wallet.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"wallet.d.ts","sourceRoot":"","sources":["../../src/wallet/wallet.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;;;AAEH,OAAO,EAAE,YAAY,EAAE,MAAM,QAAQ,CAAC;AACtC,OAAO,OAAiB,MAAM,aAAa,CAAC;AAkB5C,OAAO,WAAW,MAAM,uBAAuB,CAAC;AAChD,OAAO,sBAAsB,MAAM,oCAAoC,CAAC;AAIxE,OAAO,OAAO,MAAM,mBAAmB,CAAC;AAKxC,OAAO,EACL,iBAAiB,EACjB,gBAAgB,EAChB,kBAAkB,EAClB,gBAAgB,EAEhB,IAAI,EAGJ,gBAAgB,EAChB,0BAA0B,EAC1B,eAAe,EACf,qBAAqB,EACrB,aAAa,EACb,aAAa,EACb,oBAAoB,EACpB,eAAe,EACf,kBAAkB,EAClB,iBAAiB,EACjB,uBAAuB,EACvB,mBAAmB,EACnB,gBAAgB,EAChB,wBAAwB,EACxB,wBAAwB,EACxB,uBAAuB,EACvB,kBAAkB,EAClB,kCAAkC,EACnC,MAAM,SAAS,CAAC;AASjB,OAAO,EAAE,QAAQ,EAAqB,eAAe,EAAE,UAAU,EAAE,MAAM,UAAU,CAAC;AAYpF,cAAM,yBAA0B,SAAQ,YAAa,YAAW,aAAa;IAE3E,UAAU,EAAE,MAAM,CAAC;IAGnB,QAAQ,EAAE,MAAM,GAAG,IAAI,CAAC;IAGxB,OAAO,EAAE,OAAO,CAAC;IAGjB,OAAO,CAAC,eAAe,CAAwB;IAG/C,OAAO,CAAC,IAAI,CAAgB;IAG5B,OAAO,CAAC,IAAI,CAAgB;IAG5B,OAAO,CAAC,KAAK,CAAgB;IAG7B,OAAO,CAAC,WAAW,CAA8B;IAGjD,OAAO,CAAC,KAAK,CAAS;IAGtB,OAAO,CAAC,WAAW,CAAU;IAG7B,OAAO,CAAC,YAAY,CAAgB;IAGpC,OAAO,CAAC,SAAS,CAAgB;IAIjC,OAAO,CAAC,YAAY,CAAsB;IAG1C,OAAO,CAAC,UAAU,CAAS;IAG3B,OAAO,CAAC,IAAI,CAA0B;IAGtC,OAAO,CAAC,eAAe,CAAU;IAGjC,OAAO,CAAC,QAAQ,CAAC,YAAY,CAAU;IAEhC,OAAO,EAAE,QAAQ,CAAC;gBAEb,EACV,eAAe,EACf,IAAW,EACX,KAAY,EACZ,SAAgB,EAChB,IAAW,EACX,OAAO,EACP,UAAe,EACf,QAAe,EACf,OAAc,GACf,EAAE;QACD,eAAe,EAAE,MAAM,OAAO,CAAC,MAAM,CAAC,CAAC;QACvC,IAAI,CAAC,EAAE,MAAM,GAAG,IAAI,CAAC;QACrB,KAAK,CAAC,EAAE,MAAM,GAAG,IAAI,CAAC;QACtB,SAAS,CAAC,EAAE,MAAM,GAAG,IAAI,CAAC;QAC1B,IAAI,CAAC,EAAE,MAAM,GAAG,IAAI,CAAC;QACrB,OAAO,EAAE,OAAO,CAAC;QACjB,UAAU,CAAC,EAAE,MAAM,CAAC;QACpB,QAAQ,CAAC,EAAE,OAAO,CAAC;QACnB,OAAO,CAAC,EAAE,QAAQ,GAAG,IAAI,CAAC;KAC3B;IAiED;;;;;;;OAOG;IACG,YAAY,CAAC,SAAS,EAAE,MAAM;IAKpC;;;;;;;OAOG;IACG,cAAc,CAAC,SAAS,EAAE,MAAM;IAKtC;;;;;OAKG;IACG,wBAAwB,IAAI,OAAO,CAAC,uBAAuB,CAAC;IAclE;;;;;;SAMK;IACL,kBAAkB;IAKlB;;;;;;;;;OASG;IACH,MAAM,CAAC,sBAAsB,CAC3B,IAAI,EAAE,MAAM,EACZ,OAAO,GAAE;QAAE,UAAU,CAAC,EAAE,MAAM,CAAC;QAAC,WAAW,CAAC,EAAE,MAAM,CAAA;KAAO,GAC1D,MAAM;IAaT;;;;;;;;OAQG;IACH,MAAM,CAAC,oBAAoB,CAAC,KAAK,EAAE,OAAO,CAAC,YAAY,GAAG,OAAO,CAAC,YAAY;IAI9E;;;;;;;;OAQG;IACH,MAAM,CAAC,mBAAmB,CAAC,IAAI,EAAE,MAAM;IAIvC;;;;;;;;;;;OAWG;IACG,KAAK,CAAC,EAAE,OAAO,EAAE,QAAQ,EAAE,GAAE;QAAE,OAAO,CAAC,EAAE,MAAM,CAAC;QAAC,QAAQ,CAAC,EAAE,MAAM,CAAA;KAAO;IA6F/E;;SAEK;IACC,cAAc,IAAI,OAAO,CAAC,mBAAmB,CAAC;IAIpD;;;;;;;;OAQG;IACG,4BAA4B,CAAC,OAAO,EAAE,MAAM,GAAG,OAAO,CAAC,oBAAoB,CAAC;IAiElF;;;;;OAKG;IACH,UAAU,CAAC,SAAS,KAAA;IAIpB;;;;;OAKG;IACG,OAAO,CAAC,KAAK,EAAE,aAAa;IA2BlC;;;;;OAKG;IACH,YAAY,IAAI,MAAM,GAAG,IAAI;IAI7B;;;;;;;;SAQK;IACC,YAAY,CAChB,EAAE,EAAE,UAAU,EACd,YAAY,KAAK,GAChB,OAAO,CAAC;QAAE,CAAC,OAAO,EAAE,MAAM,GAAG,eAAe,CAAA;KAAE,CAAC;IAqDlD;;;;;;OAMG;IACG,mBAAmB,IAAI,OAAO,CAAC,IAAI,CAAC;IAkB1C;;;;;OAKG;IACI,oBAAoB;IAM3B;;;;;OAKG;YACW,aAAa;IAU3B,eAAe;IAaf;;;;;;;;;;SAUK;IACL,wBAAwB,CAAC,QAAQ,EAAE,eAAe;IAYlD;;;;;OAKG;IACI,eAAe,IAAI,cAAc,CAAC,kBAAkB,CAAC;IAQ5D;;;;;;;;OAQG;YACW,eAAe;IAY7B;;;;;OAKG;IACG,UAAU,CAAC,KAAK,GAAE,MAAM,GAAG,IAAW,GAAG,OAAO,CAAC,gBAAgB,EAAE,CAAC;IAMpE,SAAS,IAAI,OAAO,CAAC,MAAM,EAAE,CAAC;IAMpC;;;;;OAKG;IACG,YAAY,CAChB,OAAO,GAAE;QAAE,QAAQ,CAAC,EAAE,MAAM,CAAC;QAAC,KAAK,CAAC,EAAE,MAAM,CAAC;QAAC,IAAI,CAAC,EAAE,MAAM,CAAA;KAAO,GACjE,OAAO,CAAC,gBAAgB,EAAE,CAAC;IAM9B;;;;;OAKG;IACG,aAAa,CAAC,IAAI,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM,GAAG,OAAO,CAAC,IAAI,GAAG,IAAI,CAAC;IAoBtE;;;;;OAKG;IACG,QAAQ,CACZ,OAAO,GAAE;QACP,OAAO,CAAC,EAAE,MAAM,CAAC;QACjB,SAAS,CAAC,EAAE,eAAe,CAAC;QAC5B,SAAS,CAAC,EAAE,MAAM,EAAE,CAAC;QACrB,WAAW,CAAC,EAAE,eAAe,CAAC;QAC9B,KAAK,CAAC,EAAE,MAAM,CAAC;KACX,GACL,OAAO,CAAC;QAAE,KAAK,EAAE,IAAI,EAAE,CAAC;QAAC,YAAY,EAAE,eAAe,CAAA;KAAE,CAAC;IA4C5D;;;;;OAKG;IACH,WAAW,CAAC,SAAS,EAAE,OAAO,CAAC,YAAY,EAAE,SAAS,EAAE,MAAM,EAAE,QAAQ,EAAE,MAAM,GAAG,MAAM;IAOzF;;;;;;;;;OASG;IACG,yBAAyB,CAAC,WAAW,CAAC,EAAE,MAAM,GAAG,OAAO,CAAC,IAAI,CAAC;IA8CpE;;;;;;;;OAQG;IACG,cAAc,CAAC,OAAO,EAAE,OAAO,CAAC,YAAY,EAAE,SAAS,EAAE,MAAM;IAWrE;;;;;OAKG;IACG,0BAA0B,CAC9B,OAAO,EAAE,KAAK,CAAC,gBAAgB,GAAG,0BAA0B,CAAC,EAC7D,OAAO,GAAE;QAAE,MAAM,CAAC,EAAE,eAAe,EAAE,CAAC;QAAC,aAAa,CAAC,EAAE,MAAM,CAAC;QAAC,OAAO,CAAC,EAAE,MAAM,CAAA;KAAO,GACrF,OAAO,CAAC,WAAW,CAAC;IA4BvB;;;;;OAKG;IACG,eAAe,CACnB,OAAO,EAAE,MAAM,EACf,KAAK,EAAE,eAAe,EACtB,OAAO,GAAE;QAAE,KAAK,CAAC,EAAE,MAAM,CAAC;QAAC,aAAa,CAAC,EAAE,MAAM,CAAC;QAAC,OAAO,CAAC,EAAE,MAAM,CAAA;KAAO,GACzE,OAAO,CAAC,WAAW,CAAC;IAYvB;;;;;;;OAOG;IAEH,YAAY,CAAC,QAAQ,EAAE,MAAM,EAAE,cAAc,EAAE,MAAM,EAAE,WAAW,EAAE,MAAM,GAAG,MAAM;IAWnF;;;;;OAKG;IACH,OAAO,IAAI,OAAO;IAIlB;;;;;;;OAOG;IACH,QAAQ,CAAC,KAAK,EAAE,MAAM;IAKtB;;;;;OAKG;IACG,IAAI,CAAC,EAAE,YAAmB,EAAE;;KAAK;IAUvC;;;;;OAKG;IACG,iBAAiB,CAAC,KAAK,EAAE,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;IAUvD;;;;;;;;OAQG;IACG,iBAAiB,CAAC,OAAO,EAAE,MAAM,EAAE,YAAY,EAAE,MAAM,GAAG,OAAO,CAAC,OAAO,CAAC,YAAY,CAAC;IAO7F;;;;;OAKG;IACH,gBAAgB;IAIhB;;;;;OAKG;IACH,iBAAiB,CAAC,EAAE,UAAkB,EAAE;;KAAK,GAAG,iBAAiB;IAcjE;;;;;;OAMG;IACG,sBAAsB,CAAC,OAAO,EAAE,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,OAAO,EAAE,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;IAO9F;;;;;OAKG;IACH,cAAc,IAAI,iBAAiB;IAOnC,eAAe,CAAC,OAAO,EAAE,MAAM;IAI/B,aAAa,CAAC,OAAO,EAAE,MAAM;IAI7B,KAAK,CAAC,EAAE,EAAE,MAAM;IAIhB,cAAc,CAAC,OAAO,EAAE,MAAM,EAAE,OAAO,KAAK;IAI5C,gBAAgB,CAAC,kBAAkB,EAAE,MAAM,EAAE,OAAO,KAAK;IAIzD,cAAc,IAAI,qBAAqB,EAAE;IAKzC;;;;;OAKG;IACG,kBAAkB,CAAC,SAAS,EAAE,MAAM,EAAE,GAAG,OAAO,CAAC,gBAAgB,CAAC;IAMxE;;;;;;OAMG;IACG,6BAA6B,CAAC,cAAc,EAAE,WAAW,GAAG,OAAO,CAAC,WAAW,CAAC;IAKtF;;;;;OAKG;IACG,qBAAqB,CACzB,IAAI,EAAE,MAAM,EACZ,MAAM,EAAE,MAAM,EACd,MAAM,EAAE,eAAe,EACvB,OAAO,KAAK,GACX,OAAO,CAAC,sBAAsB,CAAC;IAiKlC;;;;;;;OAOG;IACH,MAAM,CAAC,2BAA2B,CAAC,QAAQ,EAAE,MAAM,GAAG,MAAM;IAQ5D;;;OAGG;IACG,qBAAqB,CAAC,OAAO,EAAE;QACnC,OAAO,EAAE,MAAM,CAAC;QAChB,SAAS,EAAE,eAAe,CAAC;QAC3B,SAAS,EAAE,OAAO,CAAC;QACnB,UAAU,CAAC,EAAE,MAAM,CAAC;KACrB,GAAG,OAAO,CAAC,iBAAiB,EAAE,CAAC;IAWhC;;;;;;;;;;;;;SAaK;IACC,gBAAgB,CACpB,OAAO,EAAE,MAAM,EACf,OAAO,GAAE;QAAE,IAAI,CAAC,EAAE,OAAO,CAAC;QAAC,SAAS,CAAC,EAAE,OAAO,CAAA;KAAO,GACpD,OAAO,CAAC,iBAAiB,EAAE,CAAC;IAW/B;;;;;;;;;;;;;SAaK;IACC,gBAAgB,CACpB,OAAO,EAAE,MAAM,EACf,OAAO,GAAE;QAAE,IAAI,CAAC,EAAE,OAAO,CAAC;QAAC,SAAS,CAAC,EAAE,OAAO,CAAA;KAAO,GACpD,OAAO,CAAC,iBAAiB,EAAE,CAAC;IAW/B;;;;;OAKG;IACG,cAAc,CAClB,IAAI,EAAE,MAAM,EACZ,MAAM,EAAE,MAAM,EACd,MAAM,EAAE,eAAe,EACvB,OAAO,KAAK,GACX,OAAO,CAAC,WAAW,CAAC;IAMvB;;;;;OAKG;IACG,qBAAqB,CACzB,KAAK,EAAE,MAAM,EACb,MAAM,EAAE,eAAe,EACvB,OAAO,KAAK,GACX,OAAO,CAAC,WAAW,CAAC;IAmIvB;;;;;OAKG;IACG,UAAU,CAAC,KAAK,EAAE,MAAM,EAAE,MAAM,EAAE,eAAe,EAAE,OAAO,KAAK,GAAG,OAAO,CAAC,WAAW,CAAC;IAM5F;;;;;;;OAOG;IACG,eAAe,CAAC,OAAO,EAAE,MAAM,GAAG,OAAO,CAAC,kBAAkB,CAAC;IAOnE;;;;;OAKG;IACG,qBAAqB,CACzB,KAAK,EAAE,MAAM,EACb,MAAM,EAAE,eAAe,EACvB,OAAO,KAAK,GACX,OAAO,CAAC,WAAW,CAAC;IAoIvB;;;;;OAKG;IACG,UAAU,CAAC,KAAK,EAAE,MAAM,EAAE,MAAM,EAAE,eAAe,EAAE,OAAO,KAAK,GAAG,OAAO,CAAC,WAAW,CAAC;IAM5F;;;;;OAKG;IACG,4BAA4B,CAChC,KAAK,EAAE,MAAM,EACb,IAAI,EAAE,MAAM,EACZ,OAAO,EAAE,MAAM,EACf,EACE,uBAA8B,EAC9B,aAAoB,EACpB,OAAc,GACf,EAAE,wBAAwB,GAC1B,OAAO,CAAC,WAAW,CAAC;IA+EvB;;;;;OAKG;IACG,iBAAiB,CACrB,KAAK,EAAE,MAAM,EACb,IAAI,EAAE,MAAM,EACZ,OAAO,EAAE,MAAM,EACf,OAAO,EAAE,wBAAwB,GAChC,OAAO,CAAC,WAAW,CAAC;IAMvB;;;;;OAKG;IACG,2BAA2B,CAC/B,KAAK,EAAE,MAAM,EACb,IAAI,EAAE,MAAM,EACZ,KAAK,EAAE,MAAM,EACb,EAAE,OAAc,EAAE,EAAE,uBAAuB,GAC1C,OAAO,CAAC,WAAW,CAAC;IAqDvB;;;;;OAKG;IACG,gBAAgB,CACpB,KAAK,EAAE,MAAM,EACb,IAAI,EAAE,MAAM,EACZ,KAAK,EAAE,MAAM,EACb,OAAO,EAAE,uBAAuB,GAC/B,OAAO,CAAC,WAAW,CAAC;IAMvB;;;;;OAKG;IACG,SAAS,CACb,IAAI,EAAE,MAAM,EACZ,MAAM,EAAE,MAAM,EACd,MAAM,EAAE,eAAe,EACvB,IAAI,EAAE,MAAM,EACZ,OAAO,KAAK,GACX,OAAO,CAAC,WAAW,CAAC;IA6BjB,SAAS,CAAC,IAAI,EAAE,MAAM,GAAG,OAAO,CAAC,wBAAwB,CAAC;IAM1D,aAAa,CAAC,IAAI,EAAE,MAAM,GAAG,OAAO,CAAC,kBAAkB,CAAC;IAOxD,qBAAqB,CAAC,IAAI,EAAE,MAAM,GAAG,OAAO,CAAC,kCAAkC,CAAC;IAOhF,sBAAsB,CAAC,IAAI,EAAE,MAAM,EAAE,SAAS,EAAE,MAAM,EAAE,QAAQ,EAAE,MAAM,GAAG,OAAO,CAAC,MAAM,CAAC;IAOhG;;;;;;;OAOG;IACH,WAAW,IAAI,OAAO;IAItB;;;;OAIG;IACG,QAAQ,CAAC,GAAG,EAAE,MAAM,GAAG,OAAO,CAAC,OAAO,CAAC;IAI7C;;;;OAIG;IACG,aAAa,CAAC,QAAQ,EAAE,MAAM,GAAG,OAAO,CAAC,OAAO,CAAC;IAIvD;;;;OAIG;IACG,mBAAmB,CAAC,GAAG,EAAE,MAAM,EAAE,QAAQ,EAAE,MAAM,GAAG,OAAO,CAAC,OAAO,CAAC;IAI1E;;;OAGG;IAEG,gBAAgB,IAAI,OAAO,CAAC,OAAO,CAAC;CAK3C;AAED,eAAe,yBAAyB,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/wallet/wallet.js b/node_modules/@hathor/wallet-lib/oldLib/wallet/wallet.js
new file mode 100644
index 0000000..c6e32ac
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/wallet/wallet.js
@@ -0,0 +1,1902 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+var _events = require("events");
+var _bitcoreLib = _interopRequireWildcard(require("bitcore-lib"));
+var _assert = _interopRequireDefault(require("assert"));
+var _constants = require("../constants");
+var _crypto = require("../utils/crypto");
+var _walletApi = _interopRequireDefault(require("./api/walletApi"));
+var _address = require("../utils/address");
+var _wallet = _interopRequireDefault(require("../utils/wallet"));
+var _helpers = _interopRequireDefault(require("../utils/helpers"));
+var _transaction = _interopRequireDefault(require("../utils/transaction"));
+var _tokens = _interopRequireDefault(require("../utils/tokens"));
+var _config = _interopRequireDefault(require("../config"));
+var _p2pkh = _interopRequireDefault(require("../models/p2pkh"));
+var _transaction2 = _interopRequireDefault(require("../models/transaction"));
+var _create_token_transaction = _interopRequireDefault(require("../models/create_token_transaction"));
+var _output = _interopRequireDefault(require("../models/output"));
+var _input = _interopRequireDefault(require("../models/input"));
+var _address2 = _interopRequireDefault(require("../models/address"));
+var _network = _interopRequireDefault(require("../network"));
+var _storage = require("../storage");
+var _connection = _interopRequireDefault(require("./connection"));
+var _sendTransactionWalletService = _interopRequireDefault(require("./sendTransactionWalletService"));
+var _types = require("./types");
+var _errors = require("../errors");
+var _errorMessages = require("../errorMessages");
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
+function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
+function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
+function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
+function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
+function _awaitAsyncGenerator(e) { return new _OverloadYield(e, 0); }
+function _wrapAsyncGenerator(e) { return function () { return new AsyncGenerator(e.apply(this, arguments)); }; }
+function AsyncGenerator(e) { var r, t; function resume(r, t) { try { var n = e[r](t), o = n.value, u = o instanceof _OverloadYield; Promise.resolve(u ? o.v : o).then(function (t) { if (u) { var i = "return" === r ? "return" : "next"; if (!o.k || t.done) return resume(i, t); t = e[i](t).value; } settle(n.done ? "return" : "normal", t); }, function (e) { resume("throw", e); }); } catch (e) { settle("throw", e); } } function settle(e, n) { switch (e) { case "return": r.resolve({ value: n, done: !0 }); break; case "throw": r.reject(n); break; default: r.resolve({ value: n, done: !1 }); } (r = r.next) ? resume(r.key, r.arg) : t = null; } this._invoke = function (e, n) { return new Promise(function (o, u) { var i = { key: e, arg: n, resolve: o, reject: u, next: null }; t ? t = t.next = i : (r = t = i, resume(e, n)); }); }, "function" != typeof e.return && (this.return = void 0); }
+AsyncGenerator.prototype["function" == typeof Symbol && Symbol.asyncIterator || "@@asyncIterator"] = function () { return this; }, AsyncGenerator.prototype.next = function (e) { return this._invoke("next", e); }, AsyncGenerator.prototype.throw = function (e) { return this._invoke("throw", e); }, AsyncGenerator.prototype.return = function (e) { return this._invoke("return", e); };
+function _OverloadYield(e, d) { this.v = e, this.k = d; } /**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+// Time in milliseconds berween each polling to check wallet status
+// if it ended loading and became ready
+const WALLET_STATUS_POLLING_INTERVAL = 3000;
+var walletState = /*#__PURE__*/function (walletState) {
+  walletState["NOT_STARTED"] = "Not started";
+  walletState["LOADING"] = "Loading";
+  walletState["READY"] = "Ready";
+  return walletState;
+}(walletState || {});
+class HathorWalletServiceWallet extends _events.EventEmitter {
+  constructor({
+    requestPassword,
+    seed = null,
+    xpriv = null,
+    authxpriv = null,
+    xpub = null,
+    network,
+    passphrase = '',
+    enableWs = true,
+    storage = null
+  }) {
+    super();
+    // String with wallet passphrase
+    _defineProperty(this, "passphrase", void 0);
+    // Wallet id from the wallet service
+    _defineProperty(this, "walletId", void 0);
+    // Network in which the wallet is connected ('mainnet' or 'testnet')
+    _defineProperty(this, "network", void 0);
+    // Method to request the password from the client
+    _defineProperty(this, "requestPassword", void 0);
+    // String with 24 words separated by space
+    _defineProperty(this, "seed", void 0);
+    // Xpub of the wallet
+    _defineProperty(this, "xpub", void 0);
+    // Xpriv of the wallet on the account derivation path
+    _defineProperty(this, "xpriv", void 0);
+    // Xpriv of the auth derivation path
+    _defineProperty(this, "authPrivKey", void 0);
+    // State of the wallet. One of the walletState enum options
+    _defineProperty(this, "state", void 0);
+    // Variable to prevent start sending more than one tx concurrently
+    _defineProperty(this, "isSendingTx", void 0);
+    // ID of tx proposal
+    _defineProperty(this, "txProposalId", void 0);
+    // Auth token to be used in the wallet API requests to wallet service
+    _defineProperty(this, "authToken", void 0);
+    // Wallet status interval
+    // Variable to store the possible addresses to use that are after the last used address
+    _defineProperty(this, "newAddresses", void 0);
+    // Index of the address to be used by the wallet
+    _defineProperty(this, "indexToUse", void 0);
+    // WalletService-ready connection class
+    _defineProperty(this, "conn", void 0);
+    // Flag to indicate if the wallet was already connected when the websocket conn is established
+    _defineProperty(this, "firstConnection", void 0);
+    // Flag to indicate if the websocket connection is enabled
+    _defineProperty(this, "_isWsEnabled", void 0);
+    _defineProperty(this, "storage", void 0);
+    if (!seed && !xpriv && !xpub) {
+      throw Error('You must explicitly provide the seed, xpriv or the xpub.');
+    }
+    if (seed && xpriv) {
+      throw Error('You cannot provide both a seed and an xpriv.');
+    }
+    if (xpriv && passphrase !== '') {
+      throw Error("You can't use xpriv with passphrase.");
+    }
+    if (xpriv && !authxpriv) {
+      throw new Error('You must provide both the account path xpriv and auth path xpriv.');
+    }
+    if (seed) {
+      // It will throw InvalidWords error in case is not valid
+      _wallet.default.wordsValid(seed);
+    }
+    if (!storage) {
+      const store = new _storage.MemoryStore();
+      this.storage = new _storage.Storage(store);
+    } else {
+      this.storage = storage;
+    }
+
+    // Setup the connection so clients can listen to its events before it is started
+    this.conn = new _connection.default();
+    this._isWsEnabled = enableWs;
+    this.state = walletState.NOT_STARTED;
+    this.xpriv = xpriv;
+    this.seed = seed;
+    this.xpub = xpub;
+    if (authxpriv && !_bitcoreLib.default.HDPrivateKey.isValidSerialized(authxpriv)) {
+      throw new Error('authxpriv parameter is an invalid hd privatekey');
+    }
+    this.authPrivKey = authxpriv ? _bitcoreLib.default.HDPrivateKey(authxpriv) : null;
+    this.passphrase = passphrase;
+    this.requestPassword = requestPassword;
+
+    // ID of wallet after created on wallet service
+    this.walletId = null;
+    this.isSendingTx = false;
+    this.txProposalId = null;
+    this.xpub = null;
+    this.network = network;
+    _network.default.setNetwork(this.network.name);
+    this.authToken = null;
+    this.firstConnection = true;
+    this.newAddresses = [];
+    this.indexToUse = -1;
+    // TODO should we have a debug mode?
+  }
+
+  /**
+   * Sets the server to connect on config singleton and storage
+   *
+   * @param {String} newServer - The new server to set the config and storage to
+   *
+   * @memberof HathorWalletServiceWallet
+   * @inner
+   */
+  async changeServer(newServer) {
+    await this.storage.store.setItem('wallet:wallet_service:base_server', newServer);
+    _config.default.setWalletServiceBaseUrl(newServer);
+  }
+
+  /**
+   * Sets the websocket server to connect on config singleton and storage
+   *
+   * @param {String} newServer - The new websocket server to set the config and storage to
+   *
+   * @memberof HathorWalletServiceWallet
+   * @inner
+   */
+  async changeWsServer(newServer) {
+    await this.storage.store.setItem('wallet:wallet_service:ws_server', newServer);
+    _config.default.setWalletServiceBaseWsUrl(newServer);
+  }
+
+  /**
+   * Gets the stored websocket and base server urls
+   *
+   * @memberof HathorWalletServiceWallet
+   * @inner
+   */
+  async getServerUrlsFromStorage() {
+    const walletServiceBaseUrl = await this.storage.store.getItem('wallet:wallet_service:base_server');
+    const walletServiceWsUrl = await this.storage.store.getItem('wallet:wallet_service:ws_server');
+    return {
+      walletServiceBaseUrl,
+      walletServiceWsUrl
+    };
+  }
+
+  /**
+   * Remove sensitive data from memory
+   *
+   * NOTICE: This won't remove data from memory immediately, we have to wait until javascript
+   * garbage collect it. JavaScript currently does not provide a standard way to trigger
+   * garbage collection
+   * */
+  clearSensitiveData() {
+    this.seed = null;
+    this.authPrivKey = null;
+  }
+
+  /**
+   * Get auth xpubkey from seed
+   *
+   * @param {String} seed 24 words
+   * @param {Object} options Options with passphrase and networkName
+   *
+   * @return {String} auth xpubkey
+   * @memberof HathorWalletServiceWallet
+   * @inner
+   */
+  static getAuthXPubKeyFromSeed(seed, options = {}) {
+    const methodOptions = {
+      passphrase: '',
+      networkName: 'mainnet',
+      ...options
+    };
+    const xpriv = _wallet.default.getXPrivKeyFromSeed(seed, methodOptions);
+    const privkey = HathorWalletServiceWallet.deriveAuthPrivateKey(xpriv);
+    return privkey.xpubkey;
+  }
+
+  /**
+   * Derive private key from root to the auth specific purpose derivation path
+   *
+   * @param {HDPrivateKey} xpriv The wallet's root xpriv
+   *
+   * @return {HDPrivateKey} Derived private key at the auth derivation path
+   * @memberof HathorWalletServiceWallet
+   * @inner
+   */
+  static deriveAuthPrivateKey(xpriv) {
+    return xpriv.deriveNonCompliantChild(_constants.WALLET_SERVICE_AUTH_DERIVATION_PATH);
+  }
+
+  /**
+   * getWalletIdFromXPub: Get the wallet id given the xpubkey
+   *
+   * @param xpub - The xpubkey
+   * @returns The wallet id
+   *
+   * @memberof HathorWalletServiceWallet
+   * @inner
+   */
+  static getWalletIdFromXPub(xpub) {
+    return _wallet.default.getWalletIdFromXPub(xpub);
+  }
+
+  /**
+   * Start wallet: load the wallet data, update state and start polling wallet status until it's ready
+   *
+   * @param {Object} optionsParams Options parameters
+   *  {
+   *   'pinCode': PIN to encrypt the auth xpriv on storage
+   *   'password': Password to decrypt xpriv information
+   *  }
+   *
+   * @memberof HathorWalletServiceWallet
+   * @inner
+   */
+  async start({
+    pinCode,
+    password
+  } = {}) {
+    if (!pinCode) {
+      throw new Error('Pin code is required when starting the wallet.');
+    }
+    this.setState(walletState.LOADING);
+    let hasAccessData;
+    try {
+      const accessData = await this.storage.getAccessData();
+      hasAccessData = !!accessData;
+    } catch (err) {
+      if (err instanceof _errors.UninitializedWalletError) {
+        hasAccessData = false;
+      } else {
+        throw err;
+      }
+    }
+    if (!hasAccessData) {
+      let accessData;
+      if (this.seed) {
+        if (!password) {
+          throw new Error('Password is required when starting the wallet from the seed.');
+        }
+        accessData = _wallet.default.generateAccessDataFromSeed(this.seed, {
+          passphrase: this.passphrase,
+          pin: pinCode,
+          password,
+          networkName: this.network.name
+          // multisig: not implemented on wallet service yet
+        });
+      } else if (this.xpriv) {
+        // generateAccessDataFromXpriv expects a xpriv on the change level path
+        const accountLevelPrivKey = new _bitcoreLib.default.HDPrivateKey(this.xpriv);
+        const changeLevelPrivKey = accountLevelPrivKey.deriveNonCompliantChild(0);
+        accessData = _wallet.default.generateAccessDataFromXpriv(changeLevelPrivKey.xprivkey, {
+          pin: pinCode,
+          authXpriv: this.authPrivKey.xprivkey
+          // multisig: not implemented on wallet service yet
+        });
+      } else {
+        throw new Error('WalletService facade initialized without seed or xprivkey');
+      }
+      await this.storage.saveAccessData(accessData);
+    }
+    const {
+      xpub,
+      authXpub,
+      xpubkeySignature,
+      authXpubkeySignature,
+      timestampNow,
+      firstAddress,
+      authDerivedPrivKey
+    } = await this.generateCreateWalletAuthData(pinCode);
+    this.xpub = xpub;
+    this.authPrivKey = authDerivedPrivKey;
+    const handleCreate = async data => {
+      this.walletId = data.walletId;
+      if (data.status === 'creating') {
+        // If the wallet status is creating, we should wait until it is ready
+        // before continuing
+        await this.pollForWalletStatus();
+      } else if (data.status !== 'ready') {
+        // At this stage, if the wallet is not `ready` or `creating` we should
+        // throw an error as there are only three states: `ready`, `creating` or `error`
+        throw new _errors.WalletRequestError(_errorMessages.ErrorMessages.WALLET_STATUS_ERROR, {
+          cause: data.status
+        });
+      }
+      await this.onWalletReady();
+    };
+    const data = await _walletApi.default.createWallet(this, xpub, xpubkeySignature, authXpub, authXpubkeySignature, timestampNow, firstAddress);
+    await handleCreate(data.status);
+    this.clearSensitiveData();
+  }
+
+  /**
+   * Returns version data from the connected fullnode
+   * */
+  async getVersionData() {
+    return _walletApi.default.getVersionData(this);
+  }
+
+  /**
+   * Detects if we are loading from the seed or the account path and returns the
+   * required information for authentication
+   *
+   * @param pinCode The pincode to be used to encrypt the auth xprivkey
+   *
+   * @memberof HathorWalletServiceWallet
+   * @inner
+   */
+  async generateCreateWalletAuthData(pinCode) {
+    let xpub;
+    let authXpub;
+    let privKeyAccountPath;
+    let authDerivedPrivKey;
+    const now = Date.now();
+    const timestampNow = Math.floor(now / 1000); // in seconds
+
+    if (this.seed) {
+      // getXPrivKeyFromSeed returns a HDPrivateKey on the root path
+      const privKey = _wallet.default.getXPrivKeyFromSeed(this.seed, {
+        passphrase: this.passphrase,
+        networkName: this.network.name
+      });
+      // getXPubKeyFromSeed returns a xpubkey on the account level path
+      xpub = _wallet.default.getXPubKeyFromSeed(this.seed, {
+        passphrase: this.passphrase,
+        networkName: this.network.name
+      });
+      authXpub = HathorWalletServiceWallet.getAuthXPubKeyFromSeed(this.seed, {
+        passphrase: this.passphrase,
+        networkName: this.network.name
+      });
+      privKeyAccountPath = _wallet.default.deriveXpriv(privKey, "0'");
+      authDerivedPrivKey = HathorWalletServiceWallet.deriveAuthPrivateKey(privKey);
+    } else if (this.xpriv) {
+      // this.xpriv is already on the account derivation path
+      privKeyAccountPath = _bitcoreLib.default.HDPrivateKey(this.xpriv);
+      xpub = privKeyAccountPath.xpubkey;
+
+      // If the wallet is being loaded from the xpriv, we assume we already have the authXPriv on storage, so just fetch it
+      authDerivedPrivKey = _bitcoreLib.default.HDPrivateKey.fromString(await this.storage.getAuthPrivKey(pinCode));
+      authXpub = authDerivedPrivKey.xpubkey;
+    } else {
+      throw new Error('generateCreateWalletAuthData called without seed or xpriv in memory.');
+    }
+    const walletId = HathorWalletServiceWallet.getWalletIdFromXPub(xpub);
+
+    // prove we own the xpubkey
+    const xpubkeySignature = this.signMessage(privKeyAccountPath, timestampNow, walletId);
+
+    // prove we own the auth_xpubkey
+    const authXpubkeySignature = this.signMessage(authDerivedPrivKey, timestampNow, walletId);
+    const xpubChangeDerivation = _wallet.default.xpubDeriveChild(xpub, 0);
+    const {
+      base58: firstAddress
+    } = (0, _address.deriveAddressFromXPubP2PKH)(xpubChangeDerivation, 0, this.network.name);
+    return {
+      xpub,
+      xpubkeySignature,
+      authXpub,
+      authXpubkeySignature,
+      timestampNow,
+      firstAddress,
+      authDerivedPrivKey
+    };
+  }
+
+  /**
+   * onUpdateTx: Event called when a transaction is updated
+   *
+   * @memberof HathorWalletServiceWallet
+   * @inner
+   */
+  onUpdateTx(updatedTx) {
+    this.emit('update-tx', updatedTx);
+  }
+
+  /**
+   * onNewTx: Event called when a new transaction is received on the websocket feed
+   *
+   * @memberof HathorWalletServiceWallet
+   * @inner
+   */
+  async onNewTx(newTx) {
+    const {
+      outputs
+    } = newTx;
+    let shouldGetNewAddresses = false;
+    for (const output of outputs) {
+      // Check if the output's decoded address matches any of the wallet's new addresses
+      if (output.decoded && output.decoded.address && this.newAddresses.find(newAddress => newAddress.address === output.decoded.address)) {
+        // break early
+        shouldGetNewAddresses = true;
+        break;
+      }
+    }
+
+    // We need to update the `newAddresses` array on every new transaction
+    // because the new tx might have used one of those addresses and we try to guarantee
+    // that every transaction uses a new address for increased privacy
+    if (shouldGetNewAddresses) {
+      await this.getNewAddresses();
+    }
+    this.emit('new-tx', newTx);
+  }
+
+  /**
+   * Return wallet auth token
+   *
+   * @memberof HathorWalletServiceWallet
+   * @inner
+   */
+  getAuthToken() {
+    return this.authToken;
+  }
+
+  /**
+   * Returns the balance for each token in tx, if the input/output belongs to this wallet
+   *
+   * This method is meant to keep compatibility with the old facade
+   *
+   * @param {Object} tx Transaction data with array of inputs and outputs
+   *
+   * @return {Object} Object with each token and it's balance in this tx for this wallet
+   * */
+  async getTxBalance(tx, optionsParam = {}) {
+    const options = {
+      includeAuthorities: false,
+      ...optionsParam
+    };
+    const addresses = [];
+    const generator = this.getAllAddresses();
+
+    // We are not using for async (...) to maintain compatibility with older nodejs versions
+    // if we ever deprecate older node versions, we can refactor this to the new, cleaner syntax
+    let nextAddress = await generator.next();
+    while (!nextAddress.done) {
+      addresses.push(nextAddress.value.address);
+      nextAddress = await generator.next();
+    }
+    const balance = {};
+    for (const txout of tx.outputs) {
+      if (_transaction.default.isAuthorityOutput(txout)) {
+        if (options.includeAuthorities) {
+          if (!balance[txout.token]) {
+            balance[txout.token] = 0n;
+          }
+        }
+        continue;
+      }
+      if (txout.decoded && txout.decoded.address && addresses.includes(txout.decoded.address)) {
+        if (!balance[txout.token]) {
+          balance[txout.token] = 0n;
+        }
+        balance[txout.token] += txout.value;
+      }
+    }
+    for (const txin of tx.inputs) {
+      if (_transaction.default.isAuthorityOutput(txin)) {
+        if (options.includeAuthorities) {
+          if (!balance[txin.token]) {
+            balance[txin.token] = 0n;
+          }
+        }
+        continue;
+      }
+      if (txin.decoded && txin.decoded.address && addresses.includes(txin.decoded.address)) {
+        if (!balance[txin.token]) {
+          balance[txin.token] = 0n;
+        }
+        balance[txin.token] -= txin.value;
+      }
+    }
+    return balance;
+  }
+
+  /**
+   * When the wallet starts, it might take some seconds for the wallet service to completely load all addresses
+   * This method is responsible for polling the wallet status until it's ready
+   *
+   * @memberof HathorWalletServiceWallet
+   * @inner
+   */
+  async pollForWalletStatus() {
+    return new Promise((resolve, reject) => {
+      const pollIntervalTimer = setInterval(async () => {
+        const data = await _walletApi.default.getWalletStatus(this);
+        if (data.status.status === 'ready') {
+          clearInterval(pollIntervalTimer);
+          resolve();
+        } else if (data.status.status !== 'creating') {
+          // Only possible states are 'ready', 'creating' and 'error', if status
+          // is not ready or creating, we should reject the promise
+          clearInterval(pollIntervalTimer);
+          reject(new _errors.WalletRequestError('Error getting wallet status.', {
+            cause: data.status
+          }));
+        }
+      }, WALLET_STATUS_POLLING_INTERVAL);
+    });
+  }
+
+  /**
+   * Check if wallet is ready and throw error if not ready
+   *
+   * @memberof HathorWalletServiceWallet
+   * @public
+   */
+  failIfWalletNotReady() {
+    if (!this.isReady()) {
+      throw new _errors.WalletError('Wallet not ready');
+    }
+  }
+
+  /**
+   * Method executed when wallet is ready
+   *
+   * @memberof HathorWalletServiceWallet
+   * @inner
+   */
+  async onWalletReady() {
+    // We should wait for new addresses before setting wallet to ready
+    await this.getNewAddresses(true);
+    if (this.isWsEnabled()) {
+      this.setupConnection();
+    }
+    this.setState(walletState.READY);
+  }
+  setupConnection() {
+    if (!this.walletId) {
+      // This should never happen
+      throw new Error('Tried to setup connection but wallet_id is not set.');
+    }
+    this.conn.setWalletId(this.walletId);
+    this.conn.on('new-tx', newTx => this.onNewTx(newTx));
+    this.conn.on('update-tx', updatedTx => this.onUpdateTx(updatedTx));
+    this.conn.on('state', newState => this.onConnectionChangedState(newState));
+    this.conn.start();
+  }
+
+  /**
+   * Called when the connection to the websocket changes.
+   * It is also called if the network is down.
+   *
+   * Since the wallet service facade holds no data (as opposed to
+   * the old facade, where the wallet facade receives a storage object),
+   * the client needs to handle the data reload, so we just emit an event
+   * to indicate that a reload is necessary.
+   *
+   * @param {Number} newState Enum of new state after change
+   * */
+  onConnectionChangedState(newState) {
+    if (newState === _types.ConnectionState.CONNECTED) {
+      // We don't need to reload data if this is the first
+      // connection
+      if (!this.firstConnection) {
+        this.emit('reload-data');
+      }
+      this.firstConnection = false;
+    }
+  }
+
+  /**
+   * Get all addresses of the wallet
+   *
+   * @memberof HathorWalletServiceWallet
+   * @inner
+   */
+  getAllAddresses() {
+    var _this = this;
+    return _wrapAsyncGenerator(function* () {
+      _this.failIfWalletNotReady();
+      const data = yield _awaitAsyncGenerator(_walletApi.default.getAddresses(_this));
+      for (const address of data.addresses) {
+        yield address;
+      }
+    })();
+  }
+
+  /**
+   * Get the new addresses to be used by this wallet, i.e. the last GAP LIMIT unused addresses
+   * Then it updates this.newAddresses and this.indexToUse that handle the addresses to use
+   *
+   * @param ignoreWalletReady Will download new addresses even if the wallet is not set to ready
+   *
+   * @memberof HathorWalletServiceWallet
+   * @inner
+   */
+  async getNewAddresses(ignoreWalletReady = false) {
+    // If the user is sure the wallet service has already loaded his wallet, he can ignore the check
+    if (!ignoreWalletReady) {
+      // We should fail if the wallet is not ready because the wallet service address load mechanism is
+      // asynchronous, so we will get an empty or partial array of addresses if they are not all loaded.
+      this.failIfWalletNotReady();
+    }
+    const data = await _walletApi.default.getNewAddresses(this);
+    this.newAddresses = data.addresses;
+    this.indexToUse = 0;
+  }
+
+  /**
+   * Get the balance of the wallet for a specific token
+   *
+   * @memberof HathorWalletServiceWallet
+   * @inner
+   */
+  async getBalance(token = null) {
+    this.failIfWalletNotReady();
+    const data = await _walletApi.default.getBalances(this, token);
+    return data.balances;
+  }
+  async getTokens() {
+    this.failIfWalletNotReady();
+    const data = await _walletApi.default.getTokens(this);
+    return data.tokens;
+  }
+
+  /**
+   * Get the history of the wallet for a specific token
+   *
+   * @memberof HathorWalletServiceWallet
+   * @inner
+   */
+  async getTxHistory(options = {}) {
+    this.failIfWalletNotReady();
+    const data = await _walletApi.default.getHistory(this, options);
+    return data.history;
+  }
+
+  /**
+   * Get utxo from tx id and index
+   *
+   * @memberof HathorWalletServiceWallet
+   * @inner
+   */
+  async getUtxoFromId(txId, index) {
+    const data = await _walletApi.default.getTxOutputs(this, {
+      txId,
+      index,
+      skipSpent: true // This is the API default, but we should be explicit about it
+    });
+    const utxos = data.txOutputs;
+    if (utxos.length === 0) {
+      // No utxo for this txId/index or is not from the requested wallet
+      return null;
+    }
+    if (utxos.length > 1) {
+      throw new _errors.UtxoError(`Expected to receive only one utxo for txId ${txId} and index ${index} but received ${utxos.length}.`);
+    }
+    return utxos[0];
+  }
+
+  /**
+   * Get utxos for filling a transaction
+   *
+   * @memberof HathorWalletServiceWallet
+   * @inner
+   */
+  async getUtxos(options = {}) {
+    const newOptions = {
+      tokenId: _constants.NATIVE_TOKEN_UID,
+      authority: null,
+      addresses: null,
+      totalAmount: null,
+      count: 1,
+      ...options,
+      ignoreLocked: true,
+      skipSpent: true // We only want UTXOs
+    };
+    if (!newOptions.authority && !newOptions.totalAmount) {
+      throw new _errors.UtxoError("We need the total amount of utxos if it's not an authority request.");
+    }
+    const data = await _walletApi.default.getTxOutputs(this, newOptions);
+    let changeAmount = 0n;
+    let utxos = [];
+    if (data.txOutputs.length === 0) {
+      // No utxos available for the requested filter
+      utxos = data.txOutputs;
+    } else if (newOptions.authority) {
+      // Requests an authority utxo, then I return the count of requested authority utxos
+      utxos = data.txOutputs.slice(0, newOptions.count);
+    } else {
+      // We got an array of utxos, then we must check if there is enough amount to fill the totalAmount
+      // and slice the least possible utxos
+      const ret = _transaction.default.selectUtxos(data.txOutputs, newOptions.totalAmount);
+      changeAmount = ret.changeAmount;
+      utxos = ret.utxos;
+    }
+    return {
+      utxos,
+      changeAmount
+    };
+  }
+
+  /**
+   * Signs a message using xpriv derivation path m/44'/280'/0'
+   *
+   * @memberof HathorWalletServiceWallet
+   * @inner
+   */
+  signMessage(hdPrivKey, timestamp, walletId) {
+    const address = hdPrivKey.publicKey.toAddress(this.network.getNetwork()).toString();
+    const message = String(timestamp).concat(walletId).concat(address);
+    return (0, _crypto.signMessage)(message, hdPrivKey.privateKey);
+  }
+
+  /**
+   * Validate that the wallet auth token is valid
+   * If it's not valid, requests a new one and update
+   *
+   * @param {string} usePassword Accepts the password as a parameter so we don't have to ask
+   * the client for it if we already have it in memory
+   *
+   * @memberof HathorWalletServiceWallet
+   * @inner
+   */
+  async validateAndRenewAuthToken(usePassword) {
+    if (!this.walletId) {
+      throw new Error('Wallet not ready yet.');
+    }
+    const now = new Date();
+    const timestampNow = Math.floor(now.getTime() / 1000);
+    const validateJWTExpireDate = token => {
+      const base64Url = token.split('.')[1];
+      const base64 = base64Url.replace('-', '+').replace('_', '/');
+      const decodedData = JSON.parse(Buffer.from(base64, 'base64').toString('binary'));
+
+      // If the token will expire in the next 60 seconds (or has already expired)
+      const delta = 60;
+      if (timestampNow + delta > decodedData.exp) {
+        return false;
+      }
+      return true;
+    };
+    if (!this.authToken || !validateJWTExpireDate(this.authToken)) {
+      let privKey = this.authPrivKey;
+      if (!privKey) {
+        // Request the client for the PIN
+        const password = usePassword || (await this.requestPassword());
+
+        // Use it to get the words from the storage
+        privKey = _bitcoreLib.default.HDPrivateKey.fromString(await this.storage.getAuthPrivKey(password));
+      }
+      await this.renewAuthToken(privKey, timestampNow);
+    } else if (usePassword) {
+      // If we have received the user PIN, we should renew the token anyway
+      // without blocking this method's promise
+
+      const privKey = _bitcoreLib.default.HDPrivateKey.fromString(await this.storage.getAuthPrivKey(usePassword));
+      this.renewAuthToken(privKey, timestampNow);
+    }
+  }
+
+  /**
+   * Renew the auth token on the wallet service
+   *
+   * @param {HDPrivateKey} privKey - private key to sign the auth message
+   * @param {number} timestamp - Current timestamp to assemble the signature
+   *
+   * @memberof HathorWalletServiceWallet
+   * @inner
+   */
+  async renewAuthToken(privKey, timestamp) {
+    if (!this.walletId) {
+      throw new Error('Wallet not ready yet.');
+    }
+    const sign = this.signMessage(privKey, timestamp, this.walletId);
+    const data = await _walletApi.default.createAuthToken(this, timestamp, privKey.xpubkey, sign);
+    this.authToken = data.token;
+  }
+
+  /**
+   * Creates and send a transaction from an array of inputs and outputs
+   *
+   * @memberof HathorWalletServiceWallet
+   * @inner
+   */
+  async sendManyOutputsTransaction(outputs, options = {}) {
+    this.failIfWalletNotReady();
+    const newOptions = {
+      inputs: [],
+      changeAddress: null,
+      ...options
+    };
+    const {
+      inputs,
+      changeAddress,
+      pinCode
+    } = newOptions;
+    const sendTransactionOutputs = outputs.map(output => {
+      const typedOutput = output;
+      if (typedOutput.type === _types.OutputType.DATA) {
+        typedOutput.value = 1n;
+        typedOutput.token = _constants.NATIVE_TOKEN_UID;
+      } else {
+        typedOutput.type = _helpers.default.getOutputTypeFromAddress(typedOutput.address, this.network);
+      }
+      return typedOutput;
+    });
+    const sendTransaction = new _sendTransactionWalletService.default(this, {
+      outputs: sendTransactionOutputs,
+      inputs,
+      changeAddress,
+      pin: pinCode
+    });
+    return sendTransaction.run();
+  }
+
+  /**
+   * Creates and send a simple transaction with one output
+   *
+   * @memberof HathorWalletServiceWallet
+   * @inner
+   */
+  async sendTransaction(address, value, options = {}) {
+    this.failIfWalletNotReady();
+    const newOptions = {
+      token: '00',
+      changeAddress: undefined,
+      ...options
+    };
+    const {
+      token,
+      changeAddress,
+      pinCode
+    } = newOptions;
+    const outputs = [{
+      address,
+      value,
+      token
+    }];
+    return this.sendManyOutputsTransaction(outputs, {
+      inputs: [],
+      changeAddress,
+      pinCode
+    });
+  }
+
+  /**
+   * Calculate input data from dataToSign and addressPath
+   * Get the private key corresponding to the addressPath,
+   * calculate the signature and add the public key
+   *
+   * @memberof HathorWalletServiceWallet
+   * @inner
+   */
+  // eslint-disable-next-line class-methods-use-this -- XXX: This method should be made static
+  getInputData(xprivkey, dataToSignHash, addressPath) {
+    const xpriv = _bitcoreLib.default.HDPrivateKey(xprivkey);
+    const derivedKey = xpriv.deriveNonCompliantChild(addressPath);
+    const {
+      privateKey
+    } = derivedKey;
+    const arr = [];
+    _helpers.default.pushDataToStack(arr, _transaction.default.getSignature(dataToSignHash, privateKey));
+    _helpers.default.pushDataToStack(arr, derivedKey.publicKey.toBuffer());
+    return _bitcoreLib.util.buffer.concat(arr);
+  }
+
+  /**
+   * Return if wallet is ready to be used
+   *
+   * @memberof HathorWalletServiceWallet
+   * @inner
+   */
+  isReady() {
+    return this.state === walletState.READY;
+  }
+
+  /**
+   * Update wallet state and emit 'state' event
+   *
+   * @param {string} state New wallet state
+   *
+   * @memberof HathorWalletServiceWallet
+   * @inner
+   */
+  setState(state) {
+    this.state = state;
+    this.emit('state', state);
+  }
+
+  /**
+   * Stop the wallet
+   *
+   * @memberof HathorWalletServiceWallet
+   * @inner
+   */
+  async stop({
+    cleanStorage = true
+  } = {}) {
+    this.walletId = null;
+    this.state = walletState.NOT_STARTED;
+    this.firstConnection = true;
+    this.removeAllListeners();
+    await this.storage.handleStop({
+      cleanStorage
+    });
+    this.conn.stop();
+  }
+
+  /**
+   * Get address at specific index
+   *
+   * @memberof HathorWalletServiceWallet
+   * @inner
+   */
+  async getAddressAtIndex(index) {
+    const {
+      addresses
+    } = await _walletApi.default.getAddresses(this, index);
+    if (addresses.length <= 0) {
+      throw new Error('Error getting wallet addresses.');
+    }
+    return addresses[0].address;
+  }
+
+  /**
+   * Returns an address' privateKey given an index and the encryption password
+   *
+   * @param {string} pinCode - The PIN used to encrypt data in accessData
+   * @param {number} addressIndex - The address' index to fetch
+   *
+   * @memberof HathorWalletServiceWallet
+   * @inner
+   */
+  async getAddressPrivKey(pinCode, addressIndex) {
+    const mainXPrivKey = await this.storage.getMainXPrivKey(pinCode);
+    const addressHDPrivKey = new _bitcoreLib.default.HDPrivateKey(mainXPrivKey).derive(addressIndex);
+    return addressHDPrivKey;
+  }
+
+  /**
+   * Gets the network model object
+   *
+   * @memberof HathorWalletServiceWallet
+   * @inner
+   */
+  getNetworkObject() {
+    return this.network;
+  }
+
+  /**
+   * Get the current address to be used
+   *
+   * @memberof HathorWalletServiceWallet
+   * @inner
+   */
+  getCurrentAddress({
+    markAsUsed = false
+  } = {}) {
+    const newAddressesLen = this.newAddresses.length;
+    if (this.indexToUse > newAddressesLen - 1) {
+      const addressInfo = this.newAddresses[newAddressesLen - 1];
+      return {
+        ...addressInfo,
+        info: 'GAP_LIMIT_REACHED'
+      };
+    }
+    const addressInfo = this.newAddresses[this.indexToUse];
+    if (markAsUsed) {
+      this.indexToUse += 1;
+    }
+    return addressInfo;
+  }
+
+  /**
+   * Returns a base64 encoded signed message with an address' private key given an
+   * address index
+   *
+   * @memberof HathorWalletServiceWallet
+   * @inner
+   */
+  async signMessageWithAddress(message, index, pinCode) {
+    const addressHDPrivKey = await this.getAddressPrivKey(pinCode, index);
+    const signedMessage = (0, _crypto.signMessage)(message, addressHDPrivKey.privateKey);
+    return signedMessage;
+  }
+
+  /**
+   * Get the next address after the current available
+   *
+   * @memberof HathorWalletServiceWallet
+   * @inner
+   */
+  getNextAddress() {
+    // First we mark the current address as used, then return the next
+    this.getCurrentAddress({
+      markAsUsed: true
+    });
+    return this.getCurrentAddress();
+  }
+
+  /* eslint-disable class-methods-use-this -- Methods are not yet implemented */
+  getAddressIndex(address) {
+    throw new _errors.WalletError('Not implemented.');
+  }
+  isAddressMine(address) {
+    throw new _errors.WalletError('Not implemented.');
+  }
+  getTx(id) {
+    throw new _errors.WalletError('Not implemented.');
+  }
+  getAddressInfo(address, options = {}) {
+    throw new _errors.WalletError('Not implemented.');
+  }
+  consolidateUtxos(destinationAddress, options = {}) {
+    throw new _errors.WalletError('Not implemented.');
+  }
+  getFullHistory() {
+    throw new _errors.WalletError('Not implemented.');
+  }
+  /* eslint-enable class-methods-use-this */
+
+  /**
+   * Checks if the given array of addresses belongs to the caller wallet
+   *
+   * @memberof HathorWalletServiceWallet
+   * @inner
+   */
+  async checkAddressesMine(addresses) {
+    const response = await _walletApi.default.checkAddressesMine(this, addresses);
+    return response.addresses;
+  }
+
+  /**
+   * Create SendTransaction object and run from mining
+   * Returns a promise that resolves when the send succeeds
+   *
+   * @memberof HathorWalletServiceWallet
+   * @inner
+   */
+  async handleSendPreparedTransaction(transactionObj) {
+    const sendTransaction = new _sendTransactionWalletService.default(this, {
+      transaction: transactionObj
+    });
+    return sendTransaction.runFromMining();
+  }
+
+  /**
+   * Prepare create new token data, sign the inputs and returns an object ready to be mined
+   *
+   * @memberof HathorWalletServiceWallet
+   * @inner
+   */
+  async prepareCreateNewToken(name, symbol, amount, options = {}) {
+    this.failIfWalletNotReady();
+    const newOptions = {
+      address: null,
+      changeAddress: null,
+      createMintAuthority: true,
+      mintAuthorityAddress: null,
+      allowExternalMintAuthorityAddress: false,
+      createMeltAuthority: true,
+      meltAuthorityAddress: null,
+      allowExternalMeltAuthorityAddress: false,
+      nftData: null,
+      pinCode: null,
+      signTx: true,
+      ...options
+    };
+    if (newOptions.mintAuthorityAddress && !newOptions.allowExternalMintAuthorityAddress) {
+      // Validate that the mint authority address belongs to the wallet
+      const checkAddressMineMap = await this.checkAddressesMine([newOptions.mintAuthorityAddress]);
+      if (!checkAddressMineMap[newOptions.mintAuthorityAddress]) {
+        throw new _errors.SendTxError('The mint authority address must belong to your wallet.');
+      }
+    }
+    if (newOptions.meltAuthorityAddress && !newOptions.allowExternalMeltAuthorityAddress) {
+      // Validate that the melt authority address belongs to the wallet
+      const checkAddressMineMap = await this.checkAddressesMine([newOptions.meltAuthorityAddress]);
+      if (!checkAddressMineMap[newOptions.meltAuthorityAddress]) {
+        throw new _errors.SendTxError('The melt authority address must belong to your wallet.');
+      }
+    }
+    const isNFT = newOptions.nftData !== null;
+    const depositPercent = this.storage.getTokenDepositPercentage();
+    // 1. Calculate HTR deposit needed
+    let deposit = _tokens.default.getDepositAmount(amount, depositPercent);
+    if (isNFT) {
+      // For NFT we have a fee of 0.01 HTR, then the deposit utxo query must get an additional 1
+      deposit += 1n;
+    }
+
+    // 2. Get utxos for HTR
+    const {
+      utxos,
+      changeAmount
+    } = await this.getUtxos({
+      tokenId: _constants.NATIVE_TOKEN_UID,
+      totalAmount: deposit
+    });
+    if (utxos.length === 0) {
+      throw new _errors.UtxoError(`No utxos available to fill the request. Token: HTR - Amount: ${deposit}.`);
+    }
+    const utxosAddressPath = [];
+    // 3. Create the transaction object with the inputs and outputs (new token amount, change address with HTR, mint/melt authorities - depending on parameters)
+    const inputsObj = [];
+    for (const utxo of utxos) {
+      inputsObj.push(new _input.default(utxo.txId, utxo.index));
+      utxosAddressPath.push(utxo.addressPath);
+    }
+
+    // Create outputs
+    const outputsObj = [];
+    // NFT transactions must have the first output as the script data
+    if (isNFT) {
+      outputsObj.push(_helpers.default.createNFTOutput(newOptions.nftData));
+    }
+    // a. Token amount
+    const addressToUse = newOptions.address || this.getCurrentAddress({
+      markAsUsed: true
+    }).address;
+    const address = new _address2.default(addressToUse, {
+      network: this.network
+    });
+    if (!address.isValid()) {
+      throw new _errors.SendTxError(`Address ${newOptions.address} is not valid.`);
+    }
+    const p2pkhScript = address.getScript();
+    outputsObj.push(new _output.default(amount, p2pkhScript, {
+      tokenData: 1
+    }));
+    if (newOptions.createMintAuthority) {
+      // b. Mint authority
+      const mintAuthorityAddress = newOptions.mintAuthorityAddress || this.getCurrentAddress({
+        markAsUsed: true
+      }).address;
+      const mintAuthorityAddressObj = new _address2.default(mintAuthorityAddress, {
+        network: this.network
+      });
+      if (!mintAuthorityAddressObj.isValid()) {
+        throw new _errors.SendTxError(`Address ${newOptions.mintAuthorityAddress} is not valid.`);
+      }
+      const p2pkhMintAuthorityScript = mintAuthorityAddressObj.getScript();
+      outputsObj.push(new _output.default(_constants.TOKEN_MINT_MASK, p2pkhMintAuthorityScript, {
+        tokenData: _constants.AUTHORITY_TOKEN_DATA
+      }));
+    }
+    if (newOptions.createMeltAuthority) {
+      // c. Melt authority
+      const meltAuthorityAddress = newOptions.meltAuthorityAddress || this.getCurrentAddress({
+        markAsUsed: true
+      }).address;
+      const meltAuthorityAddressObj = new _address2.default(meltAuthorityAddress, {
+        network: this.network
+      });
+      if (!meltAuthorityAddressObj.isValid()) {
+        throw new _errors.SendTxError(`Address ${newOptions.meltAuthorityAddress} is not valid.`);
+      }
+      const p2pkhMeltAuthorityScript = meltAuthorityAddressObj.getScript();
+      outputsObj.push(new _output.default(_constants.TOKEN_MELT_MASK, p2pkhMeltAuthorityScript, {
+        tokenData: _constants.AUTHORITY_TOKEN_DATA
+      }));
+    }
+    if (changeAmount) {
+      // d. HTR change output
+      const changeAddressStr = newOptions.changeAddress || this.getCurrentAddress({
+        markAsUsed: true
+      }).address;
+      const changeAddress = new _address2.default(changeAddressStr, {
+        network: this.network
+      });
+      if (!changeAddress.isValid()) {
+        throw new _errors.SendTxError(`Address ${newOptions.changeAddress} is not valid.`);
+      }
+      const p2pkhChange = new _p2pkh.default(changeAddress);
+      const p2pkhChangeScript = p2pkhChange.createScript();
+      outputsObj.push(new _output.default(changeAmount, p2pkhChangeScript));
+    }
+    const tx = new _create_token_transaction.default(name, symbol, inputsObj, outputsObj);
+
+    // Sign transaction
+    if (newOptions.signTx) {
+      const dataToSignHash = tx.getDataToSignHash();
+      if (!newOptions.pinCode) {
+        throw new Error('PIN not specified in prepareCreateNewToken options');
+      }
+      const xprivkey = await this.storage.getMainXPrivKey(newOptions.pinCode);
+      for (const [idx, inputObj] of tx.inputs.entries()) {
+        const inputData = this.getInputData(xprivkey, dataToSignHash, HathorWalletServiceWallet.getAddressIndexFromFullPath(utxosAddressPath[idx]));
+        inputObj.setData(inputData);
+      }
+    }
+    tx.prepareToSend();
+    return tx;
+  }
+
+  /**
+   * Expects a BIP44 path at the address level and returns the address index
+   *
+   * @param {string} fullPath - The full BIP44 path for the address index
+   *
+   * @memberof HathorWalletServiceWallet
+   * @inner
+   */
+  static getAddressIndexFromFullPath(fullPath) {
+    const parts = fullPath.split('/');
+    _assert.default.equal(6, parts.length);
+    return parseInt(parts[5], 10);
+  }
+
+  /**
+   * Helper method to get authority tx_outputs
+   * Uses the getTxOutputs API method to return one or many authorities
+   */
+  async _getAuthorityTxOutput(options) {
+    const {
+      txOutputs
+    } = await _walletApi.default.getTxOutputs(this, options);
+    return txOutputs.map(txOutput => ({
+      txId: txOutput.txId,
+      index: txOutput.index,
+      address: txOutput.address,
+      authorities: txOutput.authorities
+    }));
+  }
+
+  /**
+   * Get mint authorities
+   * Uses the getTxOutputs API method to return one or many mint authorities
+   *
+   * @param tokenId of the token to select the authority utxo
+   * @param options Object with custom options.
+   *  {
+   *    'many': if should return many utxos or just one (default false),
+   *    'skipSpent': if should not include spent utxos (default true)
+   *  }
+   *
+   * @return Promise that resolves with an Array of objects with {txId, index, address, authorities} of the authority output.
+   * Returns an empty array in case there are no tx outputs for this type
+   * */
+  async getMintAuthority(tokenId, options = {}) {
+    const newOptions = {
+      many: false,
+      skipSpent: true,
+      ...options
+    };
+    return this._getAuthorityTxOutput({
+      tokenId,
+      authority: _constants.TOKEN_MINT_MASK,
+      skipSpent: newOptions.skipSpent,
+      maxOutputs: newOptions.many ? undefined : 1
+    });
+  }
+
+  /**
+   * Get melt authorities
+   * Uses the getTxOutputs API method to return one or many melt authorities
+   *
+   * @param tokenId of the token to select the authority utxo
+   * @param options Object with custom options.
+   *  {
+   *    'many': if should return many utxos or just one (default false),
+   *    'skipSpent': if should not include spent utxos (default true)
+   *  }
+   *
+   * @return Promise that resolves with an Array of objects with {txId, index, address, authorities} of the authority output.
+   * Returns an empty array in case there are no tx outputs for this type
+   * */
+  async getMeltAuthority(tokenId, options = {}) {
+    const newOptions = {
+      many: false,
+      skipSpent: true,
+      ...options
+    };
+    return this._getAuthorityTxOutput({
+      tokenId,
+      authority: _constants.TOKEN_MELT_MASK,
+      skipSpent: newOptions.skipSpent,
+      maxOutputs: newOptions.many ? undefined : 1
+    });
+  }
+
+  /**
+   * Create a new custom token in the network
+   *
+   * @memberof HathorWalletServiceWallet
+   * @inner
+   */
+  async createNewToken(name, symbol, amount, options = {}) {
+    this.failIfWalletNotReady();
+    const tx = await this.prepareCreateNewToken(name, symbol, amount, options);
+    return this.handleSendPreparedTransaction(tx);
+  }
+
+  /**
+   * Prepare mint token data, sign the inputs and returns an object ready to be mined
+   *
+   * @memberof HathorWalletServiceWallet
+   * @inner
+   */
+  async prepareMintTokensData(token, amount, options = {}) {
+    this.failIfWalletNotReady();
+    const newOptions = {
+      address: null,
+      changeAddress: null,
+      createAnotherMint: true,
+      mintAuthorityAddress: null,
+      allowExternalMintAuthorityAddress: false,
+      pinCode: null,
+      signTx: true,
+      ...options
+    };
+    if (newOptions.mintAuthorityAddress && !newOptions.allowExternalMintAuthorityAddress) {
+      // Validate that the mint authority address belongs to the wallet
+      const checkAddressMineMap = await this.checkAddressesMine([newOptions.mintAuthorityAddress]);
+      if (!checkAddressMineMap[newOptions.mintAuthorityAddress]) {
+        throw new _errors.SendTxError('The mint authority address must belong to your wallet.');
+      }
+    }
+
+    // 1. Calculate HTR deposit needed
+    const depositPercent = this.storage.getTokenDepositPercentage();
+    const deposit = _tokens.default.getDepositAmount(amount, depositPercent);
+
+    // 2. Get utxos for HTR
+    const {
+      utxos,
+      changeAmount
+    } = await this.getUtxos({
+      tokenId: _constants.NATIVE_TOKEN_UID,
+      totalAmount: deposit
+    });
+    if (utxos.length === 0) {
+      throw new _errors.UtxoError(`No utxos available to fill the request. Token: HTR - Amount: ${deposit}.`);
+    }
+
+    // 3. Get mint authority
+    const ret = await this.getUtxos({
+      tokenId: token,
+      authority: _constants.TOKEN_MINT_MASK
+    });
+    if (ret.utxos.length === 0) {
+      throw new _errors.UtxoError(`No authority utxo available for minting tokens. Token: ${token}.`);
+    }
+    // it's safe to assume that we have an utxo in the array
+    const mintUtxo = ret.utxos[0];
+
+    // 4. Create inputs from utxos
+    const inputsObj = [];
+    for (const utxo of utxos) {
+      // First add HTR utxos
+      inputsObj.push(new _input.default(utxo.txId, utxo.index));
+    }
+
+    // Then add a single mint authority utxo
+    inputsObj.push(new _input.default(mintUtxo.txId, mintUtxo.index));
+
+    // Create outputs
+    const outputsObj = [];
+    // a. Token amount
+    const addressToUse = newOptions.address || this.getCurrentAddress({
+      markAsUsed: true
+    }).address;
+    const address = new _address2.default(addressToUse, {
+      network: this.network
+    });
+    if (!address.isValid()) {
+      throw new _errors.SendTxError(`Address ${newOptions.address} is not valid.`);
+    }
+    const p2pkhScript = address.getScript();
+    outputsObj.push(new _output.default(amount, p2pkhScript, {
+      tokenData: 1
+    }));
+    if (newOptions.createAnotherMint) {
+      // b. Mint authority
+      const authorityAddress = newOptions.mintAuthorityAddress || this.getCurrentAddress({
+        markAsUsed: true
+      }).address;
+      const authorityAddressObj = new _address2.default(authorityAddress, {
+        network: this.network
+      });
+      if (!authorityAddressObj.isValid()) {
+        throw new _errors.SendTxError(`Address ${newOptions.mintAuthorityAddress} is not valid.`);
+      }
+      const p2pkhAuthorityScript = authorityAddressObj.getScript();
+      outputsObj.push(new _output.default(_constants.TOKEN_MINT_MASK, p2pkhAuthorityScript, {
+        tokenData: _constants.AUTHORITY_TOKEN_DATA
+      }));
+    }
+    if (changeAmount) {
+      // c. HTR change output
+      const changeAddressStr = newOptions.changeAddress || this.getCurrentAddress({
+        markAsUsed: true
+      }).address;
+      const changeAddress = new _address2.default(changeAddressStr, {
+        network: this.network
+      });
+      if (!changeAddress.isValid()) {
+        throw new _errors.SendTxError(`Address ${newOptions.changeAddress} is not valid.`);
+      }
+      const p2pkhChange = new _p2pkh.default(changeAddress);
+      const p2pkhChangeScript = p2pkhChange.createScript();
+      outputsObj.push(new _output.default(changeAmount, p2pkhChangeScript));
+    }
+    const tx = new _transaction2.default(inputsObj, outputsObj);
+    tx.tokens = [token];
+
+    // Sign transaction
+    if (newOptions.signTx) {
+      const dataToSignHash = tx.getDataToSignHash();
+      if (!newOptions.pinCode) {
+        throw new Error('PIN not specified in prepareMintTokensData options');
+      }
+      const xprivkey = await this.storage.getMainXPrivKey(newOptions.pinCode);
+      for (const [idx, inputObj] of tx.inputs.entries()) {
+        // We have an array of utxos and the last input is the one with the authority
+        const addressPath = idx === tx.inputs.length - 1 ? mintUtxo.addressPath : utxos[idx].addressPath;
+        const inputData = this.getInputData(xprivkey, dataToSignHash, HathorWalletServiceWallet.getAddressIndexFromFullPath(addressPath));
+        inputObj.setData(inputData);
+      }
+    }
+    tx.prepareToSend();
+    return tx;
+  }
+
+  /**
+   * Mint new token units
+   *
+   * @memberof HathorWalletServiceWallet
+   * @inner
+   */
+  async mintTokens(token, amount, options = {}) {
+    this.failIfWalletNotReady();
+    const tx = await this.prepareMintTokensData(token, amount, options);
+    return this.handleSendPreparedTransaction(tx);
+  }
+
+  /**
+   * Call get token details API
+   *
+   * @param tokenId Token uid to get the token details
+   *
+   * @memberof HathorWalletServiceWallet
+   * @inner
+   */
+  async getTokenDetails(tokenId) {
+    const response = await _walletApi.default.getTokenDetails(this, tokenId);
+    const {
+      details
+    } = response;
+    return details;
+  }
+
+  /**
+   * Prepare melt token data, sign the inputs and returns an object ready to be mined
+   *
+   * @memberof HathorWalletServiceWallet
+   * @inner
+   */
+  async prepareMeltTokensData(token, amount, options = {}) {
+    this.failIfWalletNotReady();
+    const newOptions = {
+      address: null,
+      changeAddress: null,
+      createAnotherMelt: true,
+      meltAuthorityAddress: null,
+      allowExternalMeltAuthorityAddress: false,
+      pinCode: null,
+      signTx: true,
+      ...options
+    };
+    if (newOptions.meltAuthorityAddress && !newOptions.allowExternalMeltAuthorityAddress) {
+      // Validate that the melt authority address belongs to the wallet
+      const checkAddressMineMap = await this.checkAddressesMine([newOptions.meltAuthorityAddress]);
+      if (!checkAddressMineMap[newOptions.meltAuthorityAddress]) {
+        throw new _errors.SendTxError('The melt authority address must belong to your wallet.');
+      }
+    }
+
+    // 1. Calculate HTR deposit needed
+    const depositPercent = this.storage.getTokenDepositPercentage();
+    const withdraw = _tokens.default.getWithdrawAmount(amount, depositPercent);
+
+    // 2. Get utxos for custom token to melt
+    const {
+      utxos,
+      changeAmount
+    } = await this.getUtxos({
+      tokenId: token,
+      totalAmount: amount
+    });
+    if (utxos.length === 0) {
+      throw new _errors.UtxoError(`Not enough tokens to be melted. Token: ${token} - Amount: ${amount}.`);
+    }
+
+    // 3. Get mint authority
+    const ret = await this.getUtxos({
+      tokenId: token,
+      authority: _constants.TOKEN_MELT_MASK
+    });
+    if (ret.utxos.length === 0) {
+      throw new _errors.UtxoError(`No authority utxo available for melting tokens. Token: ${token}.`);
+    }
+    // it's safe to assume that we have an utxo in the array
+    const meltUtxo = ret.utxos[0];
+
+    // 4. Create inputs from utxos
+    const inputsObj = [];
+    for (const utxo of utxos) {
+      // First add HTR utxos
+      inputsObj.push(new _input.default(utxo.txId, utxo.index));
+    }
+
+    // Then add a single mint authority utxo (it's safe to assume that we have an utxo in the array)
+    inputsObj.push(new _input.default(meltUtxo.txId, meltUtxo.index));
+
+    // Create outputs
+    const outputsObj = [];
+    // a. Deposit back
+    const addressToUse = newOptions.address || this.getCurrentAddress({
+      markAsUsed: true
+    }).address;
+    const address = new _address2.default(addressToUse, {
+      network: this.network
+    });
+    if (!address.isValid()) {
+      throw new _errors.SendTxError(`Address ${newOptions.address} is not valid.`);
+    }
+    const p2pkh = new _p2pkh.default(address);
+    const p2pkhScript = p2pkh.createScript();
+    if (withdraw) {
+      // We may have nothing to get back
+      outputsObj.push(new _output.default(withdraw, p2pkhScript, {
+        tokenData: 0
+      }));
+    }
+    if (newOptions.createAnotherMelt) {
+      // b. Melt authority
+      const authorityAddress = newOptions.meltAuthorityAddress || this.getCurrentAddress({
+        markAsUsed: true
+      }).address;
+      const authorityAddressObj = new _address2.default(authorityAddress, {
+        network: this.network
+      });
+      if (!authorityAddressObj.isValid()) {
+        throw new _errors.SendTxError(`Address ${newOptions.meltAuthorityAddress} is not valid.`);
+      }
+      const p2pkhAuthorityScript = authorityAddressObj.getScript();
+      outputsObj.push(new _output.default(_constants.TOKEN_MELT_MASK, p2pkhAuthorityScript, {
+        tokenData: _constants.AUTHORITY_TOKEN_DATA
+      }));
+    }
+    if (changeAmount) {
+      // c. Token change output
+      const changeAddressStr = newOptions.changeAddress || this.getCurrentAddress({
+        markAsUsed: true
+      }).address;
+      const changeAddress = new _address2.default(changeAddressStr, {
+        network: this.network
+      });
+      if (!changeAddress.isValid()) {
+        throw new _errors.SendTxError(`Address ${newOptions.changeAddress} is not valid.`);
+      }
+      const p2pkhChange = new _p2pkh.default(changeAddress);
+      const p2pkhChangeScript = p2pkhChange.createScript();
+      outputsObj.push(new _output.default(changeAmount, p2pkhChangeScript, {
+        tokenData: 1
+      }));
+    }
+    const tx = new _transaction2.default(inputsObj, outputsObj);
+    tx.tokens = [token];
+
+    // Sign transaction
+    if (newOptions.signTx) {
+      const dataToSignHash = tx.getDataToSignHash();
+      if (!newOptions.pinCode) {
+        throw new Error('PIN not specified in prepareMeltTokensData options');
+      }
+      const xprivkey = await this.storage.getMainXPrivKey(newOptions.pinCode);
+      for (const [idx, inputObj] of tx.inputs.entries()) {
+        // We have an array of utxos and the last input is the one with the authority
+        const addressPath = idx === tx.inputs.length - 1 ? meltUtxo.addressPath : utxos[idx].addressPath;
+        const inputData = this.getInputData(xprivkey, dataToSignHash, HathorWalletServiceWallet.getAddressIndexFromFullPath(addressPath));
+        inputObj.setData(inputData);
+      }
+    }
+    tx.prepareToSend();
+    return tx;
+  }
+
+  /**
+   * Melt custom token units
+   *
+   * @memberof HathorWalletServiceWallet
+   * @inner
+   */
+  async meltTokens(token, amount, options = {}) {
+    this.failIfWalletNotReady();
+    const tx = await this.prepareMeltTokensData(token, amount, options);
+    return this.handleSendPreparedTransaction(tx);
+  }
+
+  /**
+   * Prepare delegate authority data, sign the inputs and returns an object ready to be mined
+   *
+   * @memberof HathorWalletServiceWallet
+   * @inner
+   */
+  async prepareDelegateAuthorityData(token, type, address, {
+    anotherAuthorityAddress = null,
+    createAnother = true,
+    pinCode = null
+  }) {
+    this.failIfWalletNotReady();
+    let authority;
+    let mask;
+    if (type === 'mint') {
+      authority = 1n;
+      mask = _constants.TOKEN_MINT_MASK;
+    } else if (type === 'melt') {
+      authority = 2n;
+      mask = _constants.TOKEN_MELT_MASK;
+    } else {
+      throw new _errors.WalletError('Type options are mint and melt for delegate authority method.');
+    }
+
+    // 1. Get authority utxo to spend
+    const ret = await this.getUtxos({
+      tokenId: token,
+      authority
+    });
+    if (ret.utxos.length === 0) {
+      throw new _errors.UtxoError(`No authority utxo available for delegating authority. Token: ${token} - Type ${type}.`);
+    }
+    // it's safe to assume that we have an utxo in the array
+    const utxo = ret.utxos[0];
+
+    // 2. Create input from utxo
+    const inputsObj = [];
+    inputsObj.push(new _input.default(utxo.txId, utxo.index));
+
+    // Create outputs
+    const outputsObj = [];
+    const addressObj = new _address2.default(address, {
+      network: this.network
+    });
+    if (!addressObj.isValid()) {
+      throw new _errors.SendTxError(`Address ${address} is not valid.`);
+    }
+    const p2pkh = new _p2pkh.default(addressObj);
+    const p2pkhScript = p2pkh.createScript();
+    outputsObj.push(new _output.default(mask, p2pkhScript, {
+      tokenData: _constants.AUTHORITY_TOKEN_DATA
+    }));
+    if (createAnother) {
+      const anotherAddressStr = anotherAuthorityAddress || this.getCurrentAddress({
+        markAsUsed: true
+      }).address;
+      const anotherAddress = new _address2.default(anotherAddressStr, {
+        network: this.network
+      });
+      if (!anotherAddress.isValid()) {
+        throw new _errors.SendTxError(`Address ${anotherAuthorityAddress} is not valid.`);
+      }
+      const p2pkhAnotherAddress = new _p2pkh.default(anotherAddress);
+      const p2pkhAnotherAddressScript = p2pkhAnotherAddress.createScript();
+      outputsObj.push(new _output.default(mask, p2pkhAnotherAddressScript, {
+        tokenData: _constants.AUTHORITY_TOKEN_DATA
+      }));
+    }
+    const tx = new _transaction2.default(inputsObj, outputsObj);
+    tx.tokens = [token];
+    if (!pinCode) {
+      throw new Error('PIN not specified in prepareDelegateAuthorityData options');
+    }
+    const xprivkey = await this.storage.getMainXPrivKey(pinCode);
+
+    // Set input data
+    const dataToSignHash = tx.getDataToSignHash();
+    const inputData = this.getInputData(xprivkey, dataToSignHash, HathorWalletServiceWallet.getAddressIndexFromFullPath(utxo.addressPath));
+    inputsObj[0].setData(inputData);
+    tx.prepareToSend();
+    return tx;
+  }
+
+  /**
+   * Transfer (delegate) authority outputs to another address
+   *
+   * @memberof HathorWalletServiceWallet
+   * @inner
+   */
+  async delegateAuthority(token, type, address, options) {
+    this.failIfWalletNotReady();
+    const tx = await this.prepareDelegateAuthorityData(token, type, address, options);
+    return this.handleSendPreparedTransaction(tx);
+  }
+
+  /**
+   * Destroy authority outputs
+   *
+   * @memberof HathorWalletServiceWallet
+   * @inner
+   */
+  async prepareDestroyAuthorityData(token, type, count, {
+    pinCode = null
+  }) {
+    this.failIfWalletNotReady();
+    let authority;
+    if (type === 'mint') {
+      authority = 1n;
+    } else if (type === 'melt') {
+      authority = 2n;
+    } else {
+      throw new _errors.WalletError('Type options are mint and melt for destroy authority method.');
+    }
+
+    // 1. Get authority utxo to spend
+    const ret = await this.getUtxos({
+      tokenId: token,
+      authority,
+      count
+    });
+    if (ret.utxos.length < count) {
+      throw new _errors.UtxoError(`Not enough authority utxos available for destroying. Token: ${token} - Type ${type}. Requested quantity ${count} - Available quantity ${ret.utxos.length}`);
+    }
+
+    // 1. Create input from utxo
+    const inputsObj = [];
+    for (const utxo of ret.utxos) {
+      inputsObj.push(new _input.default(utxo.txId, utxo.index));
+    }
+
+    // No outputs because we are just destroying the authority utxos
+
+    const tx = new _transaction2.default(inputsObj, []);
+    tx.tokens = [token];
+
+    // Set input data
+    const dataToSignHash = tx.getDataToSignHash();
+    if (!pinCode) {
+      throw new Error('PIN not specified in prepareDestroyAuthorityData options');
+    }
+    const xprivkey = await this.storage.getMainXPrivKey(pinCode);
+    for (const [idx, inputObj] of tx.inputs.entries()) {
+      const inputData = this.getInputData(xprivkey, dataToSignHash, HathorWalletServiceWallet.getAddressIndexFromFullPath(ret.utxos[idx].addressPath));
+      inputObj.setData(inputData);
+    }
+    tx.prepareToSend();
+    return tx;
+  }
+
+  /**
+   * Destroy authority outputs
+   *
+   * @memberof HathorWalletServiceWallet
+   * @inner
+   */
+  async destroyAuthority(token, type, count, options) {
+    this.failIfWalletNotReady();
+    const tx = await this.prepareDestroyAuthorityData(token, type, count, options);
+    return this.handleSendPreparedTransaction(tx);
+  }
+
+  /**
+   * Create an NFT in the network
+   *
+   * @memberof HathorWalletServiceWallet
+   * @inner
+   */
+  async createNFT(name, symbol, amount, data, options = {}) {
+    this.failIfWalletNotReady();
+    const newOptions = {
+      address: null,
+      changeAddress: null,
+      createMintAuthority: false,
+      mintAuthorityAddress: null,
+      allowExternalMintAuthorityAddress: false,
+      createMeltAuthority: false,
+      meltAuthorityAddress: null,
+      allowExternalMeltAuthorityAddress: false,
+      ...options
+    };
+    newOptions.nftData = data;
+    const tx = await this.prepareCreateNewToken(name, symbol, amount, newOptions);
+    return this.handleSendPreparedTransaction(tx);
+  }
+  async getTxById(txId) {
+    this.failIfWalletNotReady();
+    const data = await _walletApi.default.getTxById(this, txId);
+    return data;
+  }
+  async getFullTxById(txId) {
+    this.failIfWalletNotReady();
+    const data = await _walletApi.default.getFullTxById(this, txId);
+    return data;
+  }
+  async getTxConfirmationData(txId) {
+    this.failIfWalletNotReady();
+    const data = await _walletApi.default.getTxConfirmationData(this, txId);
+    return data;
+  }
+  async graphvizNeighborsQuery(txId, graphType, maxLevel) {
+    this.failIfWalletNotReady();
+    const data = await _walletApi.default.graphvizNeighborsQuery(this, txId, graphType, maxLevel);
+    return data;
+  }
+
+  /**
+   * Check if websocket connection is enabled
+   *
+   * @memberof HathorWalletServiceWallet
+   * @inner
+   *
+   * @returns {boolean} If wallet has websocket connection enabled
+   */
+  isWsEnabled() {
+    return this._isWsEnabled;
+  }
+
+  /**
+   * Check if the pin used to encrypt the main key is valid.
+   * @param {string} pin
+   * @returns {Promise<boolean>}
+   */
+  async checkPin(pin) {
+    return this.storage.checkPin(pin);
+  }
+
+  /**
+   * Check if the password used to encrypt the seed is valid.
+   * @param {string} password
+   * @returns {Promise<boolean>}
+   */
+  async checkPassword(password) {
+    return this.storage.checkPassword(password);
+  }
+
+  /**
+   * @param {string} pin
+   * @param {string} password
+   * @returns {Promise<boolean>}
+   */
+  async checkPinAndPassword(pin, password) {
+    return (await this.checkPin(pin)) && this.checkPassword(password); // The promise from checkPassword will be returned
+  }
+
+  /**
+   * Check if the wallet is a hardware wallet.
+   * @returns {Promise<boolean>}
+   */
+  // eslint-disable-next-line class-methods-use-this -- The method returns a hardcoded value
+  async isHardwareWallet() {
+    // We currently do not have support for hardware wallets
+    // in the wallet-service facade.
+    return false;
+  }
+}
+var _default = exports.default = HathorWalletServiceWallet;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/wallet/websocket.d.ts b/node_modules/@hathor/wallet-lib/oldLib/wallet/websocket.d.ts
new file mode 100644
index 0000000..b2bec19
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/wallet/websocket.d.ts
@@ -0,0 +1,59 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+import BaseWebSocket, { WsOptions } from '../websocket/base';
+export interface WalletServiceWebSocketOptions extends WsOptions {
+    walletId: string;
+    joinTimeout?: number;
+}
+/**
+ * Handles websocket connections and message transmission.
+ *
+ * This class extends the base websocket class and is meant to be used
+ * exclusively when connecting to the Hathor Wallet Service.
+ *
+ * @class
+ * @name WalletServiceWebSocket
+ */
+declare class WalletServiceWebSocket extends BaseWebSocket {
+    private walletId;
+    private joinTimeoutTimer;
+    private joinTimeout;
+    constructor(options: WalletServiceWebSocketOptions);
+    /**
+     * Handle message receiving from websocket
+     *
+     * @param {Object} evt Event that has data (evt.data) sent in the websocket
+     */
+    onMessage(evt: any): void;
+    /**
+     * Method called when websocket connection is opened
+     */
+    onOpen(): void;
+    /**
+     * Clears the join timeout timer
+     */
+    clearJoinTimeout(): void;
+    /**
+     * Called when the `join-success` event is received on the websocket connection
+     */
+    onJoinSuccess(): void;
+    /**
+     * Handler for timeouts on the `join` wallet action
+     */
+    onJoinTimeout(): void;
+    /**
+     * Sends the join action to the websocket connection to start receiving updates
+     * from our wallet
+     */
+    joinWallet(): void;
+    /**
+     * Returns a JSON stringified ping message
+     */
+    getPingMessage(): string;
+}
+export default WalletServiceWebSocket;
+//# sourceMappingURL=websocket.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/wallet/websocket.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/wallet/websocket.d.ts.map
new file mode 100644
index 0000000..2164b44
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/wallet/websocket.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"websocket.d.ts","sourceRoot":"","sources":["../../src/wallet/websocket.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;AAEH,OAAO,aAAa,EAAE,EAAE,SAAS,EAAsB,MAAM,mBAAmB,CAAC;AAEjF,MAAM,WAAW,6BAA8B,SAAQ,SAAS;IAC9D,QAAQ,EAAE,MAAM,CAAC;IACjB,WAAW,CAAC,EAAE,MAAM,CAAC;CACtB;AAID;;;;;;;;GAQG;AACH,cAAM,sBAAuB,SAAQ,aAAa;IAEhD,OAAO,CAAC,QAAQ,CAAS;IAGzB,OAAO,CAAC,gBAAgB,CAAuC;IAG/D,OAAO,CAAC,WAAW,CAAS;gBAEhB,OAAO,EAAE,6BAA6B;IA8BlD;;;;OAIG;IACH,SAAS,CAAC,GAAG,KAAA;IAkBb;;OAEG;IACH,MAAM;IAKN;;OAEG;IACH,gBAAgB;IAQhB;;OAEG;IACH,aAAa;IAKb;;OAEG;IACH,aAAa;IAMb;;;OAGG;IACH,UAAU;IAWV;;OAEG;IAEH,cAAc;CAGf;AAED,eAAe,sBAAsB,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/wallet/websocket.js b/node_modules/@hathor/wallet-lib/oldLib/wallet/websocket.js
new file mode 100644
index 0000000..cd2c02d
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/wallet/websocket.js
@@ -0,0 +1,144 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+var _base = _interopRequireWildcard(require("../websocket/base"));
+function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
+function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
+function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
+function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
+function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+const DEFAULT_JOIN_TIMEOUT = 5000;
+
+/**
+ * Handles websocket connections and message transmission.
+ *
+ * This class extends the base websocket class and is meant to be used
+ * exclusively when connecting to the Hathor Wallet Service.
+ *
+ * @class
+ * @name WalletServiceWebSocket
+ */
+class WalletServiceWebSocket extends _base.default {
+  constructor(options) {
+    const {
+      wsURL,
+      heartbeatInterval,
+      connectionTimeout,
+      retryConnectionInterval,
+      openConnectionTimeout,
+      logger,
+      walletId,
+      joinTimeout
+    } = {
+      ..._base.DEFAULT_WS_OPTIONS,
+      joinTimeout: DEFAULT_JOIN_TIMEOUT,
+      ...options
+    };
+    super({
+      wsURL,
+      heartbeatInterval,
+      connectionTimeout,
+      retryConnectionInterval,
+      openConnectionTimeout,
+      logger
+    });
+    // The walletId to subscribe to new events
+    _defineProperty(this, "walletId", void 0);
+    // Timer used to detected when join wallet failed
+    _defineProperty(this, "joinTimeoutTimer", void 0);
+    // The default timeout for the join wallet action
+    _defineProperty(this, "joinTimeout", void 0);
+    this.walletId = walletId;
+    this.joinTimeout = joinTimeout;
+    this.joinTimeoutTimer = null;
+  }
+
+  /**
+   * Handle message receiving from websocket
+   *
+   * @param {Object} evt Event that has data (evt.data) sent in the websocket
+   */
+  onMessage(evt) {
+    const payload = JSON.parse(evt.data);
+    if (payload.type === 'pong') {
+      this.onPong();
+    } else if (payload.type === 'join-success') {
+      this.onJoinSuccess();
+    } else if (this.timeoutTimer) {
+      // The websoket might be exchanging many messages and end up getting the pong from the full node too late
+      // in that case the websocket would be closed but we know the connection is not down because we are receiving
+      // other messages. Because of that we just reset the timeoutTimer when we receive a message that is not a pong
+      clearTimeout(this.timeoutTimer);
+      this.timeoutTimer = setTimeout(() => this.onConnectionDown(), this.connectionTimeout);
+    }
+    this.emit(payload.type, payload);
+  }
+
+  /**
+   * Method called when websocket connection is opened
+   */
+  onOpen() {
+    super.onOpen();
+    this.joinWallet();
+  }
+
+  /**
+   * Clears the join timeout timer
+   */
+  clearJoinTimeout() {
+    if (!this.joinTimeoutTimer) {
+      return;
+    }
+    clearTimeout(this.joinTimeoutTimer);
+  }
+
+  /**
+   * Called when the `join-success` event is received on the websocket connection
+   */
+  onJoinSuccess() {
+    this.clearJoinTimeout();
+    this.setIsOnline(true);
+  }
+
+  /**
+   * Handler for timeouts on the `join` wallet action
+   */
+  onJoinTimeout() {
+    this.clearJoinTimeout();
+    this.joinWallet();
+    this.setIsOnline(false);
+  }
+
+  /**
+   * Sends the join action to the websocket connection to start receiving updates
+   * from our wallet
+   */
+  joinWallet() {
+    // Subscribe to the current wallet id
+    const msg = JSON.stringify({
+      action: 'join',
+      id: this.walletId
+    });
+    this.sendMessage(msg);
+    this.joinTimeoutTimer = setTimeout(() => this.onJoinTimeout(), this.joinTimeout);
+  }
+
+  /**
+   * Returns a JSON stringified ping message
+   */
+  // eslint-disable-next-line class-methods-use-this -- The method returns a hardcoded value
+  getPingMessage() {
+    return JSON.stringify({
+      action: 'ping'
+    });
+  }
+}
+var _default = exports.default = WalletServiceWebSocket;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/websocket/base.d.ts b/node_modules/@hathor/wallet-lib/oldLib/websocket/base.d.ts
new file mode 100644
index 0000000..14b1d49
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/websocket/base.d.ts
@@ -0,0 +1,125 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/// <reference types="node" />
+import { EventEmitter } from 'events';
+import _WebSocket from 'isomorphic-ws';
+import { ILogger } from '../types';
+export declare const DEFAULT_WS_OPTIONS: {
+    wsURL: string;
+    heartbeatInterval: number;
+    connectionTimeout: number;
+    retryConnectionInterval: number;
+    openConnectionTimeout: number;
+    logger: ILogger;
+};
+export type WsOptions = {
+    wsURL?: string;
+    heartbeatInterval?: number;
+    connectionTimeout?: number;
+    retryConnectionInterval?: number;
+    openConnectionTimeout?: number;
+    logger: ILogger;
+};
+/**
+ * Handles websocket connections and message transmission
+ *
+ * @class
+ * @name WS
+ */
+declare abstract class BaseWebSocket extends EventEmitter {
+    WebSocket: _WebSocket;
+    private ws;
+    private wsURL;
+    private started;
+    private connected;
+    private isOnline;
+    private heartbeatInterval;
+    private retryConnectionInterval;
+    private openConnectionTimeout;
+    private connectedDate;
+    private latestSetupDate;
+    private latestRTT;
+    private heartbeat;
+    protected latestPingDate: Date | null;
+    protected timeoutTimer: ReturnType<typeof setTimeout> | null;
+    protected setupTimer: ReturnType<typeof setTimeout> | null;
+    protected connectionTimeout: number;
+    protected logger: ILogger;
+    constructor(options: WsOptions);
+    /**
+     * Return websocket url to connect to.
+     * */
+    getWSServerURL(): string;
+    /**
+     * Start websocket object and its methods
+     */
+    setup(): void;
+    /**
+     * Sets all event listeners to noops on the WebSocket instance
+     * and close it.
+     * */
+    closeWs(): void;
+    /**
+     * Return connection uptime in seconds (or null if not connected).
+     * */
+    uptime(): number | null;
+    onPong(): void;
+    /**
+     * Handle message receiving from websocket
+     */
+    abstract onMessage(evt: any): any;
+    /**
+     * Method called when websocket connection is opened
+     */
+    onOpen(): void;
+    /**
+     * Removes all listeners, ends the connection and removes the setup reconnection timer
+     */
+    close(): void;
+    /**
+     * Clears the reconnection timer if it exists
+     */
+    clearSetupTimer(): void;
+    /**
+     * Clears the pong timeout timer if it exists
+     */
+    clearPongTimeoutTimer(): void;
+    /**
+     * Method called when websocket connection is closed
+     */
+    onClose(): void;
+    /**
+     * Method called when an error happend on websocket
+     */
+    onError(evt: any): void;
+    /**
+     * Method called to send a message to the server
+     */
+    sendMessage(msg: string): void;
+    /**
+     * Should return a stringified ping message
+     */
+    abstract getPingMessage(): string;
+    /**
+     * Ping method to check if server is still alive
+     */
+    sendPing(): void;
+    /**
+     * Event received when the websocket connection is down.
+     */
+    onConnectionDown(): void;
+    /**
+     * Method called to end a websocket connection
+     */
+    endConnection(): void;
+    /**
+     * Set if websocket is online
+     */
+    setIsOnline(value: boolean): void;
+}
+export default BaseWebSocket;
+//# sourceMappingURL=base.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/websocket/base.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/websocket/base.d.ts.map
new file mode 100644
index 0000000..b5eb873
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/websocket/base.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"base.d.ts","sourceRoot":"","sources":["../../src/websocket/base.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;;AAEH,OAAO,EAAE,YAAY,EAAE,MAAM,QAAQ,CAAC;AACtC,OAAO,UAAU,MAAM,eAAe,CAAC;AACvC,OAAO,EAAE,OAAO,EAAoB,MAAM,UAAU,CAAC;AAErD,eAAO,MAAM,kBAAkB;;;;;;;CAO9B,CAAC;AAEF,MAAM,MAAM,SAAS,GAAG;IACtB,KAAK,CAAC,EAAE,MAAM,CAAC;IACf,iBAAiB,CAAC,EAAE,MAAM,CAAC;IAC3B,iBAAiB,CAAC,EAAE,MAAM,CAAC;IAC3B,uBAAuB,CAAC,EAAE,MAAM,CAAC;IACjC,qBAAqB,CAAC,EAAE,MAAM,CAAC;IAC/B,MAAM,EAAE,OAAO,CAAC;CACjB,CAAC;AAEF;;;;;GAKG;AACH,uBAAe,aAAc,SAAQ,YAAY;IAIxC,SAAS,EAAE,UAAU,CAAC;IAG7B,OAAO,CAAC,EAAE,CAAa;IAGvB,OAAO,CAAC,KAAK,CAA0B;IAKvC,OAAO,CAAC,OAAO,CAAU;IAIzB,OAAO,CAAC,SAAS,CAAiB;IAGlC,OAAO,CAAC,QAAQ,CAAU;IAG1B,OAAO,CAAC,iBAAiB,CAAS;IAGlC,OAAO,CAAC,uBAAuB,CAAS;IAGxC,OAAO,CAAC,qBAAqB,CAAS;IAGtC,OAAO,CAAC,aAAa,CAAc;IAGnC,OAAO,CAAC,eAAe,CAAc;IAGrC,OAAO,CAAC,SAAS,CAAgB;IAGjC,OAAO,CAAC,SAAS,CAAuC;IAGxD,SAAS,CAAC,cAAc,EAAE,IAAI,GAAG,IAAI,CAAC;IAGtC,SAAS,CAAC,YAAY,EAAE,UAAU,CAAC,OAAO,UAAU,CAAC,GAAG,IAAI,CAAC;IAG7D,SAAS,CAAC,UAAU,EAAE,UAAU,CAAC,OAAO,UAAU,CAAC,GAAG,IAAI,CAAC;IAG3D,SAAS,CAAC,iBAAiB,EAAE,MAAM,CAAC;IAEpC,SAAS,CAAC,MAAM,EAAE,OAAO,CAAC;gBAEd,OAAO,EAAE,SAAS;IAkC9B;;SAEK;IACL,cAAc;IAOd;;OAEG;IACH,KAAK;IAkCL;;;SAGK;IACL,OAAO;IAmBP;;SAEK;IACL,MAAM;IAQN,MAAM;IASN;;OAEG;IACH,QAAQ,CAAC,SAAS,CAAC,GAAG,KAAA;IAEtB;;OAEG;IACH,MAAM;IAYN;;OAEG;IACH,KAAK;IAOL;;OAEG;IACH,eAAe;IAOf;;OAEG;IACH,qBAAqB;IAOrB;;OAEG;IACH,OAAO;IAcP;;OAEG;IACH,OAAO,CAAC,GAAG,KAAA;IAKX;;OAEG;IACH,WAAW,CAAC,GAAG,EAAE,MAAM;IAmBvB;;OAEG;IACH,QAAQ,CAAC,cAAc,IAAI,MAAM;IAEjC;;OAEG;IACH,QAAQ;IAWR;;OAEG;IACH,gBAAgB;IAShB;;OAEG;IACH,aAAa;IAQb;;OAEG;IACH,WAAW,CAAC,KAAK,EAAE,OAAO;CAO3B;AAED,eAAe,aAAa,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/websocket/base.js b/node_modules/@hathor/wallet-lib/oldLib/websocket/base.js
new file mode 100644
index 0000000..4dfb69f
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/websocket/base.js
@@ -0,0 +1,330 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = exports.DEFAULT_WS_OPTIONS = void 0;
+var _events = require("events");
+var _isomorphicWs = _interopRequireDefault(require("isomorphic-ws"));
+var _types = require("../types");
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
+function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
+function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+const DEFAULT_WS_OPTIONS = exports.DEFAULT_WS_OPTIONS = {
+  wsURL: 'wss://node1.mainnet.hathor.network/v1a/',
+  heartbeatInterval: 3000,
+  connectionTimeout: 5000,
+  retryConnectionInterval: 1000,
+  openConnectionTimeout: 20000,
+  logger: (0, _types.getDefaultLogger)()
+};
+/**
+ * Handles websocket connections and message transmission
+ *
+ * @class
+ * @name WS
+ */
+class BaseWebSocket extends _events.EventEmitter {
+  constructor(options) {
+    super();
+    // This is the class of the Websocket. It is used to open new WebSocket
+    // connections. We don't directly use it from import, so the unittests
+    // can replace it by a mock.
+    _defineProperty(this, "WebSocket", void 0);
+    // This is the websocket instance
+    _defineProperty(this, "ws", void 0);
+    // This is the URL of the websocket.
+    _defineProperty(this, "wsURL", void 0);
+    // Boolean that indicates that the websocket was instantiated. It's important to
+    // notice that it does not indicate that the connection has been established with
+    // the server, which is what the `connected` flag indicates
+    _defineProperty(this, "started", void 0);
+    // Boolean to show when the websocket connection was established with the
+    // server. This gets set to true on the onOpen event listener.
+    _defineProperty(this, "connected", void 0);
+    // Boolean to show when the websocket is online
+    _defineProperty(this, "isOnline", void 0);
+    // Heartbeat interval in milliseconds
+    _defineProperty(this, "heartbeatInterval", void 0);
+    // Retry connection interval in milliseconds
+    _defineProperty(this, "retryConnectionInterval", void 0);
+    // Open connection timeout in milliseconds
+    _defineProperty(this, "openConnectionTimeout", void 0);
+    // Date of connection.
+    _defineProperty(this, "connectedDate", void 0);
+    // Date of latest setup call. The setup is the way to open a new connection.
+    _defineProperty(this, "latestSetupDate", void 0);
+    // Latest round trip time measured by PING/PONG.
+    _defineProperty(this, "latestRTT", void 0);
+    // Heartbeat interval to send pings
+    _defineProperty(this, "heartbeat", void 0);
+    // Date of latest ping.
+    _defineProperty(this, "latestPingDate", void 0);
+    // Timer used to detected when connection is down.
+    _defineProperty(this, "timeoutTimer", void 0);
+    // Timer used to retry connection
+    _defineProperty(this, "setupTimer", void 0);
+    // Connection timeout in milliseconds
+    _defineProperty(this, "connectionTimeout", void 0);
+    _defineProperty(this, "logger", void 0);
+    const {
+      wsURL,
+      heartbeatInterval,
+      connectionTimeout,
+      retryConnectionInterval,
+      openConnectionTimeout,
+      logger
+    } = {
+      ...DEFAULT_WS_OPTIONS,
+      ...options
+    };
+    this.WebSocket = _isomorphicWs.default;
+    this.wsURL = wsURL;
+    this.started = false;
+    this.connected = false;
+    this.isOnline = false;
+    this.heartbeatInterval = heartbeatInterval;
+    this.connectionTimeout = connectionTimeout;
+    this.retryConnectionInterval = retryConnectionInterval;
+    this.openConnectionTimeout = openConnectionTimeout;
+    this.connectedDate = null;
+    this.latestSetupDate = null;
+    this.latestPingDate = null;
+    this.latestRTT = null;
+    this.timeoutTimer = null;
+    this.setupTimer = null;
+    this.heartbeat = null;
+    this.logger = logger;
+  }
+
+  /**
+   * Return websocket url to connect to.
+   * */
+  getWSServerURL() {
+    if (typeof this.wsURL === 'function') {
+      return this.wsURL();
+    }
+    return this.wsURL;
+  }
+
+  /**
+   * Start websocket object and its methods
+   */
+  setup() {
+    if (this.started) {
+      return;
+    }
+    const wsURL = this.getWSServerURL();
+    if (wsURL === null) {
+      throw new Error('No server URL specified.');
+    }
+    if (this.ws) {
+      if (this.latestSetupDate) {
+        // This check is just to prevent trying to open
+        // a connection more than once within the open timeout
+        const dt = (new Date().getTime() - this.latestSetupDate.getTime()) / 1000;
+        if (dt < this.openConnectionTimeout) {
+          return;
+        }
+      }
+      this.closeWs();
+    }
+    this.ws = new this.WebSocket(wsURL);
+    this.latestSetupDate = new Date();
+    this.ws.onopen = () => this.onOpen();
+    this.ws.onmessage = evt => this.onMessage(evt);
+    this.ws.onerror = evt => this.onError(evt);
+    this.ws.onclose = () => this.onClose();
+    this.started = true;
+  }
+
+  /**
+   * Sets all event listeners to noops on the WebSocket instance
+   * and close it.
+   * */
+  closeWs() {
+    if (!this.ws) {
+      return;
+    }
+    this.ws.onopen = () => {};
+    this.ws.onclose = () => {};
+    this.ws.onerror = () => {};
+    this.ws.onmessage = () => {};
+    if (this.ws.readyState === _isomorphicWs.default.OPEN) {
+      this.ws.close();
+    }
+    this.ws = null;
+    this.started = false;
+    this.connected = false;
+  }
+
+  /**
+   * Return connection uptime in seconds (or null if not connected).
+   * */
+  uptime() {
+    if (!this.connectedDate) {
+      return null;
+    }
+    const now = new Date().getTime();
+    return (now - this.connectedDate.getTime()) / 1000;
+  }
+  onPong() {
+    if (this.latestPingDate) {
+      const dt = (new Date().getTime() - this.latestPingDate.getTime()) / 1000;
+      this.latestRTT = dt;
+      this.latestPingDate = null;
+    }
+    this.clearPongTimeoutTimer();
+  }
+
+  /**
+   * Handle message receiving from websocket
+   */
+
+  /**
+   * Method called when websocket connection is opened
+   */
+  onOpen() {
+    if (!this.started) {
+      return;
+    }
+    this.connected = true;
+    this.connectedDate = new Date();
+    this.heartbeat = setInterval(() => {
+      this.sendPing();
+    }, this.heartbeatInterval);
+  }
+
+  /**
+   * Removes all listeners, ends the connection and removes the setup reconnection timer
+   */
+  close() {
+    this.removeAllListeners();
+    this.endConnection();
+    this.clearSetupTimer();
+    this.clearPongTimeoutTimer();
+  }
+
+  /**
+   * Clears the reconnection timer if it exists
+   */
+  clearSetupTimer() {
+    if (this.setupTimer) {
+      clearTimeout(this.setupTimer);
+      this.setupTimer = null;
+    }
+  }
+
+  /**
+   * Clears the pong timeout timer if it exists
+   */
+  clearPongTimeoutTimer() {
+    if (this.timeoutTimer) {
+      clearTimeout(this.timeoutTimer);
+      this.timeoutTimer = null;
+    }
+  }
+
+  /**
+   * Method called when websocket connection is closed
+   */
+  onClose() {
+    this.started = false;
+    this.connected = false;
+    this.connectedDate = null;
+    this.latestPingDate = null;
+    this.setIsOnline(false);
+    this.closeWs();
+    this.clearSetupTimer();
+    this.clearPongTimeoutTimer();
+    this.setupTimer = setTimeout(() => this.setup(), this.retryConnectionInterval);
+    clearInterval(this.heartbeat || undefined); // XXX: We should probably handle a missing heartbeat
+  }
+
+  /**
+   * Method called when an error happend on websocket
+   */
+  onError(evt) {
+    this.emit('connection_error', evt);
+    this.onClose();
+  }
+
+  /**
+   * Method called to send a message to the server
+   */
+  sendMessage(msg) {
+    // The started flag means that the websocket instance has been
+    // instantiated, but it does not mean that the connection was
+    // successful yet, which is what the connected flags indicates.
+    if (!this.started || !this.connected) {
+      this.setIsOnline(false);
+      return;
+    }
+    if (this.ws.readyState === _isomorphicWs.default.OPEN) {
+      this.ws.send(msg);
+    } else {
+      // If it is still connecting, we wait a little and try again
+      setTimeout(() => {
+        this.sendMessage(msg);
+      }, 1000);
+    }
+  }
+
+  /**
+   * Should return a stringified ping message
+   */
+
+  /**
+   * Ping method to check if server is still alive
+   */
+  sendPing() {
+    if (this.latestPingDate) {
+      // Skipping sendPing. Still waiting for pong...
+      return;
+    }
+    const msg = this.getPingMessage();
+    this.latestPingDate = new Date();
+    this.timeoutTimer = setTimeout(() => this.onConnectionDown(), this.connectionTimeout);
+    this.sendMessage(msg);
+  }
+
+  /**
+   * Event received when the websocket connection is down.
+   */
+  onConnectionDown() {
+    this.logger.warn('Ping timeout. Connection is down...', {
+      uptime: this.uptime(),
+      connectionTimeout: this.connectionTimeout
+    });
+    this.onClose();
+  }
+
+  /**
+   * Method called to end a websocket connection
+   */
+  endConnection() {
+    this.setIsOnline(false);
+    this.started = false;
+    this.connected = null;
+    this.closeWs();
+    clearInterval(this.heartbeat || undefined); // XXX: We should probably handle a missing heartbeat
+  }
+
+  /**
+   * Set if websocket is online
+   */
+  setIsOnline(value) {
+    if (this.isOnline !== value) {
+      this.isOnline = value;
+      // Emits event of online state change
+      this.emit('is_online', value);
+    }
+  }
+}
+var _default = exports.default = BaseWebSocket;
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/websocket/index.d.ts b/node_modules/@hathor/wallet-lib/oldLib/websocket/index.d.ts
new file mode 100644
index 0000000..0b64d81
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/websocket/index.d.ts
@@ -0,0 +1,39 @@
+/**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+import BaseWebSocket, { WsOptions } from './base';
+/**
+ * Handles websocket connections and message transmission
+ *
+ * This class extends the base websocket class and is currently used by:
+ * - the default wallet (using the "old" facade) for wallets that haven't migrated to the Wallet Service yet.
+ * - the Atomic Swap Service event listeners
+ *
+ * @class
+ * @name GenericWebSocket
+ */
+declare class GenericWebSocket extends BaseWebSocket {
+    private readonly splitMessageType;
+    constructor(options: WsOptions & {
+        splitMessageType?: boolean;
+    });
+    /**
+     * Handle message receiving from websocket
+     *
+     * @param {Object} evt Event that has data (evt.data) sent in the websocket
+     */
+    onMessage(evt: any): void;
+    /**
+     * Returns a JSON stringified ping message
+     */
+    getPingMessage(): string;
+    /**
+     * Extend onOpen to consider online as soon as the websocket connection is open
+     */
+    onOpen(): void;
+}
+export default GenericWebSocket;
+//# sourceMappingURL=index.d.ts.map
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/websocket/index.d.ts.map b/node_modules/@hathor/wallet-lib/oldLib/websocket/index.d.ts.map
new file mode 100644
index 0000000..42f7168
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/websocket/index.d.ts.map
@@ -0,0 +1 @@
+{"version":3,"file":"index.d.ts","sourceRoot":"","sources":["../../src/websocket/index.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;AAEH,OAAO,aAAa,EAAE,EAAE,SAAS,EAAE,MAAM,QAAQ,CAAC;AAGlD;;;;;;;;;GASG;AACH,cAAM,gBAAiB,SAAQ,aAAa;IAC1C,OAAO,CAAC,QAAQ,CAAC,gBAAgB,CAAU;gBAE/B,OAAO,EAAE,SAAS,GAAG;QAAE,gBAAgB,CAAC,EAAE,OAAO,CAAA;KAAE;IAM/D;;;;OAIG;IACH,SAAS,CAAC,GAAG,KAAA;IAeb;;OAEG;IAEH,cAAc;IAId;;OAEG;IACH,MAAM;CAIP;AAED,eAAe,gBAAgB,CAAC"}
\ No newline at end of file
diff --git a/node_modules/@hathor/wallet-lib/oldLib/websocket/index.js b/node_modules/@hathor/wallet-lib/oldLib/websocket/index.js
new file mode 100644
index 0000000..ab6c28c
--- /dev/null
+++ b/node_modules/@hathor/wallet-lib/oldLib/websocket/index.js
@@ -0,0 +1,73 @@
+"use strict";
+
+Object.defineProperty(exports, "__esModule", {
+  value: true
+});
+exports.default = void 0;
+var _base = _interopRequireDefault(require("./base"));
+var _bigint = require("../utils/bigint");
+function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
+function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
+function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
+function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } /**
+ * Copyright (c) Hathor Labs and its affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/**
+ * Handles websocket connections and message transmission
+ *
+ * This class extends the base websocket class and is currently used by:
+ * - the default wallet (using the "old" facade) for wallets that haven't migrated to the Wallet Service yet.
+ * - the Atomic Swap Service event listeners
+ *
+ * @class
+ * @name GenericWebSocket
+ */
+class GenericWebSocket extends _base.default {
+  constructor(options) {
+    super(options);
+    _defineProperty(this, "splitMessageType", void 0);
+    this.splitMessageType = options.splitMessageType ?? true;
+  }
+
+  /**
+   * Handle message receiving from websocket
+   *
+   * @param {Object} evt Event that has data (evt.data) sent in the websocket
+   */
+  onMessage(evt) {
+    const message = _bigint.JSONBigInt.parse(evt.data);
+    const _type = this.splitMessageType ? message.type.split(':')[0] : message.type;
+    if (_type === 'pong') {
+      this.onPong();
+    } else if (this.timeoutTimer) {
+      // The websocket might be exchanging many messages and end up getting the pong from the full node too late
+      // in that case the websocket would be closed, but we know the connection is not down because we are receiving
+      // other messages. Because of that we just reset the timeoutTimer when we receive a message that is not a pong
+      clearTimeout(this.timeoutTimer);
+      this.timeoutTimer = setTimeout(() => this.onConnectionDown(), this.connectionTimeout);
+    }
+    this.emit(_type, message);
+  }
+
+  /**
+   * Returns a JSON stringified ping message
+   */
+  // eslint-disable-next-line class-methods-use-this -- The method returns a hardcoded value
+  getPingMessage() {
+    return JSON.stringify({
+      type: 'ping'
+    });
+  }
+
+  /**
+   * Extend onOpen to consider online as soon as the websocket connection is open
+   */
+  onOpen() {
+    super.onOpen();
+    this.setIsOnline(true);
+  }
+}
+var _default = exports.default = GenericWebSocket;
\ No newline at end of file
